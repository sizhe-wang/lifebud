module.exports = [
"[project]/node_modules/@mastra/core/dist/chunk-Y22QMA7S.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MASTRA_RESOURCE_ID_KEY",
    ()=>MASTRA_RESOURCE_ID_KEY,
    "MASTRA_THREAD_ID_KEY",
    ()=>MASTRA_THREAD_ID_KEY,
    "RequestContext",
    ()=>RequestContext
]);
// src/request-context/index.ts
var MASTRA_RESOURCE_ID_KEY = "mastra__resourceId";
var MASTRA_THREAD_ID_KEY = "mastra__threadId";
var RequestContext = class {
    registry = /* @__PURE__ */ new Map();
    constructor(iterable){
        this.registry = new Map(iterable);
    }
    /**
   * set a value with strict typing if `Values` is a Record and the key exists in it.
   */ set(key, value) {
        this.registry.set(key, value);
    }
    /**
   * Get a value with its type
   */ get(key) {
        return this.registry.get(key);
    }
    /**
   * Check if a key exists in the container
   */ has(key) {
        return this.registry.has(key);
    }
    /**
   * Delete a value by key
   */ delete(key) {
        return this.registry.delete(key);
    }
    /**
   * Clear all values from the container
   */ clear() {
        this.registry.clear();
    }
    /**
   * Get all keys in the container
   */ keys() {
        return this.registry.keys();
    }
    /**
   * Get all values in the container
   */ values() {
        return this.registry.values();
    }
    /**
   * Get all entries in the container.
   * Returns a discriminated union of tuples for proper type narrowing when iterating.
   */ entries() {
        return this.registry.entries();
    }
    /**
   * Get the size of the container
   */ size() {
        return this.registry.size;
    }
    /**
   * Execute a function for each entry in the container.
   * The callback receives properly typed key-value pairs.
   */ forEach(callbackfn) {
        this.registry.forEach(callbackfn);
    }
    /**
   * Custom JSON serialization method
   * Converts the internal Map to a plain object for proper JSON serialization
   */ toJSON() {
        return Object.fromEntries(this.registry);
    }
};
;
 //# sourceMappingURL=chunk-Y22QMA7S.js.map
 //# sourceMappingURL=chunk-Y22QMA7S.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-7D4SUZUM.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commonJS",
    ()=>__commonJS,
    "__require",
    ()=>__require,
    "__toESM",
    ()=>__toESM
]);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x)=>("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.z : "TURBOPACK unreachable")(function(x) {
    if ("TURBOPACK compile-time truthy", 1) return /*TURBOPACK member replacement*/ __turbopack_context__.z.apply(this, arguments);
    //TURBOPACK unreachable
    ;
});
var __commonJS = (cb, mod)=>function __require2() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
;
 //# sourceMappingURL=chunk-7D4SUZUM.js.map
 //# sourceMappingURL=chunk-7D4SUZUM.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-D22XABFZ.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commonJS",
    ()=>__commonJS,
    "__require",
    ()=>__require2,
    "__toESM",
    ()=>__toESM,
    "require_token_error",
    ()=>require_token_error
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-7D4SUZUM.js [app-route] (ecmascript)");
;
// ../_vendored/ai_v5/dist/chunk-7D4SUZUM.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x)=>typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : typeof Proxy !== "undefined" ? new Proxy(x, {
        get: (a, b)=>(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : a)[b]
    }) : x)(function(x) {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"].apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod)=>function __require22() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// ../_vendored/ai_v5/dist/chunk-TLQKI65U.js
var require_token_error = __commonJS({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export = (target, all)=>{
            for(var name in all)__defProp2(target, name, {
                get: all[name],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var token_error_exports = {};
        __export(token_error_exports, {
            VercelOidcTokenError: ()=>VercelOidcTokenError
        });
        module.exports = __toCommonJS(token_error_exports);
        var VercelOidcTokenError = class extends Error {
            constructor(message, cause){
                super(message);
                this.name = "VercelOidcTokenError";
                this.cause = cause;
            }
            toString() {
                if (this.cause) {
                    return `${this.name}: ${this.message}: ${this.cause}`;
                }
                return `${this.name}: ${this.message}`;
            }
        };
    }
});
;
 //# sourceMappingURL=chunk-D22XABFZ.js.map
 //# sourceMappingURL=chunk-D22XABFZ.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-CPLRD2VP.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AISDKError",
    ()=>AISDKError,
    "APICallError",
    ()=>APICallError,
    "asSchema",
    ()=>asSchema,
    "combineHeaders",
    ()=>combineHeaders,
    "convertBase64ToUint8Array",
    ()=>convertBase64ToUint8Array,
    "convertUint8ArrayToBase64",
    ()=>convertUint8ArrayToBase64,
    "createEventSourceResponseHandler",
    ()=>createEventSourceResponseHandler,
    "createIdGenerator",
    ()=>createIdGenerator,
    "createJsonErrorResponseHandler",
    ()=>createJsonErrorResponseHandler,
    "createJsonResponseHandler",
    ()=>createJsonResponseHandler,
    "delay",
    ()=>delay,
    "generateId",
    ()=>generateId,
    "getErrorMessage",
    ()=>getErrorMessage,
    "getErrorMessage2",
    ()=>getErrorMessage2,
    "getFromApi",
    ()=>getFromApi,
    "getRuntimeEnvironmentUserAgent",
    ()=>getRuntimeEnvironmentUserAgent,
    "isAbortError",
    ()=>isAbortError,
    "jsonSchema",
    ()=>jsonSchema,
    "lazyValidator",
    ()=>lazyValidator,
    "loadOptionalSetting",
    ()=>loadOptionalSetting,
    "postJsonToApi",
    ()=>postJsonToApi,
    "resolve",
    ()=>resolve,
    "safeParseJSON",
    ()=>safeParseJSON,
    "safeValidateTypes",
    ()=>safeValidateTypes,
    "tool",
    ()=>tool,
    "withUserAgentSuffix",
    ()=>withUserAgentSuffix,
    "withoutTrailingSlash",
    ()=>withoutTrailingSlash,
    "zodSchema",
    ()=>zodSchema
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/parse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/core/to-json-schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/types.js [app-route] (ecmascript)");
;
;
// ../_vendored/ai_v5/dist/chunk-VQ35X6XO.js
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name14, message, cause }){
        super(message);
        this[_a] = true;
        this.name = name14;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError2.hasMarker(error, marker);
    }
    static hasMarker(error, marker15) {
        const markerSymbol = Symbol.for(marker15);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name,
            message,
            cause
        });
        this[_a2] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker2);
    }
};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}){
        super({
            name: name2,
            message
        });
        this[_a3] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker3);
    }
};
_a3 = symbol3;
function getErrorMessage(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
    constructor({ message, cause, argument }){
        super({
            name: name3,
            message,
            cause
        });
        this[_a4] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker4);
    }
};
_a4 = symbol4;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
    constructor({ text, cause }){
        super({
            name: name6,
            message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a7] = true;
        this.text = text;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker7);
    }
};
_a7 = symbol7;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
    constructor({ value, cause }){
        super({
            name: name12,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a13] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker13);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({
            value,
            cause
        });
    }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var ParseError = class extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
};
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = createParser({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
};
function combineHeaders(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>({
            ...combinedHeaders,
            ...currentHeaders != null ? currentHeaders : {}
        }), {});
}
async function delay(delayInMs, options) {
    if (delayInMs == null) {
        return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve2, reject)=>{
        if (signal == null ? void 0 : signal.aborted) {
            reject(createAbortError());
            return;
        }
        const timeoutId = setTimeout(()=>{
            cleanup();
            resolve2();
        }, delayInMs);
        const cleanup = ()=>{
            clearTimeout(timeoutId);
            signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        };
        const onAbort = ()=>{
            cleanup();
            reject(createAbortError());
        };
        signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
}
function createAbortError() {
    return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
    return Object.fromEntries([
        ...response.headers
    ]);
}
var createIdGenerator = ({ prefix, size = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = ()=>{
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for(let i = 0; i < size; i++){
            chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
    };
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new InvalidArgumentError({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return ()=>`${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function getErrorMessage2(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
function isAbortError(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = [
    "fetch failed",
    "failed to fetch"
];
function handleFetchError({ error, url, requestBodyValues }) {
    if (isAbortError(error)) {
        return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
        const cause = error.cause;
        if (cause != null) {
            return new APICallError({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
            });
        }
    }
    return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
    var _a15, _b, _c;
    if (globalThisAny.window) {
        return `runtime/browser`;
    }
    if ((_a15 = globalThisAny.navigator) == null ? void 0 : _a15.userAgent) {
        return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
        return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
        return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
}
function normalizeHeaders(headers) {
    if (headers == null) {
        return {};
    }
    const normalized = {};
    if (headers instanceof Headers) {
        headers.forEach((value, key)=>{
            normalized[key.toLowerCase()] = value;
        });
    } else {
        if (!Array.isArray(headers)) {
            headers = Object.entries(headers);
        }
        for (const [key, value] of headers){
            if (value != null) {
                normalized[key.toLowerCase()] = value;
            }
        }
    }
    return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
    const normalizedHeaders = new Headers(normalizeHeaders(headers));
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set("user-agent", [
        currentUserAgentHeader,
        ...userAgentSuffixParts
    ].filter(Boolean).join(" "));
    return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION = "3.0.17";
var getOriginalFetch = ()=>globalThis.fetch;
var getFromApi = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch() })=>{
    try {
        const response = await fetch(url, {
            method: "GET",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: {}
                });
            } catch (error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
                throw new APICallError({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: {}
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: {}
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: {}
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: {}
        });
    }
};
function loadOptionalSetting({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
    const obj = JSON.parse(text);
    if (obj === null || typeof obj !== "object") {
        return obj;
    }
    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
    }
    return filter(obj);
}
function filter(obj) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === "object") {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function secureJsonParse(text) {
    const { stackTraceLimit } = Error;
    try {
        Error.stackTraceLimit = 0;
    } catch (e) {
        return _parse(text);
    }
    try {
        return _parse(text);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
    return {
        [validatorSymbol]: true,
        validate
    };
}
function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function lazyValidator(createValidator) {
    let validator2;
    return ()=>{
        if (validator2 == null) {
            validator2 = createValidator();
        }
        return validator2;
    };
}
function asValidator(value) {
    return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
    return validator(async (value)=>{
        const result = await standardSchema["~standard"].validate(value);
        return result.issues == null ? {
            success: true,
            value: result.value
        } : {
            success: false,
            error: new TypeValidationError({
                value,
                cause: result.issues
            })
        };
    });
}
async function validateTypes({ value, schema }) {
    const result = await safeValidateTypes({
        value,
        schema
    });
    if (!result.success) {
        throw TypeValidationError.wrap({
            value,
            cause: result.error
        });
    }
    return result.value;
}
async function safeValidateTypes({ value, schema }) {
    const validator2 = asValidator(schema);
    try {
        if (validator2.validate == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const result = await validator2.validate(value);
        if (result.success) {
            return {
                success: true,
                value: result.value,
                rawValue: value
            };
        }
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: result.error
            }),
            rawValue: value
        };
    } catch (error) {
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: error
            }),
            rawValue: value
        };
    }
}
async function parseJSON({ text, schema }) {
    try {
        const value = secureJsonParse(text);
        if (schema == null) {
            return value;
        }
        return validateTypes({
            value,
            schema
        });
    } catch (error) {
        if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
            throw error;
        }
        throw new JSONParseError({
            text,
            cause: error
        });
    }
}
async function safeParseJSON({ text, schema }) {
    try {
        const value = secureJsonParse(text);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        return await safeValidateTypes({
            value,
            schema
        });
    } catch (error) {
        return {
            success: false,
            error: JSONParseError.isInstance(error) ? error : new JSONParseError({
                text,
                cause: error
            }),
            rawValue: void 0
        };
    }
}
function parseJsonEventStream({ stream, schema }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({
        async transform ({ data }, controller) {
            if (data === "[DONE]") {
                return;
            }
            controller.enqueue(await safeParseJSON({
                text: data,
                schema
            }));
        }
    }));
}
var getOriginalFetch2 = ()=>globalThis.fetch;
var postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch })=>postToApi({
        url,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        body: {
            content: JSON.stringify(body),
            values: body
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch
    });
var postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch2() })=>{
    try {
        const response = await fetch(url, {
            method: "POST",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
            body: body.content,
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
                throw new APICallError({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: body.values
        });
    }
};
function tool(tool2) {
    return tool2;
}
async function resolve(value) {
    if (typeof value === "function") {
        value = value();
    }
    return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const responseHeaders = extractResponseHeaders(response);
        if (responseBody.trim() === "") {
            return {
                responseHeaders,
                value: new APICallError({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
        try {
            const parsedError = await parseJSON({
                text: responseBody,
                schema: errorSchema
            });
            return {
                responseHeaders,
                value: new APICallError({
                    message: errorToMessage(parsedError),
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    data: parsedError,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                })
            };
        } catch (parseError) {
            return {
                responseHeaders,
                value: new APICallError({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
    };
var createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (response.body == null) {
            throw new EmptyResponseBodyError({});
        }
        return {
            responseHeaders,
            value: parseJsonEventStream({
                stream: response.body,
                schema: chunkSchema
            })
        };
    };
var createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const parsedResult = await safeParseJSON({
            text: responseBody,
            schema: responseSchema
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!parsedResult.success) {
            throw new APICallError({
                message: "Invalid JSON response",
                cause: parsedResult.error,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                url,
                requestBodyValues
            });
        }
        return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
        };
    };
var getRelativePath = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
var ignoreOverride = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
};
var getDefaultOptions = (options)=>typeof options === "string" ? {
        ...defaultOptions,
        name: options
    } : {
        ...defaultOptions,
        ...options
    };
function parseAnyDef() {
    return {};
}
function parseArrayDef(def, refs) {
    var _a15, _b, _c;
    const res = {
        type: "array"
    };
    if (((_a15 = def.type) == null ? void 0 : _a15._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        });
    }
    if (def.minLength) {
        res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
        res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
        res.minItems = def.exactLength.value;
        res.maxItems = def.exactLength.value;
    }
    return res;
}
function parseBigintDef(def) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseBooleanDef() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser(def);
    }
}
var integerDateParser = (def)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                res.minimum = check.value;
                break;
            case "max":
                res.maximum = check.value;
                break;
        }
    }
    return res;
};
function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf
    } : void 0;
}
function parseLiteralDef(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex = void 0;
var zodPatterns = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex === void 0) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    break;
                case "max":
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "includes":
                    {
                        addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern(res, zodPatterns.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    res.contentEncoding = "base64";
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern(res, zodPatterns.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern(res, zodPatterns.nanoid, check.message, refs);
                    }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    var _a15;
    if (schema.format || ((_a15 = schema.anyOf) == null ? void 0 : _a15.some((x)=>x.format))) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format
            });
            delete schema.format;
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else {
        schema.format = value;
    }
}
function addPattern(schema, regex, message, refs) {
    var _a15;
    if (schema.pattern || ((_a15 = schema.allOf) == null ? void 0 : _a15.some((x)=>x.pattern))) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern
            });
            delete schema.pattern;
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else {
        schema.pattern = stringifyRegExpWithFlags(regex, refs);
    }
}
function stringifyRegExpWithFlags(regex, refs) {
    var _a15;
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        // Case-insensitive
        m: regex.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && ((_a15 = source[i + 2]) == null ? void 0 : _a15.match(/[a-z]/))) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}
function parseRecordDef(def, refs) {
    var _a15, _b, _c, _d, _e, _f;
    const schema = {
        type: "object",
        additionalProperties: (_a15 = parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        })) != null ? _a15 : refs.allowedAdditionalProperties
    };
    if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values
            }
        };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded && def.keyType._def.type._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || parseAnyDef();
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || parseAnyDef();
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef() {
    return {
        not: parseAnyDef()
    };
}
function parseNullDef() {
    return {
        type: "null"
    };
}
var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf(def, refs);
}
var asAnyOf = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef(def) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                break;
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseObjectDef(def, refs) {
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        const propOptional = safeIsOptional(propDef);
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        });
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        });
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    } catch (e) {
        return true;
    }
}
var parseOptionalDef = (def, refs)=>{
    var _a15;
    if (refs.currentPath.toString() === ((_a15 = refs.propertyPath) == null ? void 0 : _a15.toString())) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef()
            },
            innerSchema
        ]
    } : parseAnyDef();
};
var parsePipelineDef = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
        schema.maxItems = def.maxSize.value;
    }
    return schema;
}
function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            })
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef() {
    return {
        not: parseAnyDef()
    };
}
function parseUnknownDef() {
    return parseAnyDef();
}
var parseReadonlyDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs)=>{
    switch(typeName){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString:
            return parseStringDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNumber:
            return parseNumberDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodObject:
            return parseObjectDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBigInt:
            return parseBigintDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBoolean:
            return parseBooleanDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDate:
            return parseDateDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUndefined:
            return parseUndefinedDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNull:
            return parseNullDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodArray:
            return parseArrayDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnion:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodIntersection:
            return parseIntersectionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodTuple:
            return parseTupleDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodRecord:
            return parseRecordDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLiteral:
            return parseLiteralDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum:
            return parseEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNativeEnum:
            return parseNativeEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNullable:
            return parseNullableDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodOptional:
            return parseOptionalDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodMap:
            return parseMapDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSet:
            return parseSetDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLazy:
            return ()=>def.getter()._def;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPromise:
            return parsePromiseDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNaN:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNever:
            return parseNeverDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEffects:
            return parseEffectsDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny:
            return parseAnyDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnknown:
            return parseUnknownDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDefault:
            return parseDefaultDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded:
            return parseBrandedDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodReadonly:
            return parseReadonlyDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodCatch:
            return parseCatchDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPipeline:
            return parsePipelineDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodFunction:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodVoid:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)();
    }
};
function parseDef(def, refs, forceResolution = false) {
    var _a15;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = (_a15 = refs.override) == null ? void 0 : _a15.call(refs, def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
        addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
        newItem.jsonSchema = jsonSchema2;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
}
var get$ref = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef();
                }
                return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
            }
    }
};
var addMeta = (def, refs, jsonSchema2)=>{
    if (def.description) {
        jsonSchema2.description = def.description;
    }
    return jsonSchema2;
};
var getRefs = (options)=>{
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name14, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name14
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    };
};
var zodToJsonSchema = (schema, options)=>{
    var _a15;
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name22, schema2])=>{
        var _a22;
        return {
            ...acc,
            [name22]: (_a22 = parseDef(schema2._def, {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name22
                ]
            }, true)) != null ? _a22 : parseAnyDef()
        };
    }, {}) : void 0;
    const name14 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a15 = parseDef(schema._def, name14 === void 0 ? refs : {
        ...refs,
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name14
        ]
    }, false)) != null ? _a15 : parseAnyDef();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    const combined = name14 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
    } : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name14
        ].join("/"),
        [refs.definitionPath]: {
            ...definitions,
            [name14]: main
        }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
};
var zod_to_json_schema_default = zodToJsonSchema;
function zod3Schema(zodSchema2, options) {
    var _a15;
    const useReferences = (_a15 = options == null ? void 0 : options.useReferences) != null ? _a15 : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>zod_to_json_schema_default(zodSchema2, {
            $refStrategy: useReferences ? "root" : "none"
        }), {
        validate: async (value)=>{
            const result = await zodSchema2.safeParseAsync(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function zod4Schema(zodSchema2, options) {
    var _a15;
    const useReferences = (_a15 = options == null ? void 0 : options.useReferences) != null ? _a15 : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toJSONSchema"](zodSchema2, {
            target: "draft-7",
            io: "output",
            reused: useReferences ? "ref" : "inline"
        }), {
        validate: async (value)=>{
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseAsync"](zodSchema2, value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function isZod4Schema(zodSchema2) {
    return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
    if (isZod4Schema(zodSchema2)) {
        return zod4Schema(zodSchema2, options);
    } else {
        return zod3Schema(zodSchema2, options);
    }
}
var schemaSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, { validate } = {}) {
    return {
        [schemaSymbol]: true,
        _type: void 0,
        // should never be used directly
        [validatorSymbol]: true,
        get jsonSchema () {
            if (typeof jsonSchema2 === "function") {
                jsonSchema2 = jsonSchema2();
            }
            return jsonSchema2;
        },
        validate
    };
}
function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
    return schema == null ? jsonSchema({
        properties: {},
        additionalProperties: false
    }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);
}
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob(base64Url);
    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
    let latin1string = "";
    for(let i = 0; i < array.length; i++){
        latin1string += String.fromCodePoint(array[i]);
    }
    return btoa(latin1string);
}
function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
;
 //# sourceMappingURL=chunk-CPLRD2VP.js.map
 //# sourceMappingURL=chunk-CPLRD2VP.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrorCategory",
    ()=>ErrorCategory,
    "ErrorDomain",
    ()=>ErrorDomain,
    "MastraBaseError",
    ()=>MastraBaseError,
    "MastraError",
    ()=>MastraError,
    "getErrorFromUnknown",
    ()=>getErrorFromUnknown
]);
// src/error/utils.ts
function safeParseErrorObject(obj) {
    if (typeof obj !== "object" || obj === null) {
        return String(obj);
    }
    try {
        const stringified = JSON.stringify(obj);
        if (stringified === "{}") {
            return String(obj);
        }
        return stringified;
    } catch  {
        return String(obj);
    }
}
function getErrorFromUnknown(unknown, options = {}) {
    const defaultOptions = {
        fallbackMessage: "Unknown error",
        maxDepth: 5,
        supportSerialization: true,
        serializeStack: true
    };
    const mergedOptions = options ? {
        ...defaultOptions,
        ...options
    } : defaultOptions;
    const { fallbackMessage, maxDepth, supportSerialization, serializeStack } = mergedOptions;
    if (unknown && unknown instanceof Error) {
        if (supportSerialization) {
            addErrorToJSON(unknown, serializeStack, {
                maxDepth
            });
        }
        return unknown;
    }
    let error;
    if (unknown && typeof unknown === "object") {
        const errorMessage = unknown && "message" in unknown && typeof unknown.message === "string" ? unknown.message : safeParseErrorObject(unknown);
        const errorCause = "cause" in unknown && unknown.cause !== void 0 ? unknown.cause instanceof Error ? unknown.cause : maxDepth > 0 ? getErrorFromUnknown(unknown.cause, {
            ...mergedOptions,
            maxDepth: maxDepth - 1
        }) : void 0 : void 0;
        error = new Error(errorMessage, errorCause ? {
            cause: errorCause
        } : void 0);
        Object.assign(error, unknown);
        error.stack = "stack" in unknown && typeof unknown.stack === "string" ? unknown.stack : void 0;
    } else if (unknown && typeof unknown === "string") {
        error = new Error(unknown);
        error.stack = void 0;
    } else {
        error = new Error(fallbackMessage);
    }
    if (supportSerialization) {
        addErrorToJSON(error, serializeStack, {
            maxDepth
        });
    }
    return error;
}
var DEFAULT_MAX_DEPTH = 5;
function addErrorToJSON(error, serializeStack = true, options) {
    const maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
    const currentDepth = options?.currentDepth ?? 0;
    if (error.toJSON) {
        return;
    }
    if (error.cause instanceof Error && currentDepth < maxDepth) {
        addErrorToJSON(error.cause, serializeStack, {
            maxDepth,
            currentDepth: currentDepth + 1
        });
    }
    Object.defineProperty(error, "toJSON", {
        value: function() {
            const json = {
                message: this.message,
                name: this.name
            };
            if (serializeStack && this.stack !== void 0) {
                json.stack = this.stack;
            }
            if (this.cause !== void 0) {
                if (this.cause instanceof Error && "toJSON" in this.cause && typeof this.cause.toJSON === "function") {
                    json.cause = this.cause.toJSON();
                } else {
                    json.cause = this.cause;
                }
            }
            const errorAsAny = this;
            for(const key in errorAsAny){
                if (errorAsAny.hasOwnProperty(key) && !(key in json) && key !== "toJSON") {
                    json[key] = errorAsAny[key];
                }
            }
            return json;
        },
        enumerable: false,
        writable: true,
        configurable: true
    });
}
// src/error/index.ts
var ErrorDomain = /* @__PURE__ */ ((ErrorDomain2)=>{
    ErrorDomain2["TOOL"] = "TOOL";
    ErrorDomain2["AGENT"] = "AGENT";
    ErrorDomain2["MCP"] = "MCP";
    ErrorDomain2["AGENT_NETWORK"] = "AGENT_NETWORK";
    ErrorDomain2["MASTRA_SERVER"] = "MASTRA_SERVER";
    ErrorDomain2["MASTRA_OBSERVABILITY"] = "MASTRA_OBSERVABILITY";
    ErrorDomain2["MASTRA_WORKFLOW"] = "MASTRA_WORKFLOW";
    ErrorDomain2["MASTRA_VOICE"] = "MASTRA_VOICE";
    ErrorDomain2["MASTRA_VECTOR"] = "MASTRA_VECTOR";
    ErrorDomain2["MASTRA_MEMORY"] = "MASTRA_MEMORY";
    ErrorDomain2["LLM"] = "LLM";
    ErrorDomain2["EVAL"] = "EVAL";
    ErrorDomain2["SCORER"] = "SCORER";
    ErrorDomain2["A2A"] = "A2A";
    ErrorDomain2["MASTRA_INSTANCE"] = "MASTRA_INSTANCE";
    ErrorDomain2["MASTRA"] = "MASTRA";
    ErrorDomain2["DEPLOYER"] = "DEPLOYER";
    ErrorDomain2["STORAGE"] = "STORAGE";
    ErrorDomain2["MODEL_ROUTER"] = "MODEL_ROUTER";
    return ErrorDomain2;
})(ErrorDomain || {});
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2)=>{
    ErrorCategory2["UNKNOWN"] = "UNKNOWN";
    ErrorCategory2["USER"] = "USER";
    ErrorCategory2["SYSTEM"] = "SYSTEM";
    ErrorCategory2["THIRD_PARTY"] = "THIRD_PARTY";
    return ErrorCategory2;
})(ErrorCategory || {});
var MastraBaseError = class extends Error {
    id;
    domain;
    category;
    details = {};
    message;
    cause;
    constructor(errorDefinition, originalError){
        const error = originalError ? getErrorFromUnknown(originalError, {
            serializeStack: false,
            fallbackMessage: "Unknown error"
        }) : void 0;
        const message = errorDefinition.text ?? error?.message ?? "Unknown error";
        super(message, {
            cause: error
        });
        this.id = errorDefinition.id;
        this.domain = errorDefinition.domain;
        this.category = errorDefinition.category;
        this.details = errorDefinition.details ?? {};
        this.message = message;
        this.cause = error;
        Object.setPrototypeOf(this, new.target.prototype);
    }
    /**
   * Returns a structured representation of the error, useful for logging or API responses.
   */ toJSONDetails() {
        return {
            message: this.message,
            domain: this.domain,
            category: this.category,
            details: this.details
        };
    }
    toJSON() {
        return {
            message: this.message,
            domain: this.domain,
            category: this.category,
            code: this.id,
            details: this.details,
            cause: this.cause?.toJSON?.()
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
};
var MastraError = class extends MastraBaseError {
};
;
 //# sourceMappingURL=chunk-FJEVLHJT.js.map
 //# sourceMappingURL=chunk-FJEVLHJT.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-NRUZYMHE.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ConsoleLogger",
    ()=>ConsoleLogger,
    "LogLevel",
    ()=>LogLevel,
    "MastraLogger",
    ()=>MastraLogger,
    "RegisteredLogger",
    ()=>RegisteredLogger,
    "createLogger",
    ()=>createLogger
]);
// src/logger/constants.ts
var RegisteredLogger = {
    AGENT: "AGENT",
    OBSERVABILITY: "OBSERVABILITY",
    AUTH: "AUTH",
    NETWORK: "NETWORK",
    WORKFLOW: "WORKFLOW",
    LLM: "LLM",
    TTS: "TTS",
    VOICE: "VOICE",
    VECTOR: "VECTOR",
    BUNDLER: "BUNDLER",
    DEPLOYER: "DEPLOYER",
    MEMORY: "MEMORY",
    STORAGE: "STORAGE",
    EMBEDDINGS: "EMBEDDINGS",
    MCP_SERVER: "MCP_SERVER",
    SERVER_CACHE: "SERVER_CACHE",
    SERVER: "SERVER"
};
var LogLevel = {
    DEBUG: "debug",
    INFO: "info",
    WARN: "warn",
    ERROR: "error",
    NONE: "silent"
};
// src/logger/logger.ts
var MastraLogger = class {
    name;
    level;
    transports;
    constructor(options = {}){
        this.name = options.name || "Mastra";
        this.level = options.level || LogLevel.ERROR;
        this.transports = new Map(Object.entries(options.transports || {}));
    }
    getTransports() {
        return this.transports;
    }
    trackException(_error) {}
    async listLogs(transportId, params) {
        if (!transportId || !this.transports.has(transportId)) {
            return {
                logs: [],
                total: 0,
                page: params?.page ?? 1,
                perPage: params?.perPage ?? 100,
                hasMore: false
            };
        }
        return this.transports.get(transportId).listLogs(params) ?? {
            logs: [],
            total: 0,
            page: params?.page ?? 1,
            perPage: params?.perPage ?? 100,
            hasMore: false
        };
    }
    async listLogsByRunId({ transportId, runId, fromDate, toDate, logLevel, filters, page, perPage }) {
        if (!transportId || !this.transports.has(transportId) || !runId) {
            return {
                logs: [],
                total: 0,
                page: page ?? 1,
                perPage: perPage ?? 100,
                hasMore: false
            };
        }
        return this.transports.get(transportId).listLogsByRunId({
            runId,
            fromDate,
            toDate,
            logLevel,
            filters,
            page,
            perPage
        }) ?? {
            logs: [],
            total: 0,
            page: page ?? 1,
            perPage: perPage ?? 100,
            hasMore: false
        };
    }
};
// src/logger/default-logger.ts
var createLogger = (options)=>{
    const logger = new ConsoleLogger(options);
    logger.warn(`createLogger is deprecated. Please use "new ConsoleLogger()" from "@mastra/core/logger" instead.`);
    return logger;
};
var ConsoleLogger = class extends MastraLogger {
    constructor(options = {}){
        super(options);
    }
    debug(message, ...args) {
        if (this.level === LogLevel.DEBUG) {
            console.info(message, ...args);
        }
    }
    info(message, ...args) {
        if (this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.info(message, ...args);
        }
    }
    warn(message, ...args) {
        if (this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.info(message, ...args);
        }
    }
    error(message, ...args) {
        if (this.level === LogLevel.ERROR || this.level === LogLevel.WARN || this.level === LogLevel.INFO || this.level === LogLevel.DEBUG) {
            console.error(message, ...args);
        }
    }
    async listLogs(_transportId, _params) {
        return {
            logs: [],
            total: 0,
            page: _params?.page ?? 1,
            perPage: _params?.perPage ?? 100,
            hasMore: false
        };
    }
    async listLogsByRunId(_args) {
        return {
            logs: [],
            total: 0,
            page: _args.page ?? 1,
            perPage: _args.perPage ?? 100,
            hasMore: false
        };
    }
};
;
 //# sourceMappingURL=chunk-NRUZYMHE.js.map
 //# sourceMappingURL=chunk-NRUZYMHE.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MastraBase",
    ()=>MastraBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-NRUZYMHE.js [app-route] (ecmascript)");
;
// src/base.ts
var MastraBase = class {
    component = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM;
    logger;
    name;
    constructor({ component, name }){
        this.component = component || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM;
        this.name = name;
        this.logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ConsoleLogger"]({
            name: `${this.component} - ${this.name}`
        });
    }
    /**
   * Set the logger for the agent
   * @param logger
   */ __setLogger(logger) {
        this.logger = logger;
        if (this.component !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegisteredLogger"].LLM) {
            this.logger.debug(`Logger updated [component=${this.component}] [name=${this.name}]`);
        }
    }
};
;
 //# sourceMappingURL=chunk-LSHPJWM5.js.map
 //# sourceMappingURL=chunk-LSHPJWM5.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-TX5GUG5Q.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AISDKSpeech",
    ()=>AISDKSpeech,
    "AISDKTranscription",
    ()=>AISDKTranscription,
    "CompositeVoice",
    ()=>CompositeVoice,
    "DefaultVoice",
    ()=>DefaultVoice,
    "MastraVoice",
    ()=>MastraVoice
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-K2LPTKSY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
;
;
;
;
// src/voice/voice.ts
var MastraVoice = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    listeningModel;
    speechModel;
    speaker;
    realtimeConfig;
    constructor({ listeningModel, speechModel, speaker, realtimeConfig, name } = {}){
        super({
            component: "VOICE",
            name
        });
        this.listeningModel = listeningModel;
        this.speechModel = speechModel;
        this.speaker = speaker;
        this.realtimeConfig = realtimeConfig;
    }
    updateConfig(_options) {
        this.logger.warn("updateConfig not implemented by this voice provider");
    }
    /**
   * Initializes a WebSocket or WebRTC connection for real-time communication
   * @returns Promise that resolves when the connection is established
   */ connect(_options) {
        this.logger.warn("connect not implemented by this voice provider");
        return Promise.resolve();
    }
    /**
   * Relay audio data to the voice provider for real-time processing
   * @param audioData Audio data to relay
   */ send(_audioData) {
        this.logger.warn("relay not implemented by this voice provider");
        return Promise.resolve();
    }
    /**
   * Trigger voice providers to respond
   */ answer(_options) {
        this.logger.warn("answer not implemented by this voice provider");
        return Promise.resolve();
    }
    /**
   * Equip the voice provider with instructions
   * @param instructions Instructions to add
   */ addInstructions(_instructions) {}
    /**
   * Equip the voice provider with tools
   * @param tools Array of tools to add
   */ addTools(_tools) {}
    /**
   * Disconnect from the WebSocket or WebRTC connection
   */ close() {
        this.logger.warn("close not implemented by this voice provider");
    }
    /**
   * Register an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function that receives event data
   */ on(_event, _callback) {
        this.logger.warn("on not implemented by this voice provider");
    }
    /**
   * Remove an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function to remove
   */ off(_event, _callback) {
        this.logger.warn("off not implemented by this voice provider");
    }
    /**
   * Get available speakers/voices
   * @returns Array of available voice IDs and their metadata
   */ getSpeakers() {
        this.logger.warn("getSpeakers not implemented by this voice provider");
        return Promise.resolve([]);
    }
    /**
   * Get available speakers/voices
   * @returns Array of available voice IDs and their metadata
   */ getListener() {
        this.logger.warn("getListener not implemented by this voice provider");
        return Promise.resolve({
            enabled: false
        });
    }
};
var AISDKSpeech = class extends MastraVoice {
    model;
    defaultVoice;
    constructor(model, options){
        super({
            name: "ai-sdk-speech"
        });
        this.model = model;
        this.defaultVoice = options?.voice;
    }
    async speak(input, options) {
        const text = typeof input === "string" ? input : await this.streamToText(input);
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateSpeech"])({
            model: this.model,
            text,
            voice: options?.speaker || this.defaultVoice,
            // Map speaker to AI SDK's voice parameter
            language: options?.language,
            providerOptions: options?.providerOptions,
            abortSignal: options?.abortSignal,
            headers: options?.headers
        });
        const stream = new __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["PassThrough"]();
        stream.end(Buffer.from(result.audio.uint8Array));
        return stream;
    }
    async listen() {
        throw new Error("AI SDK speech models do not support transcription. Use AISDKTranscription instead.");
    }
    async getSpeakers() {
        return [];
    }
    async getListener() {
        return {
            enabled: false
        };
    }
    async streamToText(stream) {
        const chunks = [];
        for await (const chunk of stream){
            chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
        }
        return Buffer.concat(chunks).toString("utf-8");
    }
};
// src/voice/aisdk/transcription.ts
var AISDKTranscription = class extends MastraVoice {
    model;
    constructor(model){
        super({
            name: "ai-sdk-transcription"
        });
        this.model = model;
    }
    async speak() {
        throw new Error("AI SDK transcription models do not support text-to-speech. Use AISDKSpeech instead.");
    }
    async getSpeakers() {
        return [];
    }
    async getListener() {
        return {
            enabled: true
        };
    }
    /**
   * Transcribe audio to text
   * For enhanced metadata (segments, language, duration), use AI SDK's transcribe() directly
   */ async listen(audioStream, options) {
        const audioBuffer = await this.convertToBuffer(audioStream);
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["transcribe"])({
            model: this.model,
            audio: audioBuffer,
            providerOptions: options?.providerOptions,
            abortSignal: options?.abortSignal,
            headers: options?.headers
        });
        return result.text;
    }
    async convertToBuffer(audio) {
        if (Buffer.isBuffer(audio)) return audio;
        if (audio instanceof Uint8Array) return Buffer.from(audio);
        if (typeof audio === "string") return Buffer.from(audio, "base64");
        const chunks = [];
        for await (const chunk of audio){
            chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
        }
        return Buffer.concat(chunks);
    }
};
// src/voice/composite-voice.ts
var supportedSpecificationVersions = [
    "v2",
    "v3"
];
function isTranscriptionModel(obj) {
    return obj && typeof obj === "object" && obj.modelId && supportedSpecificationVersions.includes(obj.specificationVersion);
}
function isSpeechModel(obj) {
    return obj && typeof obj === "object" && obj.modelId && supportedSpecificationVersions.includes(obj.specificationVersion);
}
var CompositeVoice = class extends MastraVoice {
    speakProvider;
    listenProvider;
    realtimeProvider;
    constructor({ input, output, realtime }){
        super();
        if (input) {
            this.listenProvider = isTranscriptionModel(input) ? new AISDKTranscription(input) : input;
        }
        if (output) {
            this.speakProvider = isSpeechModel(output) ? new AISDKSpeech(output) : output;
        }
        this.realtimeProvider = realtime;
    }
    /**
   * Convert text to speech using the configured provider
   * @param input Text or text stream to convert to speech
   * @param options Speech options including speaker and provider-specific options
   * @returns Audio stream or void if in realtime mode
   */ async speak(input, options) {
        if (this.realtimeProvider) {
            return this.realtimeProvider.speak(input, options);
        } else if (this.speakProvider) {
            return this.speakProvider.speak(input, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_COMPOSITE_NO_SPEAK_PROVIDER",
            text: "No speak provider or realtime provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async listen(audioStream, options) {
        if (this.realtimeProvider) {
            return await this.realtimeProvider.listen(audioStream, options);
        } else if (this.listenProvider) {
            return await this.listenProvider.listen(audioStream, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_COMPOSITE_NO_LISTEN_PROVIDER",
            text: "No listen provider or realtime provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async getSpeakers() {
        if (this.realtimeProvider) {
            return this.realtimeProvider.getSpeakers();
        } else if (this.speakProvider) {
            return this.speakProvider.getSpeakers();
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_COMPOSITE_NO_SPEAKERS_PROVIDER",
            text: "No speak provider or realtime provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async getListener() {
        if (this.realtimeProvider) {
            return this.realtimeProvider.getListener();
        } else if (this.listenProvider) {
            return this.listenProvider.getListener();
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_COMPOSITE_NO_LISTENER_PROVIDER",
            text: "No listener provider or realtime provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    updateConfig(options) {
        if (!this.realtimeProvider) {
            return;
        }
        this.realtimeProvider.updateConfig(options);
    }
    /**
   * Initializes a WebSocket or WebRTC connection for real-time communication
   * @returns Promise that resolves when the connection is established
   */ connect(options) {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CONNECT",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        return this.realtimeProvider.connect(options);
    }
    /**
   * Relay audio data to the voice provider for real-time processing
   * @param audioData Audio data to send
   */ send(audioData) {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_SEND",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        return this.realtimeProvider.send(audioData);
    }
    /**
   * Trigger voice providers to respond
   */ answer(options) {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ANSWER",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        return this.realtimeProvider.answer(options);
    }
    /**
   * Equip the voice provider with instructions
   * @param instructions Instructions to add
   */ addInstructions(instructions) {
        if (!this.realtimeProvider) {
            return;
        }
        this.realtimeProvider.addInstructions(instructions);
    }
    /**
   * Equip the voice provider with tools
   * @param tools Array of tools to add
   */ addTools(tools) {
        if (!this.realtimeProvider) {
            return;
        }
        this.realtimeProvider.addTools(tools);
    }
    /**
   * Disconnect from the WebSocket or WebRTC connection
   */ close() {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CLOSE",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        this.realtimeProvider.close();
    }
    /**
   * Register an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function that receives event data
   */ on(event, callback) {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ON",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        this.realtimeProvider.on(event, callback);
    }
    /**
   * Remove an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function to remove
   */ off(event, callback) {
        if (!this.realtimeProvider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VOICE_COMPOSITE_NO_REALTIME_PROVIDER_OFF",
                text: "No realtime provider configured",
                domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
                category: "USER" /* USER */ 
            });
        }
        this.realtimeProvider.off(event, callback);
    }
};
// src/voice/default-voice.ts
var DefaultVoice = class extends MastraVoice {
    constructor(){
        super();
    }
    async speak(_input) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_DEFAULT_NO_SPEAK_PROVIDER",
            text: "No voice provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async listen(_input) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_DEFAULT_NO_LISTEN_PROVIDER",
            text: "No voice provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async getSpeakers() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_DEFAULT_NO_SPEAKERS_PROVIDER",
            text: "No voice provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
    async getListener() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "VOICE_DEFAULT_NO_LISTENER_PROVIDER",
            text: "No voice provider configured",
            domain: "MASTRA_VOICE" /* MASTRA_VOICE */ ,
            category: "USER" /* USER */ 
        });
    }
};
;
 //# sourceMappingURL=chunk-TX5GUG5Q.js.map
 //# sourceMappingURL=chunk-TX5GUG5Q.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-YEQB4VUA.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PUBSUB_SYMBOL",
    ()=>PUBSUB_SYMBOL,
    "STREAM_FORMAT_SYMBOL",
    ()=>STREAM_FORMAT_SYMBOL
]);
// src/workflows/constants.ts
var PUBSUB_SYMBOL = /* @__PURE__ */ Symbol("pubsub");
var STREAM_FORMAT_SYMBOL = /* @__PURE__ */ Symbol("stream_format");
;
 //# sourceMappingURL=chunk-YEQB4VUA.js.map
 //# sourceMappingURL=chunk-YEQB4VUA.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-XKBYPAOY.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EntityType",
    ()=>EntityType,
    "InternalSpans",
    ()=>InternalSpans,
    "NoOpObservability",
    ()=>NoOpObservability,
    "SamplingStrategyType",
    ()=>SamplingStrategyType,
    "SpanType",
    ()=>SpanType,
    "TracingEventType",
    ()=>TracingEventType,
    "executeWithContext",
    ()=>executeWithContext,
    "executeWithContextSync",
    ()=>executeWithContextSync,
    "getOrCreateSpan",
    ()=>getOrCreateSpan,
    "wrapMastra",
    ()=>wrapMastra
]);
// src/observability/types/tracing.ts
var SpanType = /* @__PURE__ */ ((SpanType2)=>{
    SpanType2["AGENT_RUN"] = "agent_run";
    SpanType2["GENERIC"] = "generic";
    SpanType2["MODEL_GENERATION"] = "model_generation";
    SpanType2["MODEL_STEP"] = "model_step";
    SpanType2["MODEL_CHUNK"] = "model_chunk";
    SpanType2["MCP_TOOL_CALL"] = "mcp_tool_call";
    SpanType2["PROCESSOR_RUN"] = "processor_run";
    SpanType2["TOOL_CALL"] = "tool_call";
    SpanType2["WORKFLOW_RUN"] = "workflow_run";
    SpanType2["WORKFLOW_STEP"] = "workflow_step";
    SpanType2["WORKFLOW_CONDITIONAL"] = "workflow_conditional";
    SpanType2["WORKFLOW_CONDITIONAL_EVAL"] = "workflow_conditional_eval";
    SpanType2["WORKFLOW_PARALLEL"] = "workflow_parallel";
    SpanType2["WORKFLOW_LOOP"] = "workflow_loop";
    SpanType2["WORKFLOW_SLEEP"] = "workflow_sleep";
    SpanType2["WORKFLOW_WAIT_EVENT"] = "workflow_wait_event";
    return SpanType2;
})(SpanType || {});
var EntityType = /* @__PURE__ */ ((EntityType2)=>{
    EntityType2["AGENT"] = "agent";
    EntityType2["EVAL"] = "eval";
    EntityType2["INPUT_PROCESSOR"] = "input_processor";
    EntityType2["INPUT_STEP_PROCESSOR"] = "input_step_processor";
    EntityType2["OUTPUT_PROCESSOR"] = "output_processor";
    EntityType2["OUTPUT_STEP_PROCESSOR"] = "output_step_processor";
    EntityType2["WORKFLOW_STEP"] = "workflow_step";
    EntityType2["TOOL"] = "tool";
    EntityType2["WORKFLOW_RUN"] = "workflow_run";
    return EntityType2;
})(EntityType || {});
var InternalSpans = /* @__PURE__ */ ((InternalSpans2)=>{
    InternalSpans2[InternalSpans2["NONE"] = 0] = "NONE";
    InternalSpans2[InternalSpans2["WORKFLOW"] = 1] = "WORKFLOW";
    InternalSpans2[InternalSpans2["AGENT"] = 2] = "AGENT";
    InternalSpans2[InternalSpans2["TOOL"] = 4] = "TOOL";
    InternalSpans2[InternalSpans2["MODEL"] = 8] = "MODEL";
    InternalSpans2[InternalSpans2["ALL"] = 15] = "ALL";
    return InternalSpans2;
})(InternalSpans || {});
var SamplingStrategyType = /* @__PURE__ */ ((SamplingStrategyType2)=>{
    SamplingStrategyType2["ALWAYS"] = "always";
    SamplingStrategyType2["NEVER"] = "never";
    SamplingStrategyType2["RATIO"] = "ratio";
    SamplingStrategyType2["CUSTOM"] = "custom";
    return SamplingStrategyType2;
})(SamplingStrategyType || {});
var TracingEventType = /* @__PURE__ */ ((TracingEventType2)=>{
    TracingEventType2["SPAN_STARTED"] = "span_started";
    TracingEventType2["SPAN_UPDATED"] = "span_updated";
    TracingEventType2["SPAN_ENDED"] = "span_ended";
    return TracingEventType2;
})(TracingEventType || {});
// src/observability/no-op.ts
var NoOpObservability = class {
    setMastraContext(_options) {
        return;
    }
    setLogger(_options) {
        return;
    }
    getSelectedInstance(_options) {
        return;
    }
    registerInstance(_name, _instance, _isDefault = false) {
        return;
    }
    getInstance(_name) {
        return;
    }
    getDefaultInstance() {
        return;
    }
    listInstances() {
        return /* @__PURE__ */ new Map();
    }
    unregisterInstance(_name) {
        return false;
    }
    hasInstance(_name) {
        return false;
    }
    setConfigSelector(_selector) {
        return;
    }
    clear() {
        return;
    }
    async shutdown() {
        return;
    }
};
// src/observability/utils.ts
function getOrCreateSpan(options) {
    const { type, attributes, tracingContext, requestContext, tracingOptions, ...rest } = options;
    const metadata = {
        ...rest.metadata ?? {},
        ...tracingOptions?.metadata ?? {}
    };
    if (tracingContext?.currentSpan) {
        return tracingContext.currentSpan.createChildSpan({
            type,
            attributes,
            ...rest,
            metadata
        });
    }
    const instance = options.mastra?.observability?.getSelectedInstance({
        requestContext
    });
    return instance?.startSpan({
        type,
        attributes,
        ...rest,
        metadata,
        requestContext,
        tracingOptions,
        traceId: tracingOptions?.traceId,
        parentSpanId: tracingOptions?.parentSpanId,
        customSamplerOptions: {
            requestContext,
            metadata
        }
    });
}
async function executeWithContext(params) {
    const { span, fn } = params;
    if (span?.executeInContext) {
        return span.executeInContext(fn);
    }
    return fn();
}
function executeWithContextSync(params) {
    const { span, fn } = params;
    if (span?.executeInContextSync) {
        return span.executeInContextSync(fn);
    }
    return fn();
}
// src/observability/context.ts
var AGENT_GETTERS = [
    "getAgent",
    "getAgentById"
];
var AGENT_METHODS_TO_WRAP = [
    "generate",
    "stream",
    "generateLegacy",
    "streamLegacy"
];
var WORKFLOW_GETTERS = [
    "getWorkflow",
    "getWorkflowById"
];
var WORKFLOW_METHODS_TO_WRAP = [
    "execute",
    "createRun",
    "createRun"
];
function isNoOpSpan(span) {
    return span.constructor.name === "NoOpSpan" || span.__isNoOp === true;
}
function isMastra(mastra) {
    const hasAgentGetters = AGENT_GETTERS.every((method)=>typeof mastra?.[method] === "function");
    const hasWorkflowGetters = WORKFLOW_GETTERS.every((method)=>typeof mastra?.[method] === "function");
    return hasAgentGetters && hasWorkflowGetters;
}
function wrapMastra(mastra, tracingContext) {
    if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
        return mastra;
    }
    if (!isMastra(mastra)) {
        return mastra;
    }
    try {
        return new Proxy(mastra, {
            get (target, prop) {
                try {
                    if (AGENT_GETTERS.includes(prop)) {
                        return (...args)=>{
                            const agent = target[prop](...args);
                            return wrapAgent(agent, tracingContext);
                        };
                    }
                    if (WORKFLOW_GETTERS.includes(prop)) {
                        return (...args)=>{
                            const workflow = target[prop](...args);
                            return wrapWorkflow(workflow, tracingContext);
                        };
                    }
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                } catch (error) {
                    console.warn("Tracing: Failed to wrap method, falling back to original", error);
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                }
            }
        });
    } catch (error) {
        console.warn("Tracing: Failed to create proxy, using original Mastra instance", error);
        return mastra;
    }
}
function wrapAgent(agent, tracingContext) {
    if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
        return agent;
    }
    try {
        return new Proxy(agent, {
            get (target, prop) {
                try {
                    if (AGENT_METHODS_TO_WRAP.includes(prop)) {
                        return (input, options = {})=>{
                            return target[prop](input, {
                                ...options,
                                tracingContext
                            });
                        };
                    }
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                } catch (error) {
                    console.warn("Tracing: Failed to wrap agent method, falling back to original", error);
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                }
            }
        });
    } catch (error) {
        console.warn("Tracing: Failed to create agent proxy, using original instance", error);
        return agent;
    }
}
function wrapWorkflow(workflow, tracingContext) {
    if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
        return workflow;
    }
    try {
        return new Proxy(workflow, {
            get (target, prop) {
                try {
                    if (WORKFLOW_METHODS_TO_WRAP.includes(prop)) {
                        if (prop === "createRun" || prop === "createRun") {
                            return async (options = {})=>{
                                const run = await target[prop](options);
                                return run ? wrapRun(run, tracingContext) : run;
                            };
                        }
                        return (input, options = {})=>{
                            return target[prop](input, {
                                ...options,
                                tracingContext
                            });
                        };
                    }
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                } catch (error) {
                    console.warn("Tracing: Failed to wrap workflow method, falling back to original", error);
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                }
            }
        });
    } catch (error) {
        console.warn("Tracing: Failed to create workflow proxy, using original instance", error);
        return workflow;
    }
}
function wrapRun(run, tracingContext) {
    if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {
        return run;
    }
    try {
        return new Proxy(run, {
            get (target, prop) {
                try {
                    if (prop === "start") {
                        return (startOptions = {})=>{
                            return target.start({
                                ...startOptions,
                                tracingContext: startOptions.tracingContext ?? tracingContext
                            });
                        };
                    }
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                } catch (error) {
                    console.warn("Tracing: Failed to wrap run method, falling back to original", error);
                    const value = target[prop];
                    return typeof value === "function" ? value.bind(target) : value;
                }
            }
        });
    } catch (error) {
        console.warn("Tracing: Failed to create run proxy, using original instance", error);
        return run;
    }
}
;
 //# sourceMappingURL=chunk-XKBYPAOY.js.map
 //# sourceMappingURL=chunk-XKBYPAOY.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-AIJLACR2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getZodDef",
    ()=>getZodDef,
    "getZodTypeName",
    ()=>getZodTypeName,
    "isZodArray",
    ()=>isZodArray,
    "isZodObject",
    ()=>isZodObject
]);
// src/utils/zod-utils.ts
function isZodType(value) {
    return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function getZodTypeName(schema) {
    const schemaAny = schema;
    if (schemaAny._def?.typeName) {
        return schemaAny._def.typeName;
    }
    const zod4Type = schemaAny._def?.type;
    if (typeof zod4Type === "string" && zod4Type) {
        return "Zod" + zod4Type.charAt(0).toUpperCase() + zod4Type.slice(1);
    }
    return void 0;
}
function isZodArray(value) {
    if (!isZodType(value)) return false;
    return getZodTypeName(value) === "ZodArray";
}
function isZodObject(value) {
    if (!isZodType(value)) return false;
    return getZodTypeName(value) === "ZodObject";
}
function getZodDef(schema) {
    const schemaAny = schema;
    return schemaAny._zod?.def ?? schemaAny._def;
}
;
 //# sourceMappingURL=chunk-AIJLACR2.js.map
 //# sourceMappingURL=chunk-AIJLACR2.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-65QFXXAD.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AGENTS_SCHEMA",
    ()=>AGENTS_SCHEMA,
    "OLD_SPAN_SCHEMA",
    ()=>OLD_SPAN_SCHEMA,
    "SCORERS_SCHEMA",
    ()=>SCORERS_SCHEMA,
    "SPAN_SCHEMA",
    ()=>SPAN_SCHEMA,
    "TABLE_AGENTS",
    ()=>TABLE_AGENTS,
    "TABLE_MESSAGES",
    ()=>TABLE_MESSAGES,
    "TABLE_RESOURCES",
    ()=>TABLE_RESOURCES,
    "TABLE_SCHEMAS",
    ()=>TABLE_SCHEMAS,
    "TABLE_SCORERS",
    ()=>TABLE_SCORERS,
    "TABLE_SPANS",
    ()=>TABLE_SPANS,
    "TABLE_THREADS",
    ()=>TABLE_THREADS,
    "TABLE_TRACES",
    ()=>TABLE_TRACES,
    "TABLE_WORKFLOW_SNAPSHOT",
    ()=>TABLE_WORKFLOW_SNAPSHOT,
    "TraceStatus",
    ()=>TraceStatus,
    "batchCreateSpansArgsSchema",
    ()=>batchCreateSpansArgsSchema,
    "batchDeleteTracesArgsSchema",
    ()=>batchDeleteTracesArgsSchema,
    "batchUpdateSpansArgsSchema",
    ()=>batchUpdateSpansArgsSchema,
    "buildStorageSchema",
    ()=>buildStorageSchema,
    "createSpanArgsSchema",
    ()=>createSpanArgsSchema,
    "createSpanRecordSchema",
    ()=>createSpanRecordSchema,
    "createdAtField",
    ()=>createdAtField,
    "dateRangeSchema",
    ()=>dateRangeSchema,
    "dbTimestamps",
    ()=>dbTimestamps,
    "entityIdField",
    ()=>entityIdField,
    "entityNameField",
    ()=>entityNameField,
    "entityTypeField",
    ()=>entityTypeField,
    "environmentField",
    ()=>environmentField,
    "getRootSpanArgsSchema",
    ()=>getRootSpanArgsSchema,
    "getRootSpanResponseSchema",
    ()=>getRootSpanResponseSchema,
    "getSpanArgsSchema",
    ()=>getSpanArgsSchema,
    "getSpanResponseSchema",
    ()=>getSpanResponseSchema,
    "getTraceArgsSchema",
    ()=>getTraceArgsSchema,
    "getTraceResponseSchema",
    ()=>getTraceResponseSchema,
    "listScoresBySpanResponseSchema",
    ()=>listScoresBySpanResponseSchema,
    "listScoresResponseSchema",
    ()=>listScoresResponseSchema,
    "listTracesArgsSchema",
    ()=>listTracesArgsSchema,
    "listTracesResponseSchema",
    ()=>listTracesResponseSchema,
    "organizationIdField",
    ()=>organizationIdField,
    "paginationArgsSchema",
    ()=>paginationArgsSchema,
    "paginationInfoSchema",
    ()=>paginationInfoSchema,
    "requestIdField",
    ()=>requestIdField,
    "resourceIdField",
    ()=>resourceIdField,
    "runIdField",
    ()=>runIdField,
    "saveScorePayloadSchema",
    ()=>saveScorePayloadSchema,
    "scoreResultSchema",
    ()=>scoreResultSchema,
    "scoreRowDataSchema",
    ()=>scoreRowDataSchema,
    "scoreTracesRequestSchema",
    ()=>scoreTracesRequestSchema,
    "scoreTracesResponseSchema",
    ()=>scoreTracesResponseSchema,
    "scoringEntityTypeSchema",
    ()=>scoringEntityTypeSchema,
    "scoringExtractStepResultSchema",
    ()=>scoringExtractStepResultSchema,
    "scoringHookInputSchema",
    ()=>scoringHookInputSchema,
    "scoringInputSchema",
    ()=>scoringInputSchema,
    "scoringInputWithExtractStepResultAndAnalyzeStepResultSchema",
    ()=>scoringInputWithExtractStepResultAndAnalyzeStepResultSchema,
    "scoringInputWithExtractStepResultAndScoreAndReasonSchema",
    ()=>scoringInputWithExtractStepResultAndScoreAndReasonSchema,
    "scoringInputWithExtractStepResultSchema",
    ()=>scoringInputWithExtractStepResultSchema,
    "scoringPromptsSchema",
    ()=>scoringPromptsSchema,
    "scoringSourceSchema",
    ()=>scoringSourceSchema,
    "scoringValueSchema",
    ()=>scoringValueSchema,
    "serviceNameField",
    ()=>serviceNameField,
    "sessionIdField",
    ()=>sessionIdField,
    "sortDirectionSchema",
    ()=>sortDirectionSchema,
    "sourceField",
    ()=>sourceField,
    "spanIdField",
    ()=>spanIdField,
    "spanIds",
    ()=>spanIds,
    "spanIdsSchema",
    ()=>spanIdsSchema,
    "spanRecordSchema",
    ()=>spanRecordSchema,
    "threadIdField",
    ()=>threadIdField,
    "traceIdField",
    ()=>traceIdField,
    "tracesFilterSchema",
    ()=>tracesFilterSchema,
    "tracesOrderByFieldSchema",
    ()=>tracesOrderByFieldSchema,
    "tracesOrderBySchema",
    ()=>tracesOrderBySchema,
    "updateSpanArgsSchema",
    ()=>updateSpanArgsSchema,
    "updateSpanRecordSchema",
    ()=>updateSpanRecordSchema,
    "updatedAtField",
    ()=>updatedAtField,
    "userIdField",
    ()=>userIdField
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-XKBYPAOY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-AIJLACR2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
var createdAtField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().describe("Database record creation time");
var updatedAtField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().describe("Database record last update time");
var dbTimestamps = {
    createdAt: createdAtField,
    updatedAt: updatedAtField.nullable()
};
var paginationArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    page: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].coerce.number().int().min(0).optional().default(0).describe("Zero-indexed page number"),
    perPage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].coerce.number().int().min(1).max(100).optional().default(10).describe("Number of items per page")
}).describe("Pagination options for list queries");
var paginationInfoSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    total: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().describe("Total number of items available"),
    page: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().describe("Current page"),
    perPage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(false)
    ]).describe("Number of items per page, or false if pagination is disabled"),
    hasMore: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().describe("True if more pages are available")
});
var dateRangeSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].coerce.date().optional().describe("Start of date range (inclusive by default)"),
    end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].coerce.date().optional().describe("End of date range (inclusive by default)"),
    startExclusive: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().describe("When true, excludes the start date from results (uses > instead of >=)"),
    endExclusive: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().describe("When true, excludes the end date from results (uses < instead of <=)")
}).describe("Date range filter for timestamps");
var sortDirectionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
    "ASC",
    "DESC"
]).describe("Sort direction: 'ASC' | 'DESC'");
var entityTypeField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].nativeEnum(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EntityType"]).describe(`Entity type (e.g., 'agent' | 'processor' | 'tool' | 'workflow')`);
var entityIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe('ID of the entity (e.g., "weatherAgent", "orderWorkflow")');
var entityNameField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Name of the entity");
var userIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Human end-user who triggered execution");
var organizationIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Multi-tenant organization/account");
var resourceIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Broader resource context (Mastra memory compatibility)");
var runIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Unique execution run identifier");
var sessionIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Session identifier for grouping traces");
var threadIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Conversation thread identifier");
var requestIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("HTTP request ID for log correlation");
var environmentField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe(`Environment (e.g., "production" | "staging" | "development")`);
var sourceField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe(`Source of execution (e.g., "local" | "cloud" | "ci")`);
var serviceNameField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Name of the service");
// src/evals/types.ts
var scoringSourceSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
    "LIVE",
    "TEST"
]);
var scoringEntityTypeSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
    "AGENT",
    "WORKFLOW",
    ...Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SpanType"])
]);
var scoringPromptsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    prompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
var recordSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown());
var optionalRecordSchema = recordSchema.optional();
var scoringInputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    runId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional(),
    output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    additionalContext: optionalRecordSchema,
    requestContext: optionalRecordSchema
});
var scoringHookInputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    runId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    scorer: recordSchema,
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    metadata: optionalRecordSchema,
    additionalContext: optionalRecordSchema,
    source: scoringSourceSchema,
    entity: recordSchema,
    entityType: scoringEntityTypeSchema,
    requestContext: optionalRecordSchema,
    structuredOutput: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional(),
    traceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    spanId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    resourceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    threadId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var scoringExtractStepResultSchema = optionalRecordSchema;
var scoringValueSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number();
var scoreResultSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    result: optionalRecordSchema,
    score: scoringValueSchema,
    prompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var scoringInputWithExtractStepResultSchema = scoringInputSchema.extend({
    runId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    // Required in this context
    extractStepResult: optionalRecordSchema,
    extractPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultSchema.extend({
    score: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
    analyzeStepResult: optionalRecordSchema,
    analyzePrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema.extend({
    reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    reasonPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var scoreRowDataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    scorerId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    entityId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    // From ScoringInputWithExtractStepResultAndScoreAndReason
    runId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional(),
    output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    additionalContext: optionalRecordSchema,
    requestContext: optionalRecordSchema,
    extractStepResult: optionalRecordSchema,
    extractPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    score: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
    analyzeStepResult: optionalRecordSchema,
    analyzePrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    reasonPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    // From ScoringHookInput
    scorer: recordSchema,
    metadata: optionalRecordSchema,
    source: scoringSourceSchema,
    entity: recordSchema,
    entityType: scoringEntityTypeSchema.optional(),
    structuredOutput: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional(),
    traceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    spanId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    resourceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    threadId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    // Additional ScoreRowData fields
    preprocessStepResult: optionalRecordSchema,
    preprocessPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    generateScorePrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    generateReasonPrompt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    // Timestamps
    ...dbTimestamps
});
var saveScorePayloadSchema = scoreRowDataSchema.omit({
    id: true,
    createdAt: true,
    updatedAt: true
});
var listScoresResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    pagination: paginationInfoSchema,
    scores: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(scoreRowDataSchema)
});
// src/storage/domains/observability/types.ts
var createOmitKeys = (shape)=>Object.fromEntries(Object.keys(shape).map((k)=>[
            k,
            true
        ]));
var traceIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Unique trace identifier");
var spanIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Unique span identifier within a trace");
var spanNameField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Human-readable span name");
var parentSpanIdField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("Parent span reference (null = root span)");
var spanTypeField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].nativeEnum(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SpanType"]).describe("Span type (e.g., WORKFLOW_RUN, AGENT_RUN, TOOL_CALL, etc.)");
var attributesField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).describe("Span-type specific attributes (e.g., model, tokens, tools)");
var metadataField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).describe("User-defined metadata for custom filtering");
var tagsField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).describe("Labels for filtering traces (only on the root span)");
var scopeField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).describe('Arbitrary package/app version info (e.g., {"core": "1.0.0", "memory": "1.0.0", "gitSha": "abcd1234"})');
var linksField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).describe("References to related spans in other traces");
var inputField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().describe("Input data passed to the span");
var outputField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().describe("Output data returned from the span");
var errorField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().describe("Error info - presence indicates failure (status derived from this)");
var isEventField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().describe("Whether this is an event (point-in-time) vs a span (duration)");
var startedAtField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().describe("When the span started");
var endedAtField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().describe("When the span ended (null = running, status derived from this)");
var TraceStatus = /* @__PURE__ */ ((TraceStatus2)=>{
    TraceStatus2["SUCCESS"] = "success";
    TraceStatus2["ERROR"] = "error";
    TraceStatus2["RUNNING"] = "running";
    return TraceStatus2;
})(TraceStatus || {});
var traceStatusField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].nativeEnum(TraceStatus).describe("Current status of the trace");
var hasChildErrorField = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].preprocess((v)=>{
    if (v === "true") return true;
    if (v === "false") return false;
    return v;
}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean()).describe("True if any span in the trace encountered an error");
var sharedFields = {
    // Entity identification - first-class fields for filtering (e.g., agent, workflow, tool)
    entityType: entityTypeField.nullish(),
    entityId: entityIdField.nullish(),
    entityName: entityNameField.nullish(),
    // Identity & tenancy - for multi-tenant applications
    userId: userIdField.nullish(),
    organizationId: organizationIdField.nullish(),
    resourceId: resourceIdField.nullish(),
    // Correlation IDs - for linking related operations
    runId: runIdField.nullish(),
    sessionId: sessionIdField.nullish(),
    threadId: threadIdField.nullish(),
    requestId: requestIdField.nullish(),
    // Deployment context - these fields only exist on the root span
    environment: environmentField.nullish(),
    source: sourceField.nullish(),
    serviceName: serviceNameField.nullish(),
    scope: scopeField.nullish(),
    // Filterable data - user-defined metadata and tags (tags only on root span)
    metadata: metadataField.nullish(),
    tags: tagsField.nullish()
};
var spanIds = {
    traceId: traceIdField,
    spanId: spanIdField
};
var spanIdsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    ...spanIds
});
var omitDbTimestamps = createOmitKeys(dbTimestamps);
var omitSpanIds = createOmitKeys(spanIds);
var spanRecordSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    // Required identifiers
    ...spanIds,
    name: spanNameField,
    spanType: spanTypeField,
    isEvent: isEventField,
    startedAt: startedAtField,
    // Shared fields
    parentSpanId: parentSpanIdField.nullish(),
    ...sharedFields,
    // Additional span-specific nullish fields
    attributes: attributesField.nullish(),
    links: linksField.nullish(),
    input: inputField.nullish(),
    output: outputField.nullish(),
    error: errorField.nullish(),
    endedAt: endedAtField.nullish(),
    // Database timestamps
    ...dbTimestamps
}).describe("Span record data");
var createSpanRecordSchema = spanRecordSchema.omit(omitDbTimestamps);
var createSpanArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    span: createSpanRecordSchema
}).describe("Arguments for creating a single span");
var batchCreateSpansArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    records: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(createSpanRecordSchema)
}).describe("Arguments for batch creating spans");
var getSpanArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    traceId: traceIdField.min(1),
    spanId: spanIdField.min(1)
}).describe("Arguments for getting a single span");
var getSpanResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    span: spanRecordSchema
});
var getRootSpanArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    traceId: traceIdField.min(1)
}).describe("Arguments for getting a root span");
var getRootSpanResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    span: spanRecordSchema
});
var getTraceArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    traceId: traceIdField.min(1)
}).describe("Arguments for getting a single trace");
var getTraceResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    traceId: traceIdField,
    spans: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(spanRecordSchema)
});
var tracesFilterSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    // Date range filters
    startedAt: dateRangeSchema.optional().describe("Filter by span start time range"),
    endedAt: dateRangeSchema.optional().describe("Filter by span end time range"),
    // Span type filter
    spanType: spanTypeField.optional(),
    // Shared fields
    ...sharedFields,
    // Filter-specific derived status fields
    status: traceStatusField.optional(),
    hasChildError: hasChildErrorField.optional()
}).describe("Filters for querying traces");
var tracesOrderByFieldSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
    "startedAt",
    "endedAt"
]).describe("Field to order by: 'startedAt' | 'endedAt'");
var tracesOrderBySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    field: tracesOrderByFieldSchema.default("startedAt").describe("Field to order by"),
    direction: sortDirectionSchema.default("DESC").describe("Sort direction")
}).describe("Order by configuration");
var listTracesArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    filters: tracesFilterSchema.optional().describe("Optional filters to apply"),
    pagination: paginationArgsSchema.default({}).describe("Pagination settings"),
    orderBy: tracesOrderBySchema.default({}).describe("Ordering configuration (defaults to startedAt desc)")
}).describe("Arguments for listing traces");
var listTracesResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    pagination: paginationInfoSchema,
    spans: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(spanRecordSchema)
});
var updateSpanRecordSchema = createSpanRecordSchema.omit(omitSpanIds);
var updateSpanArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    spanId: spanIdField,
    traceId: traceIdField,
    updates: updateSpanRecordSchema.partial()
}).describe("Arguments for updating a single span");
var batchUpdateSpansArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    records: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        traceId: traceIdField,
        spanId: spanIdField,
        updates: updateSpanRecordSchema.partial()
    }))
}).describe("Arguments for batch updating spans");
var batchDeleteTracesArgsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    traceIds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(traceIdField)
}).describe("Arguments for batch deleting traces");
var listScoresBySpanResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    pagination: paginationInfoSchema,
    scores: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(scoreRowDataSchema)
});
var scoreTracesRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    scorerName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
    targets: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        traceId: traceIdField,
        spanId: spanIdField.optional()
    })).min(1)
});
var scoreTracesResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    traceCount: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
});
// src/storage/types.ts
function getInnerType(schema, typeName) {
    const schemaAny = schema;
    if (typeName === "ZodNullable" || typeName === "ZodOptional" || typeName === "ZodDefault") {
        return schemaAny._zod?.def?.innerType ?? schemaAny._def?.innerType;
    }
    if (typeName === "ZodEffects") {
        return schemaAny._zod?.def?.schema ?? schemaAny._def?.schema;
    }
    if (typeName === "ZodBranded") {
        return schemaAny._zod?.def?.type ?? schemaAny._def?.type;
    }
    return void 0;
}
function unwrapSchema(schema) {
    let current = schema;
    let nullable = false;
    while(true){
        const typeName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodTypeName"])(current);
        if (typeName === "ZodNullable") {
            nullable = true;
            const inner = getInnerType(current, typeName);
            if (inner) {
                current = inner;
                continue;
            }
        }
        if (typeName === "ZodOptional") {
            nullable = true;
            const inner = getInnerType(current, typeName);
            if (inner) {
                current = inner;
                continue;
            }
        }
        if (typeName === "ZodDefault") {
            const inner = getInnerType(current, typeName);
            if (inner) {
                current = inner;
                continue;
            }
        }
        if (typeName === "ZodEffects") {
            const inner = getInnerType(current, typeName);
            if (inner) {
                current = inner;
                continue;
            }
        }
        if (typeName === "ZodBranded") {
            const inner = getInnerType(current, typeName);
            if (inner) {
                current = inner;
                continue;
            }
        }
        break;
    }
    return {
        base: current,
        nullable
    };
}
function getZodChecks(schema) {
    const schemaAny = schema;
    if (schemaAny._zod?.def?.checks) {
        return schemaAny._zod.def.checks;
    }
    if (schemaAny._def?.checks) {
        return schemaAny._def.checks;
    }
    return [];
}
function zodToStorageType(schema) {
    const typeName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodTypeName"])(schema);
    if (typeName === "ZodString") {
        const checks = getZodChecks(schema);
        if (checks.some((c)=>c.kind === "uuid")) {
            return "uuid";
        }
        return "text";
    }
    if (typeName === "ZodNativeEnum" || typeName === "ZodEnum") {
        return "text";
    }
    if (typeName === "ZodNumber") {
        const checks = getZodChecks(schema);
        return checks.some((c)=>c.kind === "int") ? "integer" : "float";
    }
    if (typeName === "ZodBigInt") {
        return "bigint";
    }
    if (typeName === "ZodDate") {
        return "timestamp";
    }
    if (typeName === "ZodBoolean") {
        return "boolean";
    }
    return "jsonb";
}
function buildStorageSchema(zObject) {
    const shape = zObject.shape;
    const result = {};
    for (const [key, field] of Object.entries(shape)){
        const { base, nullable } = unwrapSchema(field);
        result[key] = {
            type: zodToStorageType(base),
            nullable
        };
    }
    return result;
}
// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_RESOURCES = "mastra_resources";
var TABLE_SCORERS = "mastra_scorers";
var TABLE_SPANS = "mastra_ai_spans";
var TABLE_AGENTS = "mastra_agents";
var SCORERS_SCHEMA = {
    id: {
        type: "text",
        nullable: false,
        primaryKey: true
    },
    scorerId: {
        type: "text"
    },
    traceId: {
        type: "text",
        nullable: true
    },
    spanId: {
        type: "text",
        nullable: true
    },
    runId: {
        type: "text"
    },
    scorer: {
        type: "jsonb"
    },
    preprocessStepResult: {
        type: "jsonb",
        nullable: true
    },
    extractStepResult: {
        type: "jsonb",
        nullable: true
    },
    analyzeStepResult: {
        type: "jsonb",
        nullable: true
    },
    score: {
        type: "float"
    },
    reason: {
        type: "text",
        nullable: true
    },
    metadata: {
        type: "jsonb",
        nullable: true
    },
    preprocessPrompt: {
        type: "text",
        nullable: true
    },
    extractPrompt: {
        type: "text",
        nullable: true
    },
    generateScorePrompt: {
        type: "text",
        nullable: true
    },
    generateReasonPrompt: {
        type: "text",
        nullable: true
    },
    analyzePrompt: {
        type: "text",
        nullable: true
    },
    // Deprecated
    reasonPrompt: {
        type: "text",
        nullable: true
    },
    input: {
        type: "jsonb"
    },
    output: {
        type: "jsonb"
    },
    // MESSAGE OUTPUT
    additionalContext: {
        type: "jsonb",
        nullable: true
    },
    // DATA FROM THE CONTEXT PARAM ON AN AGENT
    requestContext: {
        type: "jsonb",
        nullable: true
    },
    // THE EVALUATE Request Context FOR THE RUN
    /**
   * Things you can evaluate
   */ entityType: {
        type: "text",
        nullable: true
    },
    // WORKFLOW, AGENT, TOOL, STEP, NETWORK
    entity: {
        type: "jsonb",
        nullable: true
    },
    // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK
    entityId: {
        type: "text",
        nullable: true
    },
    source: {
        type: "text"
    },
    resourceId: {
        type: "text",
        nullable: true
    },
    threadId: {
        type: "text",
        nullable: true
    },
    createdAt: {
        type: "timestamp"
    },
    updatedAt: {
        type: "timestamp"
    }
};
var SPAN_SCHEMA = buildStorageSchema(spanRecordSchema);
var OLD_SPAN_SCHEMA = {
    // Composite primary key of traceId and spanId
    traceId: {
        type: "text",
        nullable: false
    },
    spanId: {
        type: "text",
        nullable: false
    },
    parentSpanId: {
        type: "text",
        nullable: true
    },
    name: {
        type: "text",
        nullable: false
    },
    scope: {
        type: "jsonb",
        nullable: true
    },
    // Mastra package info {"core-version": "0.1.0"}
    spanType: {
        type: "text",
        nullable: false
    },
    // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.
    attributes: {
        type: "jsonb",
        nullable: true
    },
    metadata: {
        type: "jsonb",
        nullable: true
    },
    links: {
        type: "jsonb",
        nullable: true
    },
    input: {
        type: "jsonb",
        nullable: true
    },
    output: {
        type: "jsonb",
        nullable: true
    },
    error: {
        type: "jsonb",
        nullable: true
    },
    startedAt: {
        type: "timestamp",
        nullable: false
    },
    // When the span started
    endedAt: {
        type: "timestamp",
        nullable: true
    },
    // When the span ended
    createdAt: {
        type: "timestamp",
        nullable: false
    },
    // The time the database record was created
    updatedAt: {
        type: "timestamp",
        nullable: true
    },
    // The time the database record was last updated
    isEvent: {
        type: "boolean",
        nullable: false
    }
};
var AGENTS_SCHEMA = {
    id: {
        type: "text",
        nullable: false,
        primaryKey: true
    },
    name: {
        type: "text",
        nullable: false
    },
    description: {
        type: "text",
        nullable: true
    },
    instructions: {
        type: "text",
        nullable: false
    },
    // System instructions for the agent
    model: {
        type: "jsonb",
        nullable: false
    },
    // Model configuration (provider, name, etc.)
    tools: {
        type: "jsonb",
        nullable: true
    },
    // Serialized tool references/configurations
    defaultOptions: {
        type: "jsonb",
        nullable: true
    },
    // Default options for generate/stream calls
    workflows: {
        type: "jsonb",
        nullable: true
    },
    // Workflow references (IDs or configurations)
    agents: {
        type: "jsonb",
        nullable: true
    },
    // Sub-agent references (IDs or configurations)
    inputProcessors: {
        type: "jsonb",
        nullable: true
    },
    // Input processor configurations
    outputProcessors: {
        type: "jsonb",
        nullable: true
    },
    // Output processor configurations
    memory: {
        type: "jsonb",
        nullable: true
    },
    // Memory configuration
    scorers: {
        type: "jsonb",
        nullable: true
    },
    // Scorer configurations
    metadata: {
        type: "jsonb",
        nullable: true
    },
    // Additional metadata for the agent
    createdAt: {
        type: "timestamp",
        nullable: false
    },
    updatedAt: {
        type: "timestamp",
        nullable: false
    }
};
var TABLE_SCHEMAS = {
    [TABLE_WORKFLOW_SNAPSHOT]: {
        workflow_name: {
            type: "text"
        },
        run_id: {
            type: "text"
        },
        resourceId: {
            type: "text",
            nullable: true
        },
        snapshot: {
            type: "jsonb"
        },
        createdAt: {
            type: "timestamp"
        },
        updatedAt: {
            type: "timestamp"
        }
    },
    [TABLE_SCORERS]: SCORERS_SCHEMA,
    [TABLE_THREADS]: {
        id: {
            type: "text",
            nullable: false,
            primaryKey: true
        },
        resourceId: {
            type: "text",
            nullable: false
        },
        title: {
            type: "text",
            nullable: false
        },
        metadata: {
            type: "jsonb",
            nullable: true
        },
        createdAt: {
            type: "timestamp",
            nullable: false
        },
        updatedAt: {
            type: "timestamp",
            nullable: false
        }
    },
    [TABLE_MESSAGES]: {
        id: {
            type: "text",
            nullable: false,
            primaryKey: true
        },
        thread_id: {
            type: "text",
            nullable: false
        },
        content: {
            type: "text",
            nullable: false
        },
        role: {
            type: "text",
            nullable: false
        },
        type: {
            type: "text",
            nullable: false
        },
        createdAt: {
            type: "timestamp",
            nullable: false
        },
        resourceId: {
            type: "text",
            nullable: true
        }
    },
    [TABLE_SPANS]: SPAN_SCHEMA,
    [TABLE_TRACES]: {
        id: {
            type: "text",
            nullable: false,
            primaryKey: true
        },
        parentSpanId: {
            type: "text",
            nullable: true
        },
        name: {
            type: "text",
            nullable: false
        },
        traceId: {
            type: "text",
            nullable: false
        },
        scope: {
            type: "text",
            nullable: false
        },
        kind: {
            type: "integer",
            nullable: false
        },
        attributes: {
            type: "jsonb",
            nullable: true
        },
        status: {
            type: "jsonb",
            nullable: true
        },
        events: {
            type: "jsonb",
            nullable: true
        },
        links: {
            type: "jsonb",
            nullable: true
        },
        other: {
            type: "text",
            nullable: true
        },
        startTime: {
            type: "bigint",
            nullable: false
        },
        endTime: {
            type: "bigint",
            nullable: false
        },
        createdAt: {
            type: "timestamp",
            nullable: false
        }
    },
    [TABLE_RESOURCES]: {
        id: {
            type: "text",
            nullable: false,
            primaryKey: true
        },
        workingMemory: {
            type: "text",
            nullable: true
        },
        metadata: {
            type: "jsonb",
            nullable: true
        },
        createdAt: {
            type: "timestamp",
            nullable: false
        },
        updatedAt: {
            type: "timestamp",
            nullable: false
        }
    },
    [TABLE_AGENTS]: AGENTS_SCHEMA
};
;
 //# sourceMappingURL=chunk-65QFXXAD.js.map
 //# sourceMappingURL=chunk-65QFXXAD.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-DDH2PEZG.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AgentsStorage",
    ()=>AgentsStorage,
    "InMemoryAgentsStorage",
    ()=>InMemoryAgentsStorage,
    "InMemoryDB",
    ()=>InMemoryDB,
    "InMemoryMemory",
    ()=>InMemoryMemory,
    "InMemoryStore",
    ()=>InMemoryStore,
    "MastraStorage",
    ()=>MastraStorage,
    "MemoryStorage",
    ()=>MemoryStorage,
    "MockStore",
    ()=>MockStore,
    "ObservabilityInMemory",
    ()=>ObservabilityInMemory,
    "ObservabilityStorage",
    ()=>ObservabilityStorage,
    "ScoresInMemory",
    ()=>ScoresInMemory,
    "ScoresStorage",
    ()=>ScoresStorage,
    "StorageDomain",
    ()=>StorageDomain,
    "StoreOperations",
    ()=>StoreOperations,
    "StoreOperationsInMemory",
    ()=>StoreOperationsInMemory,
    "WorkflowsInMemory",
    ()=>WorkflowsInMemory,
    "WorkflowsStorage",
    ()=>WorkflowsStorage,
    "calculatePagination",
    ()=>calculatePagination,
    "createStorageErrorId",
    ()=>createStorageErrorId,
    "createStoreErrorId",
    ()=>createStoreErrorId,
    "createVectorErrorId",
    ()=>createVectorErrorId,
    "ensureDate",
    ()=>ensureDate,
    "filterByDateRange",
    ()=>filterByDateRange,
    "getDefaultValue",
    ()=>getDefaultValue,
    "getSqlType",
    ()=>getSqlType,
    "normalizePerPage",
    ()=>normalizePerPage,
    "safelyParseJSON",
    ()=>safelyParseJSON,
    "serializeDate",
    ()=>serializeDate,
    "transformRow",
    ()=>transformRow,
    "transformScoreRow",
    ()=>transformScoreRow
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-PSIJ6OSV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-65QFXXAD.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
;
;
;
;
// src/storage/base.ts
function normalizePerPage(perPageInput, defaultValue) {
    if (perPageInput === false) {
        return Number.MAX_SAFE_INTEGER;
    } else if (perPageInput === 0) {
        return 0;
    } else if (typeof perPageInput === "number" && perPageInput > 0) {
        return perPageInput;
    }
    return defaultValue;
}
function calculatePagination(page, perPageInput, normalizedPerPage) {
    return {
        offset: perPageInput === false ? 0 : page * normalizedPerPage,
        perPage: perPageInput === false ? false : normalizedPerPage
    };
}
var MastraStorage = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    hasInitialized = null;
    shouldCacheInit = true;
    id;
    stores;
    /**
   * When true, automatic initialization (table creation/migrations) is disabled.
   */ disableInit = false;
    constructor(config){
        const name = config.name ?? "MastraStorage";
        if (!config.id || typeof config.id !== "string" || config.id.trim() === "") {
            throw new Error(`${name}: id must be provided and cannot be empty.`);
        }
        super({
            component: "STORAGE",
            name
        });
        this.id = config.id;
        this.disableInit = config.disableInit ?? false;
        if (config.default || config.domains) {
            const defaultStores = config.default?.stores;
            const domainOverrides = config.domains ?? {};
            const hasDefaultDomains = defaultStores && Object.values(defaultStores).some((v)=>v !== void 0);
            const hasOverrideDomains = Object.values(domainOverrides).some((v)=>v !== void 0);
            if (!hasDefaultDomains && !hasOverrideDomains) {
                throw new Error("MastraStorage requires at least one storage source. Provide either a default storage with domains or domain overrides.");
            }
            this.stores = {
                memory: domainOverrides.memory ?? defaultStores?.memory,
                workflows: domainOverrides.workflows ?? defaultStores?.workflows,
                scores: domainOverrides.scores ?? defaultStores?.scores,
                observability: domainOverrides.observability ?? defaultStores?.observability,
                agents: domainOverrides.agents ?? defaultStores?.agents
            };
        }
    }
    /**
   * Get a domain-specific storage interface.
   *
   * @param storeName - The name of the domain to access ('memory', 'workflows', 'scores', 'observability', 'agents')
   * @returns The domain storage interface, or undefined if not available
   *
   * @example
   * ```typescript
   * const memory = await storage.getStore('memory');
   * if (memory) {
   *   await memory.saveThread({ thread });
   * }
   * ```
   */ async getStore(storeName) {
        return this.stores?.[storeName];
    }
    /**
   * Initialize all domain stores.
   * This creates necessary tables, indexes, and performs any required migrations.
   */ async init() {
        if (this.shouldCacheInit && await this.hasInitialized) {
            return;
        }
        const initTasks = [];
        if (this.stores?.memory) {
            initTasks.push(this.stores.memory.init());
        }
        if (this.stores?.workflows) {
            initTasks.push(this.stores.workflows.init());
        }
        if (this.stores?.scores) {
            initTasks.push(this.stores.scores.init());
        }
        if (this.stores?.observability) {
            initTasks.push(this.stores.observability.init());
        }
        if (this.stores?.agents) {
            initTasks.push(this.stores.agents.init());
        }
        this.hasInitialized = Promise.all(initTasks).then(()=>true);
        await this.hasInitialized;
    }
};
// src/storage/domains/base.ts
var StorageDomain = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    /**
   * Initialize the storage domain.
   * This should create any necessary tables/collections.
   * Default implementation is a no-op - override in adapters that need initialization.
   */ async init() {}
};
// src/storage/domains/agents/base.ts
var AgentsStorage = class extends StorageDomain {
    constructor(){
        super({
            component: "STORAGE",
            name: "AGENTS"
        });
    }
    /**
   * Parses orderBy input for consistent sorting behavior.
   */ parseOrderBy(orderBy, defaultDirection = "DESC") {
        return {
            field: orderBy?.field && orderBy.field in AGENT_ORDER_BY_SET ? orderBy.field : "createdAt",
            direction: orderBy?.direction && orderBy.direction in AGENT_SORT_DIRECTION_SET ? orderBy.direction : defaultDirection
        };
    }
};
var AGENT_ORDER_BY_SET = {
    createdAt: true,
    updatedAt: true
};
var AGENT_SORT_DIRECTION_SET = {
    ASC: true,
    DESC: true
};
// src/storage/domains/agents/inmemory.ts
var InMemoryAgentsStorage = class extends AgentsStorage {
    db;
    constructor({ db }){
        super();
        this.db = db;
    }
    async dangerouslyClearAll() {
        this.db.agents.clear();
    }
    async getAgentById({ id }) {
        this.logger.debug(`InMemoryAgentsStorage: getAgentById called for ${id}`);
        const agent = this.db.agents.get(id);
        return agent ? {
            ...agent,
            metadata: agent.metadata ? {
                ...agent.metadata
            } : agent.metadata,
            model: {
                ...agent.model
            },
            tools: agent.tools ? [
                ...agent.tools
            ] : agent.tools,
            workflows: agent.workflows ? [
                ...agent.workflows
            ] : agent.workflows,
            agents: agent.agents ? [
                ...agent.agents
            ] : agent.agents,
            scorers: agent.scorers ? {
                ...agent.scorers
            } : agent.scorers
        } : null;
    }
    async createAgent({ agent }) {
        this.logger.debug(`InMemoryAgentsStorage: createAgent called for ${agent.id}`);
        if (this.db.agents.has(agent.id)) {
            throw new Error(`Agent with id ${agent.id} already exists`);
        }
        const now = /* @__PURE__ */ new Date();
        const newAgent = {
            ...agent,
            createdAt: now,
            updatedAt: now
        };
        this.db.agents.set(agent.id, newAgent);
        return {
            ...newAgent
        };
    }
    async updateAgent({ id, ...updates }) {
        this.logger.debug(`InMemoryAgentsStorage: updateAgent called for ${id}`);
        const existingAgent = this.db.agents.get(id);
        if (!existingAgent) {
            throw new Error(`Agent with id ${id} not found`);
        }
        const updatedAgent = {
            ...existingAgent,
            ...updates.name !== void 0 && {
                name: updates.name
            },
            ...updates.description !== void 0 && {
                description: updates.description
            },
            ...updates.instructions !== void 0 && {
                instructions: updates.instructions
            },
            ...updates.model !== void 0 && {
                model: updates.model
            },
            ...updates.tools !== void 0 && {
                tools: updates.tools
            },
            ...updates.defaultOptions !== void 0 && {
                defaultOptions: updates.defaultOptions
            },
            ...updates.workflows !== void 0 && {
                workflows: updates.workflows
            },
            ...updates.agents !== void 0 && {
                agents: updates.agents
            },
            ...updates.inputProcessors !== void 0 && {
                inputProcessors: updates.inputProcessors
            },
            ...updates.outputProcessors !== void 0 && {
                outputProcessors: updates.outputProcessors
            },
            ...updates.memory !== void 0 && {
                memory: updates.memory
            },
            ...updates.scorers !== void 0 && {
                scorers: updates.scorers
            },
            ...updates.metadata !== void 0 && {
                metadata: {
                    ...existingAgent.metadata,
                    ...updates.metadata
                }
            },
            updatedAt: /* @__PURE__ */ new Date()
        };
        this.db.agents.set(id, updatedAgent);
        return {
            ...updatedAgent
        };
    }
    async deleteAgent({ id }) {
        this.logger.debug(`InMemoryAgentsStorage: deleteAgent called for ${id}`);
        this.db.agents.delete(id);
    }
    async listAgents(args) {
        const { page = 0, perPage: perPageInput, orderBy } = args || {};
        const { field, direction } = this.parseOrderBy(orderBy);
        this.logger.debug(`InMemoryAgentsStorage: listAgents called`);
        const perPage = normalizePerPage(perPageInput, 100);
        if (page < 0) {
            throw new Error("page must be >= 0");
        }
        const maxOffset = Number.MAX_SAFE_INTEGER / 2;
        if (page * perPage > maxOffset) {
            throw new Error("page value too large");
        }
        const agents = Array.from(this.db.agents.values());
        const sortedAgents = this.sortAgents(agents, field, direction);
        const clonedAgents = sortedAgents.map((agent)=>({
                ...agent,
                metadata: agent.metadata ? {
                    ...agent.metadata
                } : agent.metadata,
                model: {
                    ...agent.model
                },
                tools: agent.tools ? [
                    ...agent.tools
                ] : agent.tools,
                workflows: agent.workflows ? [
                    ...agent.workflows
                ] : agent.workflows,
                agents: agent.agents ? [
                    ...agent.agents
                ] : agent.agents,
                scorers: agent.scorers ? {
                    ...agent.scorers
                } : agent.scorers
            }));
        const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        return {
            agents: clonedAgents.slice(offset, offset + perPage),
            total: clonedAgents.length,
            page,
            perPage: perPageForResponse,
            hasMore: offset + perPage < clonedAgents.length
        };
    }
    sortAgents(agents, field, direction) {
        return agents.sort((a, b)=>{
            const aValue = new Date(a[field]).getTime();
            const bValue = new Date(b[field]).getTime();
            return direction === "ASC" ? aValue - bValue : bValue - aValue;
        });
    }
};
// src/storage/domains/inmemory-db.ts
var InMemoryDB = class {
    threads = /* @__PURE__ */ new Map();
    messages = /* @__PURE__ */ new Map();
    resources = /* @__PURE__ */ new Map();
    workflows = /* @__PURE__ */ new Map();
    scores = /* @__PURE__ */ new Map();
    traces = /* @__PURE__ */ new Map();
    agents = /* @__PURE__ */ new Map();
    /**
   * Clears all data from all collections.
   * Useful for testing.
   */ clear() {
        this.threads.clear();
        this.messages.clear();
        this.resources.clear();
        this.workflows.clear();
        this.scores.clear();
        this.traces.clear();
        this.agents.clear();
    }
};
// src/storage/utils.ts
function safelyParseJSON(input) {
    if (input && typeof input === "object") return input;
    if (input == null) return {};
    if (typeof input === "string") {
        try {
            return JSON.parse(input);
        } catch  {
            return input;
        }
    }
    return {};
}
function transformRow(row, tableName, options = {}) {
    const { preferredTimestampFields = {}, convertTimestamps = false, nullValuePattern, fieldMappings = {} } = options;
    const tableSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName];
    const result = {};
    for (const [key, columnSchema] of Object.entries(tableSchema)){
        const sourceKey = fieldMappings[key] ?? key;
        let value = row[sourceKey];
        if (preferredTimestampFields[key]) {
            value = row[preferredTimestampFields[key]] ?? value;
        }
        if (value === void 0 || value === null) {
            continue;
        }
        if (nullValuePattern && value === nullValuePattern) {
            continue;
        }
        if (columnSchema.type === "jsonb") {
            if (typeof value === "string") {
                result[key] = safelyParseJSON(value);
            } else if (typeof value === "object") {
                result[key] = value;
            } else {
                result[key] = value;
            }
        } else if (columnSchema.type === "timestamp" && convertTimestamps && typeof value === "string") {
            result[key] = new Date(value);
        } else {
            result[key] = value;
        }
    }
    return result;
}
function transformScoreRow(row, options = {}) {
    return transformRow(row, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"], options);
}
function toUpperSnakeCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toUpperCase().replace(/[^A-Z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}
function createStoreErrorId(type, store, operation, status) {
    const normalizedStore = toUpperSnakeCase(store);
    const normalizedOperation = toUpperSnakeCase(operation);
    const normalizedStatus = toUpperSnakeCase(status);
    const typePrefix = type === "storage" ? "STORAGE" : "VECTOR";
    return `MASTRA_${typePrefix}_${normalizedStore}_${normalizedOperation}_${normalizedStatus}`;
}
function createStorageErrorId(store, operation, status) {
    return createStoreErrorId("storage", store, operation, status);
}
function createVectorErrorId(store, operation, status) {
    return createStoreErrorId("vector", store, operation, status);
}
function getSqlType(type) {
    switch(type){
        case "text":
            return "TEXT";
        case "timestamp":
            return "TIMESTAMP";
        case "float":
            return "FLOAT";
        case "integer":
            return "INTEGER";
        case "bigint":
            return "BIGINT";
        case "jsonb":
            return "JSONB";
        case "boolean":
            return "BOOLEAN";
        default:
            return "TEXT";
    }
}
function getDefaultValue(type) {
    switch(type){
        case "text":
        case "uuid":
            return "DEFAULT ''";
        case "timestamp":
            return "DEFAULT '1970-01-01 00:00:00'";
        case "integer":
        case "bigint":
        case "float":
            return "DEFAULT 0";
        case "jsonb":
            return "DEFAULT '{}'";
        case "boolean":
            return "DEFAULT FALSE";
        default:
            return "DEFAULT ''";
    }
}
function ensureDate(date) {
    if (!date) return void 0;
    return date instanceof Date ? date : new Date(date);
}
function serializeDate(date) {
    if (!date) return void 0;
    const dateObj = ensureDate(date);
    return dateObj?.toISOString();
}
function filterByDateRange(items, getCreatedAt, dateRange) {
    if (!dateRange) return items;
    let result = items;
    if (dateRange.start) {
        const startTime = ensureDate(dateRange.start).getTime();
        result = result.filter((item)=>{
            const itemTime = getCreatedAt(item).getTime();
            return dateRange.startExclusive ? itemTime > startTime : itemTime >= startTime;
        });
    }
    if (dateRange.end) {
        const endTime = ensureDate(dateRange.end).getTime();
        result = result.filter((item)=>{
            const itemTime = getCreatedAt(item).getTime();
            return dateRange.endExclusive ? itemTime < endTime : itemTime <= endTime;
        });
    }
    return result;
}
// src/storage/domains/memory/base.ts
var MemoryStorage = class extends StorageDomain {
    constructor(){
        super({
            component: "STORAGE",
            name: "MEMORY"
        });
    }
    async deleteMessages(_messageIds) {
        throw new Error(`Message deletion is not supported by this storage adapter (${this.constructor.name}). The deleteMessages method needs to be implemented in the storage adapter.`);
    }
    /**
   * Clone a thread and its messages to create a new independent thread.
   * The cloned thread will have clone metadata stored in its metadata field.
   *
   * @param args - Clone configuration options
   * @returns The newly created thread and the cloned messages
   */ async cloneThread(_args) {
        throw new Error(`Thread cloning is not implemented by this storage adapter (${this.constructor.name}). The cloneThread method needs to be implemented in the storage adapter.`);
    }
    async getResourceById(_) {
        throw new Error(`Resource working memory is not implemented by this storage adapter (${this.constructor.name}). This is likely a bug - all Mastra storage adapters should implement resource support. Please report this issue at https://github.com/mastra-ai/mastra/issues`);
    }
    async saveResource(_) {
        throw new Error(`Resource working memory is not implemented by this storage adapter (${this.constructor.name}). This is likely a bug - all Mastra storage adapters should implement resource support. Please report this issue at https://github.com/mastra-ai/mastra/issues`);
    }
    async updateResource(_) {
        throw new Error(`Resource working memory is not implemented by this storage adapter (${this.constructor.name}). This is likely a bug - all Mastra storage adapters should implement resource support. Please report this issue at https://github.com/mastra-ai/mastra/issues`);
    }
    parseOrderBy(orderBy, defaultDirection = "DESC") {
        return {
            field: orderBy?.field && orderBy.field in THREAD_ORDER_BY_SET ? orderBy.field : "createdAt",
            direction: orderBy?.direction && orderBy.direction in THREAD_THREAD_SORT_DIRECTION_SET ? orderBy.direction : defaultDirection
        };
    }
};
var THREAD_ORDER_BY_SET = {
    createdAt: true,
    updatedAt: true
};
var THREAD_THREAD_SORT_DIRECTION_SET = {
    ASC: true,
    DESC: true
};
// src/storage/domains/memory/inmemory.ts
var InMemoryMemory = class extends MemoryStorage {
    db;
    constructor({ db }){
        super();
        this.db = db;
    }
    async dangerouslyClearAll() {
        this.db.threads.clear();
        this.db.messages.clear();
        this.db.resources.clear();
    }
    async getThreadById({ threadId }) {
        this.logger.debug(`InMemoryMemory: getThreadById called for ${threadId}`);
        const thread = this.db.threads.get(threadId);
        return thread ? {
            ...thread,
            metadata: thread.metadata ? {
                ...thread.metadata
            } : thread.metadata
        } : null;
    }
    async saveThread({ thread }) {
        this.logger.debug(`InMemoryMemory: saveThread called for ${thread.id}`);
        const key = thread.id;
        this.db.threads.set(key, thread);
        return thread;
    }
    async updateThread({ id, title, metadata }) {
        this.logger.debug(`InMemoryMemory: updateThread called for ${id}`);
        const thread = this.db.threads.get(id);
        if (!thread) {
            throw new Error(`Thread with id ${id} not found`);
        }
        if (thread) {
            thread.title = title;
            thread.metadata = {
                ...thread.metadata,
                ...metadata
            };
            thread.updatedAt = /* @__PURE__ */ new Date();
        }
        return thread;
    }
    async deleteThread({ threadId }) {
        this.logger.debug(`InMemoryMemory: deleteThread called for ${threadId}`);
        this.db.threads.delete(threadId);
        this.db.messages.forEach((msg, key)=>{
            if (msg.thread_id === threadId) {
                this.db.messages.delete(key);
            }
        });
    }
    async listMessages({ threadId, resourceId, include, filter, perPage: perPageInput, page = 0, orderBy }) {
        const threadIds = Array.isArray(threadId) ? threadId : [
            threadId
        ];
        this.logger.debug(`InMemoryMemory: listMessages called for threads ${threadIds.join(", ")}`);
        if (threadIds.length === 0 || threadIds.some((id)=>!id.trim())) {
            throw new Error("threadId must be a non-empty string or array of non-empty strings");
        }
        const threadIdSet = new Set(threadIds);
        const { field, direction } = this.parseOrderBy(orderBy, "ASC");
        const perPage = normalizePerPage(perPageInput, 40);
        if (page < 0) {
            throw new Error("page must be >= 0");
        }
        const maxOffset = Number.MAX_SAFE_INTEGER / 2;
        if (page * perPage > maxOffset) {
            throw new Error("page value too large");
        }
        const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        let threadMessages = Array.from(this.db.messages.values()).filter((msg)=>{
            if (!threadIdSet.has(msg.thread_id)) return false;
            if (resourceId && msg.resourceId !== resourceId) return false;
            return true;
        });
        threadMessages = filterByDateRange(threadMessages, (msg)=>new Date(msg.createdAt), filter?.dateRange);
        threadMessages.sort((a, b)=>{
            const isDateField = field === "createdAt" || field === "updatedAt";
            const aValue = isDateField ? new Date(a[field]).getTime() : a[field];
            const bValue = isDateField ? new Date(b[field]).getTime() : b[field];
            if (typeof aValue === "number" && typeof bValue === "number") {
                return direction === "ASC" ? aValue - bValue : bValue - aValue;
            }
            return direction === "ASC" ? String(aValue).localeCompare(String(bValue)) : String(bValue).localeCompare(String(aValue));
        });
        const totalThreadMessages = threadMessages.length;
        const start = offset;
        const end = start + perPage;
        const paginatedThreadMessages = threadMessages.slice(start, end);
        const messages = [];
        const messageIds = /* @__PURE__ */ new Set();
        for (const msg of paginatedThreadMessages){
            const convertedMessage = this.parseStoredMessage(msg);
            messages.push(convertedMessage);
            messageIds.add(msg.id);
        }
        if (include && include.length > 0) {
            for (const includeItem of include){
                const targetMessage = this.db.messages.get(includeItem.id);
                if (targetMessage) {
                    const convertedMessage = {
                        id: targetMessage.id,
                        threadId: targetMessage.thread_id,
                        content: safelyParseJSON(targetMessage.content),
                        role: targetMessage.role,
                        type: targetMessage.type,
                        createdAt: targetMessage.createdAt,
                        resourceId: targetMessage.resourceId
                    };
                    if (!messageIds.has(convertedMessage.id)) {
                        messages.push(convertedMessage);
                        messageIds.add(convertedMessage.id);
                    }
                    if (includeItem.withPreviousMessages) {
                        const allThreadMessages = Array.from(this.db.messages.values()).filter((msg)=>msg.thread_id === (includeItem.threadId || threadId)).sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
                        const targetIndex = allThreadMessages.findIndex((msg)=>msg.id === includeItem.id);
                        if (targetIndex !== -1) {
                            const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));
                            for(let i = startIndex; i < targetIndex; i++){
                                const message = allThreadMessages[i];
                                if (message && !messageIds.has(message.id)) {
                                    const convertedPrevMessage = {
                                        id: message.id,
                                        threadId: message.thread_id,
                                        content: safelyParseJSON(message.content),
                                        role: message.role,
                                        type: message.type,
                                        createdAt: message.createdAt,
                                        resourceId: message.resourceId
                                    };
                                    messages.push(convertedPrevMessage);
                                    messageIds.add(message.id);
                                }
                            }
                        }
                    }
                    if (includeItem.withNextMessages) {
                        const allThreadMessages = Array.from(this.db.messages.values()).filter((msg)=>msg.thread_id === (includeItem.threadId || threadId)).sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
                        const targetIndex = allThreadMessages.findIndex((msg)=>msg.id === includeItem.id);
                        if (targetIndex !== -1) {
                            const endIndex = Math.min(allThreadMessages.length, targetIndex + (includeItem.withNextMessages || 0) + 1);
                            for(let i = targetIndex + 1; i < endIndex; i++){
                                const message = allThreadMessages[i];
                                if (message && !messageIds.has(message.id)) {
                                    const convertedNextMessage = {
                                        id: message.id,
                                        threadId: message.thread_id,
                                        content: safelyParseJSON(message.content),
                                        role: message.role,
                                        type: message.type,
                                        createdAt: message.createdAt,
                                        resourceId: message.resourceId
                                    };
                                    messages.push(convertedNextMessage);
                                    messageIds.add(message.id);
                                }
                            }
                        }
                    }
                }
            }
        }
        messages.sort((a, b)=>{
            const isDateField = field === "createdAt" || field === "updatedAt";
            const aValue = isDateField ? new Date(a[field]).getTime() : a[field];
            const bValue = isDateField ? new Date(b[field]).getTime() : b[field];
            if (typeof aValue === "number" && typeof bValue === "number") {
                return direction === "ASC" ? aValue - bValue : bValue - aValue;
            }
            return direction === "ASC" ? String(aValue).localeCompare(String(bValue)) : String(bValue).localeCompare(String(aValue));
        });
        let hasMore;
        if (include && include.length > 0) {
            const returnedThreadMessageIds = new Set(messages.filter((m)=>m.threadId === threadId).map((m)=>m.id));
            hasMore = returnedThreadMessageIds.size < totalThreadMessages;
        } else {
            hasMore = end < totalThreadMessages;
        }
        return {
            messages,
            total: totalThreadMessages,
            page,
            perPage: perPageForResponse,
            hasMore
        };
    }
    parseStoredMessage(message) {
        const { resourceId, content, role, thread_id, ...rest } = message;
        let parsedContent = safelyParseJSON(content);
        if (typeof parsedContent === "string") {
            parsedContent = {
                format: 2,
                content: parsedContent,
                parts: [
                    {
                        type: "text",
                        text: parsedContent
                    }
                ]
            };
        }
        return {
            ...rest,
            threadId: thread_id,
            ...message.resourceId && {
                resourceId: message.resourceId
            },
            content: parsedContent,
            role
        };
    }
    async listMessagesById({ messageIds }) {
        this.logger.debug(`InMemoryMemory: listMessagesById called`);
        const rawMessages = messageIds.map((id)=>this.db.messages.get(id)).filter((message)=>!!message);
        const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]().add(rawMessages.map((m)=>this.parseStoredMessage(m)), "memory");
        return {
            messages: list.get.all.db()
        };
    }
    async saveMessages(args) {
        const { messages } = args;
        this.logger.debug(`InMemoryMemory: saveMessages called with ${messages.length} messages`);
        if (messages.some((msg)=>msg.id === "error-message" || msg.resourceId === null)) {
            throw new Error("Simulated error for testing");
        }
        const threadIds = new Set(messages.map((msg)=>msg.threadId).filter((id)=>Boolean(id)));
        for (const threadId of threadIds){
            const thread = this.db.threads.get(threadId);
            if (thread) {
                thread.updatedAt = /* @__PURE__ */ new Date();
            }
        }
        for (const message of messages){
            const key = message.id;
            const storageMessage = {
                id: message.id,
                thread_id: message.threadId || "",
                content: JSON.stringify(message.content),
                role: message.role || "user",
                type: message.type || "text",
                createdAt: message.createdAt,
                resourceId: message.resourceId || null
            };
            this.db.messages.set(key, storageMessage);
        }
        const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]().add(messages, "memory");
        return {
            messages: list.get.all.db()
        };
    }
    async updateMessages(args) {
        const updatedMessages = [];
        for (const update of args.messages){
            const storageMsg = this.db.messages.get(update.id);
            if (!storageMsg) continue;
            const oldThreadId = storageMsg.thread_id;
            const newThreadId = update.threadId || oldThreadId;
            let threadIdChanged = false;
            if (update.threadId && update.threadId !== oldThreadId) {
                threadIdChanged = true;
            }
            if (update.role !== void 0) storageMsg.role = update.role;
            if (update.type !== void 0) storageMsg.type = update.type;
            if (update.createdAt !== void 0) storageMsg.createdAt = update.createdAt;
            if (update.resourceId !== void 0) storageMsg.resourceId = update.resourceId;
            if (update.content !== void 0) {
                let oldContent = safelyParseJSON(storageMsg.content);
                let newContent = update.content;
                if (typeof newContent === "object" && typeof oldContent === "object") {
                    newContent = {
                        ...oldContent,
                        ...newContent
                    };
                    if (oldContent.metadata && newContent.metadata) {
                        newContent.metadata = {
                            ...oldContent.metadata,
                            ...newContent.metadata
                        };
                    }
                }
                storageMsg.content = JSON.stringify(newContent);
            }
            if (threadIdChanged) {
                storageMsg.thread_id = newThreadId;
                const base = Date.now();
                let oldThreadNewTime;
                const oldThread = this.db.threads.get(oldThreadId);
                if (oldThread) {
                    const prev = new Date(oldThread.updatedAt).getTime();
                    oldThreadNewTime = Math.max(base, prev + 1);
                    oldThread.updatedAt = new Date(oldThreadNewTime);
                }
                const newThread = this.db.threads.get(newThreadId);
                if (newThread) {
                    const prev = new Date(newThread.updatedAt).getTime();
                    let newThreadNewTime = Math.max(base + 1, prev + 1);
                    if (oldThreadNewTime !== void 0 && newThreadNewTime <= oldThreadNewTime) {
                        newThreadNewTime = oldThreadNewTime + 1;
                    }
                    newThread.updatedAt = new Date(newThreadNewTime);
                }
            } else {
                const thread = this.db.threads.get(oldThreadId);
                if (thread) {
                    const prev = new Date(thread.updatedAt).getTime();
                    let newTime = Date.now();
                    if (newTime <= prev) newTime = prev + 1;
                    thread.updatedAt = new Date(newTime);
                }
            }
            this.db.messages.set(update.id, storageMsg);
            updatedMessages.push({
                id: storageMsg.id,
                threadId: storageMsg.thread_id,
                content: safelyParseJSON(storageMsg.content),
                role: storageMsg.role === "user" || storageMsg.role === "assistant" ? storageMsg.role : "user",
                type: storageMsg.type,
                createdAt: storageMsg.createdAt,
                resourceId: storageMsg.resourceId === null ? void 0 : storageMsg.resourceId
            });
        }
        return updatedMessages;
    }
    async deleteMessages(messageIds) {
        if (!messageIds || messageIds.length === 0) {
            return;
        }
        this.logger.debug(`InMemoryMemory: deleteMessages called for ${messageIds.length} messages`);
        const threadIds = /* @__PURE__ */ new Set();
        for (const messageId of messageIds){
            const message = this.db.messages.get(messageId);
            if (message && message.thread_id) {
                threadIds.add(message.thread_id);
            }
            this.db.messages.delete(messageId);
        }
        const now = /* @__PURE__ */ new Date();
        for (const threadId of threadIds){
            const thread = this.db.threads.get(threadId);
            if (thread) {
                thread.updatedAt = now;
            }
        }
    }
    async listThreadsByResourceId(args) {
        const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;
        const { field, direction } = this.parseOrderBy(orderBy);
        const perPage = normalizePerPage(perPageInput, 100);
        if (page < 0) {
            throw new Error("page must be >= 0");
        }
        const maxOffset = Number.MAX_SAFE_INTEGER / 2;
        if (page * perPage > maxOffset) {
            throw new Error("page value too large");
        }
        this.logger.debug(`InMemoryMemory: listThreadsByResourceId called for ${resourceId}`);
        const threads = Array.from(this.db.threads.values()).filter((t)=>t.resourceId === resourceId);
        const sortedThreads = this.sortThreads(threads, field, direction);
        const clonedThreads = sortedThreads.map((thread)=>({
                ...thread,
                metadata: thread.metadata ? {
                    ...thread.metadata
                } : thread.metadata
            }));
        const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        return {
            threads: clonedThreads.slice(offset, offset + perPage),
            total: clonedThreads.length,
            page,
            perPage: perPageForResponse,
            hasMore: offset + perPage < clonedThreads.length
        };
    }
    async getResourceById({ resourceId }) {
        this.logger.debug(`InMemoryMemory: getResourceById called for ${resourceId}`);
        const resource = this.db.resources.get(resourceId);
        return resource ? {
            ...resource,
            metadata: resource.metadata ? {
                ...resource.metadata
            } : resource.metadata
        } : null;
    }
    async saveResource({ resource }) {
        this.logger.debug(`InMemoryMemory: saveResource called for ${resource.id}`);
        this.db.resources.set(resource.id, resource);
        return resource;
    }
    async updateResource({ resourceId, workingMemory, metadata }) {
        this.logger.debug(`InMemoryMemory: updateResource called for ${resourceId}`);
        let resource = this.db.resources.get(resourceId);
        if (!resource) {
            resource = {
                id: resourceId,
                workingMemory,
                metadata: metadata || {},
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
            };
        } else {
            resource = {
                ...resource,
                workingMemory: workingMemory !== void 0 ? workingMemory : resource.workingMemory,
                metadata: {
                    ...resource.metadata,
                    ...metadata
                },
                updatedAt: /* @__PURE__ */ new Date()
            };
        }
        this.db.resources.set(resourceId, resource);
        return resource;
    }
    async cloneThread(args) {
        const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;
        this.logger.debug(`InMemoryMemory: cloneThread called for source thread ${sourceThreadId}`);
        const sourceThread = this.db.threads.get(sourceThreadId);
        if (!sourceThread) {
            throw new Error(`Source thread with id ${sourceThreadId} not found`);
        }
        const newThreadId = providedThreadId || crypto.randomUUID();
        if (this.db.threads.has(newThreadId)) {
            throw new Error(`Thread with id ${newThreadId} already exists`);
        }
        let sourceMessages = Array.from(this.db.messages.values()).filter((msg)=>msg.thread_id === sourceThreadId).sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        if (options?.messageFilter) {
            const { startDate, endDate, messageIds } = options.messageFilter;
            if (messageIds && messageIds.length > 0) {
                const messageIdSet = new Set(messageIds);
                sourceMessages = sourceMessages.filter((msg)=>messageIdSet.has(msg.id));
            }
            if (startDate) {
                sourceMessages = sourceMessages.filter((msg)=>new Date(msg.createdAt) >= startDate);
            }
            if (endDate) {
                sourceMessages = sourceMessages.filter((msg)=>new Date(msg.createdAt) <= endDate);
            }
        }
        if (options?.messageLimit && options.messageLimit > 0 && sourceMessages.length > options.messageLimit) {
            sourceMessages = sourceMessages.slice(-options.messageLimit);
        }
        const now = /* @__PURE__ */ new Date();
        const lastMessageId = sourceMessages.length > 0 ? sourceMessages[sourceMessages.length - 1].id : void 0;
        const cloneMetadata = {
            sourceThreadId,
            clonedAt: now,
            ...lastMessageId && {
                lastMessageId
            }
        };
        const newThread = {
            id: newThreadId,
            resourceId: resourceId || sourceThread.resourceId,
            title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : void 0),
            metadata: {
                ...metadata,
                clone: cloneMetadata
            },
            createdAt: now,
            updatedAt: now
        };
        this.db.threads.set(newThreadId, newThread);
        const clonedMessages = [];
        for (const sourceMsg of sourceMessages){
            const newMessageId = crypto.randomUUID();
            const parsedContent = safelyParseJSON(sourceMsg.content);
            const newStorageMessage = {
                id: newMessageId,
                thread_id: newThreadId,
                content: sourceMsg.content,
                role: sourceMsg.role,
                type: sourceMsg.type,
                createdAt: sourceMsg.createdAt,
                resourceId: resourceId || sourceMsg.resourceId
            };
            this.db.messages.set(newMessageId, newStorageMessage);
            clonedMessages.push({
                id: newMessageId,
                threadId: newThreadId,
                content: parsedContent,
                role: sourceMsg.role,
                type: sourceMsg.type,
                createdAt: sourceMsg.createdAt,
                resourceId: resourceId || sourceMsg.resourceId || void 0
            });
        }
        this.logger.debug(`InMemoryMemory: cloned thread ${sourceThreadId} to ${newThreadId} with ${clonedMessages.length} messages`);
        return {
            thread: newThread,
            clonedMessages
        };
    }
    sortThreads(threads, field, direction) {
        return threads.sort((a, b)=>{
            const isDateField = field === "createdAt" || field === "updatedAt";
            const aValue = isDateField ? new Date(a[field]).getTime() : a[field];
            const bValue = isDateField ? new Date(b[field]).getTime() : b[field];
            if (typeof aValue === "number" && typeof bValue === "number") {
                if (direction === "ASC") {
                    return aValue - bValue;
                } else {
                    return bValue - aValue;
                }
            }
            return direction === "ASC" ? String(aValue).localeCompare(String(bValue)) : String(bValue).localeCompare(String(aValue));
        });
    }
};
// src/storage/domains/observability/base.ts
var ObservabilityStorage = class extends StorageDomain {
    constructor(){
        super({
            component: "STORAGE",
            name: "OBSERVABILITY"
        });
    }
    async dangerouslyClearAll() {}
    /**
   * Provides hints for tracing strategy selection by the DefaultExporter.
   * Storage adapters can override this to specify their preferred and supported strategies.
   */ get tracingStrategy() {
        return {
            preferred: "batch-with-updates",
            // Default for most SQL stores
            supported: [
                "realtime",
                "batch-with-updates",
                "insert-only"
            ]
        };
    }
    /**
   * Creates a single Span record in the storage provider.
   */ async createSpan(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_CREATE_SPAN_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support creating spans"
        });
    }
    /**
   * Updates a single Span with partial data. Primarily used for realtime trace creation.
   */ async updateSpan(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_UPDATE_SPAN_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support updating spans"
        });
    }
    /**
   * Retrieves a single span.
   */ async getSpan(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_GET_SPAN_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support getting spans"
        });
    }
    /**
   * Retrieves a single root span.
   */ async getRootSpan(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_GET_ROOT_SPAN_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support getting root spans"
        });
    }
    /**
   * Retrieves a single trace with all its associated spans.
   */ async getTrace(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_GET_TRACE_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support getting traces"
        });
    }
    /**
   * Retrieves a list of traces with optional filtering.
   */ async listTraces(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_LIST_TRACES_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support listing traces"
        });
    }
    /**
   * Creates multiple Spans in a single batch.
   */ async batchCreateSpans(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_BATCH_CREATE_SPAN_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support batch creating spans"
        });
    }
    /**
   * Updates multiple Spans in a single batch.
   */ async batchUpdateSpans(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_BATCH_UPDATE_SPANS_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support batch updating spans"
        });
    }
    /**
   * Deletes multiple traces and all their associated spans in a single batch operation.
   */ async batchDeleteTraces(_args) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "OBSERVABILITY_STORAGE_BATCH_DELETE_TRACES_NOT_IMPLEMENTED",
            domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "This storage provider does not support batch deleting traces"
        });
    }
};
// src/storage/domains/observability/inmemory.ts
var ObservabilityInMemory = class extends ObservabilityStorage {
    db;
    constructor({ db }){
        super();
        this.db = db;
    }
    async dangerouslyClearAll() {
        this.db.traces.clear();
    }
    get tracingStrategy() {
        return {
            preferred: "realtime",
            supported: [
                "realtime",
                "batch-with-updates",
                "insert-only"
            ]
        };
    }
    async createSpan(args) {
        const { span } = args;
        this.validateCreateSpan(span);
        const now = /* @__PURE__ */ new Date();
        const record = {
            ...span,
            createdAt: now,
            updatedAt: now
        };
        this.upsertSpanToTrace(record);
    }
    async batchCreateSpans(args) {
        const now = /* @__PURE__ */ new Date();
        for (const span of args.records){
            this.validateCreateSpan(span);
            const record = {
                ...span,
                createdAt: now,
                updatedAt: now
            };
            this.upsertSpanToTrace(record);
        }
    }
    validateCreateSpan(record) {
        if (!record.spanId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "OBSERVABILITY_SPAN_ID_REQUIRED",
                domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Span ID is required for creating a span"
            });
        }
        if (!record.traceId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "OBSERVABILITY_TRACE_ID_REQUIRED",
                domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Trace ID is required for creating a span"
            });
        }
    }
    /**
   * Inserts or updates a span in the trace and recomputes trace-level properties
   */ upsertSpanToTrace(span) {
        const { traceId, spanId } = span;
        let traceEntry = this.db.traces.get(traceId);
        if (!traceEntry) {
            traceEntry = {
                spans: {},
                rootSpan: null,
                status: "running" /* RUNNING */ ,
                hasChildError: false
            };
            this.db.traces.set(traceId, traceEntry);
        }
        traceEntry.spans[spanId] = span;
        if (span.parentSpanId === null) {
            traceEntry.rootSpan = span;
        }
        this.recomputeTraceProperties(traceEntry);
    }
    /**
   * Recomputes derived trace properties from all spans
   */ recomputeTraceProperties(traceEntry) {
        const spans = Object.values(traceEntry.spans);
        if (spans.length === 0) return;
        traceEntry.hasChildError = spans.some((s)=>s.error != null);
        const rootSpan = traceEntry.rootSpan;
        if (rootSpan) {
            if (rootSpan.error != null) {
                traceEntry.status = "error" /* ERROR */ ;
            } else if (rootSpan.endedAt === null) {
                traceEntry.status = "running" /* RUNNING */ ;
            } else {
                traceEntry.status = "success" /* SUCCESS */ ;
            }
        } else {
            traceEntry.status = "running" /* RUNNING */ ;
        }
    }
    async getSpan(args) {
        const { traceId, spanId } = args;
        const traceEntry = this.db.traces.get(traceId);
        if (!traceEntry) {
            return null;
        }
        const span = traceEntry.spans[spanId];
        if (!span) {
            return null;
        }
        return {
            span
        };
    }
    async getRootSpan(args) {
        const { traceId } = args;
        const traceEntry = this.db.traces.get(traceId);
        if (!traceEntry || !traceEntry.rootSpan) {
            return null;
        }
        return {
            span: traceEntry.rootSpan
        };
    }
    async getTrace(args) {
        const { traceId } = args;
        const traceEntry = this.db.traces.get(traceId);
        if (!traceEntry) {
            return null;
        }
        const spans = Object.values(traceEntry.spans);
        if (spans.length === 0) {
            return null;
        }
        spans.sort((a, b)=>a.startedAt.getTime() - b.startedAt.getTime());
        return {
            traceId,
            spans
        };
    }
    async listTraces(args) {
        const { filters, pagination, orderBy } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["listTracesArgsSchema"].parse(args);
        const matchingRootSpans = [];
        for (const [, traceEntry] of this.db.traces){
            if (!traceEntry.rootSpan) continue;
            if (this.traceMatchesFilters(traceEntry, filters)) {
                matchingRootSpans.push(traceEntry.rootSpan);
            }
        }
        const { field: sortField, direction: sortDirection } = orderBy;
        matchingRootSpans.sort((a, b)=>{
            if (sortField === "endedAt") {
                const aVal = a.endedAt;
                const bVal = b.endedAt;
                if (aVal == null && bVal == null) return 0;
                if (aVal == null) return sortDirection === "DESC" ? -1 : 1;
                if (bVal == null) return sortDirection === "DESC" ? 1 : -1;
                const diff = aVal.getTime() - bVal.getTime();
                return sortDirection === "DESC" ? -diff : diff;
            } else {
                const diff = a.startedAt.getTime() - b.startedAt.getTime();
                return sortDirection === "DESC" ? -diff : diff;
            }
        });
        const total = matchingRootSpans.length;
        const { page, perPage } = pagination;
        const start = page * perPage;
        const end = start + perPage;
        const paged = matchingRootSpans.slice(start, end);
        return {
            spans: paged,
            pagination: {
                total,
                page,
                perPage,
                hasMore: end < total
            }
        };
    }
    /**
   * Check if a trace matches all provided filters
   */ traceMatchesFilters(traceEntry, filters) {
        if (!filters) return true;
        const rootSpan = traceEntry.rootSpan;
        if (!rootSpan) return false;
        if (filters.startedAt) {
            if (filters.startedAt.start && rootSpan.startedAt < filters.startedAt.start) {
                return false;
            }
            if (filters.startedAt.end && rootSpan.startedAt > filters.startedAt.end) {
                return false;
            }
        }
        if (filters.endedAt) {
            if (rootSpan.endedAt == null) {
                return false;
            }
            if (filters.endedAt.start && rootSpan.endedAt < filters.endedAt.start) {
                return false;
            }
            if (filters.endedAt.end && rootSpan.endedAt > filters.endedAt.end) {
                return false;
            }
        }
        if (filters.spanType !== void 0 && rootSpan.spanType !== filters.spanType) {
            return false;
        }
        if (filters.entityType !== void 0 && rootSpan.entityType !== filters.entityType) {
            return false;
        }
        if (filters.entityId !== void 0 && rootSpan.entityId !== filters.entityId) {
            return false;
        }
        if (filters.entityName !== void 0 && rootSpan.entityName !== filters.entityName) {
            return false;
        }
        if (filters.userId !== void 0 && rootSpan.userId !== filters.userId) {
            return false;
        }
        if (filters.organizationId !== void 0 && rootSpan.organizationId !== filters.organizationId) {
            return false;
        }
        if (filters.resourceId !== void 0 && rootSpan.resourceId !== filters.resourceId) {
            return false;
        }
        if (filters.runId !== void 0 && rootSpan.runId !== filters.runId) {
            return false;
        }
        if (filters.sessionId !== void 0 && rootSpan.sessionId !== filters.sessionId) {
            return false;
        }
        if (filters.threadId !== void 0 && rootSpan.threadId !== filters.threadId) {
            return false;
        }
        if (filters.requestId !== void 0 && rootSpan.requestId !== filters.requestId) {
            return false;
        }
        if (filters.environment !== void 0 && rootSpan.environment !== filters.environment) {
            return false;
        }
        if (filters.source !== void 0 && rootSpan.source !== filters.source) {
            return false;
        }
        if (filters.serviceName !== void 0 && rootSpan.serviceName !== filters.serviceName) {
            return false;
        }
        if (filters.scope != null && rootSpan.scope != null) {
            for (const [key, value] of Object.entries(filters.scope)){
                if (!this.jsonValueEquals(rootSpan.scope[key], value)) {
                    return false;
                }
            }
        } else if (filters.scope != null && rootSpan.scope == null) {
            return false;
        }
        if (filters.metadata != null && rootSpan.metadata != null) {
            for (const [key, value] of Object.entries(filters.metadata)){
                if (!this.jsonValueEquals(rootSpan.metadata[key], value)) {
                    return false;
                }
            }
        } else if (filters.metadata != null && rootSpan.metadata == null) {
            return false;
        }
        if (filters.tags != null && filters.tags.length > 0) {
            if (rootSpan.tags == null) {
                return false;
            }
            for (const tag of filters.tags){
                if (!rootSpan.tags.includes(tag)) {
                    return false;
                }
            }
        }
        if (filters.status !== void 0 && traceEntry.status !== filters.status) {
            return false;
        }
        if (filters.hasChildError !== void 0 && traceEntry.hasChildError !== filters.hasChildError) {
            return false;
        }
        return true;
    }
    /**
   * Deep equality check for JSON values
   */ jsonValueEquals(a, b) {
        if (a === void 0 || b === void 0) {
            return a === b;
        }
        if (a === null || b === null) {
            return a === b;
        }
        if (typeof a !== typeof b) {
            return false;
        }
        if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
        }
        if (a instanceof Date || b instanceof Date) {
            return false;
        }
        if (typeof a === "object") {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) return false;
                return a.every((val, i)=>this.jsonValueEquals(val, b[i]));
            }
            if (Array.isArray(a) || Array.isArray(b)) {
                return false;
            }
            const aKeys = Object.keys(a);
            const bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;
            return aKeys.every((key)=>this.jsonValueEquals(a[key], b[key]));
        }
        return a === b;
    }
    async updateSpan(args) {
        const { traceId, spanId, updates } = args;
        const traceEntry = this.db.traces.get(traceId);
        if (!traceEntry) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "OBSERVABILITY_UPDATE_SPAN_NOT_FOUND",
                domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Trace not found for span update"
            });
        }
        const span = traceEntry.spans[spanId];
        if (!span) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "OBSERVABILITY_UPDATE_SPAN_NOT_FOUND",
                domain: "MASTRA_OBSERVABILITY" /* MASTRA_OBSERVABILITY */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Span not found for update"
            });
        }
        const updatedSpan = {
            ...span,
            ...updates,
            updatedAt: /* @__PURE__ */ new Date()
        };
        traceEntry.spans[spanId] = updatedSpan;
        if (updatedSpan.parentSpanId === null) {
            traceEntry.rootSpan = updatedSpan;
        }
        this.recomputeTraceProperties(traceEntry);
    }
    async batchUpdateSpans(args) {
        for (const record of args.records){
            await this.updateSpan(record);
        }
    }
    async batchDeleteTraces(args) {
        for (const traceId of args.traceIds){
            this.db.traces.delete(traceId);
        }
    }
};
// src/storage/domains/scores/base.ts
var ScoresStorage = class extends StorageDomain {
    constructor(){
        super({
            component: "STORAGE",
            name: "SCORES"
        });
    }
    async dangerouslyClearAll() {}
    async listScoresBySpan({ traceId, spanId, pagination: _pagination }) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            details: {
                traceId,
                spanId
            }
        });
    }
};
// src/storage/domains/scores/inmemory.ts
var ScoresInMemory = class extends ScoresStorage {
    db;
    constructor({ db }){
        super();
        this.db = db;
    }
    async dangerouslyClearAll() {
        this.db.scores.clear();
    }
    async getScoreById({ id }) {
        return this.db.scores.get(id) ?? null;
    }
    async saveScore(score) {
        const newScore = {
            id: crypto.randomUUID(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date(),
            ...score
        };
        this.db.scores.set(newScore.id, newScore);
        return {
            score: newScore
        };
    }
    async listScoresByScorerId({ scorerId, pagination, entityId, entityType, source }) {
        const scores = Array.from(this.db.scores.values()).filter((score)=>{
            let baseFilter = score.scorerId === scorerId;
            if (entityId) {
                baseFilter = baseFilter && score.entityId === entityId;
            }
            if (entityType) {
                baseFilter = baseFilter && score.entityType === entityType;
            }
            if (source) {
                baseFilter = baseFilter && score.source === source;
            }
            return baseFilter;
        });
        const { page, perPage: perPageInput } = pagination;
        const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);
        const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        const end = perPageInput === false ? scores.length : start + perPage;
        return {
            scores: scores.slice(start, end),
            pagination: {
                total: scores.length,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : scores.length > end
            }
        };
    }
    async listScoresByRunId({ runId, pagination }) {
        const scores = Array.from(this.db.scores.values()).filter((score)=>score.runId === runId);
        const { page, perPage: perPageInput } = pagination;
        const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);
        const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        const end = perPageInput === false ? scores.length : start + perPage;
        return {
            scores: scores.slice(start, end),
            pagination: {
                total: scores.length,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : scores.length > end
            }
        };
    }
    async listScoresByEntityId({ entityId, entityType, pagination }) {
        const scores = Array.from(this.db.scores.values()).filter((score)=>{
            const baseFilter = score.entityId === entityId && score.entityType === entityType;
            return baseFilter;
        });
        const { page, perPage: perPageInput } = pagination;
        const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);
        const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        const end = perPageInput === false ? scores.length : start + perPage;
        return {
            scores: scores.slice(start, end),
            pagination: {
                total: scores.length,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : scores.length > end
            }
        };
    }
    async listScoresBySpan({ traceId, spanId, pagination }) {
        const scores = Array.from(this.db.scores.values()).filter((score)=>score.traceId === traceId && score.spanId === spanId);
        scores.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        const { page, perPage: perPageInput } = pagination;
        const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);
        const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
        const end = perPageInput === false ? scores.length : start + perPage;
        return {
            scores: scores.slice(start, end),
            pagination: {
                total: scores.length,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : scores.length > end
            }
        };
    }
};
// src/storage/domains/workflows/base.ts
var WorkflowsStorage = class extends StorageDomain {
    constructor(){
        super({
            component: "STORAGE",
            name: "WORKFLOWS"
        });
    }
};
// src/storage/domains/workflows/inmemory.ts
var WorkflowsInMemory = class extends WorkflowsStorage {
    db;
    constructor({ db }){
        super();
        this.db = db;
    }
    async dangerouslyClearAll() {
        this.db.workflows.clear();
    }
    getWorkflowKey(workflowName, runId) {
        return `${workflowName}-${runId}`;
    }
    async updateWorkflowResults({ workflowName, runId, stepId, result, requestContext }) {
        this.logger.debug(`WorkflowsInMemory: updateWorkflowResults called for ${workflowName} ${runId} ${stepId}`, result);
        const key = this.getWorkflowKey(workflowName, runId);
        const run = this.db.workflows.get(key);
        if (!run) {
            return {};
        }
        let snapshot;
        if (!run.snapshot) {
            snapshot = {
                context: {},
                activePaths: [],
                activeStepsPath: {},
                timestamp: Date.now(),
                suspendedPaths: {},
                resumeLabels: {},
                serializedStepGraph: [],
                value: {},
                waitingPaths: {},
                status: "pending",
                runId: run.run_id
            };
            this.db.workflows.set(key, {
                ...run,
                snapshot
            });
        } else {
            snapshot = typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : run.snapshot;
        }
        if (!snapshot || !snapshot?.context) {
            throw new Error(`Snapshot not found for runId ${runId}`);
        }
        snapshot.context[stepId] = result;
        snapshot.requestContext = {
            ...snapshot.requestContext,
            ...requestContext
        };
        this.db.workflows.set(key, {
            ...run,
            snapshot
        });
        return JSON.parse(JSON.stringify(snapshot.context));
    }
    async updateWorkflowState({ workflowName, runId, opts }) {
        const key = this.getWorkflowKey(workflowName, runId);
        const run = this.db.workflows.get(key);
        if (!run) {
            return;
        }
        let snapshot;
        if (!run.snapshot) {
            snapshot = {
                context: {},
                activePaths: [],
                activeStepsPath: {},
                timestamp: Date.now(),
                suspendedPaths: {},
                resumeLabels: {},
                serializedStepGraph: [],
                value: {},
                waitingPaths: {},
                status: "pending",
                runId: run.run_id
            };
            this.db.workflows.set(key, {
                ...run,
                snapshot
            });
        } else {
            snapshot = typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : run.snapshot;
        }
        if (!snapshot || !snapshot?.context) {
            throw new Error(`Snapshot not found for runId ${runId}`);
        }
        snapshot = {
            ...snapshot,
            ...opts
        };
        this.db.workflows.set(key, {
            ...run,
            snapshot
        });
        return snapshot;
    }
    async persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot, createdAt, updatedAt }) {
        const key = this.getWorkflowKey(workflowName, runId);
        const now = /* @__PURE__ */ new Date();
        const data = {
            workflow_name: workflowName,
            run_id: runId,
            resourceId,
            snapshot,
            createdAt: createdAt ?? now,
            updatedAt: updatedAt ?? now
        };
        this.db.workflows.set(key, data);
    }
    async loadWorkflowSnapshot({ workflowName, runId }) {
        this.logger.debug("Loading workflow snapshot", {
            workflowName,
            runId
        });
        const key = this.getWorkflowKey(workflowName, runId);
        const run = this.db.workflows.get(key);
        if (!run) {
            return null;
        }
        const snapshot = typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : run.snapshot;
        return snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;
    }
    async listWorkflowRuns({ workflowName, fromDate, toDate, perPage, page, resourceId, status } = {}) {
        if (page !== void 0 && page < 0) {
            throw new Error("page must be >= 0");
        }
        let runs = Array.from(this.db.workflows.values());
        if (workflowName) runs = runs.filter((run)=>run.workflow_name === workflowName);
        if (status) {
            runs = runs.filter((run)=>{
                let snapshot = run?.snapshot;
                if (!snapshot) {
                    return false;
                }
                if (typeof snapshot === "string") {
                    try {
                        snapshot = JSON.parse(snapshot);
                    } catch  {
                        return false;
                    }
                } else {
                    snapshot = JSON.parse(JSON.stringify(snapshot));
                }
                return snapshot.status === status;
            });
        }
        if (fromDate && toDate) {
            runs = runs.filter((run)=>new Date(run.createdAt).getTime() >= fromDate.getTime() && new Date(run.createdAt).getTime() <= toDate.getTime());
        } else if (fromDate) {
            runs = runs.filter((run)=>new Date(run.createdAt).getTime() >= fromDate.getTime());
        } else if (toDate) {
            runs = runs.filter((run)=>new Date(run.createdAt).getTime() <= toDate.getTime());
        }
        if (resourceId) runs = runs.filter((run)=>run.resourceId === resourceId);
        const total = runs.length;
        runs.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        if (perPage !== void 0 && page !== void 0) {
            const normalizedPerPage = normalizePerPage(perPage, Number.MAX_SAFE_INTEGER);
            const offset = page * normalizedPerPage;
            const start = offset;
            const end = start + normalizedPerPage;
            runs = runs.slice(start, end);
        }
        const parsedRuns = runs.map((run)=>({
                ...run,
                snapshot: typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),
                createdAt: new Date(run.createdAt),
                updatedAt: new Date(run.updatedAt),
                runId: run.run_id,
                workflowName: run.workflow_name,
                resourceId: run.resourceId
            }));
        return {
            runs: parsedRuns,
            total
        };
    }
    async getWorkflowRunById({ runId, workflowName }) {
        const runs = Array.from(this.db.workflows.values()).filter((r)=>r.run_id === runId);
        let run = runs.find((r)=>r.workflow_name === workflowName);
        if (!run) return null;
        const parsedRun = {
            ...run,
            snapshot: typeof run.snapshot === "string" ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),
            createdAt: new Date(run.createdAt),
            updatedAt: new Date(run.updatedAt),
            runId: run.run_id,
            workflowName: run.workflow_name,
            resourceId: run.resourceId
        };
        return parsedRun;
    }
    async deleteWorkflowRunById({ runId, workflowName }) {
        const key = this.getWorkflowKey(workflowName, runId);
        this.db.workflows.delete(key);
    }
};
// src/storage/mock.ts
var InMemoryStore = class extends MastraStorage {
    stores;
    /**
   * Internal database layer shared across all domains.
   * This is an implementation detail - domains interact with this
   * rather than managing their own data structures.
   */ #db;
    constructor({ id = "in-memory" } = {}){
        super({
            id,
            name: "InMemoryStorage"
        });
        this.hasInitialized = Promise.resolve(true);
        this.#db = new InMemoryDB();
        this.stores = {
            memory: new InMemoryMemory({
                db: this.#db
            }),
            workflows: new WorkflowsInMemory({
                db: this.#db
            }),
            scores: new ScoresInMemory({
                db: this.#db
            }),
            observability: new ObservabilityInMemory({
                db: this.#db
            }),
            agents: new InMemoryAgentsStorage({
                db: this.#db
            })
        };
    }
    /**
   * Clears all data from the in-memory database.
   * Useful for testing.
   * @deprecated Use dangerouslyClearAll() on individual domains instead.
   */ clear() {
        this.#db.clear();
    }
};
var MockStore = InMemoryStore;
// src/storage/domains/operations/base.ts
var StoreOperations = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    constructor(){
        super({
            component: "STORAGE",
            name: "OPERATIONS"
        });
    }
    getSqlType(type) {
        switch(type){
            case "text":
                return "TEXT";
            case "timestamp":
                return "TIMESTAMP";
            case "float":
                return "FLOAT";
            case "integer":
                return "INTEGER";
            case "bigint":
                return "BIGINT";
            case "jsonb":
                return "JSONB";
            default:
                return "TEXT";
        }
    }
    getDefaultValue(type) {
        switch(type){
            case "text":
            case "uuid":
                return "DEFAULT ''";
            case "timestamp":
                return "DEFAULT '1970-01-01 00:00:00'";
            case "integer":
            case "bigint":
            case "float":
                return "DEFAULT 0";
            case "jsonb":
                return "DEFAULT '{}'";
            default:
                return "DEFAULT ''";
        }
    }
    /**
   * DATABASE INDEX MANAGEMENT
   * Optional methods for database index management.
   * Storage adapters can override these to provide index management capabilities.
   */ /**
   * Creates a database index on specified columns
   * @throws {MastraError} if not supported by the storage adapter
   */ async createIndex(_options) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: `Index management is not supported by this storage adapter`
        });
    }
    /**
   * Drops a database index by name
   * @throws {MastraError} if not supported by the storage adapter
   */ async dropIndex(_indexName) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: `Index management is not supported by this storage adapter`
        });
    }
    /**
   * Lists database indexes for a table or all tables
   * @throws {MastraError} if not supported by the storage adapter
   */ async listIndexes(_tableName) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: `Index management is not supported by this storage adapter`
        });
    }
    /**
   * Gets detailed statistics for a specific index
   * @throws {MastraError} if not supported by the storage adapter
   */ async describeIndex(_indexName) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: `Index management is not supported by this storage adapter`
        });
    }
    /**
   * Returns definitions for automatic performance indexes
   * Storage adapters can override this to define indexes that should be created during initialization
   * @returns Array of index definitions to create automatically
   */ getAutomaticIndexDefinitions() {
        return [];
    }
};
// src/storage/domains/operations/inmemory.ts
var StoreOperationsInMemory = class extends StoreOperations {
    data;
    constructor(){
        super();
        this.data = {
            mastra_workflow_snapshot: /* @__PURE__ */ new Map(),
            mastra_messages: /* @__PURE__ */ new Map(),
            mastra_threads: /* @__PURE__ */ new Map(),
            mastra_traces: /* @__PURE__ */ new Map(),
            mastra_resources: /* @__PURE__ */ new Map(),
            mastra_scorers: /* @__PURE__ */ new Map(),
            mastra_ai_spans: /* @__PURE__ */ new Map(),
            mastra_agents: /* @__PURE__ */ new Map()
        };
    }
    getDatabase() {
        return this.data;
    }
    async insert({ tableName, record }) {
        const table = this.data[tableName];
        let key = record.id;
        if ([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]
        ].includes(tableName) && !record.id && record.run_id) {
            key = record.workflow_name ? `${record.workflow_name}-${record.run_id}` : record.run_id;
            record.id = key;
        } else if (!record.id) {
            key = `auto-${Date.now()}-${Math.random()}`;
            record.id = key;
        }
        table.set(key, record);
    }
    async batchInsert({ tableName, records }) {
        const table = this.data[tableName];
        for (const record of records){
            let key = record.id;
            if ([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]
            ].includes(tableName) && !record.id && record.run_id) {
                key = record.run_id;
                record.id = key;
            } else if (!record.id) {
                key = `auto-${Date.now()}-${Math.random()}`;
                record.id = key;
            }
            table.set(key, record);
        }
    }
    async load({ tableName, keys }) {
        this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);
        const table = this.data[tableName];
        const records = Array.from(table.values());
        return records.filter((record)=>Object.keys(keys).every((key)=>record[key] === keys[key]))?.[0];
    }
    async createTable({ tableName, schema }) {
        this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);
        this.data[tableName] = /* @__PURE__ */ new Map();
    }
    async clearTable({ tableName }) {
        this.logger.debug(`MockStore: clearTable called for ${tableName}`);
        this.data[tableName].clear();
    }
    async dropTable({ tableName }) {
        this.logger.debug(`MockStore: dropTable called for ${tableName}`);
        this.data[tableName].clear();
    }
    async alterTable({ tableName, schema }) {
        this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);
    }
    async hasColumn(table, column) {
        this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);
        return true;
    }
};
;
 //# sourceMappingURL=chunk-DDH2PEZG.js.map
 //# sourceMappingURL=chunk-DDH2PEZG.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-3CKZSDTQ.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InMemoryServerCache",
    ()=>InMemoryServerCache,
    "MastraServerCache",
    ()=>MastraServerCache
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$isaacs$2f$ttlcache$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@isaacs/ttlcache/index.js [app-route] (ecmascript)");
;
;
// src/cache/base.ts
var MastraServerCache = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    constructor({ name }){
        super({
            component: "SERVER_CACHE",
            name
        });
    }
};
var InMemoryServerCache = class extends MastraServerCache {
    cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$isaacs$2f$ttlcache$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
        max: 1e3,
        ttl: 1e3 * 60 * 5
    });
    constructor(){
        super({
            name: "InMemoryServerCache"
        });
    }
    async get(key) {
        return this.cache.get(key);
    }
    async set(key, value) {
        this.cache.set(key, value);
    }
    async listLength(key) {
        const list = this.cache.get(key);
        if (!Array.isArray(list)) {
            throw new Error(`${key} is not an array`);
        }
        return list.length;
    }
    async listPush(key, value) {
        const list = this.cache.get(key);
        if (Array.isArray(list)) {
            list.push(value);
        } else {
            this.cache.set(key, [
                value
            ]);
        }
    }
    async listFromTo(key, from, to = -1) {
        const list = this.cache.get(key);
        if (Array.isArray(list)) {
            const endIndex = to === -1 ? void 0 : to + 1;
            return list.slice(from, endIndex);
        }
        return [];
    }
    async delete(key) {
        this.cache.delete(key);
    }
    async clear() {
        this.cache.clear();
    }
};
;
 //# sourceMappingURL=chunk-3CKZSDTQ.js.map
 //# sourceMappingURL=chunk-3CKZSDTQ.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-NKDMPZ4W.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NetlifyGateway",
    ()=>NetlifyGateway
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-YWUDQUAV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$3CKZSDTQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-3CKZSDTQ.js [app-route] (ecmascript)");
;
;
;
// src/llm/model/gateways/netlify.ts
var NetlifyGateway = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraModelGateway"] {
    id = "netlify";
    name = "Netlify AI Gateway";
    tokenCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$3CKZSDTQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InMemoryServerCache"]();
    async fetchProviders() {
        const response = await fetch("https://api.netlify.com/api/v1/ai-gateway/providers");
        if (!response.ok) {
            throw new Error(`Failed to fetch from Netlify: ${response.statusText}`);
        }
        const data = await response.json();
        const config = {
            apiKeyEnvVar: [
                "NETLIFY_TOKEN",
                "NETLIFY_SITE_ID"
            ],
            apiKeyHeader: "Authorization",
            name: `Netlify`,
            gateway: `netlify`,
            models: [],
            docUrl: "https://docs.netlify.com/build/ai-gateway/overview/"
        };
        for (const [providerId, provider] of Object.entries(data.providers)){
            for (const model of provider.models){
                config.models.push(`${providerId}/${model}`);
            }
        }
        return {
            netlify: config
        };
    }
    async buildUrl(routerId, envVars) {
        const siteId = envVars?.["NETLIFY_SITE_ID"] || process.env["NETLIFY_SITE_ID"];
        const netlifyToken = envVars?.["NETLIFY_TOKEN"] || process.env["NETLIFY_TOKEN"];
        if (!netlifyToken) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_NO_TOKEN",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Missing NETLIFY_TOKEN environment variable required for model: ${routerId}`
            });
        }
        if (!siteId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_NO_SITE_ID",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Missing NETLIFY_SITE_ID environment variable required for model: ${routerId}`
            });
        }
        try {
            const tokenData = await this.getOrFetchToken(siteId, netlifyToken);
            return tokenData.url.endsWith(`/`) ? tokenData.url.substring(0, tokenData.url.length - 1) : tokenData.url;
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_TOKEN_ERROR",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Failed to get Netlify AI Gateway token for model ${routerId}: ${error instanceof Error ? error.message : String(error)}`
            });
        }
    }
    /**
   * Get cached token or fetch a new site-specific AI Gateway token from Netlify
   */ async getOrFetchToken(siteId, netlifyToken) {
        const cacheKey = `netlify-token:${siteId}:${netlifyToken}`;
        const cached = await this.tokenCache.get(cacheKey);
        if (cached && cached.expiresAt > Date.now() / 1e3 + 60) {
            return {
                token: cached.token,
                url: cached.url
            };
        }
        const response = await fetch(`https://api.netlify.com/api/v1/sites/${siteId}/ai-gateway/token`, {
            method: "GET",
            headers: {
                Authorization: `Bearer ${netlifyToken}`
            }
        });
        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to get Netlify AI Gateway token: ${response.status} ${error}`);
        }
        const tokenResponse = await response.json();
        await this.tokenCache.set(cacheKey, {
            token: tokenResponse.token,
            url: tokenResponse.url,
            expiresAt: tokenResponse.expires_at
        });
        return {
            token: tokenResponse.token,
            url: tokenResponse.url
        };
    }
    /**
   * Get cached token or fetch a new site-specific AI Gateway token from Netlify
   */ async getApiKey(modelId) {
        const siteId = process.env["NETLIFY_SITE_ID"];
        const netlifyToken = process.env["NETLIFY_TOKEN"];
        if (!netlifyToken) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_NO_TOKEN",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Missing NETLIFY_TOKEN environment variable required for model: ${modelId}`
            });
        }
        if (!siteId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_NO_SITE_ID",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Missing NETLIFY_SITE_ID environment variable required for model: ${modelId}`
            });
        }
        try {
            return (await this.getOrFetchToken(siteId, netlifyToken)).token;
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "NETLIFY_GATEWAY_TOKEN_ERROR",
                domain: "LLM",
                category: "UNKNOWN",
                text: `Failed to get Netlify AI Gateway token for model ${modelId}: ${error instanceof Error ? error.message : String(error)}`
            });
        }
    }
    async resolveLanguageModel({ modelId, providerId, apiKey, headers }) {
        const baseURL = await this.buildUrl(`${providerId}/${modelId}`);
        switch(providerId){
            case "openai":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createOpenAI"])({
                    apiKey,
                    baseURL,
                    headers
                }).responses(modelId);
            case "gemini":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createGoogleGenerativeAI"])({
                    baseURL: `${baseURL}/v1beta/`,
                    apiKey,
                    headers: {
                        "user-agent": "google-genai-sdk/",
                        ...headers ? headers : {}
                    }
                }).chat(modelId);
            case "anthropic":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAnthropic"])({
                    apiKey,
                    baseURL: `${baseURL}/v1/`,
                    headers: {
                        "anthropic-version": "2023-06-01",
                        "user-agent": "anthropic/",
                        ...headers ? headers : {}
                    }
                })(modelId);
            default:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$YWUDQUAV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createOpenAICompatible"])({
                    name: providerId,
                    apiKey,
                    baseURL,
                    supportsStructuredOutputs: true
                }).chatModel(modelId);
        }
    }
};
;
 //# sourceMappingURL=chunk-NKDMPZ4W.js.map
 //# sourceMappingURL=chunk-NKDMPZ4W.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-DD2VNRQM.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToolStream",
    ()=>ToolStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$web__$5b$external$5d$__$28$stream$2f$web$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream/web [external] (stream/web, cjs)");
;
// src/tools/stream.ts
var ToolStream = class extends __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$web__$5b$external$5d$__$28$stream$2f$web$2c$__cjs$29$__["WritableStream"] {
    prefix;
    callId;
    name;
    runId;
    writeFn;
    constructor({ prefix, callId, name, runId }, writeFn){
        super({
            async write (chunk) {
                await getInstance()._write(chunk);
            }
        });
        const self = this;
        function getInstance() {
            return self;
        }
        this.prefix = prefix;
        this.callId = callId;
        this.name = name;
        this.runId = runId;
        this.writeFn = writeFn;
    }
    async _write(data) {
        if (this.writeFn) {
            await this.writeFn({
                type: `${this.prefix}-output`,
                runId: this.runId,
                from: "USER",
                payload: {
                    output: data,
                    ...this.prefix === "workflow-step" ? {
                        runId: this.runId,
                        stepName: this.name
                    } : {
                        [`${this.prefix}CallId`]: this.callId,
                        [`${this.prefix}Name`]: this.name
                    }
                }
            });
        }
    }
    async write(data) {
        await this._write(data);
    }
    async custom(data) {
        if (this.writeFn) {
            await this.writeFn(data);
        }
    }
};
;
 //# sourceMappingURL=chunk-DD2VNRQM.js.map
 //# sourceMappingURL=chunk-DD2VNRQM.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-N3PAHTKU.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Tool",
    ()=>Tool,
    "createTool",
    ()=>createTool,
    "isVercelTool",
    ()=>isVercelTool,
    "validateToolInput",
    ()=>validateToolInput,
    "validateToolOutput",
    ()=>validateToolOutput,
    "validateToolSuspendData",
    ()=>validateToolSuspendData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-AIJLACR2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-Y22QMA7S.js [app-route] (ecmascript)");
;
;
// src/tools/validation.ts
function truncateForLogging(data, maxLength = 200) {
    try {
        const stringified = JSON.stringify(data, null, 2);
        if (stringified.length <= maxLength) {
            return stringified;
        }
        return stringified.slice(0, maxLength) + "... (truncated)";
    } catch  {
        return "[Unable to serialize data]";
    }
}
function validateToolSuspendData(schema, suspendData, toolId) {
    if (!schema || !("safeParse" in schema)) {
        return {
            data: suspendData
        };
    }
    const validation = schema.safeParse(suspendData);
    if (validation.success) {
        return {
            data: validation.data
        };
    }
    const errorMessages = validation.error.issues.map((e)=>`- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
    const error = {
        error: true,
        message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(suspendData)}`,
        validationErrors: validation.error.format()
    };
    return {
        data: suspendData,
        error
    };
}
function normalizeNullishInput(schema, input) {
    if (input !== void 0 && input !== null) {
        return input;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodArray"])(schema)) {
        return [];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodObject"])(schema)) {
        return {};
    }
    return input;
}
function isPlainObject(value) {
    if (value === null || typeof value !== "object") {
        return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
}
function convertUndefinedToNull(input) {
    if (input === void 0) {
        return null;
    }
    if (input === null || typeof input !== "object") {
        return input;
    }
    if (Array.isArray(input)) {
        return input.map(convertUndefinedToNull);
    }
    if (!isPlainObject(input)) {
        return input;
    }
    const result = {};
    for (const [key, value] of Object.entries(input)){
        result[key] = convertUndefinedToNull(value);
    }
    return result;
}
function validateToolInput(schema, input, toolId) {
    if (!schema || !("safeParse" in schema)) {
        return {
            data: input
        };
    }
    let normalizedInput = normalizeNullishInput(schema, input);
    normalizedInput = convertUndefinedToNull(normalizedInput);
    const validation = schema.safeParse(normalizedInput);
    if (validation.success) {
        return {
            data: validation.data
        };
    }
    const errorMessages = validation.error.issues.map((e)=>`- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
    const error = {
        error: true,
        message: `Tool input validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(input)}`,
        validationErrors: validation.error.format()
    };
    return {
        data: input,
        error
    };
}
function validateToolOutput(schema, output, toolId, suspendCalled) {
    if (!schema || !("safeParse" in schema) || suspendCalled) {
        return {
            data: output
        };
    }
    const validation = schema.safeParse(output);
    if (validation.success) {
        return {
            data: validation.data
        };
    }
    const errorMessages = validation.error.issues.map((e)=>`- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
    const error = {
        error: true,
        message: `Tool output validation failed${toolId ? ` for ${toolId}` : ""}. The tool returned invalid output:
${errorMessages}

Returned output: ${truncateForLogging(output)}`,
        validationErrors: validation.error.format()
    };
    return {
        data: output,
        error
    };
}
// src/tools/tool.ts
var Tool = class {
    /** Unique identifier for the tool */ id;
    /** Description of what the tool does */ description;
    /** Schema for validating input parameters */ inputSchema;
    /** Schema for validating output structure */ outputSchema;
    /** Schema for suspend operation data */ suspendSchema;
    /** Schema for resume operation data */ resumeSchema;
    /**
   * Tool execution function
   * @param inputData - The raw, validated input data
   * @param context - Optional execution context with metadata
   * @returns Promise resolving to tool output or a ValidationError if input validation fails
   */ execute;
    /** Parent Mastra instance for accessing shared resources */ mastra;
    /**
   * Whether the tool requires explicit user approval before execution
   * @example
   * ```typescript
   * // For destructive operations
   * requireApproval: true
   * ```
   */ requireApproval;
    /**
   * Provider-specific options passed to the model when this tool is used.
   * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.
   * @example
   * ```typescript
   * providerOptions: {
   *   anthropic: {
   *     cacheControl: { type: 'ephemeral' }
   *   }
   * }
   * ```
   */ providerOptions;
    /**
   * Optional MCP-specific properties including annotations and metadata.
   * Only relevant when the tool is being used in an MCP context.
   * @example
   * ```typescript
   * mcp: {
   *   annotations: {
   *     title: 'Weather Lookup',
   *     readOnlyHint: true,
   *     destructiveHint: false
   *   },
   *   _meta: {
   *     version: '1.0.0',
   *     author: 'team@example.com'
   *   }
   * }
   * ```
   */ mcp;
    /**
   * Creates a new Tool instance with input validation wrapper.
   *
   * @param opts - Tool configuration and execute function
   * @example
   * ```typescript
   * const tool = new Tool({
   *   id: 'my-tool',
   *   description: 'Does something useful',
   *   inputSchema: z.object({ name: z.string() }),
   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })
   * });
   * ```
   */ constructor(opts){
        this.id = opts.id;
        this.description = opts.description;
        this.inputSchema = opts.inputSchema;
        this.outputSchema = opts.outputSchema;
        this.suspendSchema = opts.suspendSchema;
        this.resumeSchema = opts.resumeSchema;
        this.mastra = opts.mastra;
        this.requireApproval = opts.requireApproval || false;
        this.providerOptions = opts.providerOptions;
        this.mcp = opts.mcp;
        if (opts.execute) {
            const originalExecute = opts.execute;
            this.execute = async (inputData, context)=>{
                const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);
                if (error) {
                    return error;
                }
                let suspendData = null;
                const baseContext = context ? {
                    ...context,
                    ...context.suspend ? {
                        suspend: (args, suspendOptions)=>{
                            suspendData = args;
                            return context.suspend?.(args, suspendOptions);
                        }
                    } : {}
                } : {};
                let organizedContext = baseContext;
                if (!context) {
                    organizedContext = {
                        requestContext: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RequestContext"](),
                        mastra: void 0
                    };
                } else {
                    const isAgentExecution = baseContext.toolCallId && baseContext.messages;
                    const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);
                    if (isAgentExecution && !baseContext.agent) {
                        const { toolCallId, messages, suspend, resumeData: resumeData2, threadId, resourceId, writableStream, ...rest } = baseContext;
                        organizedContext = {
                            ...rest,
                            agent: {
                                toolCallId,
                                messages,
                                suspend,
                                resumeData: resumeData2,
                                threadId,
                                resourceId,
                                writableStream
                            },
                            // Ensure requestContext is always present
                            requestContext: rest.requestContext || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RequestContext"]()
                        };
                    } else if (isWorkflowExecution && !baseContext.workflow) {
                        const { workflowId, runId, state, setState, suspend, resumeData: resumeData2, ...rest } = baseContext;
                        organizedContext = {
                            ...rest,
                            workflow: {
                                workflowId,
                                runId,
                                state,
                                setState,
                                suspend,
                                resumeData: resumeData2
                            },
                            // Ensure requestContext is always present
                            requestContext: rest.requestContext || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RequestContext"]()
                        };
                    } else {
                        organizedContext = {
                            ...baseContext,
                            agent: baseContext.agent ? {
                                ...baseContext.agent,
                                suspend: (args, suspendOptions)=>{
                                    suspendData = args;
                                    return baseContext.agent?.suspend?.(args, suspendOptions);
                                }
                            } : baseContext.agent,
                            workflow: baseContext.workflow ? {
                                ...baseContext.workflow,
                                suspend: (args, suspendOptions)=>{
                                    suspendData = args;
                                    return baseContext.workflow?.suspend?.(args, suspendOptions);
                                }
                            } : baseContext.workflow,
                            requestContext: baseContext.requestContext || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RequestContext"]()
                        };
                    }
                }
                const resumeData = organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;
                if (resumeData) {
                    const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);
                    if (resumeValidation.error) {
                        return resumeValidation.error;
                    }
                }
                const output = await originalExecute(data, organizedContext);
                if (suspendData) {
                    const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);
                    if (suspendValidation.error) {
                        return suspendValidation.error;
                    }
                }
                const skiptOutputValidation = !!(typeof output === "undefined" && suspendData);
                const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);
                if (outputValidation.error) {
                    return outputValidation.error;
                }
                return outputValidation.data;
            };
        }
    }
};
function createTool(opts) {
    return new Tool(opts);
}
// src/tools/toolchecks.ts
function isVercelTool(tool) {
    return !!(tool && !(tool instanceof Tool) && ("parameters" in tool || "execute" in tool && typeof tool.execute === "function" && "inputSchema" in tool));
}
;
 //# sourceMappingURL=chunk-N3PAHTKU.js.map
 //# sourceMappingURL=chunk-N3PAHTKU.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-MCVLH3QV.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkEvalStorageFields",
    ()=>checkEvalStorageFields,
    "createMastraProxy",
    ()=>createMastraProxy,
    "deepMerge",
    ()=>deepMerge,
    "delay",
    ()=>delay,
    "ensureToolProperties",
    ()=>ensureToolProperties,
    "fetchWithRetry",
    ()=>fetchWithRetry,
    "generateEmptyFromSchema",
    ()=>generateEmptyFromSchema,
    "getNestedValue",
    ()=>getNestedValue,
    "isCoreMessage",
    ()=>isCoreMessage,
    "isUiMessage",
    ()=>isUiMessage,
    "isZodType",
    ()=>isZodType,
    "makeCoreTool",
    ()=>makeCoreTool,
    "makeCoreToolV5",
    ()=>makeCoreToolV5,
    "maskStreamTags",
    ()=>maskStreamTags,
    "omitKeys",
    ()=>omitKeys,
    "parseFieldKey",
    ()=>parseFieldKey,
    "parseSqlIdentifier",
    ()=>parseSqlIdentifier,
    "removeUndefinedValues",
    ()=>removeUndefinedValues,
    "resolveSerializedZodOutput",
    ()=>resolveSerializedZodOutput,
    "selectFields",
    ()=>selectFields,
    "setNestedValue",
    ()=>setNestedValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-XKBYPAOY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DD2VNRQM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-DD2VNRQM.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-N3PAHTKU.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-AIJLACR2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-Y22QMA7S.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$json$2d$to$2d$zod$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/json-to-zod.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$zod$2d$to$2d$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/zod-to-json.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/chunk-3RG3ZAXL.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
var CoreToolBuilder = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    originalTool;
    options;
    logType;
    constructor(input){
        super({
            name: "CoreToolBuilder"
        });
        this.originalTool = input.originalTool;
        this.options = input.options;
        this.logType = input.logType;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(this.originalTool) && input.autoResumeSuspendedTools) {
            let schema = this.originalTool.inputSchema;
            if (typeof schema === "function") {
                schema = schema();
            }
            if (!schema) {
                schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodObject"])(schema)) {
                this.originalTool.inputSchema = schema.extend({
                    suspendedToolRunId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe("The runId of the suspended tool").optional().default(""),
                    resumeData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().describe("The resumeData object created from the resumeSchema of suspended tool").optional()
                });
            }
        }
    }
    // Helper to get parameters based on tool type
    getParameters = ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(this.originalTool)) {
            let schema2 = this.originalTool.parameters ?? ("inputSchema" in this.originalTool ? this.originalTool.inputSchema : void 0) ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
            if (typeof schema2 === "function") {
                schema2 = schema2();
            }
            return schema2;
        }
        let schema = this.originalTool.inputSchema;
        if (typeof schema === "function") {
            schema = schema();
        }
        return schema;
    };
    getOutputSchema = ()=>{
        if ("outputSchema" in this.originalTool) {
            let schema = this.originalTool.outputSchema;
            if (typeof schema === "function") {
                schema = schema();
            }
            return schema;
        }
        return null;
    };
    getResumeSchema = ()=>{
        if ("resumeSchema" in this.originalTool) {
            let schema = this.originalTool.resumeSchema;
            if (typeof schema === "function") {
                schema = schema();
            }
            return schema;
        }
        return null;
    };
    getSuspendSchema = ()=>{
        if ("suspendSchema" in this.originalTool) {
            let schema = this.originalTool.suspendSchema;
            if (typeof schema === "function") {
                schema = schema();
            }
            return schema;
        }
        return null;
    };
    // For provider-defined tools, we need to include all required properties
    // AI SDK v5 uses type: 'provider-defined', AI SDK v6 uses type: 'provider'
    buildProviderTool(tool) {
        if ("type" in tool && (tool.type === "provider-defined" || tool.type === "provider") && "id" in tool && typeof tool.id === "string" && tool.id.includes(".")) {
            let parameters = "parameters" in tool ? tool.parameters : "inputSchema" in tool ? tool.inputSchema : void 0;
            if (typeof parameters === "function") {
                parameters = parameters();
            }
            let outputSchema = "outputSchema" in tool ? tool.outputSchema : void 0;
            if (typeof outputSchema === "function") {
                outputSchema = outputSchema();
            }
            let processedParameters;
            if (parameters !== void 0 && parameters !== null) {
                if (typeof parameters === "object" && "jsonSchema" in parameters) {
                    processedParameters = parameters;
                } else {
                    processedParameters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertZodSchemaToAISDKSchema"])(parameters);
                }
            }
            let processedOutputSchema;
            if (outputSchema !== void 0 && outputSchema !== null) {
                if (typeof outputSchema === "object" && "jsonSchema" in outputSchema) {
                    processedOutputSchema = outputSchema;
                } else {
                    processedOutputSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertZodSchemaToAISDKSchema"])(outputSchema);
                }
            }
            return {
                ...processedOutputSchema ? {
                    outputSchema: processedOutputSchema
                } : {},
                type: "provider-defined",
                id: tool.id,
                args: "args" in this.originalTool ? this.originalTool.args : {},
                description: tool.description,
                parameters: processedParameters,
                execute: this.originalTool.execute ? this.createExecute(this.originalTool, {
                    ...this.options,
                    description: this.originalTool.description
                }, this.logType) : void 0
            };
        }
        return void 0;
    }
    createLogMessageOptions({ agentName, toolName, type }) {
        if (!agentName) {
            return {
                start: `Executing tool ${toolName}`,
                error: `Failed tool execution`
            };
        }
        const prefix = `[Agent:${agentName}]`;
        const toolType = type === "toolset" ? "toolset" : "tool";
        return {
            start: `${prefix} - Executing ${toolType} ${toolName}`,
            error: `${prefix} - Failed ${toolType} execution`
        };
    }
    createExecute(tool, options, logType, processedSchema) {
        const { logger, mastra: _mastra, memory: _memory, requestContext, model, ...rest } = options;
        const logModelObject = {
            modelId: model?.modelId,
            provider: model?.provider,
            specificationVersion: model?.specificationVersion
        };
        const { start, error } = this.createLogMessageOptions({
            agentName: options.agentName,
            toolName: options.name,
            type: logType
        });
        const execFunction = async (args, execOptions)=>{
            const tracingContext = execOptions.tracingContext || options.tracingContext;
            const toolSpan = tracingContext?.currentSpan?.createChildSpan({
                type: "tool_call" /* TOOL_CALL */ ,
                name: `tool: '${options.name}'`,
                input: args,
                entityType: "tool" /* TOOL */ ,
                entityName: options.name,
                attributes: {
                    toolDescription: options.description,
                    toolType: logType || "tool"
                },
                tracingPolicy: options.tracingPolicy
            });
            try {
                let result;
                let suspendData = null;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                    result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeWithContext"])({
                        span: toolSpan,
                        fn: async ()=>tool?.execute?.(args, execOptions)
                    });
                } else {
                    const wrappedMastra = options.mastra ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["wrapMastra"])(options.mastra, {
                        currentSpan: toolSpan
                    }) : options.mastra;
                    const resumeSchema = this.getResumeSchema();
                    const baseContext = {
                        threadId: options.threadId,
                        resourceId: options.resourceId,
                        mastra: wrappedMastra,
                        memory: options.memory,
                        runId: options.runId,
                        requestContext: options.requestContext ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$Y22QMA7S$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RequestContext"](),
                        writer: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DD2VNRQM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ToolStream"]({
                            prefix: "tool",
                            callId: execOptions.toolCallId,
                            name: options.name,
                            runId: options.runId
                        }, options.outputWriter || execOptions.outputWriter),
                        tracingContext: {
                            currentSpan: toolSpan
                        },
                        abortSignal: execOptions.abortSignal,
                        suspend: (args2, suspendOptions)=>{
                            suspendData = args2;
                            const newSuspendOptions = {
                                ...suspendOptions ?? {},
                                resumeSchema: suspendOptions?.resumeSchema ?? (resumeSchema ? JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(resumeSchema)) : void 0)
                            };
                            return execOptions.suspend?.(args2, newSuspendOptions);
                        },
                        resumeData: execOptions.resumeData
                    };
                    const isAgentExecution = execOptions.toolCallId && execOptions.messages || options.agentName && options.threadId && !options.workflowId;
                    const isWorkflowExecution = !isAgentExecution && (options.workflow || options.workflowId);
                    let toolContext;
                    if (isAgentExecution) {
                        const { suspend, resumeData: resumeData2, threadId, resourceId, ...restBaseContext } = baseContext;
                        toolContext = {
                            ...restBaseContext,
                            agent: {
                                toolCallId: execOptions.toolCallId || "",
                                messages: execOptions.messages || [],
                                suspend,
                                resumeData: resumeData2,
                                threadId,
                                resourceId,
                                outputWriter: execOptions.outputWriter
                            }
                        };
                    } else if (isWorkflowExecution) {
                        const { suspend, resumeData: resumeData2, ...restBaseContext } = baseContext;
                        toolContext = {
                            ...restBaseContext,
                            workflow: options.workflow || {
                                runId: options.runId,
                                workflowId: options.workflowId,
                                state: options.state,
                                setState: options.setState,
                                suspend,
                                resumeData: resumeData2
                            }
                        };
                    } else if (execOptions.mcp) {
                        toolContext = {
                            ...baseContext,
                            mcp: execOptions.mcp
                        };
                    } else {
                        toolContext = baseContext;
                    }
                    const resumeData = execOptions.resumeData;
                    if (resumeData) {
                        const resumeValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateToolInput"])(resumeSchema, resumeData, options.name);
                        if (resumeValidation.error) {
                            logger?.warn(resumeValidation.error.message);
                            toolSpan?.end({
                                output: resumeValidation.error,
                                attributes: {
                                    success: false
                                }
                            });
                            return resumeValidation.error;
                        }
                    }
                    result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeWithContext"])({
                        span: toolSpan,
                        fn: async ()=>tool?.execute?.(args, toolContext)
                    });
                }
                if (suspendData) {
                    const suspendSchema = this.getSuspendSchema();
                    const suspendValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateToolSuspendData"])(suspendSchema, suspendData, options.name);
                    if (suspendValidation.error) {
                        logger?.warn(suspendValidation.error.message);
                        toolSpan?.end({
                            output: suspendValidation.error,
                            attributes: {
                                success: false
                            }
                        });
                        return suspendValidation.error;
                    }
                }
                const shouldSkipValidation = typeof result === "undefined" && !!suspendData;
                if (shouldSkipValidation) {
                    toolSpan?.end({
                        output: result,
                        attributes: {
                            success: true
                        }
                    });
                    return result;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                    const outputSchema = this.getOutputSchema();
                    const outputValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateToolOutput"])(outputSchema, result, options.name, false);
                    if (outputValidation.error) {
                        logger?.warn(outputValidation.error.message);
                        toolSpan?.end({
                            output: outputValidation.error,
                            attributes: {
                                success: false
                            }
                        });
                        return outputValidation.error;
                    }
                    result = outputValidation.data;
                }
                toolSpan?.end({
                    output: result,
                    attributes: {
                        success: true
                    }
                });
                return result;
            } catch (error2) {
                toolSpan?.error({
                    error: error2,
                    attributes: {
                        success: false
                    }
                });
                throw error2;
            }
        };
        return async (args, execOptions)=>{
            let logger2 = options.logger || this.logger;
            try {
                logger2.debug(start, {
                    ...rest,
                    model: logModelObject,
                    args
                });
                const parameters = processedSchema || this.getParameters();
                const { data, error: error2 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateToolInput"])(parameters, args, options.name);
                if (error2) {
                    logger2.warn(error2.message);
                    return error2;
                }
                args = data;
                return await new Promise((resolve, reject)=>{
                    setImmediate(async ()=>{
                        try {
                            const result = await execFunction(args, execOptions);
                            resolve(result);
                        } catch (err) {
                            reject(err);
                        }
                    });
                });
            } catch (err) {
                const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "TOOL_EXECUTION_FAILED",
                    domain: "TOOL" /* TOOL */ ,
                    category: "USER" /* USER */ ,
                    details: {
                        errorMessage: String(error),
                        argsJson: JSON.stringify(args),
                        model: model?.modelId ?? ""
                    }
                }, err);
                logger2.trackException(mastraError);
                logger2.error(error, {
                    ...rest,
                    model: logModelObject,
                    error: mastraError,
                    args
                });
                return mastraError;
            }
        };
    }
    buildV5() {
        const builtTool = this.build();
        if (!builtTool.parameters) {
            throw new Error("Tool parameters are required");
        }
        const base = {
            ...builtTool,
            inputSchema: builtTool.parameters,
            onInputStart: "onInputStart" in this.originalTool ? this.originalTool.onInputStart : void 0,
            onInputDelta: "onInputDelta" in this.originalTool ? this.originalTool.onInputDelta : void 0,
            onInputAvailable: "onInputAvailable" in this.originalTool ? this.originalTool.onInputAvailable : void 0,
            onOutput: "onOutput" in this.originalTool ? this.originalTool.onOutput : void 0
        };
        if (builtTool.type === "provider-defined") {
            const { execute, parameters, ...rest } = base;
            const name = builtTool.id.split(".")[1] || builtTool.id;
            return {
                ...rest,
                type: builtTool.type,
                id: builtTool.id,
                name,
                args: builtTool.args
            };
        }
        return base;
    }
    build() {
        const providerTool = this.buildProviderTool(this.originalTool);
        if (providerTool) {
            return providerTool;
        }
        const model = this.options.model;
        const schemaCompatLayers = [];
        if (model) {
            const supportsStructuredOutputs = "supportsStructuredOutputs" in model ? model.supportsStructuredOutputs ?? false : false;
            const modelInfo = {
                modelId: model.modelId,
                supportsStructuredOutputs,
                provider: model.provider
            };
            schemaCompatLayers.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIReasoningSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAISchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnthropicSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DeepSeekSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MetaSchemaCompatLayer"](modelInfo));
        }
        let processedZodSchema;
        let processedSchema;
        const originalSchema = this.getParameters();
        const applicableLayer = schemaCompatLayers.find((layer)=>layer.shouldApply());
        if (applicableLayer && originalSchema) {
            processedZodSchema = applicableLayer.processZodType(originalSchema);
            processedSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
                schema: originalSchema,
                compatLayers: schemaCompatLayers,
                mode: "aiSdkSchema"
            });
        } else if (originalSchema) {
            processedZodSchema = originalSchema;
            processedSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
                schema: originalSchema,
                compatLayers: schemaCompatLayers,
                mode: "aiSdkSchema"
            });
        } else {
            processedZodSchema = void 0;
            processedSchema = void 0;
        }
        let processedOutputSchema;
        if (this.getOutputSchema()) {
            processedOutputSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
                schema: this.getOutputSchema(),
                compatLayers: [],
                mode: "aiSdkSchema"
            });
        }
        let requireApproval = this.options.requireApproval;
        let needsApprovalFn;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(this.originalTool) && "needsApproval" in this.originalTool) {
            const needsApproval = this.originalTool.needsApproval;
            if (typeof needsApproval === "boolean") {
                requireApproval = needsApproval;
            } else if (typeof needsApproval === "function") {
                needsApprovalFn = needsApproval;
                requireApproval = true;
            }
        }
        const definition = {
            type: "function",
            description: this.originalTool.description,
            requireApproval,
            needsApprovalFn,
            hasSuspendSchema: !!this.getSuspendSchema(),
            execute: this.originalTool.execute ? this.createExecute(this.originalTool, {
                ...this.options,
                description: this.originalTool.description
            }, this.logType, processedZodSchema) : void 0
        };
        return {
            ...definition,
            id: "id" in this.originalTool ? this.originalTool.id : void 0,
            parameters: processedSchema ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}),
            outputSchema: processedOutputSchema,
            providerOptions: "providerOptions" in this.originalTool ? this.originalTool.providerOptions : void 0,
            mcp: "mcp" in this.originalTool ? this.originalTool.mcp : void 0
        };
    }
};
// src/utils.ts
var delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
function deepMerge(target, source) {
    const output = {
        ...target
    };
    if (!source) return output;
    Object.keys(source).forEach((key)=>{
        const targetValue = output[key];
        const sourceValue = source[key];
        if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
            output[key] = sourceValue;
        } else if (sourceValue instanceof Object && targetValue instanceof Object && !Array.isArray(sourceValue) && !Array.isArray(targetValue)) {
            output[key] = deepMerge(targetValue, sourceValue);
        } else if (sourceValue !== void 0) {
            output[key] = sourceValue;
        }
    });
    return output;
}
function generateEmptyFromSchema(schema) {
    try {
        const parsedSchema = JSON.parse(schema);
        if (!parsedSchema || parsedSchema.type !== "object" || !parsedSchema.properties) return {};
        const obj = {};
        const TYPE_DEFAULTS = {
            string: "",
            array: [],
            object: {},
            number: 0,
            integer: 0,
            boolean: false
        };
        for (const [key, prop] of Object.entries(parsedSchema.properties)){
            obj[key] = TYPE_DEFAULTS[prop.type] ?? null;
        }
        return obj;
    } catch  {
        return {};
    }
}
async function* maskStreamTags(stream, tag, options = {}) {
    const { onStart, onEnd, onMask } = options;
    const openTag = `<${tag}>`;
    const closeTag = `</${tag}>`;
    let buffer = "";
    let fullContent = "";
    let isMasking = false;
    let isBuffering = false;
    const trimOutsideDelimiter = (text, delimiter, trim)=>{
        if (!text.includes(delimiter)) {
            return text;
        }
        const parts = text.split(delimiter);
        if (trim === `before-start`) {
            return `${delimiter}${parts[1]}`;
        }
        return `${parts[0]}${delimiter}`;
    };
    const startsWith = (text, pattern)=>{
        if (pattern.includes(openTag.substring(0, 3))) {
            pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);
        }
        return text.trim().startsWith(pattern.trim());
    };
    for await (const chunk of stream){
        fullContent += chunk;
        if (isBuffering) buffer += chunk;
        const chunkHasTag = startsWith(chunk, openTag);
        const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);
        let toYieldBeforeMaskedStartTag = ``;
        if (!isMasking && (chunkHasTag || bufferHasTag)) {
            isMasking = true;
            isBuffering = false;
            const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);
            if (taggedTextToMask !== buffer.trim()) {
                toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);
            }
            buffer = "";
            onStart?.();
        }
        if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== "") {
            isBuffering = true;
            buffer += chunk;
            continue;
        }
        if (isBuffering && buffer && !startsWith(openTag, buffer)) {
            yield buffer;
            buffer = "";
            isBuffering = false;
            continue;
        }
        if (isMasking && fullContent.includes(closeTag)) {
            onMask?.(chunk);
            onEnd?.();
            isMasking = false;
            const lastFullContent = fullContent;
            fullContent = ``;
            const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, "after-end");
            if (textUntilEndTag !== lastFullContent) {
                yield lastFullContent.replace(textUntilEndTag, ``);
            }
            continue;
        }
        if (isMasking) {
            onMask?.(chunk);
            if (toYieldBeforeMaskedStartTag) {
                yield toYieldBeforeMaskedStartTag;
            }
            continue;
        }
        yield chunk;
    }
}
function resolveSerializedZodOutput(schema) {
    return Function("z", `"use strict";return (${schema});`)(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"]);
}
function isZodType(value) {
    return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function createDeterministicId(input) {
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"])("sha256").update(input).digest("hex").slice(0, 8);
}
function setVercelToolProperties(tool) {
    const inputSchema = "inputSchema" in tool ? tool.inputSchema : convertVercelToolParameters(tool);
    const toolId = !("id" in tool) ? tool.description ? `tool-${createDeterministicId(tool.description)}` : `tool-${Math.random().toString(36).substring(2, 9)}` : tool.id;
    return {
        ...tool,
        id: toolId,
        inputSchema
    };
}
function ensureToolProperties(tools) {
    const toolsWithProperties = Object.keys(tools).reduce((acc, key)=>{
        const tool = tools?.[key];
        if (tool) {
            if (typeof tool === "function" && !(tool instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Tool"]) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "TOOL_INVALID_FORMAT",
                    domain: "TOOL" /* TOOL */ ,
                    category: "USER" /* USER */ ,
                    text: `Tool "${key}" is not a valid tool format. Tools must be created using createTool() or be a valid Vercel AI SDK tool. Received a function.`
                });
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isVercelTool"])(tool)) {
                acc[key] = setVercelToolProperties(tool);
            } else {
                acc[key] = tool;
            }
        }
        return acc;
    }, {});
    return toolsWithProperties;
}
function convertVercelToolParameters(tool) {
    let schema = tool.parameters ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({});
    if (typeof schema === "function") {
        schema = schema();
    }
    return isZodType(schema) ? schema : resolveSerializedZodOutput((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$json$2d$to$2d$zod$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jsonSchemaToZod"])(schema));
}
function makeCoreTool(originalTool, options, logType, autoResumeSuspendedTools) {
    return new CoreToolBuilder({
        originalTool,
        options,
        logType,
        autoResumeSuspendedTools
    }).build();
}
function makeCoreToolV5(originalTool, options, logType, autoResumeSuspendedTools) {
    return new CoreToolBuilder({
        originalTool,
        options,
        logType,
        autoResumeSuspendedTools
    }).buildV5();
}
function createMastraProxy({ mastra, logger }) {
    return new Proxy(mastra, {
        get (target, prop) {
            const hasProp = Reflect.has(target, prop);
            if (hasProp) {
                const value = Reflect.get(target, prop);
                const isFunction = typeof value === "function";
                if (isFunction) {
                    return value.bind(target);
                }
                return value;
            }
            if (prop === "logger") {
                logger.warn(`Please use 'getLogger' instead, logger is deprecated`);
                return Reflect.apply(target.getLogger, target, []);
            }
            if (prop === "storage") {
                logger.warn(`Please use 'getStorage' instead, storage is deprecated`);
                return Reflect.get(target, "storage");
            }
            if (prop === "agents") {
                logger.warn(`Please use 'listAgents' instead, agents is deprecated`);
                return Reflect.apply(target.listAgents, target, []);
            }
            if (prop === "tts") {
                logger.warn(`Please use 'getTTS' instead, tts is deprecated`);
                return Reflect.apply(target.getTTS, target, []);
            }
            if (prop === "vectors") {
                logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);
                return Reflect.apply(target.getVectors, target, []);
            }
            if (prop === "memory") {
                logger.warn(`Please use 'getMemory' instead, memory is deprecated`);
                return Reflect.get(target, "memory");
            }
            return Reflect.get(target, prop);
        }
    });
}
function checkEvalStorageFields(traceObject, logger) {
    const missingFields = [];
    if (!traceObject.input) missingFields.push("input");
    if (!traceObject.output) missingFields.push("output");
    if (!traceObject.agentName) missingFields.push("agent_name");
    if (!traceObject.metricName) missingFields.push("metric_name");
    if (!traceObject.instructions) missingFields.push("instructions");
    if (!traceObject.globalRunId) missingFields.push("global_run_id");
    if (!traceObject.runId) missingFields.push("run_id");
    if (missingFields.length > 0) {
        if (logger) {
            logger.warn("Skipping evaluation storage due to missing required fields", {
                missingFields,
                runId: traceObject.runId,
                agentName: traceObject.agentName
            });
        } else {
            console.warn("Skipping evaluation storage due to missing required fields", {
                missingFields,
                runId: traceObject.runId,
                agentName: traceObject.agentName
            });
        }
        return false;
    }
    return true;
}
function detectSingleMessageCharacteristics(message) {
    if (typeof message === "object" && message !== null && (message.role === "function" || // UI-only role
    message.role === "data" || // UI-only role
    "toolInvocations" in message || // UI-specific field
    "parts" in message || // UI-specific field
    "experimental_attachments" in message)) {
        return "has-ui-specific-parts";
    } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || // Core messages can have array content
    "experimental_providerMetadata" in message || "providerOptions" in message)) {
        return "has-core-specific-parts";
    } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && [
        "system",
        "user",
        "assistant",
        "tool"
    ].includes(message.role)) {
        return "message";
    } else {
        return "other";
    }
}
function isUiMessage(message) {
    return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;
}
function isCoreMessage(message) {
    return [
        `has-core-specific-parts`,
        `message`
    ].includes(detectSingleMessageCharacteristics(message));
}
var SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function parseSqlIdentifier(name, kind = "identifier") {
    if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {
        throw new Error(`Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`);
    }
    return name;
}
function parseFieldKey(key) {
    if (!key) throw new Error("Field key cannot be empty");
    const segments = key.split(".");
    for (const segment of segments){
        if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {
            throw new Error(`Invalid field key segment: ${segment} in ${key}`);
        }
    }
    return key;
}
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    let retryCount = 0;
    let lastError = null;
    while(retryCount < maxRetries){
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);
            }
            return response;
        } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            retryCount++;
            if (retryCount >= maxRetries) {
                break;
            }
            const delay2 = Math.min(1e3 * Math.pow(2, retryCount) * 1e3, 1e4);
            await new Promise((resolve)=>setTimeout(resolve, delay2));
        }
    }
    throw lastError || new Error("Request failed after multiple retry attempts");
}
function omitKeys(obj, keysToOmit) {
    return Object.fromEntries(Object.entries(obj).filter(([key])=>!keysToOmit.includes(key)));
}
function selectFields(obj, fields) {
    if (!obj || typeof obj !== "object") {
        return obj;
    }
    const result = {};
    for (const field of fields){
        const value = getNestedValue(obj, field);
        if (value !== void 0) {
            setNestedValue(result, field, value);
        }
    }
    return result;
}
function getNestedValue(obj, path) {
    return path.split(".").reduce((current, key)=>{
        return current && typeof current === "object" ? current[key] : void 0;
    }, obj);
}
function setNestedValue(obj, path, value) {
    const keys = path.split(".");
    const lastKey = keys.pop();
    if (!lastKey) {
        return;
    }
    const target = keys.reduce((current, key)=>{
        if (!current[key] || typeof current[key] !== "object") {
            current[key] = {};
        }
        return current[key];
    }, obj);
    target[lastKey] = value;
}
var removeUndefinedValues = (obj)=>{
    return Object.fromEntries(Object.entries(obj).filter(([_, value])=>value !== void 0));
};
;
 //# sourceMappingURL=chunk-MCVLH3QV.js.map
 //# sourceMappingURL=chunk-MCVLH3QV.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-FY75XHWB.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AISDKV5LanguageModel",
    ()=>AISDKV5LanguageModel,
    "MastraLLMV1",
    ()=>MastraLLMV1,
    "createStreamFromGenerateResult",
    ()=>createStreamFromGenerateResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-6OBQKOBQ.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-MCVLH3QV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-XKBYPAOY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-AIJLACR2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$zod$2d$to$2d$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/zod-to-json.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/chunk-3RG3ZAXL.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
;
;
;
;
// src/stream/aisdk/v4/usage.ts
function convertV4Usage(usage) {
    if (!usage) {
        return {};
    }
    return {
        inputTokens: usage.promptTokens,
        outputTokens: usage.completionTokens
    };
}
// src/llm/model/model.ts
var MastraLLMV1 = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    #model;
    #mastra;
    #options;
    constructor({ model, mastra, options }){
        super({
            name: "aisdk"
        });
        this.#model = model;
        this.#options = options;
        if (mastra) {
            this.#mastra = mastra;
            if (mastra.getLogger()) {
                this.__setLogger(this.#mastra.getLogger());
            }
        }
    }
    __registerPrimitives(p) {
        if (p.logger) {
            this.__setLogger(p.logger);
        }
    }
    __registerMastra(p) {
        this.#mastra = p;
    }
    getProvider() {
        return this.#model.provider;
    }
    getModelId() {
        return this.#model.modelId;
    }
    getModel() {
        return this.#model;
    }
    _applySchemaCompat(schema) {
        const model = this.#model;
        const schemaCompatLayers = [];
        if (model) {
            const modelInfo = {
                modelId: model.modelId,
                supportsStructuredOutputs: model.supportsStructuredOutputs ?? false,
                provider: model.provider
            };
            schemaCompatLayers.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAIReasoningSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenAISchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnthropicSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DeepSeekSchemaCompatLayer"](modelInfo), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MetaSchemaCompatLayer"](modelInfo));
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applyCompatLayer"])({
            schema,
            compatLayers: schemaCompatLayers,
            mode: "aiSdkSchema"
        });
    }
    async __text({ runId, messages, maxSteps = 5, tools = {}, temperature, toolChoice = "auto", onStepFinish, experimental_output, threadId, resourceId, requestContext, tracingContext, ...rest }) {
        const model = this.#model;
        this.logger.debug(`[LLM] - Generating text`, {
            runId,
            messages,
            maxSteps,
            threadId,
            resourceId,
            tools: Object.keys(tools)
        });
        let schema = void 0;
        if (experimental_output) {
            this.logger.debug("[LLM] - Using experimental output", {
                runId
            });
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodType"])(experimental_output)) {
                schema = experimental_output;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodArray"])(schema)) {
                    schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodDef"])(schema).type;
                }
                const jsonSchemaToUse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(schema, "jsonSchema7");
                schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonSchema"])(jsonSchemaToUse);
            } else {
                schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonSchema"])(experimental_output);
            }
        }
        const llmSpan = tracingContext.currentSpan?.createChildSpan({
            name: `llm: '${model.modelId}'`,
            type: "model_generation" /* MODEL_GENERATION */ ,
            input: {
                messages,
                schema
            },
            attributes: {
                model: model.modelId,
                provider: model.provider,
                parameters: {
                    temperature,
                    maxOutputTokens: rest.maxTokens,
                    topP: rest.topP,
                    frequencyPenalty: rest.frequencyPenalty,
                    presencePenalty: rest.presencePenalty
                },
                streaming: false
            },
            metadata: {
                runId,
                threadId,
                resourceId
            },
            tracingPolicy: this.#options?.tracingPolicy
        });
        const argsForExecute = {
            ...rest,
            messages,
            model,
            temperature,
            tools: {
                ...tools
            },
            toolChoice,
            maxSteps,
            onStepFinish: async (props)=>{
                try {
                    await onStepFinish?.({
                        ...props,
                        runId
                    });
                } catch (e) {
                    const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                        id: "LLM_TEXT_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED",
                        domain: "LLM" /* LLM */ ,
                        category: "USER" /* USER */ ,
                        details: {
                            modelId: model.modelId,
                            modelProvider: model.provider,
                            runId: runId ?? "unknown",
                            threadId: threadId ?? "unknown",
                            resourceId: resourceId ?? "unknown",
                            finishReason: props?.finishReason,
                            toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                            toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                            usage: props?.usage ? JSON.stringify(props.usage) : ""
                        }
                    }, e);
                    throw mastraError;
                }
                this.logger.debug("[LLM] - Text Step Change:", {
                    text: props?.text,
                    toolCalls: props?.toolCalls,
                    toolResults: props?.toolResults,
                    finishReason: props?.finishReason,
                    usage: props?.usage,
                    runId
                });
                const remainingTokens = parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"] ?? "", 10);
                if (!isNaN(remainingTokens) && remainingTokens > 0 && remainingTokens < 2e3) {
                    this.logger.warn("Rate limit approaching, waiting 10 seconds", {
                        runId
                    });
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["delay"])(10 * 1e3);
                }
            },
            experimental_output: schema ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["output_exports"].object({
                schema
            }) : void 0
        };
        try {
            const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeWithContext"])({
                span: llmSpan,
                fn: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateText"])(argsForExecute)
            });
            if (schema && result.finishReason === "stop") {
                result.object = result.experimental_output;
            }
            llmSpan?.end({
                output: {
                    text: result.text,
                    object: result.object,
                    reasoning: result.reasoningDetails,
                    reasoningText: result.reasoning,
                    files: result.files,
                    sources: result.sources,
                    warnings: result.warnings
                },
                attributes: {
                    finishReason: result.finishReason,
                    usage: convertV4Usage(result.usage)
                }
            });
            return result;
        } catch (e) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "LLM_GENERATE_TEXT_AI_SDK_EXECUTION_FAILED",
                domain: "LLM" /* LLM */ ,
                category: "THIRD_PARTY" /* THIRD_PARTY */ ,
                details: {
                    modelId: model.modelId,
                    modelProvider: model.provider,
                    runId: runId ?? "unknown",
                    threadId: threadId ?? "unknown",
                    resourceId: resourceId ?? "unknown"
                }
            }, e);
            llmSpan?.error({
                error: mastraError
            });
            throw mastraError;
        }
    }
    async __textObject({ messages, structuredOutput, runId, threadId, resourceId, requestContext, tracingContext, ...rest }) {
        const model = this.#model;
        this.logger.debug(`[LLM] - Generating a text object`, {
            runId
        });
        const llmSpan = tracingContext.currentSpan?.createChildSpan({
            name: `llm: '${model.modelId}'`,
            type: "model_generation" /* MODEL_GENERATION */ ,
            input: {
                messages
            },
            attributes: {
                model: model.modelId,
                provider: model.provider,
                parameters: {
                    temperature: rest.temperature,
                    maxOutputTokens: rest.maxTokens,
                    topP: rest.topP,
                    frequencyPenalty: rest.frequencyPenalty,
                    presencePenalty: rest.presencePenalty
                },
                streaming: false
            },
            metadata: {
                runId,
                threadId,
                resourceId
            },
            tracingPolicy: this.#options?.tracingPolicy
        });
        try {
            let output = "object";
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodArray"])(structuredOutput)) {
                output = "array";
                structuredOutput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodDef"])(structuredOutput).type;
            }
            const processedSchema = this._applySchemaCompat(structuredOutput);
            llmSpan?.update({
                input: {
                    messages,
                    schema: processedSchema
                }
            });
            const argsForExecute = {
                ...rest,
                messages,
                model,
                // @ts-expect-error - output in our implementation can only be object or array
                output,
                schema: processedSchema
            };
            try {
                const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateObject"])(argsForExecute);
                llmSpan?.end({
                    output: {
                        object: result.object,
                        warnings: result.warnings
                    },
                    attributes: {
                        finishReason: result.finishReason,
                        usage: convertV4Usage(result.usage)
                    }
                });
                return result;
            } catch (e) {
                const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "LLM_GENERATE_OBJECT_AI_SDK_EXECUTION_FAILED",
                    domain: "LLM" /* LLM */ ,
                    category: "THIRD_PARTY" /* THIRD_PARTY */ ,
                    details: {
                        modelId: model.modelId,
                        modelProvider: model.provider,
                        runId: runId ?? "unknown",
                        threadId: threadId ?? "unknown",
                        resourceId: resourceId ?? "unknown"
                    }
                }, e);
                llmSpan?.error({
                    error: mastraError
                });
                throw mastraError;
            }
        } catch (e) {
            if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]) {
                throw e;
            }
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "LLM_GENERATE_OBJECT_AI_SDK_SCHEMA_CONVERSION_FAILED",
                domain: "LLM" /* LLM */ ,
                category: "USER" /* USER */ ,
                details: {
                    modelId: model.modelId,
                    modelProvider: model.provider,
                    runId: runId ?? "unknown",
                    threadId: threadId ?? "unknown",
                    resourceId: resourceId ?? "unknown"
                }
            }, e);
            llmSpan?.error({
                error: mastraError
            });
            throw mastraError;
        }
    }
    __stream({ messages, onStepFinish, onFinish, maxSteps = 5, tools = {}, runId, temperature, toolChoice = "auto", experimental_output, threadId, resourceId, requestContext, tracingContext, ...rest }) {
        const model = this.#model;
        this.logger.debug(`[LLM] - Streaming text`, {
            runId,
            threadId,
            resourceId,
            messages,
            maxSteps,
            tools: Object.keys(tools || {})
        });
        let schema;
        if (experimental_output) {
            this.logger.debug("[LLM] - Using experimental output", {
                runId
            });
            if (typeof experimental_output.parse === "function") {
                schema = experimental_output;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodArray"])(schema)) {
                    schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodDef"])(schema).type;
                }
            } else {
                schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonSchema"])(experimental_output);
            }
        }
        const llmSpan = tracingContext.currentSpan?.createChildSpan({
            name: `llm: '${model.modelId}'`,
            type: "model_generation" /* MODEL_GENERATION */ ,
            input: {
                messages
            },
            attributes: {
                model: model.modelId,
                provider: model.provider,
                parameters: {
                    temperature,
                    maxOutputTokens: rest.maxTokens,
                    topP: rest.topP,
                    frequencyPenalty: rest.frequencyPenalty,
                    presencePenalty: rest.presencePenalty
                },
                streaming: true
            },
            metadata: {
                runId,
                threadId,
                resourceId
            },
            tracingPolicy: this.#options?.tracingPolicy
        });
        const argsForExecute = {
            model,
            temperature,
            tools: {
                ...tools
            },
            maxSteps,
            toolChoice,
            onStepFinish: async (props)=>{
                try {
                    await onStepFinish?.({
                        ...props,
                        runId
                    });
                } catch (e) {
                    const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                        id: "LLM_STREAM_ON_STEP_FINISH_CALLBACK_EXECUTION_FAILED",
                        domain: "LLM" /* LLM */ ,
                        category: "USER" /* USER */ ,
                        details: {
                            modelId: model.modelId,
                            modelProvider: model.provider,
                            runId: runId ?? "unknown",
                            threadId: threadId ?? "unknown",
                            resourceId: resourceId ?? "unknown",
                            finishReason: props?.finishReason,
                            toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                            toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                            usage: props?.usage ? JSON.stringify(props.usage) : ""
                        }
                    }, e);
                    this.logger.trackException(mastraError);
                    llmSpan?.error({
                        error: mastraError
                    });
                    throw mastraError;
                }
                this.logger.debug("[LLM] - Stream Step Change:", {
                    text: props?.text,
                    toolCalls: props?.toolCalls,
                    toolResults: props?.toolResults,
                    finishReason: props?.finishReason,
                    usage: props?.usage,
                    runId
                });
                const remainingTokens = parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"] ?? "", 10);
                if (!isNaN(remainingTokens) && remainingTokens > 0 && remainingTokens < 2e3) {
                    this.logger.warn("Rate limit approaching, waiting 10 seconds", {
                        runId
                    });
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["delay"])(10 * 1e3);
                }
            },
            onFinish: async (props)=>{
                llmSpan?.end({
                    output: {
                        text: props?.text,
                        reasoning: props?.reasoningDetails,
                        reasoningText: props?.reasoning,
                        files: props?.files,
                        sources: props?.sources,
                        warnings: props?.warnings
                    },
                    attributes: {
                        finishReason: props?.finishReason,
                        usage: convertV4Usage(props?.usage)
                    }
                });
                try {
                    await onFinish?.({
                        ...props,
                        runId
                    });
                } catch (e) {
                    const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                        id: "LLM_STREAM_ON_FINISH_CALLBACK_EXECUTION_FAILED",
                        domain: "LLM" /* LLM */ ,
                        category: "USER" /* USER */ ,
                        details: {
                            modelId: model.modelId,
                            modelProvider: model.provider,
                            runId: runId ?? "unknown",
                            threadId: threadId ?? "unknown",
                            resourceId: resourceId ?? "unknown",
                            finishReason: props?.finishReason,
                            toolCalls: props?.toolCalls ? JSON.stringify(props.toolCalls) : "",
                            toolResults: props?.toolResults ? JSON.stringify(props.toolResults) : "",
                            usage: props?.usage ? JSON.stringify(props.usage) : ""
                        }
                    }, e);
                    llmSpan?.error({
                        error: mastraError
                    });
                    this.logger.trackException(mastraError);
                    throw mastraError;
                }
                this.logger.debug("[LLM] - Stream Finished:", {
                    text: props?.text,
                    toolCalls: props?.toolCalls,
                    toolResults: props?.toolResults,
                    finishReason: props?.finishReason,
                    usage: props?.usage,
                    runId,
                    threadId,
                    resourceId
                });
            },
            ...rest,
            messages,
            experimental_output: schema ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["output_exports"].object({
                schema
            }) : void 0
        };
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeWithContextSync"])({
                span: llmSpan,
                fn: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["streamText"])(argsForExecute)
            });
        } catch (e) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "LLM_STREAM_TEXT_AI_SDK_EXECUTION_FAILED",
                domain: "LLM" /* LLM */ ,
                category: "THIRD_PARTY" /* THIRD_PARTY */ ,
                details: {
                    modelId: model.modelId,
                    modelProvider: model.provider,
                    runId: runId ?? "unknown",
                    threadId: threadId ?? "unknown",
                    resourceId: resourceId ?? "unknown"
                }
            }, e);
            llmSpan?.error({
                error: mastraError
            });
            throw mastraError;
        }
    }
    __streamObject({ messages, runId, requestContext, threadId, resourceId, onFinish, structuredOutput, tracingContext, ...rest }) {
        const model = this.#model;
        this.logger.debug(`[LLM] - Streaming structured output`, {
            runId,
            messages
        });
        const llmSpan = tracingContext.currentSpan?.createChildSpan({
            name: `llm: '${model.modelId}'`,
            type: "model_generation" /* MODEL_GENERATION */ ,
            input: {
                messages
            },
            attributes: {
                model: model.modelId,
                provider: model.provider,
                parameters: {
                    temperature: rest.temperature,
                    maxOutputTokens: rest.maxTokens,
                    topP: rest.topP,
                    frequencyPenalty: rest.frequencyPenalty,
                    presencePenalty: rest.presencePenalty
                },
                streaming: true
            },
            metadata: {
                runId,
                threadId,
                resourceId
            },
            tracingPolicy: this.#options?.tracingPolicy
        });
        try {
            let output = "object";
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isZodArray"])(structuredOutput)) {
                output = "array";
                structuredOutput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$AIJLACR2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getZodDef"])(structuredOutput).type;
            }
            const processedSchema = this._applySchemaCompat(structuredOutput);
            llmSpan?.update({
                input: {
                    messages,
                    schema: processedSchema
                }
            });
            const argsForExecute = {
                ...rest,
                model,
                onFinish: async (props)=>{
                    llmSpan?.end({
                        output: {
                            text: props?.text,
                            object: props?.object,
                            reasoning: props?.reasoningDetails,
                            reasoningText: props?.reasoning,
                            files: props?.files,
                            sources: props?.sources,
                            warnings: props?.warnings
                        },
                        attributes: {
                            finishReason: props?.finishReason,
                            usage: props?.usage
                        }
                    });
                    try {
                        await onFinish?.({
                            ...props,
                            runId
                        });
                    } catch (e) {
                        const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                            id: "LLM_STREAM_OBJECT_ON_FINISH_CALLBACK_EXECUTION_FAILED",
                            domain: "LLM" /* LLM */ ,
                            category: "USER" /* USER */ ,
                            details: {
                                modelId: model.modelId,
                                modelProvider: model.provider,
                                runId: runId ?? "unknown",
                                threadId: threadId ?? "unknown",
                                resourceId: resourceId ?? "unknown",
                                toolCalls: "",
                                toolResults: "",
                                finishReason: "",
                                usage: props?.usage ? JSON.stringify(props.usage) : ""
                            }
                        }, e);
                        this.logger.trackException(mastraError);
                        llmSpan?.error({
                            error: mastraError
                        });
                        throw mastraError;
                    }
                    this.logger.debug("[LLM] - Object Stream Finished:", {
                        usage: props?.usage,
                        runId,
                        threadId,
                        resourceId
                    });
                },
                messages,
                // @ts-expect-error - output in our implementation can only be object or array
                output,
                schema: processedSchema
            };
            try {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["streamObject"])(argsForExecute);
            } catch (e) {
                const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "LLM_STREAM_OBJECT_AI_SDK_EXECUTION_FAILED",
                    domain: "LLM" /* LLM */ ,
                    category: "THIRD_PARTY" /* THIRD_PARTY */ ,
                    details: {
                        modelId: model.modelId,
                        modelProvider: model.provider,
                        runId: runId ?? "unknown",
                        threadId: threadId ?? "unknown",
                        resourceId: resourceId ?? "unknown"
                    }
                }, e);
                llmSpan?.error({
                    error: mastraError
                });
                throw mastraError;
            }
        } catch (e) {
            if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]) {
                llmSpan?.error({
                    error: e
                });
                throw e;
            }
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "LLM_STREAM_OBJECT_AI_SDK_SCHEMA_CONVERSION_FAILED",
                domain: "LLM" /* LLM */ ,
                category: "USER" /* USER */ ,
                details: {
                    modelId: model.modelId,
                    modelProvider: model.provider,
                    runId: runId ?? "unknown",
                    threadId: threadId ?? "unknown",
                    resourceId: resourceId ?? "unknown"
                }
            }, e);
            llmSpan?.error({
                error: mastraError
            });
            throw mastraError;
        }
    }
    convertToMessages(messages) {
        if (Array.isArray(messages)) {
            return messages.map((m)=>{
                if (typeof m === "string") {
                    return {
                        role: "user",
                        content: m
                    };
                }
                return m;
            });
        }
        return [
            {
                role: "user",
                content: messages
            }
        ];
    }
    async generate(messages, { output, ...rest }) {
        const msgs = this.convertToMessages(messages);
        if (!output) {
            const { maxSteps, onStepFinish, ...textOptions } = rest;
            return await this.__text({
                messages: msgs,
                maxSteps,
                onStepFinish,
                ...textOptions
            });
        }
        return await this.__textObject({
            messages: msgs,
            structuredOutput: output,
            ...rest
        });
    }
    stream(messages, { maxSteps = 5, output, onFinish, ...rest }) {
        const msgs = this.convertToMessages(messages);
        if (!output) {
            return this.__stream({
                messages: msgs,
                maxSteps,
                onFinish,
                ...rest
            });
        }
        return this.__streamObject({
            messages: msgs,
            structuredOutput: output,
            onFinish,
            ...rest
        });
    }
};
function createStreamFromGenerateResult(result) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue({
                type: "stream-start",
                warnings: result.warnings
            });
            controller.enqueue({
                type: "response-metadata",
                id: result.response?.id,
                modelId: result.response?.modelId,
                timestamp: result.response?.timestamp
            });
            for (const message of result.content){
                if (message.type === "tool-call") {
                    const toolCall = message;
                    controller.enqueue({
                        type: "tool-input-start",
                        id: toolCall.toolCallId,
                        toolName: toolCall.toolName
                    });
                    controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall.toolCallId,
                        delta: toolCall.input
                    });
                    controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.toolCallId
                    });
                    controller.enqueue(toolCall);
                } else if (message.type === "tool-result") {
                    controller.enqueue(message);
                } else if (message.type === "text") {
                    const text = message;
                    const id = `msg_${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])()}`;
                    controller.enqueue({
                        type: "text-start",
                        id,
                        providerMetadata: text.providerMetadata
                    });
                    controller.enqueue({
                        type: "text-delta",
                        id,
                        delta: text.text
                    });
                    controller.enqueue({
                        type: "text-end",
                        id
                    });
                } else if (message.type === "reasoning") {
                    const id = `reasoning_${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])()}`;
                    const reasoning = message;
                    controller.enqueue({
                        type: "reasoning-start",
                        id,
                        providerMetadata: reasoning.providerMetadata
                    });
                    controller.enqueue({
                        type: "reasoning-delta",
                        id,
                        delta: reasoning.text,
                        providerMetadata: reasoning.providerMetadata
                    });
                    controller.enqueue({
                        type: "reasoning-end",
                        id,
                        providerMetadata: reasoning.providerMetadata
                    });
                } else if (message.type === "file") {
                    const file = message;
                    controller.enqueue({
                        type: "file",
                        mediaType: file.mediaType,
                        data: file.data
                    });
                } else if (message.type === "source") {
                    const source = message;
                    if (source.sourceType === "url") {
                        controller.enqueue({
                            type: "source",
                            id: source.id,
                            sourceType: "url",
                            url: source.url,
                            title: source.title,
                            providerMetadata: source.providerMetadata
                        });
                    } else {
                        controller.enqueue({
                            type: "source",
                            id: source.id,
                            sourceType: "document",
                            mediaType: source.mediaType,
                            filename: source.filename,
                            title: source.title,
                            providerMetadata: source.providerMetadata
                        });
                    }
                }
            }
            controller.enqueue({
                type: "finish",
                finishReason: result.finishReason,
                usage: result.usage,
                providerMetadata: result.providerMetadata
            });
            controller.close();
        }
    });
}
// src/llm/model/aisdk/v5/model.ts
var AISDKV5LanguageModel = class {
    /**
   * The language model must specify which language model interface version it implements.
   */ specificationVersion = "v2";
    /**
   * Name of the provider for logging purposes.
   */ provider;
    /**
   * Provider-specific model ID for logging purposes.
   */ modelId;
    /**
   * Supported URL patterns by media type for the provider.
   *
   * The keys are media type patterns or full media types (e.g. `*\/*` for everything, `audio/*`, `video/*`, or `application/pdf`).
   * and the values are arrays of regular expressions that match the URL paths.
   * The matching should be against lower-case URLs.
   * Matched URLs are supported natively by the model and are not downloaded.
   * @returns A map of supported URL patterns by media type (as a promise or a plain object).
   */ supportedUrls;
    #model;
    constructor(config){
        this.#model = config;
        this.provider = this.#model.provider;
        this.modelId = this.#model.modelId;
        this.supportedUrls = this.#model.supportedUrls;
    }
    async doGenerate(options) {
        const result = await this.#model.doGenerate(options);
        return {
            request: result.request,
            response: result.response,
            stream: createStreamFromGenerateResult(result)
        };
    }
    async doStream(options) {
        return await this.#model.doStream(options);
    }
};
;
 //# sourceMappingURL=chunk-FY75XHWB.js.map
 //# sourceMappingURL=chunk-FY75XHWB.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-BVUMKER5.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PubSub",
    ()=>PubSub
]);
// src/events/pubsub.ts
var PubSub = class {
};
;
 //# sourceMappingURL=chunk-BVUMKER5.js.map
 //# sourceMappingURL=chunk-BVUMKER5.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-L54GIUCB.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AvailableHooks",
    ()=>AvailableHooks,
    "executeHook",
    ()=>executeHook,
    "registerHook",
    ()=>registerHook
]);
// src/hooks/mitt.ts
function mitt(all) {
    all = all || /* @__PURE__ */ new Map();
    return {
        /**
     * A Map of event names to registered handler functions.
     */ all,
        /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */ on (type, handler) {
            const handlers = all.get(type);
            if (handlers) {
                handlers.push(handler);
            } else {
                all.set(type, [
                    handler
                ]);
            }
        },
        /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */ off (type, handler) {
            const handlers = all.get(type);
            if (handlers) {
                if (handler) {
                    handlers.splice(handlers.indexOf(handler) >>> 0, 1);
                } else {
                    all.set(type, []);
                }
            }
        },
        /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */ emit (type, evt) {
            let handlers = all.get(type);
            if (handlers) {
                handlers.slice().map((handler)=>{
                    handler(evt);
                });
            }
            handlers = all.get("*");
            if (handlers) {
                handlers.slice().map((handler)=>{
                    handler(type, evt);
                });
            }
        }
    };
}
// src/hooks/index.ts
var AvailableHooks = /* @__PURE__ */ ((AvailableHooks2)=>{
    AvailableHooks2["ON_EVALUATION"] = "onEvaluation";
    AvailableHooks2["ON_GENERATION"] = "onGeneration";
    AvailableHooks2["ON_SCORER_RUN"] = "onScorerRun";
    return AvailableHooks2;
})(AvailableHooks || {});
var hooks = mitt();
function registerHook(hook, action) {
    hooks.on(hook, action);
}
function executeHook(hook, data) {
    setImmediate(()=>{
        hooks.emit(hook, data);
    });
}
;
 //# sourceMappingURL=chunk-L54GIUCB.js.map
 //# sourceMappingURL=chunk-L54GIUCB.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-2AU5ZHBL.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commonJS",
    ()=>__commonJS,
    "__require",
    ()=>__require2,
    "__toESM",
    ()=>__toESM,
    "require_token_error",
    ()=>require_token_error
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-7D4SUZUM.js [app-route] (ecmascript)");
;
// ../_vendored/ai_v6/dist/chunk-7D4SUZUM.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x)=>typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : typeof Proxy !== "undefined" ? new Proxy(x, {
        get: (a, b)=>(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : a)[b]
    }) : x)(function(x) {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7D4SUZUM$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"].apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod)=>function __require22() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// ../_vendored/ai_v6/dist/chunk-TLQKI65U.js
var require_token_error = __commonJS({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export = (target, all)=>{
            for(var name in all)__defProp2(target, name, {
                get: all[name],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var token_error_exports = {};
        __export(token_error_exports, {
            VercelOidcTokenError: ()=>VercelOidcTokenError
        });
        module.exports = __toCommonJS(token_error_exports);
        var VercelOidcTokenError = class extends Error {
            constructor(message, cause){
                super(message);
                this.name = "VercelOidcTokenError";
                this.cause = cause;
            }
            toString() {
                if (this.cause) {
                    return `${this.name}: ${this.message}: ${this.cause}`;
                }
                return `${this.name}: ${this.message}`;
            }
        };
    }
});
;
 //# sourceMappingURL=chunk-2AU5ZHBL.js.map
 //# sourceMappingURL=chunk-2AU5ZHBL.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-RYYO3WBT.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSettings",
    ()=>getSettings,
    "isToolLoopAgentLike",
    ()=>isToolLoopAgentLike,
    "toolLoopAgentToMastraAgent",
    ()=>toolLoopAgentToMastraAgent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$QVMJVO5F$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-QVMJVO5F.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5A5RM7PH.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$CPLRD2VP$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-CPLRD2VP.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$4ZZPV6RH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-4ZZPV6RH.js [app-route] (ecmascript)");
;
;
;
;
// src/tool-loop-agent/utils.ts
function isToolLoopAgentLike(obj) {
    if (!obj) return false;
    if (obj instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$QVMJVO5F$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ToolLoopAgent"]) return true;
    return "version" in obj && typeof obj.version === "string" && (obj.version === "agent-v1" || obj.version.startsWith("agent-v"));
}
function getSettings(agent) {
    const settings = agent.settings;
    if (!settings) {
        throw new Error("Could not extract settings from ToolLoopAgent. The agent may be from an incompatible version.");
    }
    return settings;
}
// src/tool-loop-agent/tool-loop-processor.ts
var ToolLoopAgentProcessor = class {
    id = "tool-loop-agent-processor";
    name = "ToolLoop to Mastra Agent Processor";
    agent;
    settings;
    prepareCallResult;
    constructor(agent){
        this.agent = agent;
        this.settings = getSettings(agent);
    }
    getAgentConfig() {
        const tools = "tools" in this.agent ? this.agent.tools : void 0;
        const defaultOptions = {};
        if (this.settings.toolChoice) {
            defaultOptions.toolChoice = this.settings.toolChoice;
        }
        if (this.settings.providerOptions) {
            defaultOptions.providerOptions = this.settings.providerOptions;
        }
        if (this.settings.temperature !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                temperature: this.settings.temperature
            };
        }
        if (this.settings.topP !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                topP: this.settings.topP
            };
        }
        if (this.settings.topK !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                topK: this.settings.topK
            };
        }
        if (this.settings.seed !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                seed: this.settings.seed
            };
        }
        if (this.settings.maxOutputTokens !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                maxOutputTokens: this.settings.maxOutputTokens
            };
        }
        if (this.settings.presencePenalty !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                presencePenalty: this.settings.presencePenalty
            };
        }
        if (this.settings.frequencyPenalty !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                frequencyPenalty: this.settings.frequencyPenalty
            };
        }
        if (this.settings.stopSequences !== void 0) {
            defaultOptions.modelSettings = {
                ...defaultOptions.modelSettings ?? {},
                stopSequences: this.settings.stopSequences
            };
        }
        if (this.settings.stopWhen) {
            defaultOptions.stopWhen = this.settings.stopWhen;
        }
        if (this.settings.onStepFinish) {
            defaultOptions.onStepFinish = this.settings.onStepFinish;
        }
        if (this.settings.onFinish) {
            defaultOptions.onFinish = this.settings.onFinish;
        }
        return {
            id: this.settings.id,
            name: this.settings.id,
            instructions: this.settings.instructions ?? "",
            model: this.settings.model,
            tools,
            maxRetries: this.settings.maxRetries,
            defaultOptions: Object.keys(defaultOptions).length > 0 ? defaultOptions : void 0
        };
    }
    /**
   * Maps prepareCall or prepareStep result to ProcessInputStepResult.
   * Both hooks return similar structures that can override model, tools, activeTools, etc.
   */ mapToProcessInputStepResult(result) {
        if (!result) {
            return {};
        }
        const stepResult = {};
        if (result.model) {
            stepResult.model = result.model;
        }
        if ("tools" in result && result.tools) {
            stepResult.tools = result.tools;
        }
        if ("toolChoice" in result && result.toolChoice !== void 0) {
            stepResult.toolChoice = result.toolChoice;
        }
        if (result.activeTools) {
            stepResult.activeTools = result.activeTools;
        }
        if ("providerOptions" in result && result.providerOptions) {
            stepResult.providerOptions = result.providerOptions;
        }
        const modelSettings = {};
        if ("temperature" in result && result.temperature !== void 0) {
            modelSettings.temperature = result.temperature;
        }
        if ("topP" in result && result.topP !== void 0) {
            modelSettings.topP = result.topP;
        }
        if ("topK" in result && result.topK !== void 0) {
            modelSettings.topK = result.topK;
        }
        if ("maxOutputTokens" in result && result.maxOutputTokens !== void 0) {
            modelSettings.maxOutputTokens = result.maxOutputTokens;
        }
        if ("presencePenalty" in result && result.presencePenalty !== void 0) {
            modelSettings.presencePenalty = result.presencePenalty;
        }
        if ("frequencyPenalty" in result && result.frequencyPenalty !== void 0) {
            modelSettings.frequencyPenalty = result.frequencyPenalty;
        }
        if ("stopSequences" in result && result.stopSequences !== void 0) {
            modelSettings.stopSequences = result.stopSequences;
        }
        if ("seed" in result && result.seed !== void 0) {
            modelSettings.seed = result.seed;
        }
        if (Object.keys(modelSettings).length > 0) {
            stepResult.modelSettings = modelSettings;
        }
        const systemContent = "instructions" in result ? result.instructions : "system" in result ? result.system : void 0;
        if (systemContent) {
            if (typeof systemContent === "string") {
                stepResult.systemMessages = [
                    {
                        role: "system",
                        content: systemContent
                    }
                ];
            } else if (Array.isArray(systemContent)) {
                stepResult.systemMessages = systemContent.map((msg)=>typeof msg === "string" ? {
                        role: "system",
                        content: msg
                    } : msg);
            } else if (typeof systemContent === "object" && "role" in systemContent && "content" in systemContent) {
                stepResult.systemMessages = [
                    systemContent
                ];
            }
        }
        if ("messages" in result && result.messages && Array.isArray(result.messages)) {
            stepResult.messages = result.messages;
        }
        return stepResult;
    }
    async handlePrepareCall(args) {
        if (this.settings.prepareCall) {
            const { model, messages, activeTools, providerOptions, modelSettings, tools } = args;
            const prepareCallInput = {
                // TODO: prepareCall expects messages in AI SDK format, we have them in Mastra format
                messages,
                model,
                tools,
                instructions: this.settings.instructions,
                stopWhen: this.settings.stopWhen,
                activeTools,
                providerOptions,
                // Model settings
                temperature: modelSettings?.temperature,
                topP: modelSettings?.topP,
                topK: modelSettings?.topK,
                maxOutputTokens: modelSettings?.maxOutputTokens,
                presencePenalty: modelSettings?.presencePenalty,
                frequencyPenalty: modelSettings?.frequencyPenalty,
                stopSequences: modelSettings?.stopSequences,
                seed: modelSettings?.seed
            };
            const prepareCallResult = await this.settings.prepareCall(prepareCallInput);
            this.prepareCallResult = prepareCallResult;
        }
    }
    async handlePrepareStep(args, currentResult) {
        if (this.settings.prepareStep) {
            const { messages, steps, stepNumber } = args;
            let model = args.model;
            if (currentResult.model) {
                const resolvedModel = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$4ZZPV6RH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveModelConfig"])(currentResult.model);
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSupportedLanguageModel"])(resolvedModel)) {
                    throw new Error("prepareStep returned an unsupported model version");
                }
                model = resolvedModel;
            }
            const prepareStepInputArgs = {
                model,
                // Messages are in Mastra format (MastraDBMessage[])
                messages,
                // Steps may have minor type differences in usage properties (inputTokenDetails/outputTokenDetails)
                steps,
                stepNumber,
                experimental_context: void 0
            };
            const prepareStepResult = await this.settings.prepareStep(prepareStepInputArgs);
            return prepareStepResult;
        }
    }
    async processInputStep(args) {
        const { stepNumber } = args;
        if (stepNumber === 0 && this.settings.prepareCall) {
            await this.handlePrepareCall(args);
        }
        let result = {};
        if (this.prepareCallResult) {
            const mappedResult = this.mapToProcessInputStepResult(this.prepareCallResult);
            if (Object.keys(mappedResult).length > 0) {
                result = {
                    ...result,
                    ...mappedResult
                };
            }
        }
        if (this.settings.prepareStep) {
            const prepareStepResult = await this.handlePrepareStep(args, result);
            if (prepareStepResult) {
                const mappedResult = this.mapToProcessInputStepResult(prepareStepResult);
                result = {
                    ...result,
                    ...mappedResult
                };
            }
        }
        return result;
    }
};
// src/tool-loop-agent/index.ts
function toolLoopAgentToMastraAgent(agent, options) {
    const processor = new ToolLoopAgentProcessor(agent);
    const agentConfig = processor.getAgentConfig();
    const id = agentConfig.id || options?.fallbackName || `tool-loop-agent-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$CPLRD2VP$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateId"])()}`;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Agent"]({
        ...agentConfig,
        id,
        name: agentConfig.name || id,
        inputProcessors: [
            processor
        ]
    });
}
;
 //# sourceMappingURL=chunk-RYYO3WBT.js.map
 //# sourceMappingURL=chunk-RYYO3WBT.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-NCNYUGXD.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createOnScorerHook",
    ()=>createOnScorerHook,
    "runEvals",
    ()=>runEvals
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5A5RM7PH.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-65QFXXAD.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$map$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p-map/index.js [app-route] (ecmascript)");
;
;
;
;
function createOnScorerHook(mastra) {
    return async (hookData)=>{
        const storage = mastra.getStorage();
        if (!storage) {
            mastra.getLogger()?.warn("Storage not found, skipping score validation and saving");
            return;
        }
        const entityId = hookData.entity.id;
        const entityType = hookData.entityType;
        const scorer = hookData.scorer;
        const scorerId = scorer.id;
        if (!scorerId) {
            mastra.getLogger()?.warn("Scorer ID not found, skipping score validation and saving");
            return;
        }
        try {
            const scorerToUse = await findScorer(mastra, entityId, entityType, scorerId);
            if (!scorerToUse) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "MASTRA_SCORER_NOT_FOUND",
                    domain: "MASTRA" /* MASTRA */ ,
                    category: "USER" /* USER */ ,
                    text: `Scorer with ID ${scorerId} not found`
                });
            }
            let input = hookData.input;
            let output = hookData.output;
            const { structuredOutput, ...rest } = hookData;
            const runResult = await scorerToUse.scorer.run({
                ...rest,
                input,
                output
            });
            let spanId;
            let traceId;
            const currentSpan = hookData.tracingContext?.currentSpan;
            if (currentSpan && currentSpan.isValid) {
                spanId = currentSpan.id;
                traceId = currentSpan.traceId;
            }
            const payload = {
                ...rest,
                ...runResult,
                entityId,
                scorerId,
                spanId,
                traceId,
                metadata: {
                    structuredOutput: !!structuredOutput
                }
            };
            await validateAndSaveScore(storage, payload);
            if (currentSpan && spanId && traceId) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$map$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(currentSpan.observabilityInstance.getExporters(), async (exporter)=>{
                    if (exporter.addScoreToTrace) {
                        try {
                            await exporter.addScoreToTrace({
                                traceId,
                                spanId,
                                score: runResult.score,
                                reason: runResult.reason,
                                scorerName: scorerToUse.scorer.id,
                                metadata: {
                                    ...currentSpan.metadata ?? {}
                                }
                            });
                        } catch (error) {
                            mastra.getLogger()?.error(`Failed to add score to trace via exporter: ${error}`);
                        }
                    }
                }, {
                    concurrency: 3
                });
            }
        } catch (error) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_SCORER_FAILED_TO_RUN_HOOK",
                domain: "SCORER" /* SCORER */ ,
                category: "USER" /* USER */ ,
                details: {
                    scorerId,
                    entityId,
                    entityType
                }
            }, error);
            mastra.getLogger()?.trackException(mastraError);
            mastra.getLogger()?.error(mastraError.toString());
        }
    };
}
async function validateAndSaveScore(storage, payload) {
    const scoresStore = await storage.getStore("scores");
    if (!scoresStore) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_SCORES_STORAGE_NOT_AVAILABLE",
            domain: "STORAGE" /* STORAGE */ ,
            category: "SYSTEM" /* SYSTEM */ ,
            text: "Scores storage domain is not available"
        });
    }
    const payloadToSave = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["saveScorePayloadSchema"].parse(payload);
    await scoresStore.saveScore(payloadToSave);
}
async function findScorer(mastra, entityId, entityType, scorerId) {
    let scorerToUse;
    if (entityType === "AGENT") {
        const scorers = await mastra.getAgentById(entityId).listScorers();
        for (const [_, scorer] of Object.entries(scorers)){
            if (scorer.scorer.id === scorerId) {
                scorerToUse = scorer;
                break;
            }
        }
    } else if (entityType === "WORKFLOW") {
        const scorers = await mastra.getWorkflowById(entityId).listScorers();
        for (const [_, scorer] of Object.entries(scorers)){
            if (scorer.scorer.id === scorerId) {
                scorerToUse = scorer;
                break;
            }
        }
    }
    if (!scorerToUse) {
        const mastraRegisteredScorer = mastra.getScorerById(scorerId);
        scorerToUse = mastraRegisteredScorer ? {
            scorer: mastraRegisteredScorer
        } : void 0;
    }
    return scorerToUse;
}
// src/evals/run/scorerAccumulator.ts
var ScoreAccumulator = class {
    flatScores = {};
    workflowScores = {};
    stepScores = {};
    addScores(scorerResults) {
        const isTargetWorkflowAndHasStepScores = "steps" in scorerResults;
        if (isTargetWorkflowAndHasStepScores) {
            this.addNestedScores(scorerResults);
        } else {
            this.addFlatScores(scorerResults);
        }
    }
    addFlatScores(scorerResults) {
        for (const [scorerName, result] of Object.entries(scorerResults)){
            if (!this.flatScores[scorerName]) {
                this.flatScores[scorerName] = [];
            }
            this.flatScores[scorerName].push(result.score);
        }
    }
    addNestedScores(scorerResults) {
        if ("workflow" in scorerResults && scorerResults.workflow) {
            for (const [scorerName, result] of Object.entries(scorerResults.workflow)){
                if (!this.workflowScores[scorerName]) {
                    this.workflowScores[scorerName] = [];
                }
                this.workflowScores[scorerName].push(result.score);
            }
        }
        if ("steps" in scorerResults && scorerResults.steps) {
            for (const [stepId, stepResults] of Object.entries(scorerResults.steps)){
                if (!this.stepScores[stepId]) {
                    this.stepScores[stepId] = {};
                }
                for (const [scorerName, result] of Object.entries(stepResults)){
                    if (!this.stepScores[stepId][scorerName]) {
                        this.stepScores[stepId][scorerName] = [];
                    }
                    this.stepScores[stepId][scorerName].push(result.score);
                }
            }
        }
    }
    addStepScores(stepScorerResults) {
        for (const [stepId, stepResults] of Object.entries(stepScorerResults)){
            if (!this.stepScores[stepId]) {
                this.stepScores[stepId] = {};
            }
            for (const [scorerName, result] of Object.entries(stepResults)){
                if (!this.stepScores[stepId][scorerName]) {
                    this.stepScores[stepId][scorerName] = [];
                }
                this.stepScores[stepId][scorerName].push(result.score);
            }
        }
    }
    getAverageScores() {
        const result = {};
        for (const [scorerName, scoreArray] of Object.entries(this.flatScores)){
            result[scorerName] = this.getAverageScore(scoreArray);
        }
        if (Object.keys(this.workflowScores).length > 0) {
            result.workflow = {};
            for (const [scorerName, scoreArray] of Object.entries(this.workflowScores)){
                result.workflow[scorerName] = this.getAverageScore(scoreArray);
            }
        }
        if (Object.keys(this.stepScores).length > 0) {
            result.steps = {};
            for (const [stepId, stepScorers] of Object.entries(this.stepScores)){
                result.steps[stepId] = {};
                for (const [scorerName, scoreArray] of Object.entries(stepScorers)){
                    result.steps[stepId][scorerName] = this.getAverageScore(scoreArray);
                }
            }
        }
        return result;
    }
    getAverageScore(scoreArray) {
        if (scoreArray.length > 0) {
            return scoreArray.reduce((a, b)=>a + b, 0) / scoreArray.length;
        } else {
            return 0;
        }
    }
};
// src/evals/run/index.ts
async function runEvals(config) {
    const { data, scorers, target, onItemComplete, concurrency = 1 } = config;
    validateEvalsInputs(data, scorers, target);
    let totalItems = 0;
    const scoreAccumulator = new ScoreAccumulator();
    const mastra = target.getMastraInstance?.() || target.mastra;
    const storage = mastra?.getStorage();
    const pMap2 = (await __turbopack_context__.A("[project]/node_modules/p-map/index.js [app-route] (ecmascript, async loader)")).default;
    await pMap2(data, async (item)=>{
        const targetResult = await executeTarget(target, item);
        const scorerResults = await runScorers(scorers, targetResult, item);
        scoreAccumulator.addScores(scorerResults);
        if (storage) {
            await saveScoresToStorage({
                storage,
                scorerResults,
                target,
                item,
                mastra
            });
        }
        if (onItemComplete) {
            await onItemComplete({
                item,
                targetResult,
                scorerResults
            });
        }
        totalItems++;
    }, {
        concurrency
    });
    return {
        scores: scoreAccumulator.getAverageScores(),
        summary: {
            totalItems
        }
    };
}
function isWorkflow(target) {
    return target instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Workflow"];
}
function isWorkflowScorerConfig(scorers) {
    return typeof scorers === "object" && !Array.isArray(scorers) && ("workflow" in scorers || "steps" in scorers);
}
function validateEvalsInputs(data, scorers, target) {
    if (data.length === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            domain: "SCORER",
            id: "RUN_EXPERIMENT_FAILED_NO_DATA_PROVIDED",
            category: "USER",
            text: "Failed to run experiment: Data array is empty"
        });
    }
    for(let i = 0; i < data.length; i++){
        const item = data[i];
        if (!item || typeof item !== "object" || !("input" in item)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                domain: "SCORER",
                id: "INVALID_DATA_ITEM",
                category: "USER",
                text: `Invalid data item at index ${i}: must have 'input' properties`
            });
        }
    }
    if (Array.isArray(scorers)) {
        if (scorers.length === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                domain: "SCORER",
                id: "NO_SCORERS_PROVIDED",
                category: "USER",
                text: "At least one scorer must be provided"
            });
        }
    } else if (isWorkflow(target) && isWorkflowScorerConfig(scorers)) {
        const hasScorers = scorers.workflow && scorers.workflow.length > 0 || scorers.steps && Object.keys(scorers.steps).length > 0;
        if (!hasScorers) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                domain: "SCORER",
                id: "NO_SCORERS_PROVIDED",
                category: "USER",
                text: "At least one workflow or step scorer must be provided"
            });
        }
    } else if (!isWorkflow(target) && !Array.isArray(scorers)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            domain: "SCORER",
            id: "INVALID_AGENT_SCORERS",
            category: "USER",
            text: "Agent scorers must be an array of scorers"
        });
    }
}
async function executeTarget(target, item) {
    try {
        if (isWorkflow(target)) {
            return await executeWorkflow(target, item);
        } else {
            return await executeAgent(target, item);
        }
    } catch (error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            domain: "SCORER",
            id: "RUN_EXPERIMENT_TARGET_FAILED_TO_GENERATE_RESULT",
            category: "USER",
            text: "Failed to run experiment: Error generating result from target",
            details: {
                item: JSON.stringify(item)
            }
        }, error);
    }
}
async function executeWorkflow(target, item) {
    const run = await target.createRun({
        disableScorers: true
    });
    const workflowResult = await run.start({
        inputData: item.input,
        requestContext: item.requestContext
    });
    return {
        scoringData: {
            input: item.input,
            output: workflowResult.status === "success" ? workflowResult.result : void 0,
            stepResults: workflowResult.steps
        }
    };
}
async function executeAgent(agent, item) {
    const model = await agent.getModel();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSupportedLanguageModel"])(model)) {
        return await agent.generate(item.input, {
            scorers: {},
            returnScorerData: true,
            requestContext: item.requestContext
        });
    } else {
        return await agent.generateLegacy(item.input, {
            scorers: {},
            returnScorerData: true,
            requestContext: item.requestContext
        });
    }
}
async function runScorers(scorers, targetResult, item) {
    const scorerResults = {};
    if (Array.isArray(scorers)) {
        for (const scorer of scorers){
            try {
                const score = await scorer.run({
                    input: targetResult.scoringData?.input,
                    output: targetResult.scoringData?.output,
                    groundTruth: item.groundTruth,
                    requestContext: item.requestContext,
                    tracingContext: item.tracingContext
                });
                scorerResults[scorer.id] = score;
            } catch (error) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    domain: "SCORER",
                    id: "RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_RESULT",
                    category: "USER",
                    text: `Failed to run experiment: Error running scorer ${scorer.id}`,
                    details: {
                        scorerId: scorer.id,
                        item: JSON.stringify(item)
                    }
                }, error);
            }
        }
    } else {
        if (scorers.workflow) {
            const workflowScorerResults = {};
            for (const scorer of scorers.workflow){
                const score = await scorer.run({
                    input: targetResult.scoringData.input,
                    output: targetResult.scoringData.output,
                    groundTruth: item.groundTruth,
                    requestContext: item.requestContext,
                    tracingContext: item.tracingContext
                });
                workflowScorerResults[scorer.id] = score;
            }
            if (Object.keys(workflowScorerResults).length > 0) {
                scorerResults.workflow = workflowScorerResults;
            }
        }
        if (scorers.steps) {
            const stepScorerResults = {};
            for (const [stepId, stepScorers] of Object.entries(scorers.steps)){
                const stepResult = targetResult.scoringData.stepResults?.[stepId];
                if (stepResult?.status === "success" && stepResult.payload && stepResult.output) {
                    const stepResults = {};
                    for (const scorer of stepScorers){
                        try {
                            const score = await scorer.run({
                                input: stepResult.payload,
                                output: stepResult.output,
                                groundTruth: item.groundTruth,
                                requestContext: item.requestContext,
                                tracingContext: item.tracingContext
                            });
                            stepResults[scorer.id] = score;
                        } catch (error) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                                domain: "SCORER",
                                id: "RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_STEP_RESULT",
                                category: "USER",
                                text: `Failed to run experiment: Error running scorer ${scorer.id} on step ${stepId}`,
                                details: {
                                    scorerId: scorer.id,
                                    stepId
                                }
                            }, error);
                        }
                    }
                    if (Object.keys(stepResults).length > 0) {
                        stepScorerResults[stepId] = stepResults;
                    }
                }
            }
            if (Object.keys(stepScorerResults).length > 0) {
                scorerResults.steps = stepScorerResults;
            }
        }
    }
    return scorerResults;
}
async function saveScoresToStorage({ storage, scorerResults, target, item, mastra }) {
    const entityId = target.id;
    const entityType = isWorkflow(target) ? "WORKFLOW" : "AGENT";
    if (Array.isArray(scorerResults) || !("workflow" in scorerResults && "steps" in scorerResults)) {
        for (const [scorerId, scoreResult] of Object.entries(scorerResults)){
            if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
                await saveSingleScore({
                    storage,
                    scoreResult,
                    scorerId,
                    entityId,
                    entityType,
                    mastra,
                    target,
                    item
                });
            }
        }
    } else {
        if (scorerResults.workflow) {
            for (const [scorerId, scoreResult] of Object.entries(scorerResults.workflow)){
                if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
                    await saveSingleScore({
                        storage,
                        scoreResult,
                        scorerId,
                        entityId,
                        entityType: "WORKFLOW",
                        mastra,
                        target,
                        item
                    });
                }
            }
        }
        if (scorerResults.steps) {
            for (const [stepId, stepScorers] of Object.entries(scorerResults.steps)){
                for (const [scorerId, scoreResult] of Object.entries(stepScorers)){
                    if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
                        await saveSingleScore({
                            storage,
                            scoreResult,
                            scorerId,
                            entityId: stepId,
                            entityType: "STEP",
                            mastra,
                            target,
                            item
                        });
                    }
                }
            }
        }
    }
}
async function saveSingleScore({ storage, scoreResult, scorerId, entityId, entityType, mastra, target, item }) {
    try {
        let scorer = mastra?.getScorerById?.(scorerId);
        if (!scorer) {
            const targetScorers = await target.listScorers?.();
            if (targetScorers) {
                for (const [_, scorerEntry] of Object.entries(targetScorers)){
                    if (scorerEntry.scorer?.id === scorerId) {
                        scorer = scorerEntry.scorer;
                        break;
                    }
                }
            }
        }
        let traceId;
        let spanId;
        if (item.tracingContext?.currentSpan && item.tracingContext.currentSpan.isValid) {
            spanId = item.tracingContext.currentSpan.id;
            traceId = item.tracingContext.currentSpan.traceId;
        }
        const additionalContext = {};
        if (item.groundTruth !== void 0) {
            additionalContext.groundTruth = item.groundTruth;
        }
        const payload = {
            ...scoreResult,
            scorerId,
            entityId,
            entityType,
            source: "TEST",
            scorer: {
                id: scorer?.id || scorerId,
                name: scorer?.name || scorerId,
                description: scorer?.description || "",
                type: scorer?.type || "unknown"
            },
            entity: {
                id: target.id,
                name: target.name || target.id
            },
            // Include requestContext from item
            requestContext: item.requestContext ? Object.fromEntries(item.requestContext.entries()) : void 0,
            // Include additionalContext with groundTruth
            additionalContext: Object.keys(additionalContext).length > 0 ? additionalContext : void 0,
            // Include tracing information
            traceId,
            spanId
        };
        await validateAndSaveScore(storage, payload);
    } catch (error) {
        mastra?.getLogger?.()?.warn?.(`Failed to save score for scorer ${scorerId}:`, error);
    }
}
;
 //# sourceMappingURL=chunk-NCNYUGXD.js.map
 //# sourceMappingURL=chunk-NCNYUGXD.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-PSCMWPLC.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LoggerTransport",
    ()=>LoggerTransport,
    "MultiLogger",
    ()=>MultiLogger,
    "createCustomTransport",
    ()=>createCustomTransport,
    "noopLogger",
    ()=>noopLogger
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
;
// src/logger/multi-logger.ts
var MultiLogger = class {
    loggers;
    constructor(loggers){
        this.loggers = loggers;
    }
    debug(message, ...args) {
        this.loggers.forEach((logger)=>logger.debug(message, ...args));
    }
    info(message, ...args) {
        this.loggers.forEach((logger)=>logger.info(message, ...args));
    }
    warn(message, ...args) {
        this.loggers.forEach((logger)=>logger.warn(message, ...args));
    }
    error(message, ...args) {
        this.loggers.forEach((logger)=>logger.error(message, ...args));
    }
    trackException(error) {
        this.loggers.forEach((logger)=>logger.trackException(error));
    }
    getTransports() {
        const transports = [];
        this.loggers.forEach((logger)=>transports.push(...logger.getTransports().entries()));
        return new Map(transports);
    }
    async listLogs(transportId, params) {
        for (const logger of this.loggers){
            const logs = await logger.listLogs(transportId, params);
            if (logs.total > 0) {
                return logs;
            }
        }
        return {
            logs: [],
            total: 0,
            page: params?.page ?? 1,
            perPage: params?.perPage ?? 100,
            hasMore: false
        };
    }
    async listLogsByRunId(args) {
        for (const logger of this.loggers){
            const logs = await logger.listLogsByRunId(args);
            if (logs.total > 0) {
                return logs;
            }
        }
        return {
            logs: [],
            total: 0,
            page: args.page ?? 1,
            perPage: args.perPage ?? 100,
            hasMore: false
        };
    }
};
// src/logger/noop-logger.ts
var noopLogger = {
    debug: ()=>{},
    info: ()=>{},
    warn: ()=>{},
    error: ()=>{},
    cleanup: async ()=>{},
    getTransports: ()=>/* @__PURE__ */ new Map(),
    trackException: ()=>{},
    listLogs: async ()=>({
            logs: [],
            total: 0,
            page: 1,
            perPage: 100,
            hasMore: false
        }),
    listLogsByRunId: async ()=>({
            logs: [],
            total: 0,
            page: 1,
            perPage: 100,
            hasMore: false
        })
};
var LoggerTransport = class extends __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Transform"] {
    constructor(opts = {}){
        super({
            ...opts,
            objectMode: true
        });
    }
    async listLogsByRunId(_args) {
        return {
            logs: [],
            total: 0,
            page: _args?.page ?? 1,
            perPage: _args?.perPage ?? 100,
            hasMore: false
        };
    }
    async listLogs(_args) {
        return {
            logs: [],
            total: 0,
            page: _args?.page ?? 1,
            perPage: _args?.perPage ?? 100,
            hasMore: false
        };
    }
};
var createCustomTransport = (stream, listLogs, listLogsByRunId)=>{
    let transport = stream;
    if (listLogs) {
        transport.listLogs = listLogs;
    }
    if (listLogsByRunId) {
        transport.listLogsByRunId = listLogsByRunId;
    }
    return transport;
};
;
 //# sourceMappingURL=chunk-PSCMWPLC.js.map
 //# sourceMappingURL=chunk-PSCMWPLC.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-52NRCLCF.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Mastra",
    ()=>Mastra
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7ID3GCY2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-7ID3GCY2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$RYYO3WBT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-RYYO3WBT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NCNYUGXD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-NCNYUGXD.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5A5RM7PH.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSCMWPLC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-PSCMWPLC.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$L54GIUCB$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-L54GIUCB.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-XKBYPAOY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$3CKZSDTQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-3CKZSDTQ.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-NRUZYMHE.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
;
;
;
;
;
;
function createUndefinedPrimitiveError(type, value, key) {
    const typeLabel = type === "mcp-server" ? "MCP server" : type;
    const errorId = `MASTRA_ADD_${type.toUpperCase().replace("-", "_")}_UNDEFINED`;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
        id: errorId,
        domain: "MASTRA" /* MASTRA */ ,
        category: "USER" /* USER */ ,
        text: `Cannot add ${typeLabel}: ${typeLabel} is ${value === null ? "null" : "undefined"}. This may occur if config was spread ({ ...config }) and the original object had getters or non-enumerable properties.`,
        details: {
            status: 400,
            ...key && {
                key
            }
        }
    });
}
var Mastra = class {
    #vectors;
    #agents;
    #logger;
    #workflows;
    #observability;
    #tts;
    #deployer;
    #serverMiddleware = [];
    #storage;
    #scorers;
    #tools;
    #processors;
    #memory;
    #server;
    #serverAdapter;
    #mcpServers;
    #bundler;
    #idGenerator;
    #pubsub;
    #gateways;
    #events = {};
    #internalMastraWorkflows = {};
    // This is only used internally for server handlers that require temporary persistence
    #serverCache;
    get pubsub() {
        return this.#pubsub;
    }
    /**
   * Gets the currently configured ID generator function.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   idGenerator: () => `custom-${Date.now()}`
   * });
   * const generator = mastra.getIdGenerator();
   * console.log(generator?.()); // "custom-1234567890"
   * ```
   */ getIdGenerator() {
        return this.#idGenerator;
    }
    /**
   * Generates a unique identifier using the configured generator or defaults to `crypto.randomUUID()`.
   *
   * This method is used internally by Mastra for creating unique IDs for various entities
   * like workflow runs, agent conversations, and other resources that need unique identification.
   *
   * @param context - Optional context information about what type of ID is being generated
   *                  and where it's being requested from. This allows custom ID generators
   *                  to create deterministic IDs based on context.
   *
   * @throws {MastraError} When the custom ID generator returns an empty string
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const id = mastra.generateId();
   * console.log(id); // "550e8400-e29b-41d4-a716-446655440000"
   *
   * // With context for deterministic IDs
   * const messageId = mastra.generateId({
   *   idType: 'message',
   *   source: 'agent',
   *   threadId: 'thread-123'
   * });
   * ```
   */ generateId(context) {
        if (this.#idGenerator) {
            const id = this.#idGenerator(context);
            if (!id) {
                const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: "MASTRA_ID_GENERATOR_RETURNED_EMPTY_STRING",
                    domain: "MASTRA" /* MASTRA */ ,
                    category: "USER" /* USER */ ,
                    text: "ID generator returned an empty string, which is not allowed"
                });
                this.#logger?.trackException(error);
                throw error;
            }
            return id;
        }
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])();
    }
    /**
   * Sets a custom ID generator function for creating unique identifiers.
   *
   * The ID generator function will be used by `generateId()` instead of the default
   * `crypto.randomUUID()`. This is useful for creating application-specific ID formats
   * or integrating with existing ID generation systems.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * mastra.setIdGenerator(() => `custom-${Date.now()}`);
   * const id = mastra.generateId();
   * console.log(id); // "custom-1234567890"
   * ```
   */ setIdGenerator(idGenerator) {
        this.#idGenerator = idGenerator;
    }
    /**
   * Creates a new Mastra instance with the provided configuration.
   *
   * The constructor initializes all the components specified in the config, sets up
   * internal systems like logging and observability, and registers components with each other.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   agents: {
   *     assistant: new Agent({
   *       id: 'assistant',
   *       name: 'Assistant',
   *       instructions: 'You are a helpful assistant',
   *       model: 'openai/gpt-5'
   *     })
   *   },
   *   storage: new PostgresStore({
   *     connectionString: process.env.DATABASE_URL
   *   }),
   *   logger: new PinoLogger({ name: 'MyApp' }),
   *   observability: new Observability({
   *     configs: { default: { serviceName: 'mastra', exporters: [new DefaultExporter()] } },
   *   }),
   * });
   * ```
   */ constructor(config){
        this.#serverCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$3CKZSDTQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InMemoryServerCache"]();
        if (config?.pubsub) {
            this.#pubsub = config.pubsub;
        } else {
            this.#pubsub = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EventEmitterPubSub"]();
        }
        this.#events = {};
        for(const topic in config?.events ?? {}){
            if (!Array.isArray(config?.events?.[topic])) {
                this.#events[topic] = [
                    config?.events?.[topic]
                ];
            } else {
                this.#events[topic] = config?.events?.[topic] ?? [];
            }
        }
        const workflowEventProcessor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$7ID3GCY2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WorkflowEventProcessor"]({
            mastra: this
        });
        const workflowEventCb = async (event, cb)=>{
            try {
                await workflowEventProcessor.process(event, cb);
            } catch (e) {
                this.getLogger()?.error("Error processing event", e);
            }
        };
        if (this.#events.workflows) {
            this.#events.workflows.push(workflowEventCb);
        } else {
            this.#events.workflows = [
                workflowEventCb
            ];
        }
        let logger;
        if (config?.logger === false) {
            logger = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSCMWPLC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["noopLogger"];
        } else {
            if (config?.logger) {
                logger = config.logger;
            } else {
                const levelOnEnv = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LogLevel"].INFO;
                logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NRUZYMHE$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ConsoleLogger"]({
                    name: "Mastra",
                    level: levelOnEnv
                });
            }
        }
        this.#logger = logger;
        this.#idGenerator = config?.idGenerator;
        let storage = config?.storage;
        if (storage) {
            storage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["augmentWithInit"])(storage);
        }
        if (config?.observability) {
            if (typeof config.observability.getDefaultInstance === "function") {
                this.#observability = config.observability;
                this.#observability.setLogger({
                    logger: this.#logger
                });
            } else {
                this.#logger?.warn('Observability configuration error: Expected an Observability instance, but received a config object. Import and instantiate: import { Observability, DefaultExporter } from "@mastra/observability"; then pass: observability: new Observability({ configs: { default: { serviceName: "mastra", exporters: [new DefaultExporter()] } } }). Observability has been disabled.');
                this.#observability = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoOpObservability"]();
            }
        } else {
            this.#observability = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$XKBYPAOY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoOpObservability"]();
        }
        this.#storage = storage;
        this.#vectors = {};
        this.#mcpServers = {};
        this.#tts = {};
        this.#agents = {};
        this.#scorers = {};
        this.#tools = {};
        this.#processors = {};
        this.#memory = {};
        this.#workflows = {};
        this.#gateways = {};
        if (config?.tools) {
            Object.entries(config.tools).forEach(([key, tool])=>{
                if (tool != null) {
                    this.addTool(tool, key);
                }
            });
        }
        if (config?.processors) {
            Object.entries(config.processors).forEach(([key, processor])=>{
                if (processor != null) {
                    this.addProcessor(processor, key);
                }
            });
        }
        if (config?.memory) {
            Object.entries(config.memory).forEach(([key, memory])=>{
                if (memory != null) {
                    this.addMemory(memory, key);
                }
            });
        }
        if (config?.vectors) {
            Object.entries(config.vectors).forEach(([key, vector])=>{
                if (vector != null) {
                    this.addVector(vector, key);
                }
            });
        }
        if (config?.scorers) {
            Object.entries(config.scorers).forEach(([key, scorer])=>{
                if (scorer != null) {
                    this.addScorer(scorer, key);
                }
            });
        }
        if (config?.workflows) {
            Object.entries(config.workflows).forEach(([key, workflow])=>{
                if (workflow != null) {
                    this.addWorkflow(workflow, key);
                }
            });
        }
        if (config?.gateways) {
            Object.entries(config.gateways).forEach(([key, gateway])=>{
                if (gateway != null) {
                    this.addGateway(gateway, key);
                }
            });
        }
        if (config?.mcpServers) {
            Object.entries(config.mcpServers).forEach(([key, server])=>{
                if (server != null) {
                    this.addMCPServer(server, key);
                }
            });
        }
        if (config?.agents) {
            Object.entries(config.agents).forEach(([key, agent])=>{
                if (agent != null) {
                    this.addAgent(agent, key);
                }
            });
        }
        if (config?.tts) {
            Object.entries(config.tts).forEach(([key, tts])=>{
                if (tts != null) {
                    this.#tts[key] = tts;
                }
            });
        }
        if (config?.server) {
            this.#server = config.server;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$L54GIUCB$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerHook"])("onScorerRun" /* ON_SCORER_RUN */ , (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$NCNYUGXD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createOnScorerHook"])(this));
        this.#observability.setMastraContext({
            mastra: this
        });
        this.setLogger({
            logger
        });
    }
    /**
   * Retrieves a registered agent by its name.
   *
   * @template TAgentName - The specific agent name type from the registered agents
   * @throws {MastraError} When the agent with the specified name is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   agents: {
   *     weatherAgent: new Agent({
   *       id: 'weather-agent',
   *       name: 'weather-agent',
   *       instructions: 'You provide weather information',
   *       model: 'openai/gpt-5'
   *     })
   *   }
   * });
   * const agent = mastra.getAgent('weatherAgent');
   * const response = await agent.generate('What is the weather?');
   * ```
   */ getAgent(name) {
        const agent = this.#agents?.[name];
        if (!agent) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_AGENT_BY_NAME_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Agent with name ${String(name)} not found`,
                details: {
                    status: 404,
                    agentName: String(name),
                    agents: Object.keys(this.#agents ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return this.#agents[name];
    }
    /**
   * Retrieves a registered agent by its unique ID.
   *
   * This method searches for an agent using its internal ID property. If no agent
   * is found with the given ID, it also attempts to find an agent using the ID as
   * a name.
   *
   * @throws {MastraError} When no agent is found with the specified ID
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   agents: {
   *     assistant: new Agent({
   *       id: 'assistant',
   *       name: 'assistant',
   *       instructions: 'You are a helpful assistant',
   *       model: 'openai/gpt-5'
   *     })
   *   }
   * });
   *
   * const assistant = mastra.getAgent('assistant');
   * const sameAgent = mastra.getAgentById(assistant.id);
   * ```
   */ getAgentById(id) {
        let agent = Object.values(this.#agents).find((a)=>a.id === id);
        if (!agent) {
            try {
                agent = this.getAgent(id);
            } catch  {}
        }
        if (!agent) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_AGENT_BY_AGENT_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Agent with id ${String(id)} not found`,
                details: {
                    status: 404,
                    agentId: String(id),
                    agents: Object.keys(this.#agents ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return agent;
    }
    /**
   * Returns all registered agents as a record keyed by their names.
   *
   * This method provides access to the complete registry of agents, allowing you to
   * iterate over them, check what agents are available, or perform bulk operations.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   agents: {
   *     weatherAgent: new Agent({ id: 'weather-agent', name: 'weather', model: 'openai/gpt-4o' }),
   *     supportAgent: new Agent({ id: 'support-agent', name: 'support', model: 'openai/gpt-4o' })
   *   }
   * });
   *
   * const allAgents = mastra.listAgents();
   * console.log(Object.keys(allAgents)); // ['weatherAgent', 'supportAgent']
   * ```
   */ listAgents() {
        return this.#agents;
    }
    async getStoredAgentById(id, options) {
        const storage = this.#storage;
        if (!storage) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_STORED_AGENT_STORAGE_NOT_CONFIGURED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Storage is not configured",
                details: {
                    status: 400
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        const agentsStore = await storage.getStore("agents");
        if (!agentsStore) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_STORED_AGENT_NOT_SUPPORTED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Agents storage is not available",
                details: {
                    status: 400
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        const storedAgent = await agentsStore.getAgentById({
            id
        });
        if (!storedAgent) {
            return null;
        }
        if (options?.raw) {
            return storedAgent;
        }
        return this.#createAgentFromStoredConfig(storedAgent);
    }
    async listStoredAgents(args) {
        const storage = this.#storage;
        if (!storage) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_LIST_STORED_AGENTS_STORAGE_NOT_CONFIGURED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Storage is not configured",
                details: {
                    status: 400
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        const agentsStore = await storage.getStore("agents");
        if (!agentsStore) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_LIST_STORED_AGENTS_NOT_SUPPORTED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Agents storage is not available",
                details: {
                    status: 400
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        const result = await agentsStore.listAgents({
            page: args?.page,
            perPage: args?.perPage,
            orderBy: args?.orderBy
        });
        if (args?.raw) {
            return result;
        }
        const agents = result.agents.map((storedAgent)=>this.#createAgentFromStoredConfig(storedAgent));
        return {
            agents,
            total: result.total,
            page: result.page,
            perPage: result.perPage,
            hasMore: result.hasMore
        };
    }
    /**
   * Creates an Agent instance from a stored agent configuration.
   * @private
   */ #createAgentFromStoredConfig(storedAgent) {
        const modelConfig = storedAgent.model;
        if (!modelConfig.provider || !modelConfig.name) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_STORED_AGENT_INVALID_MODEL",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Stored agent "${storedAgent.id}" has invalid model configuration. Both provider and name are required.`,
                details: {
                    agentId: storedAgent.id,
                    model: JSON.stringify(storedAgent.model)
                }
            });
        }
        const model = `${modelConfig.provider}/${modelConfig.name}`;
        const tools = this.#resolveStoredTools(storedAgent.tools);
        const workflows = this.#resolveStoredWorkflows(storedAgent.workflows);
        const agents = this.#resolveStoredAgents(storedAgent.agents);
        const memory = this.#resolveStoredMemory(storedAgent.memory);
        const scorers = this.#resolveStoredScorers(storedAgent.scorers);
        const agent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Agent"]({
            id: storedAgent.id,
            name: storedAgent.name,
            description: storedAgent.description,
            instructions: storedAgent.instructions,
            model,
            tools,
            workflows,
            agents,
            memory,
            scorers,
            defaultOptions: storedAgent.defaultOptions
        });
        agent.__setLogger(this.#logger);
        agent.__registerMastra(this);
        agent.__registerPrimitives({
            logger: this.getLogger(),
            storage: this.getStorage(),
            agents: this.#agents,
            tts: this.#tts,
            vectors: this.#vectors
        });
        return agent;
    }
    /**
   * Resolves tool references from stored configuration to actual tool instances.
   * @private
   */ #resolveStoredTools(storedTools) {
        if (!storedTools || storedTools.length === 0) {
            return {};
        }
        const resolvedTools = {};
        const registeredTools = this.#tools;
        for (const toolKey of storedTools){
            if (registeredTools && registeredTools[toolKey]) {
                resolvedTools[toolKey] = registeredTools[toolKey];
            } else {
                this.#logger?.warn(`Tool "${toolKey}" referenced in stored agent but not registered in Mastra`);
            }
        }
        return resolvedTools;
    }
    /**
   * Resolves workflow references from stored configuration to actual workflow instances.
   * @private
   */ #resolveStoredWorkflows(storedWorkflows) {
        if (!storedWorkflows || storedWorkflows.length === 0) {
            return {};
        }
        const resolvedWorkflows = {};
        for (const workflowKey of storedWorkflows){
            try {
                const workflow = this.getWorkflow(workflowKey);
                resolvedWorkflows[workflowKey] = workflow;
            } catch  {
                try {
                    const workflow = this.getWorkflowById(workflowKey);
                    resolvedWorkflows[workflowKey] = workflow;
                } catch  {
                    this.#logger?.warn(`Workflow "${workflowKey}" referenced in stored agent but not registered in Mastra`);
                }
            }
        }
        return resolvedWorkflows;
    }
    /**
   * Resolves agent references from stored configuration to actual agent instances.
   * @private
   */ #resolveStoredAgents(storedAgents) {
        if (!storedAgents || storedAgents.length === 0) {
            return {};
        }
        const resolvedAgents = {};
        for (const agentKey of storedAgents){
            try {
                const agent = this.getAgent(agentKey);
                resolvedAgents[agentKey] = agent;
            } catch  {
                try {
                    const agent = this.getAgentById(agentKey);
                    resolvedAgents[agentKey] = agent;
                } catch  {
                    this.#logger?.warn(`Agent "${agentKey}" referenced in stored agent but not registered in Mastra`);
                }
            }
        }
        return resolvedAgents;
    }
    /**
   * Resolves memory reference from stored configuration to actual memory instance.
   * @private
   */ #resolveStoredMemory(storedMemory) {
        if (!storedMemory) {
            return void 0;
        }
        try {
            return this.getMemory(storedMemory);
        } catch  {
            try {
                return this.getMemoryById(storedMemory);
            } catch  {
                this.#logger?.warn(`Memory "${storedMemory}" referenced in stored agent but not registered in Mastra`);
            }
        }
        return void 0;
    }
    /**
   * Resolves scorer references from stored configuration to actual scorer instances.
   * @private
   */ #resolveStoredScorers(storedScorers) {
        if (!storedScorers) {
            return void 0;
        }
        const resolvedScorers = {};
        for (const [scorerKey, scorerConfig] of Object.entries(storedScorers)){
            try {
                const scorer = this.getScorer(scorerKey);
                resolvedScorers[scorerKey] = {
                    scorer,
                    sampling: scorerConfig.sampling
                };
            } catch  {
                try {
                    const scorer = this.getScorerById(scorerKey);
                    resolvedScorers[scorerKey] = {
                        scorer,
                        sampling: scorerConfig.sampling
                    };
                } catch  {
                    this.#logger?.warn(`Scorer "${scorerKey}" referenced in stored agent but not registered in Mastra`);
                }
            }
        }
        return Object.keys(resolvedScorers).length > 0 ? resolvedScorers : void 0;
    }
    /**
   * Adds a new agent to the Mastra instance.
   *
   * This method allows dynamic registration of agents after the Mastra instance
   * has been created. The agent will be initialized with the current logger.
   *
   * @throws {MastraError} When an agent with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newAgent = new Agent({
   *   id: 'chat-agent',
   *   name: 'Chat Assistant',
   *   model: 'openai/gpt-4o'
   * });
   * mastra.addAgent(newAgent); // Uses agent.id as key
   * // or
   * mastra.addAgent(newAgent, 'customKey'); // Uses custom key
   * ```
   */ addAgent(agent, key) {
        if (!agent) {
            throw createUndefinedPrimitiveError("agent", agent, key);
        }
        let mastraAgent;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$RYYO3WBT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolLoopAgentLike"])(agent)) {
            mastraAgent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$RYYO3WBT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toolLoopAgentToMastraAgent"])(agent, {
                fallbackName: key
            });
        } else {
            mastraAgent = agent;
        }
        const agentKey = key || mastraAgent.id;
        const agents = this.#agents;
        if (agents[agentKey]) {
            const logger = this.getLogger();
            logger.debug(`Agent with key ${agentKey} already exists. Skipping addition.`);
            return;
        }
        mastraAgent.__setLogger(this.#logger);
        mastraAgent.__registerMastra(this);
        mastraAgent.__registerPrimitives({
            logger: this.getLogger(),
            storage: this.getStorage(),
            agents,
            tts: this.#tts,
            vectors: this.#vectors
        });
        agents[agentKey] = mastraAgent;
        mastraAgent.getConfiguredProcessorWorkflows().then((processorWorkflows)=>{
            for (const workflow of processorWorkflows){
                this.addWorkflow(workflow, workflow.id);
            }
        }).catch((err)=>{
            this.#logger?.debug(`Failed to register processor workflows for agent ${agentKey}:`, err);
        });
    }
    /**
   * Retrieves a registered vector store by its name.
   *
   * @template TVectorName - The specific vector store name type from the registered vectors
   * @throws {MastraError} When the vector store with the specified name is not found
   *
   * @example Using a vector store for semantic search
   * ```typescript
   * import { PineconeVector } from '@mastra/pinecone';
   * import { OpenAIEmbedder } from '@mastra/embedders';
   *
   * const mastra = new Mastra({
   *   vectors: {
   *     knowledge: new PineconeVector({
   *       apiKey: process.env.PINECONE_API_KEY,
   *       indexName: 'knowledge-base',
   *       embedder: new OpenAIEmbedder({
   *         apiKey: process.env.OPENAI_API_KEY,
   *         model: 'text-embedding-3-small'
   *       })
   *     }),
   *     products: new PineconeVector({
   *       apiKey: process.env.PINECONE_API_KEY,
   *       indexName: 'product-catalog'
   *     })
   *   }
   * });
   *
   * // Get a vector store and perform semantic search
   * const knowledgeBase = mastra.getVector('knowledge');
   * const results = await knowledgeBase.query({
   *   query: 'How to reset password?',
   *   topK: 5
   * });
   *
   * console.log('Relevant documents:', results);
   * ```
   */ getVector(name) {
        const vector = this.#vectors?.[name];
        if (!vector) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_VECTOR_BY_NAME_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Vector with name ${String(name)} not found`,
                details: {
                    status: 404,
                    vectorName: String(name),
                    vectors: Object.keys(this.#vectors ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return vector;
    }
    /**
   * Retrieves a specific vector store instance by its ID.
   *
   * This method searches for a vector store by its internal ID property.
   * If not found by ID, it falls back to searching by registration key.
   *
   * @throws {MastraError} When the specified vector store is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   vectors: {
   *     embeddings: chromaVector
   *   }
   * });
   *
   * const vectorStore = mastra.getVectorById('chroma-123');
   * ```
   */ getVectorById(id) {
        const allVectors = this.#vectors ?? {};
        for (const vector of Object.values(allVectors)){
            if (vector.id === id) {
                return vector;
            }
        }
        const vectorByKey = allVectors[id];
        if (vectorByKey) {
            return vectorByKey;
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_VECTOR_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Vector store with id ${id} not found`,
            details: {
                status: 404,
                vectorId: String(id),
                vectors: Object.keys(allVectors).join(", ")
            }
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Returns all registered vector stores as a record keyed by their names.
   *
   * @example Listing all vector stores
   * ```typescript
   * const mastra = new Mastra({
   *   vectors: {
   *     documents: new PineconeVector({ indexName: 'docs' }),
   *     images: new PineconeVector({ indexName: 'images' }),
   *     products: new ChromaVector({ collectionName: 'products' })
   *   }
   * });
   *
   * const allVectors = mastra.getVectors();
   * console.log(Object.keys(allVectors)); // ['documents', 'images', 'products']
   *
   * // Check vector store types and configurations
   * for (const [name, vectorStore] of Object.entries(allVectors)) {
   *   console.log(`Vector store ${name}:`, vectorStore.constructor.name);
   * }
   * ```
   */ listVectors() {
        return this.#vectors;
    }
    /**
   * Adds a new vector store to the Mastra instance.
   *
   * This method allows dynamic registration of vector stores after the Mastra instance
   * has been created. The vector store will be initialized with the current logger.
   *
   * @throws {MastraError} When a vector store with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newVector = new ChromaVector({ id: 'chroma-embeddings' });
   * mastra.addVector(newVector); // Uses vector.id as key
   * // or
   * mastra.addVector(newVector, 'customKey'); // Uses custom key
   * ```
   */ addVector(vector, key) {
        if (!vector) {
            throw createUndefinedPrimitiveError("vector", vector, key);
        }
        const vectorKey = key || vector.id;
        const vectors = this.#vectors;
        if (vectors[vectorKey]) {
            const logger = this.getLogger();
            logger.debug(`Vector with key ${vectorKey} already exists. Skipping addition.`);
            return;
        }
        vector.__setLogger(this.#logger || this.getLogger());
        vectors[vectorKey] = vector;
    }
    /**
   * @deprecated Use listVectors() instead
   */ getVectors() {
        console.warn("getVectors() is deprecated. Use listVectors() instead.");
        return this.listVectors();
    }
    /**
   * Gets the currently configured deployment provider.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   deployer: new VercelDeployer({
   *     token: process.env.VERCEL_TOKEN,
   *     projectId: process.env.VERCEL_PROJECT_ID
   *   })
   * });
   *
   * const deployer = mastra.getDeployer();
   * if (deployer) {
   *   await deployer.deploy({
   *     name: 'my-mastra-app',
   *     environment: 'production'
   *   });
   * }
   * ```
   */ getDeployer() {
        return this.#deployer;
    }
    /**
   * Retrieves a registered workflow by its ID.
   *
   * @template TWorkflowId - The specific workflow ID type from the registered workflows
   * @throws {MastraError} When the workflow with the specified ID is not found
   *
   * @example Getting and executing a workflow
   * ```typescript
   * import { createWorkflow, createStep } from '@mastra/core/workflows';
   * import { z } from 'zod';
   *
   * const processDataWorkflow = createWorkflow({
   *   name: 'process-data',
   *   triggerSchema: z.object({ input: z.string() })
   * })
   *   .then(validateStep)
   *   .then(transformStep)
   *   .then(saveStep)
   *   .commit();
   *
   * const mastra = new Mastra({
   *   workflows: {
   *     dataProcessor: processDataWorkflow
   *   }
   * });
   * ```
   */ getWorkflow(id, { serialized } = {}) {
        const workflow = this.#workflows?.[id];
        if (!workflow) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_WORKFLOW_BY_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Workflow with ID ${String(id)} not found`,
                details: {
                    status: 404,
                    workflowId: String(id),
                    workflows: Object.keys(this.#workflows ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        if (serialized) {
            return {
                name: workflow.name
            };
        }
        return workflow;
    }
    __registerInternalWorkflow(workflow) {
        workflow.__registerMastra(this);
        workflow.__registerPrimitives({
            logger: this.getLogger()
        });
        this.#internalMastraWorkflows[workflow.id] = workflow;
    }
    __hasInternalWorkflow(id) {
        return Object.values(this.#internalMastraWorkflows).some((workflow)=>workflow.id === id);
    }
    __getInternalWorkflow(id) {
        const workflow = Object.values(this.#internalMastraWorkflows).find((a)=>a.id === id);
        if (!workflow) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_INTERNAL_WORKFLOW_BY_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: `Workflow with id ${String(id)} not found`,
                details: {
                    status: 404,
                    workflowId: String(id)
                }
            });
        }
        return workflow;
    }
    /**
   * Retrieves a registered workflow by its unique ID.
   *
   * This method searches for a workflow using its internal ID property. If no workflow
   * is found with the given ID, it also attempts to find a workflow using the ID as
   * a name.
   *
   * @throws {MastraError} When no workflow is found with the specified ID
   *
   * @example Finding a workflow by ID
   * ```typescript
   * const mastra = new Mastra({
   *   workflows: {
   *     dataProcessor: createWorkflow({
   *       name: 'process-data',
   *       triggerSchema: z.object({ input: z.string() })
   *     }).commit()
   *   }
   * });
   *
   * // Get the workflow's ID
   * const workflow = mastra.getWorkflow('dataProcessor');
   * const workflowId = workflow.id;
   *
   * // Later, retrieve the workflow by ID
   * const sameWorkflow = mastra.getWorkflowById(workflowId);
   * console.log(sameWorkflow.name); // "process-data"
   * ```
   */ getWorkflowById(id) {
        let workflow = Object.values(this.#workflows).find((a)=>a.id === id);
        if (!workflow) {
            try {
                workflow = this.getWorkflow(id);
            } catch  {}
        }
        if (!workflow) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_WORKFLOW_BY_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Workflow with id ${String(id)} not found`,
                details: {
                    status: 404,
                    workflowId: String(id),
                    workflows: Object.keys(this.#workflows ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return workflow;
    }
    async listActiveWorkflowRuns() {
        const storage = this.#storage;
        if (!storage) {
            this.#logger.debug("Cannot get active workflow runs. Mastra storage is not initialized");
            return {
                runs: [],
                total: 0
            };
        }
        const defaultEngineWorkflows = Object.values(this.#workflows).filter((workflow)=>workflow.engineType === "default");
        const allRuns = [];
        let allTotal = 0;
        for (const workflow of defaultEngineWorkflows){
            const runningRuns = await workflow.listWorkflowRuns({
                status: "running"
            });
            const waitingRuns = await workflow.listWorkflowRuns({
                status: "waiting"
            });
            allRuns.push(...runningRuns.runs, ...waitingRuns.runs);
            allTotal += runningRuns.total + waitingRuns.total;
        }
        return {
            runs: allRuns,
            total: allTotal
        };
    }
    async restartAllActiveWorkflowRuns() {
        const activeRuns = await this.listActiveWorkflowRuns();
        if (activeRuns.runs.length > 0) {
            this.#logger.debug(`Restarting ${activeRuns.runs.length} active workflow run${activeRuns.runs.length > 1 ? "s" : ""}`);
        }
        for (const runSnapshot of activeRuns.runs){
            const workflow = this.getWorkflowById(runSnapshot.workflowName);
            try {
                const run = await workflow.createRun({
                    runId: runSnapshot.runId
                });
                await run.restart();
                this.#logger.debug(`Restarted ${runSnapshot.workflowName} workflow run ${runSnapshot.runId}`);
            } catch (error) {
                this.#logger.error(`Failed to restart ${runSnapshot.workflowName} workflow run ${runSnapshot.runId}: ${error}`);
            }
        }
    }
    /**
   * Returns all registered scorers as a record keyed by their IDs.
   *
   * @example Listing all scorers
   * ```typescript
   * import { HelpfulnessScorer, AccuracyScorer, RelevanceScorer } from '@mastra/scorers';
   *
   * const mastra = new Mastra({
   *   scorers: {
   *     helpfulness: new HelpfulnessScorer(),
   *     accuracy: new AccuracyScorer(),
   *     relevance: new RelevanceScorer()
   *   }
   * });
   *
   * const allScorers = mastra.listScorers();
   * console.log(Object.keys(allScorers)); // ['helpfulness', 'accuracy', 'relevance']
   *
   * // Check scorer configurations
   * for (const [id, scorer] of Object.entries(allScorers)) {
   *   console.log(`Scorer ${id}:`, scorer.id, scorer.name, scorer.description);
   * }
   * ```
   */ listScorers() {
        return this.#scorers;
    }
    /**
   * Adds a new scorer to the Mastra instance.
   *
   * This method allows dynamic registration of scorers after the Mastra instance
   * has been created.
   *
   * @throws {MastraError} When a scorer with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newScorer = new MastraScorer({
   *   id: 'quality-scorer',
   *   name: 'Quality Scorer'
   * });
   * mastra.addScorer(newScorer); // Uses scorer.id as key
   * // or
   * mastra.addScorer(newScorer, 'customKey'); // Uses custom key
   * ```
   */ addScorer(scorer, key) {
        if (!scorer) {
            throw createUndefinedPrimitiveError("scorer", scorer, key);
        }
        const scorerKey = key || scorer.id;
        const scorers = this.#scorers;
        if (scorers[scorerKey]) {
            const logger = this.getLogger();
            logger.debug(`Scorer with key ${scorerKey} already exists. Skipping addition.`);
            return;
        }
        scorer.__registerMastra(this);
        scorers[scorerKey] = scorer;
    }
    /**
   * Retrieves a registered scorer by its key.
   *
   * @template TScorerKey - The specific scorer key type from the registered scorers
   * @throws {MastraError} When the scorer with the specified key is not found
   *
   * @example Getting and using a scorer
   * ```typescript
   * import { HelpfulnessScorer, AccuracyScorer } from '@mastra/scorers';
   *
   * const mastra = new Mastra({
   *   scorers: {
   *     helpfulness: new HelpfulnessScorer({
   *       model: 'openai/gpt-4o',
   *       criteria: 'Rate how helpful this response is'
   *     }),
   *     accuracy: new AccuracyScorer({
   *       model: 'openai/gpt-5'
   *     })
   *   }
   * });
   *
   * // Get a specific scorer
   * const helpfulnessScorer = mastra.getScorer('helpfulness');
   * const score = await helpfulnessScorer.score({
   *   input: 'How do I reset my password?',
   *   output: 'You can reset your password by clicking the forgot password link.',
   *   expected: 'Detailed password reset instructions'
   * });
   *
   * console.log('Helpfulness score:', score);
   * ```
   */ getScorer(key) {
        const scorer = this.#scorers?.[key];
        if (!scorer) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_SCORER_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Scorer with ${String(key)} not found`
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return scorer;
    }
    /**
   * Retrieves a registered scorer by its name.
   *
   * This method searches through all registered scorers to find one with the specified name.
   * Unlike `getScorer()` which uses the registration key, this method uses the scorer's
   * internal name property.
   *
   * @throws {MastraError} When no scorer is found with the specified name
   *
   * @example Finding a scorer by name
   * ```typescript
   * import { HelpfulnessScorer } from '@mastra/scorers';
   *
   * const mastra = new Mastra({
   *   scorers: {
   *     myHelpfulnessScorer: new HelpfulnessScorer({
   *       name: 'helpfulness-evaluator',
   *       model: 'openai/gpt-5'
   *     })
   *   }
   * });
   *
   * // Find scorer by its internal name, not the registration key
   * const scorer = mastra.getScorerById('helpfulness-evaluator');
   * const score = await scorer.score({
   *   input: 'question',
   *   output: 'answer'
   * });
   * ```
   */ getScorerById(id) {
        for (const [_key, value] of Object.entries(this.#scorers ?? {})){
            if (value.id === id || value?.name === id) {
                return value;
            }
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_SCORER_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Scorer with id ${String(id)} not found`
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Retrieves a specific tool by registration key.
   *
   * @throws {MastraError} When the specified tool is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   tools: {
   *     calculator: calculatorTool,
   *     weather: weatherTool
   *   }
   * });
   *
   * const tool = mastra.getTool('calculator');
   * ```
   */ getTool(name) {
        if (!this.#tools || !this.#tools[name]) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_TOOL_BY_NAME_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Tool with name ${String(name)} not found`,
                details: {
                    status: 404,
                    toolName: String(name),
                    tools: Object.keys(this.#tools ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return this.#tools[name];
    }
    /**
   * Retrieves a specific tool by its ID.
   *
   * @throws {MastraError} When the specified tool is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   tools: {
   *     calculator: calculatorTool
   *   }
   * });
   *
   * const tool = mastra.getToolById('calculator-tool-id');
   * ```
   */ getToolById(id) {
        const allTools = this.#tools;
        if (!allTools) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_TOOL_BY_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Tool with id ${id} not found`
            });
        }
        for (const tool of Object.values(allTools)){
            if (tool.id === id) {
                return tool;
            }
        }
        const toolByKey = allTools[id];
        if (toolByKey) {
            return toolByKey;
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_TOOL_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Tool with id ${id} not found`,
            details: {
                status: 404,
                toolId: String(id),
                tools: Object.keys(allTools).join(", ")
            }
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Lists all configured tools.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   tools: {
   *     calculator: calculatorTool,
   *     weather: weatherTool
   *   }
   * });
   *
   * const tools = mastra.listTools();
   * Object.entries(tools || {}).forEach(([name, tool]) => {
   *   console.log(`Tool "${name}":`, tool.id);
   * });
   * ```
   */ listTools() {
        return this.#tools;
    }
    /**
   * Adds a new tool to the Mastra instance.
   *
   * This method allows dynamic registration of tools after the Mastra instance
   * has been created.
   *
   * @throws {MastraError} When a tool with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newTool = createTool({
   *   id: 'calculator-tool',
   *   description: 'Performs calculations'
   * });
   * mastra.addTool(newTool); // Uses tool.id as key
   * // or
   * mastra.addTool(newTool, 'customKey'); // Uses custom key
   * ```
   */ addTool(tool, key) {
        if (!tool) {
            throw createUndefinedPrimitiveError("tool", tool, key);
        }
        const toolKey = key || tool.id;
        const tools = this.#tools;
        if (tools[toolKey]) {
            const logger = this.getLogger();
            logger.debug(`Tool with key ${toolKey} already exists. Skipping addition.`);
            return;
        }
        tools[toolKey] = tool;
    }
    /**
   * Retrieves a specific processor by registration key.
   *
   * @throws {MastraError} When the specified processor is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   processors: {
   *     validator: validatorProcessor,
   *     transformer: transformerProcessor
   *   }
   * });
   *
   * const processor = mastra.getProcessor('validator');
   * ```
   */ getProcessor(name) {
        if (!this.#processors || !this.#processors[name]) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_PROCESSOR_BY_NAME_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Processor with name ${String(name)} not found`,
                details: {
                    status: 404,
                    processorName: String(name),
                    processors: Object.keys(this.#processors ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return this.#processors[name];
    }
    /**
   * Retrieves a specific processor by its ID.
   *
   * @throws {MastraError} When the specified processor is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   processors: {
   *     validator: validatorProcessor
   *   }
   * });
   *
   * const processor = mastra.getProcessorById('validator-processor-id');
   * ```
   */ getProcessorById(id) {
        const allProcessors = this.#processors;
        if (!allProcessors) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_PROCESSOR_BY_ID_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Processor with id ${id} not found`
            });
        }
        for (const processor of Object.values(allProcessors)){
            if (processor.id === id) {
                return processor;
            }
        }
        const processorByKey = allProcessors[id];
        if (processorByKey) {
            return processorByKey;
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_PROCESSOR_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Processor with id ${id} not found`,
            details: {
                status: 404,
                processorId: String(id),
                processors: Object.keys(allProcessors).join(", ")
            }
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Lists all configured processors.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   processors: {
   *     validator: validatorProcessor,
   *     transformer: transformerProcessor
   *   }
   * });
   *
   * const processors = mastra.listProcessors();
   * Object.entries(processors || {}).forEach(([name, processor]) => {
   *   console.log(`Processor "${name}":`, processor.id);
   * });
   * ```
   */ listProcessors() {
        return this.#processors;
    }
    /**
   * Adds a new processor to the Mastra instance.
   *
   * This method allows dynamic registration of processors after the Mastra instance
   * has been created.
   *
   * @throws {MastraError} When a processor with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newProcessor = {
   *   id: 'text-processor',
   *   processInput: async (messages) => messages
   * };
   * mastra.addProcessor(newProcessor); // Uses processor.id as key
   * // or
   * mastra.addProcessor(newProcessor, 'customKey'); // Uses custom key
   * ```
   */ addProcessor(processor, key) {
        if (!processor) {
            throw createUndefinedPrimitiveError("processor", processor, key);
        }
        const processorKey = key || processor.id;
        const processors = this.#processors;
        if (processors[processorKey]) {
            const logger = this.getLogger();
            logger.debug(`Processor with key ${processorKey} already exists. Skipping addition.`);
            return;
        }
        processors[processorKey] = processor;
    }
    /**
   * Retrieves a registered memory instance by its registration key.
   *
   * @throws {MastraError} When the memory instance with the specified key is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   memory: {
   *     chat: new Memory({ storage })
   *   }
   * });
   *
   * const chatMemory = mastra.getMemory('chat');
   * ```
   */ getMemory(name) {
        if (!this.#memory || !this.#memory[name]) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_MEMORY_BY_KEY_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Memory with key ${String(name)} not found`,
                details: {
                    status: 404,
                    memoryKey: String(name),
                    memory: Object.keys(this.#memory ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return this.#memory[name];
    }
    /**
   * Retrieves a registered memory instance by its ID.
   *
   * Searches through all registered memory instances and returns the one whose ID matches.
   *
   * @throws {MastraError} When no memory instance with the specified ID is found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   memory: {
   *     chat: new Memory({ id: 'chat-memory', storage })
   *   }
   * });
   *
   * const memory = mastra.getMemoryById('chat-memory');
   * ```
   */ getMemoryById(id) {
        const allMemory = this.#memory;
        if (allMemory) {
            for (const [, memory] of Object.entries(allMemory)){
                if (memory.id === id) {
                    return memory;
                }
            }
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_MEMORY_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Memory with id ${id} not found`,
            details: {
                status: 404,
                memoryId: id,
                availableIds: Object.values(allMemory ?? {}).map((m)=>m.id).join(", ")
            }
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Returns all registered memory instances as a record keyed by their names.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   memory: {
   *     chat: new Memory({ storage }),
   *     longTerm: new Memory({ storage })
   *   }
   * });
   *
   * const allMemory = mastra.listMemory();
   * console.log(Object.keys(allMemory)); // ['chat', 'longTerm']
   * ```
   */ listMemory() {
        return this.#memory;
    }
    /**
   * Adds a new memory instance to the Mastra instance.
   *
   * This method allows dynamic registration of memory instances after the Mastra instance
   * has been created.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const chatMemory = new Memory({
   *   id: 'chat-memory',
   *   storage: mastra.getStorage()
   * });
   * mastra.addMemory(chatMemory); // Uses memory.id as key
   * // or
   * mastra.addMemory(chatMemory, 'customKey'); // Uses custom key
   * ```
   */ addMemory(memory, key) {
        if (!memory) {
            throw createUndefinedPrimitiveError("memory", memory, key);
        }
        const memoryKey = key || memory.id;
        const memoryRegistry = this.#memory;
        if (memoryRegistry[memoryKey]) {
            const logger = this.getLogger();
            logger.debug(`Memory with key ${memoryKey} already exists. Skipping addition.`);
            return;
        }
        memoryRegistry[memoryKey] = memory;
    }
    /**
   * Returns all registered workflows as a record keyed by their IDs.
   *
   * @example Listing all workflows
   * ```typescript
   * const mastra = new Mastra({
   *   workflows: {
   *     dataProcessor: createWorkflow({...}).commit(),
   *     emailSender: createWorkflow({...}).commit(),
   *     reportGenerator: createWorkflow({...}).commit()
   *   }
   * });
   *
   * const allWorkflows = mastra.listWorkflows();
   * console.log(Object.keys(allWorkflows)); // ['dataProcessor', 'emailSender', 'reportGenerator']
   *
   * // Execute all workflows with sample data
   * for (const [id, workflow] of Object.entries(allWorkflows)) {
   *   console.log(`Workflow ${id}:`, workflow.name);
   *   // const result = await workflow.execute(sampleData);
   * }
   * ```
   */ listWorkflows(props = {}) {
        if (props.serialized) {
            return Object.entries(this.#workflows).reduce((acc, [k, v])=>{
                return {
                    ...acc,
                    [k]: {
                        name: v.name
                    }
                };
            }, {});
        }
        return this.#workflows;
    }
    /**
   * Adds a new workflow to the Mastra instance.
   *
   * This method allows dynamic registration of workflows after the Mastra instance
   * has been created. The workflow will be initialized with Mastra and primitives.
   *
   * @throws {MastraError} When a workflow with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newWorkflow = createWorkflow({
   *   id: 'data-pipeline',
   *   name: 'Data Pipeline'
   * }).commit();
   * mastra.addWorkflow(newWorkflow); // Uses workflow.id as key
   * // or
   * mastra.addWorkflow(newWorkflow, 'customKey'); // Uses custom key
   * ```
   */ addWorkflow(workflow, key) {
        if (!workflow) {
            throw createUndefinedPrimitiveError("workflow", workflow, key);
        }
        const workflowKey = key || workflow.id;
        const workflows = this.#workflows;
        if (workflows[workflowKey]) {
            const logger = this.getLogger();
            logger.debug(`Workflow with key ${workflowKey} already exists. Skipping addition.`);
            return;
        }
        workflow.__registerMastra(this);
        workflow.__registerPrimitives({
            logger: this.getLogger(),
            storage: this.getStorage()
        });
        if (!workflow.committed) {
            workflow.commit();
        }
        workflows[workflowKey] = workflow;
    }
    /**
   * Sets the storage provider for the Mastra instance.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   *
   * // Set PostgreSQL storage
   * mastra.setStorage(new PostgresStore({
   *   connectionString: process.env.DATABASE_URL
   * }));
   *
   * // Now agents can use memory with the storage
   * const agent = new Agent({
   *   id: 'assistant',
   *   name: 'assistant',
   *   memory: new Memory({ storage: mastra.getStorage() })
   * });
   * ```
   */ setStorage(storage) {
        this.#storage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["augmentWithInit"])(storage);
    }
    setLogger({ logger }) {
        this.#logger = logger;
        if (this.#agents) {
            Object.keys(this.#agents).forEach((key)=>{
                this.#agents?.[key]?.__setLogger(this.#logger);
            });
        }
        if (this.#deployer) {
            this.#deployer.__setLogger(this.#logger);
        }
        if (this.#tts) {
            Object.keys(this.#tts).forEach((key)=>{
                this.#tts?.[key]?.__setLogger(this.#logger);
            });
        }
        if (this.#storage) {
            this.#storage.__setLogger(this.#logger);
        }
        if (this.#vectors) {
            Object.keys(this.#vectors).forEach((key)=>{
                this.#vectors?.[key]?.__setLogger(this.#logger);
            });
        }
        if (this.#mcpServers) {
            Object.keys(this.#mcpServers).forEach((key)=>{
                this.#mcpServers?.[key]?.__setLogger(this.#logger);
            });
        }
        if (this.#serverAdapter) {
            this.#serverAdapter.__setLogger(this.#logger);
        }
        this.#observability.setLogger({
            logger: this.#logger
        });
    }
    /**
   * Gets all registered text-to-speech (TTS) providers.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   tts: {
   *     openai: new OpenAITTS({
   *       apiKey: process.env.OPENAI_API_KEY,
   *       voice: 'alloy'
   *     })
   *   }
   * });
   *
   * const ttsProviders = mastra.getTTS();
   * const openaiTTS = ttsProviders?.openai;
   * if (openaiTTS) {
   *   const audioBuffer = await openaiTTS.synthesize('Hello, world!');
   * }
   * ```
   */ getTTS() {
        return this.#tts;
    }
    /**
   * Gets the currently configured logger instance.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   logger: new PinoLogger({
   *     name: 'MyApp',
   *     level: 'info'
   *   })
   * });
   *
   * const logger = mastra.getLogger();
   * logger.info('Application started');
   * logger.error('An error occurred', { error: 'details' });
   * ```
   */ getLogger() {
        return this.#logger;
    }
    /**
   * Gets the currently configured storage provider.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   storage: new LibSQLStore({ id: 'mastra-storage', url: 'file:./data.db' })
   * });
   *
   * // Use the storage in agent memory
   * const agent = new Agent({
   *   id: 'assistant',
   *   name: 'assistant',
   *   memory: new Memory({
   *     storage: mastra.getStorage()
   *   })
   * });
   * ```
   */ getStorage() {
        return this.#storage;
    }
    get observability() {
        return this.#observability;
    }
    getServerMiddleware() {
        return this.#serverMiddleware;
    }
    getServerCache() {
        return this.#serverCache;
    }
    setServerMiddleware(serverMiddleware) {
        if (typeof serverMiddleware === "function") {
            this.#serverMiddleware = [
                {
                    handler: serverMiddleware,
                    path: "/api/*"
                }
            ];
            return;
        }
        if (!Array.isArray(serverMiddleware)) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_SET_SERVER_MIDDLEWARE_INVALID_TYPE",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Invalid middleware: expected a function or array, received ${typeof serverMiddleware}`
            });
            this.#logger?.trackException(error);
            throw error;
        }
        this.#serverMiddleware = serverMiddleware.map((m)=>{
            if (typeof m === "function") {
                return {
                    handler: m,
                    path: "/api/*"
                };
            }
            return {
                handler: m.handler,
                path: m.path || "/api/*"
            };
        });
    }
    getServer() {
        return this.#server;
    }
    /**
   * Sets the server adapter for this Mastra instance.
   *
   * The server adapter provides access to the underlying server app (e.g., Hono, Express)
   * and allows users to call routes directly via `app.fetch()` instead of making HTTP requests.
   *
   * This is typically called by `createHonoServer` or similar factory functions during
   * server initialization.
   *
   * @param adapter - The server adapter instance (e.g., MastraServer from @mastra/hono or @mastra/express)
   *
   * @example
   * ```typescript
   * const app = new Hono();
   * const adapter = new MastraServer({ app, mastra });
   * mastra.setMastraServer(adapter);
   * ```
   */ setMastraServer(adapter) {
        if (this.#serverAdapter) {
            this.#logger?.debug("Replacing existing server adapter. Only one adapter should be registered per Mastra instance.");
        }
        this.#serverAdapter = adapter;
        if (this.#logger) {
            adapter.__setLogger(this.#logger);
        }
    }
    /**
   * Gets the server adapter for this Mastra instance.
   *
   * @returns The server adapter, or undefined if not set
   *
   * @example
   * ```typescript
   * const adapter = mastra.getMastraServer();
   * if (adapter) {
   *   const app = adapter.getApp<Hono>();
   * }
   * ```
   */ getMastraServer() {
        return this.#serverAdapter;
    }
    /**
   * Gets the server app from the server adapter.
   *
   * This is a convenience method that calls `getMastraServer()?.getApp<T>()`.
   * Use this to access the underlying server framework's app instance (e.g., Hono, Express)
   * for direct operations like calling routes via `app.fetch()`.
   *
   * @template T - The expected type of the app (e.g., Hono, Express Application)
   * @returns The server app, or undefined if no adapter is set
   *
   * @example
   * ```typescript
   * // After createHonoServer() is called:
   * const app = mastra.getServerApp<Hono>();
   *
   * // Call routes directly without HTTP overhead
   * const response = await app?.fetch(new Request('http://localhost/health'));
   * const data = await response?.json();
   * ```
   */ getServerApp() {
        return this.#serverAdapter?.getApp();
    }
    getBundlerConfig() {
        return this.#bundler;
    }
    async listLogsByRunId({ runId, transportId, fromDate, toDate, logLevel, filters, page, perPage }) {
        if (!transportId) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_LIST_LOGS_BY_RUN_ID_MISSING_TRANSPORT",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Transport ID is required",
                details: {
                    runId,
                    transportId
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        if (!this.#logger?.listLogsByRunId) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_LOGS_BY_RUN_ID_LOGGER_NOT_CONFIGURED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Logger is not configured or does not support listLogsByRunId operation",
                details: {
                    runId,
                    transportId
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return await this.#logger.listLogsByRunId({
            runId,
            transportId,
            fromDate,
            toDate,
            logLevel,
            filters,
            page,
            perPage
        });
    }
    async listLogs(transportId, params) {
        if (!transportId) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_LOGS_MISSING_TRANSPORT",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "Transport ID is required",
                details: {
                    transportId
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        if (!this.#logger) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_LOGS_LOGGER_NOT_CONFIGURED",
                domain: "MASTRA" /* MASTRA */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                text: "Logger is not set",
                details: {
                    transportId
                }
            });
            throw error;
        }
        return await this.#logger.listLogs(transportId, params);
    }
    /**
   * Gets all registered Model Context Protocol (MCP) server instances.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   mcpServers: {
   *     filesystem: new FileSystemMCPServer({
   *       rootPath: '/app/data'
   *     })
   *   }
   * });
   *
   * const mcpServers = mastra.getMCPServers();
   * if (mcpServers) {
   *   const fsServer = mcpServers.filesystem;
   *   const tools = await fsServer.listTools();
   * }
   * ```
   */ listMCPServers() {
        return this.#mcpServers;
    }
    /**
   * Adds a new MCP server to the Mastra instance.
   *
   * This method allows dynamic registration of MCP servers after the Mastra instance
   * has been created. The server will be initialized with ID, Mastra instance, and logger.
   *
   * @throws {MastraError} When an MCP server with the same key already exists
   *
   * @example
   * ```typescript
   * const mastra = new Mastra();
   * const newServer = new FileSystemMCPServer({
   *   rootPath: '/data'
   * });
   * mastra.addMCPServer(newServer); // Uses server.id as key
   * // or
   * mastra.addMCPServer(newServer, 'customKey'); // Uses custom key
   * ```
   */ addMCPServer(server, key) {
        if (!server) {
            throw createUndefinedPrimitiveError("mcp-server", server, key);
        }
        if (key) {
            server.setId(key);
        }
        const resolvedId = server.id;
        if (!resolvedId) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_ADD_MCP_SERVER_MISSING_ID",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: "MCP server must expose an id or be registered under one",
                details: {
                    status: 400
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        const serverKey = key ?? resolvedId;
        const servers = this.#mcpServers;
        if (servers[serverKey]) {
            const logger = this.getLogger();
            logger.debug(`MCP server with key ${serverKey} already exists. Skipping addition.`);
            return;
        }
        server.__registerMastra(this);
        server.__setLogger(this.getLogger());
        servers[serverKey] = server;
    }
    /**
   * Retrieves a specific MCP server instance by registration key.
   *
   * @throws {MastraError} When the specified MCP server is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   mcpServers: {
   *     filesystem: new FileSystemMCPServer({...})
   *   }
   * });
   *
   * const fsServer = mastra.getMCPServer('filesystem');
   * const tools = await fsServer.listTools();
   * ```
   */ getMCPServer(name) {
        if (!this.#mcpServers || !this.#mcpServers[name]) {
            this.#logger?.debug(`MCP server with name ${String(name)} not found`);
            return void 0;
        }
        return this.#mcpServers[name];
    }
    /**
   * Retrieves a specific Model Context Protocol (MCP) server instance by its logical ID.
   *
   * This method searches for an MCP server using its logical ID. If a version is specified,
   * it returns the exact version match. If no version is provided, it returns the server
   * with the most recent release date.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   mcpServers: {
   *     filesystem: new FileSystemMCPServer({
   *       id: 'fs-server',
   *       version: '1.0.0',
   *       rootPath: '/app/data'
   *     })
   *   }
   * });
   *
   * const fsServer = mastra.getMCPServerById('fs-server');
   * if (fsServer) {
   *   const tools = await fsServer.listTools();
   * }
   * ```
   */ getMCPServerById(serverId, version) {
        if (!this.#mcpServers) {
            return void 0;
        }
        const allRegisteredServers = Object.values(this.#mcpServers || {});
        const matchingLogicalIdServers = allRegisteredServers.filter((server)=>server.id === serverId);
        if (matchingLogicalIdServers.length === 0) {
            this.#logger?.debug(`No MCP servers found with logical ID: ${serverId}`);
            return void 0;
        }
        if (version) {
            const specificVersionServer = matchingLogicalIdServers.find((server)=>server.version === version);
            if (!specificVersionServer) {
                this.#logger?.debug(`MCP server with logical ID '${serverId}' found, but not version '${version}'.`);
            }
            return specificVersionServer;
        } else {
            if (matchingLogicalIdServers.length === 1) {
                return matchingLogicalIdServers[0];
            }
            matchingLogicalIdServers.sort((a, b)=>{
                const dateAVal = a.releaseDate && typeof a.releaseDate === "string" ? new Date(a.releaseDate).getTime() : NaN;
                const dateBVal = b.releaseDate && typeof b.releaseDate === "string" ? new Date(b.releaseDate).getTime() : NaN;
                if (isNaN(dateAVal) && isNaN(dateBVal)) return 0;
                if (isNaN(dateAVal)) return 1;
                if (isNaN(dateBVal)) return -1;
                return dateBVal - dateAVal;
            });
            if (matchingLogicalIdServers.length > 0) {
                const latestServer = matchingLogicalIdServers[0];
                if (latestServer && latestServer.releaseDate && typeof latestServer.releaseDate === "string" && !isNaN(new Date(latestServer.releaseDate).getTime())) {
                    return latestServer;
                }
            }
            this.#logger?.warn(`Could not determine the latest server for logical ID '${serverId}' due to invalid or missing release dates, or no servers left after filtering.`);
            return void 0;
        }
    }
    async addTopicListener(topic, listener) {
        await this.#pubsub.subscribe(topic, listener);
    }
    async removeTopicListener(topic, listener) {
        await this.#pubsub.unsubscribe(topic, listener);
    }
    async startEventEngine() {
        for(const topic in this.#events){
            if (!this.#events[topic]) {
                continue;
            }
            const listeners = Array.isArray(this.#events[topic]) ? this.#events[topic] : [
                this.#events[topic]
            ];
            for (const listener of listeners){
                await this.#pubsub.subscribe(topic, listener);
            }
        }
    }
    async stopEventEngine() {
        for(const topic in this.#events){
            if (!this.#events[topic]) {
                continue;
            }
            const listeners = Array.isArray(this.#events[topic]) ? this.#events[topic] : [
                this.#events[topic]
            ];
            for (const listener of listeners){
                await this.#pubsub.unsubscribe(topic, listener);
            }
        }
        await this.#pubsub.flush();
    }
    /**
   * Retrieves a registered gateway by its key.
   *
   * @throws {MastraError} When the gateway with the specified key is not found
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   gateways: {
   *     myGateway: new CustomGateway()
   *   }
   * });
   *
   * const gateway = mastra.getGateway('myGateway');
   * ```
   */ getGateway(key) {
        const gateway = this.#gateways?.[key];
        if (!gateway) {
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_GET_GATEWAY_BY_KEY_NOT_FOUND",
                domain: "MASTRA" /* MASTRA */ ,
                category: "USER" /* USER */ ,
                text: `Gateway with key ${key} not found`,
                details: {
                    status: 404,
                    gatewayKey: key,
                    gateways: Object.keys(this.#gateways ?? {}).join(", ")
                }
            });
            this.#logger?.trackException(error);
            throw error;
        }
        return gateway;
    }
    /**
   * Retrieves a registered gateway by its ID.
   *
   * Searches through all registered gateways and returns the one whose ID matches.
   * If a gateway doesn't have an explicit ID, its name is used as the ID.
   *
   * @throws {MastraError} When no gateway with the specified ID is found
   *
   * @example
   * ```typescript
   * class CustomGateway extends MastraModelGateway {
   *   readonly id = 'custom-gateway-v1';
   *   readonly name = 'Custom Gateway';
   *   // ...
   * }
   *
   * const mastra = new Mastra({
   *   gateways: {
   *     myGateway: new CustomGateway()
   *   }
   * });
   *
   * const gateway = mastra.getGatewayById('custom-gateway-v1');
   * ```
   */ getGatewayById(id) {
        const gateways = this.#gateways ?? {};
        for (const gateway of Object.values(gateways)){
            if (gateway.getId() === id) {
                return gateway;
            }
        }
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "MASTRA_GET_GATEWAY_BY_ID_NOT_FOUND",
            domain: "MASTRA" /* MASTRA */ ,
            category: "USER" /* USER */ ,
            text: `Gateway with ID ${id} not found`,
            details: {
                status: 404,
                gatewayId: id,
                availableIds: Object.values(gateways).map((g)=>g.getId()).join(", ")
            }
        });
        this.#logger?.trackException(error);
        throw error;
    }
    /**
   * Returns all registered gateways as a record keyed by their names.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   gateways: {
   *     netlify: new NetlifyGateway(),
   *     custom: new CustomGateway()
   *   }
   * });
   *
   * const allGateways = mastra.listGateways();
   * console.log(Object.keys(allGateways)); // ['netlify', 'custom']
   * ```
   */ listGateways() {
        return this.#gateways;
    }
    /**
   * Adds a new gateway to the Mastra instance.
   *
   * This method allows dynamic registration of gateways after the Mastra instance
   * has been created. Gateways enable access to LLM providers through custom
   * authentication and routing logic.
   *
   * If no key is provided, the gateway's ID (or name if no ID is set) will be used as the key.
   *
   * @example
   * ```typescript
   * import { MastraModelGateway } from '@mastra/core';
   *
   * class CustomGateway extends MastraModelGateway {
   *   readonly id = 'custom-gateway-v1';  // Optional, defaults to name
   *   readonly name = 'custom';
   *   readonly prefix = 'custom';
   *
   *   async fetchProviders() {
   *     return {
   *       myProvider: {
   *         name: 'My Provider',
   *         models: ['model-1', 'model-2'],
   *         apiKeyEnvVar: 'MY_API_KEY',
   *         gateway: 'custom'
   *       }
   *     };
   *   }
   *
   *   buildUrl(modelId: string) {
   *     return 'https://api.myprovider.com/v1';
   *   }
   *
   *   async getApiKey(modelId: string) {
   *     return process.env.MY_API_KEY || '';
   *   }
   *
   *   async resolveLanguageModel({ modelId, providerId, apiKey }) {
   *     const baseURL = this.buildUrl(`${providerId}/${modelId}`);
   *     return createOpenAICompatible({
   *       name: providerId,
   *       apiKey,
   *       baseURL,
   *       supportsStructuredOutputs: true,
   *     }).chatModel(modelId);
   *   }
   * }
   *
   * const mastra = new Mastra();
   * const newGateway = new CustomGateway();
   * mastra.addGateway(newGateway); // Uses gateway.getId() as key (gateway.id)
   * // or
   * mastra.addGateway(newGateway, 'customKey'); // Uses custom key
   * ```
   */ addGateway(gateway, key) {
        if (!gateway) {
            throw createUndefinedPrimitiveError("gateway", gateway, key);
        }
        const gatewayKey = key || gateway.getId();
        const gateways = this.#gateways;
        if (gateways[gatewayKey]) {
            const logger = this.getLogger();
            logger.debug(`Gateway with key ${gatewayKey} already exists. Skipping addition.`);
            return;
        }
        gateways[gatewayKey] = gateway;
        this.#syncGatewayRegistry();
    }
    /**
   * Sync custom gateways with the GatewayRegistry for type generation
   * @private
   */ #syncGatewayRegistry() {
        try {
            if (process.env.MASTRA_DEV !== "true" && process.env.MASTRA_DEV !== "1") {
                return;
            }
            __turbopack_context__.A("[project]/node_modules/@mastra/core/dist/provider-registry-ZA6LYZWF.js [app-route] (ecmascript, async loader)").then(async ({ GatewayRegistry })=>{
                const registry = GatewayRegistry.getInstance();
                const customGateways = Object.values(this.#gateways || {});
                registry.registerCustomGateways(customGateways);
                const logger = this.getLogger();
                logger.info("\u{1F504} Syncing custom gateway types...");
                await registry.syncGateways(true);
                logger.info("\u2705 Custom gateway types synced! Restart your TypeScript server to see autocomplete.");
            }).catch((err)=>{
                const logger = this.getLogger();
                logger.debug("Gateway registry sync skipped:", err);
            });
        } catch (err) {
            const logger = this.getLogger();
            logger.debug("Gateway registry sync failed:", err);
        }
    }
    /**
   * Gracefully shuts down the Mastra instance and cleans up all resources.
   *
   * This method performs a clean shutdown of all Mastra components, including:
   * - tracing registry and all tracing instances
   * - Event engine and pub/sub system
   * - All registered components and their resources
   *
   * It's important to call this method when your application is shutting down
   * to ensure proper cleanup and prevent resource leaks.
   *
   * @example
   * ```typescript
   * const mastra = new Mastra({
   *   agents: { myAgent },
   *   workflows: { myWorkflow }
   * });
   *
   * // Graceful shutdown on SIGINT
   * process.on('SIGINT', async () => {
   *   await mastra.shutdown();
   *   process.exit(0);
   * });
   * ```
   */ async shutdown() {
        await this.stopEventEngine();
        await this.#observability.shutdown();
        this.#logger?.info("Mastra shutdown completed");
    }
    // This method is only used internally for server hnadlers that require temporary persistence
    get serverCache() {
        return this.#serverCache;
    }
};
;
 //# sourceMappingURL=chunk-52NRCLCF.js.map
 //# sourceMappingURL=chunk-52NRCLCF.js.map
}),
"[project]/node_modules/@mastra/core/dist/vector/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MastraVector",
    ()=>MastraVector,
    "isSupportedEmbeddingModel",
    ()=>isSupportedEmbeddingModel,
    "supportedEmbeddingModelSpecifications",
    ()=>supportedEmbeddingModelSpecifications
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
;
;
;
;
;
;
// src/vector/vector.ts
var supportedEmbeddingModelSpecifications = [
    "v2",
    "v3"
];
var isSupportedEmbeddingModel = (model)=>{
    return supportedEmbeddingModelSpecifications.includes(model.specificationVersion);
};
var MastraVector = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    id;
    constructor({ id }){
        if (!id || typeof id !== "string" || id.trim() === "") {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VECTOR_INVALID_ID",
                text: "Vector id must be provided and cannot be empty",
                domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */ ,
                category: "USER" /* USER */ 
            });
        }
        super({
            name: "MastraVector",
            component: "VECTOR"
        });
        this.id = id;
    }
    get indexSeparator() {
        return "_";
    }
    async validateExistingIndex(indexName, dimension, metric) {
        let info;
        try {
            info = await this.describeIndex({
                indexName
            });
        } catch (infoError) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VECTOR_VALIDATE_INDEX_FETCH_FAILED",
                text: `Index "${indexName}" already exists, but failed to fetch index info for dimension check.`,
                domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                details: {
                    indexName
                }
            }, infoError);
            this.logger?.trackException(mastraError);
            this.logger?.error(mastraError.toString());
            throw mastraError;
        }
        const existingDim = info?.dimension;
        const existingMetric = info?.metric;
        if (existingDim === dimension) {
            this.logger?.info(`Index "${indexName}" already exists with ${existingDim} dimensions and metric ${existingMetric}, skipping creation.`);
            if (existingMetric !== metric) {
                this.logger?.warn(`Attempted to create index with metric "${metric}", but index already exists with metric "${existingMetric}". To use a different metric, delete and recreate the index.`);
            }
        } else if (info) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VECTOR_VALIDATE_INDEX_DIMENSION_MISMATCH",
                text: `Index "${indexName}" already exists with ${existingDim} dimensions, but ${dimension} dimensions were requested`,
                domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */ ,
                category: "USER" /* USER */ ,
                details: {
                    indexName,
                    existingDim,
                    requestedDim: dimension
                }
            });
            this.logger?.trackException(mastraError);
            this.logger?.error(mastraError.toString());
            throw mastraError;
        } else {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "VECTOR_VALIDATE_INDEX_NO_DIMENSION",
                text: `Index "${indexName}" already exists, but could not retrieve its dimensions for validation.`,
                domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */ ,
                category: "SYSTEM" /* SYSTEM */ ,
                details: {
                    indexName
                }
            });
            this.logger?.trackException(mastraError);
            this.logger?.error(mastraError.toString());
            throw mastraError;
        }
    }
};
;
 //# sourceMappingURL=index.js.map
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@mastra/core/dist/chunk-BWYU7D33.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseFilterTranslator",
    ()=>BaseFilterTranslator
]);
// src/vector/filter/base.ts
var BaseFilterTranslator = class _BaseFilterTranslator {
    /**
   * Operator type checks
   */ isOperator(key) {
        return key.startsWith("$");
    }
    static BASIC_OPERATORS = [
        "$eq",
        "$ne"
    ];
    static NUMERIC_OPERATORS = [
        "$gt",
        "$gte",
        "$lt",
        "$lte"
    ];
    static ARRAY_OPERATORS = [
        "$in",
        "$nin",
        "$all",
        "$elemMatch"
    ];
    static LOGICAL_OPERATORS = [
        "$and",
        "$or",
        "$not",
        "$nor"
    ];
    static ELEMENT_OPERATORS = [
        "$exists"
    ];
    static REGEX_OPERATORS = [
        "$regex",
        "$options"
    ];
    static DEFAULT_OPERATORS = {
        logical: _BaseFilterTranslator.LOGICAL_OPERATORS,
        basic: _BaseFilterTranslator.BASIC_OPERATORS,
        numeric: _BaseFilterTranslator.NUMERIC_OPERATORS,
        array: _BaseFilterTranslator.ARRAY_OPERATORS,
        element: _BaseFilterTranslator.ELEMENT_OPERATORS,
        regex: _BaseFilterTranslator.REGEX_OPERATORS
    };
    isLogicalOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.logical.includes(key);
    }
    isBasicOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.basic.includes(key);
    }
    isNumericOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.numeric.includes(key);
    }
    isArrayOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.array.includes(key);
    }
    isElementOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.element.includes(key);
    }
    isRegexOperator(key) {
        return _BaseFilterTranslator.DEFAULT_OPERATORS.regex.includes(key);
    }
    isFieldOperator(key) {
        return this.isOperator(key) && !this.isLogicalOperator(key);
    }
    isCustomOperator(key) {
        const support = this.getSupportedOperators();
        return support.custom?.includes(key) ?? false;
    }
    getSupportedOperators() {
        return _BaseFilterTranslator.DEFAULT_OPERATORS;
    }
    isValidOperator(key) {
        const support = this.getSupportedOperators();
        const allSupported = Object.values(support).flat();
        return allSupported.includes(key);
    }
    /**
   * Value normalization for comparison operators
   */ normalizeComparisonValue(value) {
        if (value instanceof Date) {
            return value.toISOString();
        }
        if (typeof value === "number" && Object.is(value, -0)) {
            return 0;
        }
        return value;
    }
    /**
   * Helper method to simulate $all operator using $and + $eq when needed.
   * Some vector stores don't support $all natively.
   */ simulateAllOperator(field, values) {
        return {
            $and: values.map((value)=>({
                    [field]: {
                        $in: [
                            this.normalizeComparisonValue(value)
                        ]
                    }
                }))
        };
    }
    /**
   * Utility functions for type checking
   */ isPrimitive(value) {
        return value === null || value === void 0 || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    isRegex(value) {
        return value instanceof RegExp;
    }
    isEmpty(obj) {
        return obj === null || obj === void 0 || typeof obj === "object" && Object.keys(obj).length === 0;
    }
    static ErrorMessages = {
        UNSUPPORTED_OPERATOR: (op)=>`Unsupported operator: ${op}`,
        INVALID_LOGICAL_OPERATOR_LOCATION: (op, path)=>`Logical operator ${op} cannot be used at field level: ${path}`,
        NOT_REQUIRES_OBJECT: `$not operator requires an object`,
        NOT_CANNOT_BE_EMPTY: `$not operator cannot be empty`,
        INVALID_LOGICAL_OPERATOR_CONTENT: (path)=>`Logical operators must contain field conditions, not direct operators: ${path}`,
        INVALID_TOP_LEVEL_OPERATOR: (op)=>`Invalid top-level operator: ${op}`,
        ELEM_MATCH_REQUIRES_OBJECT: `$elemMatch requires an object with conditions`
    };
    /**
   * Helper to handle array value normalization consistently
   */ normalizeArrayValues(values) {
        return values.map((value)=>this.normalizeComparisonValue(value));
    }
    validateFilter(filter) {
        const validation = this.validateFilterSupport(filter);
        if (!validation.supported) {
            throw new Error(validation.messages.join(", "));
        }
    }
    /**
   * Validates if a filter structure is supported by the specific vector DB
   * and returns detailed validation information.
   */ validateFilterSupport(node, path = "") {
        const messages = [];
        if (this.isPrimitive(node) || this.isEmpty(node)) {
            return {
                supported: true,
                messages: []
            };
        }
        if (Array.isArray(node)) {
            const arrayResults = node.map((item)=>this.validateFilterSupport(item, path));
            const arrayMessages = arrayResults.flatMap((r)=>r.messages);
            return {
                supported: arrayResults.every((r)=>r.supported),
                messages: arrayMessages
            };
        }
        const nodeObj = node;
        let isSupported = true;
        for (const [key, value] of Object.entries(nodeObj)){
            const newPath = path ? `${path}.${key}` : key;
            if (this.isOperator(key)) {
                if (!this.isValidOperator(key)) {
                    isSupported = false;
                    messages.push(_BaseFilterTranslator.ErrorMessages.UNSUPPORTED_OPERATOR(key));
                    continue;
                }
                if (!path && !this.isLogicalOperator(key)) {
                    isSupported = false;
                    messages.push(_BaseFilterTranslator.ErrorMessages.INVALID_TOP_LEVEL_OPERATOR(key));
                    continue;
                }
                if (key === "$elemMatch" && (typeof value !== "object" || Array.isArray(value))) {
                    isSupported = false;
                    messages.push(_BaseFilterTranslator.ErrorMessages.ELEM_MATCH_REQUIRES_OBJECT);
                    continue;
                }
                if (this.isLogicalOperator(key)) {
                    if (key === "$not") {
                        if (Array.isArray(value) || typeof value !== "object") {
                            isSupported = false;
                            messages.push(_BaseFilterTranslator.ErrorMessages.NOT_REQUIRES_OBJECT);
                            continue;
                        }
                        if (this.isEmpty(value)) {
                            isSupported = false;
                            messages.push(_BaseFilterTranslator.ErrorMessages.NOT_CANNOT_BE_EMPTY);
                            continue;
                        }
                        continue;
                    }
                    if (path && !this.isLogicalOperator(path.split(".").pop())) {
                        isSupported = false;
                        messages.push(_BaseFilterTranslator.ErrorMessages.INVALID_LOGICAL_OPERATOR_LOCATION(key, newPath));
                        continue;
                    }
                    if (Array.isArray(value)) {
                        const hasDirectOperators = value.some((item)=>typeof item === "object" && Object.keys(item).length === 1 && this.isFieldOperator(Object.keys(item)[0]));
                        if (hasDirectOperators) {
                            isSupported = false;
                            messages.push(_BaseFilterTranslator.ErrorMessages.INVALID_LOGICAL_OPERATOR_CONTENT(newPath));
                            continue;
                        }
                    }
                }
            }
            const nestedValidation = this.validateFilterSupport(value, newPath);
            if (!nestedValidation.supported) {
                isSupported = false;
                messages.push(...nestedValidation.messages);
            }
        }
        return {
            supported: isSupported,
            messages
        };
    }
};
;
 //# sourceMappingURL=chunk-BWYU7D33.js.map
 //# sourceMappingURL=chunk-BWYU7D33.js.map
}),
];

//# sourceMappingURL=node_modules_%40mastra_core_dist_cb0ab801._.js.map