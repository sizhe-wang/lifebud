{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/core/dist/chunk-7ID3GCY2.js","sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/step-executor.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/events/processor.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow-event-processor/loop.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow-event-processor/parallel.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow-event-processor/sleep.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow-event-processor/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/workflow-event-processor/utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/core/src/workflows/evented/execution-engine.ts"],"sourcesContent":["import EventEmitter from 'node:events';\nimport { MastraBase } from '../../base';\nimport type { RequestContext } from '../../di';\nimport { getErrorFromUnknown } from '../../error/utils.js';\nimport { EventEmitterPubSub } from '../../events/event-emitter';\nimport type { PubSub } from '../../events/pubsub';\nimport { RegisteredLogger } from '../../logger';\nimport type { Mastra } from '../../mastra';\nimport { PUBSUB_SYMBOL, STREAM_FORMAT_SYMBOL } from '../constants';\nimport { getStepResult } from '../step';\nimport type { InnerOutput, LoopConditionFunction, Step } from '../step';\nimport type { StepFlowEntry, StepResult } from '../types';\nimport {\n  validateStepInput,\n  createDeprecationProxy,\n  runCountDeprecationMessage,\n  validateStepSuspendData,\n} from '../utils';\n\nexport class StepExecutor extends MastraBase {\n  protected mastra?: Mastra;\n  constructor({ mastra }: { mastra?: Mastra }) {\n    super({ name: 'StepExecutor', component: RegisteredLogger.WORKFLOW });\n    this.mastra = mastra;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n  }\n\n  async execute(params: {\n    workflowId: string;\n    step: Step<any, any, any, any>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    emitter: EventEmitter;\n    requestContext: RequestContext;\n    retryCount?: number;\n    foreachIdx?: number;\n    validateInputs?: boolean;\n    abortController?: AbortController;\n    perStep?: boolean;\n  }): Promise<StepResult<any, any, any, any>> {\n    const { step, stepResults, runId, requestContext, retryCount = 0, perStep } = params;\n\n    // Use provided abortController or create a new one for backwards compatibility\n    const abortController = params.abortController ?? new AbortController();\n\n    let suspended: { payload: any } | undefined;\n    let bailed: { payload: any } | undefined;\n    const startedAt = Date.now();\n    const { inputData, validationError } = await validateStepInput({\n      prevOutput: typeof params.foreachIdx === 'number' ? params.input?.[params.foreachIdx] : params.input,\n      step,\n      validateInputs: params.validateInputs ?? true,\n    });\n\n    let stepInfo: {\n      startedAt: number;\n      payload: any;\n      resumePayload?: any;\n      resumedAt?: number;\n      [key: string]: any;\n    } = {\n      ...stepResults[step.id],\n      startedAt,\n      payload: (typeof params.foreachIdx === 'number' ? params.input : inputData) ?? {},\n    };\n\n    if (params.resumeData) {\n      delete stepInfo.suspendPayload?.['__workflow_meta'];\n      stepInfo.resumePayload = params.resumeData;\n      stepInfo.resumedAt = Date.now();\n    }\n\n    // Extract suspend data if this step was previously suspended\n    let suspendDataToUse =\n      params.stepResults[step.id]?.status === 'suspended' ? params.stepResults[step.id]?.suspendPayload : undefined;\n\n    // Filter out internal workflow metadata before exposing to step code\n    if (suspendDataToUse && '__workflow_meta' in suspendDataToUse) {\n      const { __workflow_meta, ...userSuspendData } = suspendDataToUse;\n      suspendDataToUse = userSuspendData;\n    }\n\n    try {\n      if (validationError) {\n        throw validationError;\n      }\n\n      const stepOutput = await step.execute(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData,\n            state: params.state,\n            setState: async (state: any) => {\n              // TODO\n              params.state = state;\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            suspendData: suspendDataToUse,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (suspendPayload: unknown): Promise<InnerOutput> => {\n              const { suspendData, validationError } = await validateStepSuspendData({\n                suspendData: suspendPayload,\n                step,\n                validateInputs: params.validateInputs ?? true,\n              });\n              if (validationError) {\n                throw validationError;\n              }\n              suspended = { payload: { ...suspendData, __workflow_meta: { runId, path: [step.id] } } };\n            },\n            bail: (result: any): InnerOutput => {\n              bailed = { payload: result };\n            },\n            // TODO\n            writer: undefined as any,\n            abort: () => {\n              abortController?.abort();\n            },\n            [PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new EventEmitterPubSub(params.emitter),\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n\n      const isNestedWorkflowStep = step.component === 'WORKFLOW';\n\n      const nestedWflowStepPaused = isNestedWorkflowStep && perStep;\n\n      const endedAt = Date.now();\n\n      let finalResult: StepResult<any, any, any, any>;\n      if (suspended) {\n        finalResult = {\n          ...stepInfo,\n          status: 'suspended',\n          suspendedAt: endedAt,\n          ...(stepOutput ? { suspendOutput: stepOutput } : {}),\n        };\n\n        if (suspended.payload) {\n          finalResult.suspendPayload = suspended.payload;\n        }\n      } else if (bailed) {\n        finalResult = {\n          ...stepInfo,\n          // @ts-ignore\n          status: 'bailed',\n          endedAt,\n          output: bailed.payload,\n        };\n      } else if (nestedWflowStepPaused) {\n        finalResult = {\n          ...stepInfo,\n          status: 'paused',\n        };\n      } else {\n        finalResult = {\n          ...stepInfo,\n          status: 'success',\n          endedAt,\n          output: stepOutput,\n        };\n      }\n\n      return finalResult;\n    } catch (error: any) {\n      const endedAt = Date.now();\n\n      const errorInstance = getErrorFromUnknown(error, {\n        serializeStack: false,\n        fallbackMessage: 'Unknown step execution error',\n      });\n\n      return {\n        ...stepInfo,\n        status: 'failed',\n        endedAt,\n        error: errorInstance,\n      };\n    }\n  }\n\n  async evaluateConditions(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'conditional' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    emitter: { runtime: PubSub; events: PubSub };\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number[]> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n\n    const abortController = params.abortController ?? new AbortController();\n    const ee = new EventEmitter();\n\n    const results = await Promise.all(\n      step.conditions.map(condition => {\n        try {\n          return this.evaluateCondition({\n            workflowId: params.workflowId,\n            condition,\n            runId,\n            requestContext,\n            inputData: params.input,\n            state: params.state,\n            retryCount,\n            resumeData: params.resumeData,\n            abortController,\n            stepResults,\n            emitter: ee,\n            iterationCount: 0,\n          });\n        } catch (e) {\n          this.mastra?.getLogger()?.error('error evaluating condition', e);\n          return false;\n        }\n      }),\n    );\n\n    const idxs = results.reduce((acc, result, idx) => {\n      if (result) {\n        acc.push(idx);\n      }\n\n      return acc;\n    }, [] as number[]);\n\n    return idxs;\n  }\n\n  async evaluateCondition({\n    workflowId,\n    condition,\n    runId,\n    inputData,\n    resumeData,\n    stepResults,\n    state,\n    requestContext,\n    emitter,\n    abortController,\n    retryCount = 0,\n    iterationCount,\n  }: {\n    workflowId: string;\n    condition: LoopConditionFunction<any, any, any, any, any, any>;\n    runId: string;\n    inputData?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    emitter: EventEmitter;\n    requestContext: RequestContext;\n    abortController: AbortController;\n    retryCount?: number;\n    iterationCount: number;\n  }): Promise<boolean> {\n    return condition(\n      createDeprecationProxy(\n        {\n          workflowId,\n          runId,\n          mastra: this.mastra!,\n          requestContext,\n          inputData,\n          state,\n          retryCount,\n          resumeData: resumeData,\n          getInitData: () => stepResults?.input as any,\n          getStepResult: getStepResult.bind(this, stepResults),\n          bail: (_result: any) => {\n            throw new Error('Not implemented');\n          },\n          // TODO\n          writer: undefined as any,\n          abort: () => {\n            abortController?.abort();\n          },\n          [PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new EventEmitterPubSub(emitter),\n          [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n          engine: {},\n          abortSignal: abortController?.signal,\n          // TODO\n          tracingContext: {},\n          iterationCount,\n        },\n        {\n          paramName: 'runCount',\n          deprecationMessage: runCountDeprecationMessage,\n          logger: this.logger,\n        },\n      ),\n    );\n  }\n\n  async resolveSleep(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'sleep' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    emitter: { runtime: PubSub; events: PubSub };\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n\n    const abortController = params.abortController ?? new AbortController();\n    const ee = new EventEmitter();\n\n    if (step.duration) {\n      return step.duration;\n    }\n\n    if (!step.fn) {\n      return 0;\n    }\n\n    try {\n      return await step.fn(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData: params.input,\n            // TODO: implement state\n            state: {},\n            setState: async (_state: any) => {\n              // TODO\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (_suspendPayload: any): Promise<any> => {\n              throw new Error('Not implemented');\n            },\n            bail: (_result: any) => {\n              throw new Error('Not implemented');\n            },\n            abort: () => {\n              abortController?.abort();\n            },\n            // TODO\n            writer: undefined as any,\n            [PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new EventEmitterPubSub(ee),\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n    } catch (e) {\n      this.mastra?.getLogger()?.error('error evaluating condition', e);\n      return 0;\n    }\n  }\n\n  async resolveSleepUntil(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'sleepUntil' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    emitter: { runtime: PubSub; events: PubSub };\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n\n    const abortController = params.abortController ?? new AbortController();\n    const ee = new EventEmitter();\n\n    if (step.date) {\n      return step.date.getTime() - Date.now();\n    }\n\n    if (!step.fn) {\n      return 0;\n    }\n\n    try {\n      const result = await step.fn(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData: params.input,\n            // TODO: implement state\n            state: {},\n            setState: async (_state: any) => {\n              // TODO\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (_suspendPayload: any): Promise<any> => {\n              throw new Error('Not implemented');\n            },\n            bail: (_result: any) => {\n              throw new Error('Not implemented');\n            },\n            abort: () => {\n              abortController?.abort();\n            },\n            // TODO\n            writer: undefined as any,\n            [PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new EventEmitterPubSub(ee),\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n\n      return result.getTime() - Date.now();\n    } catch (e) {\n      this.mastra?.getLogger()?.error('error evaluating condition', e);\n      return 0;\n    }\n  }\n}\n","import type { Mastra } from '../mastra';\nimport type { Event } from './types';\n\nexport abstract class EventProcessor {\n  protected mastra: Mastra;\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n  }\n\n  constructor({ mastra }: { mastra: Mastra }) {\n    this.mastra = mastra;\n  }\n\n  protected abstract process(event: Event): Promise<void>;\n}\n","import EventEmitter from 'node:events';\nimport type { StepFlowEntry, StepResult } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport type { Mastra } from '../../../mastra';\nimport type { StepExecutor } from '../step-executor';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowLoop(\n  {\n    workflowId,\n    prevResult,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    retryCount = 0,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n    stepResult,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'loop' }>;\n    stepResult: StepResult<any, any, any, any>;\n  },\n) {\n  const loopCondition = await stepExecutor.evaluateCondition({\n    workflowId,\n    condition: step.condition,\n    runId,\n    stepResults,\n    // TODO: implement state\n    state: {},\n    emitter: new EventEmitter() as any, // TODO\n    requestContext: new RequestContext(), // TODO\n    inputData: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n    abortController: new AbortController(),\n    retryCount,\n    iterationCount: 0, //TODO: implement\n  });\n\n  if (step.loopType === 'dountil') {\n    if (loopCondition) {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    } else {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          retryCount,\n          perStep,\n        },\n      });\n    }\n  } else {\n    if (loopCondition) {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          retryCount,\n          perStep,\n        },\n      });\n    } else {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    }\n  }\n}\n\nexport async function processWorkflowForEach(\n  {\n    workflowId,\n    prevResult,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    mastra,\n    step,\n  }: {\n    pubsub: PubSub;\n    mastra: Mastra;\n    step: Extract<StepFlowEntry, { type: 'foreach' }>;\n  },\n) {\n  const currentResult: Extract<StepResult<any, any, any, any>, { status: 'success' }> = stepResults[\n    step.step.id\n  ] as any;\n\n  const idx = currentResult?.output?.length ?? 0;\n  const targetLen = (prevResult as any)?.output?.length ?? 0;\n\n  if (idx >= targetLen && currentResult.output.filter((r: any) => r !== null).length >= targetLen) {\n    await pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n        resumeSteps,\n        stepResults,\n        timeTravel,\n        prevResult: currentResult,\n        resumeData,\n        activeSteps,\n        requestContext,\n        perStep,\n      },\n    });\n\n    return;\n  } else if (idx >= targetLen) {\n    // wait for the 'null' values to be filled from the concurrent run\n    return;\n  }\n\n  const workflowsStore = await mastra.getStorage()?.getStore('workflows');\n\n  if (executionPath.length === 1 && idx === 0) {\n    // on first iteratation we need to kick off up to the set concurrency\n    const concurrency = Math.min(step.opts.concurrency ?? 1, targetLen);\n    const dummyResult = Array.from({ length: concurrency }, () => null);\n\n    await workflowsStore?.updateWorkflowResults({\n      workflowName: workflowId,\n      runId,\n      stepId: step.step.id,\n      result: {\n        status: 'success',\n        output: dummyResult as any,\n        startedAt: Date.now(),\n        payload: (prevResult as any)?.output,\n      } as any,\n      requestContext,\n    });\n\n    for (let i = 0; i < concurrency; i++) {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath: [executionPath[0]!, i],\n          resumeSteps,\n          stepResults,\n          timeTravel,\n          prevResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    }\n\n    return;\n  }\n\n  (currentResult as any).output.push(null);\n  await workflowsStore?.updateWorkflowResults({\n    workflowName: workflowId,\n    runId,\n    stepId: step.step.id,\n    result: {\n      status: 'success',\n      output: (currentResult as any).output,\n      startedAt: Date.now(),\n      payload: (prevResult as any)?.output,\n    } as any,\n    requestContext,\n  });\n\n  await pubsub.publish('workflows', {\n    type: 'workflow.step.run',\n    runId,\n    data: {\n      parentWorkflow,\n      workflowId,\n      runId,\n      executionPath: [executionPath[0]!, idx],\n      resumeSteps,\n      timeTravel,\n      stepResults,\n      prevResult,\n      resumeData,\n      activeSteps,\n      requestContext,\n      perStep,\n    },\n  });\n}\n","import EventEmitter from 'node:events';\nimport type { StepFlowEntry } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport type { StepExecutor } from '../step-executor';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowParallel(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    step,\n  }: {\n    pubsub: PubSub;\n    step: Extract<StepFlowEntry, { type: 'parallel' }>;\n  },\n) {\n  for (let i = 0; i < step.steps.length; i++) {\n    const nestedStep = step.steps[i];\n    if (nestedStep?.type === 'step') {\n      activeSteps[nestedStep.step.id] = true;\n      if (perStep) {\n        break;\n      }\n    }\n  }\n\n  await Promise.all(\n    step.steps\n      ?.filter(step => activeSteps[step.step.id])\n      .map(async (_step, idx) => {\n        return pubsub.publish('workflows', {\n          type: 'workflow.step.run',\n          runId,\n          data: {\n            workflowId,\n            runId,\n            executionPath: executionPath.concat([idx]),\n            resumeSteps,\n            stepResults,\n            prevResult,\n            resumeData,\n            timeTravel,\n            parentWorkflow,\n            activeSteps,\n            requestContext,\n            perStep,\n          },\n        });\n      }),\n  );\n}\n\nexport async function processWorkflowConditional(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'conditional' }>;\n  },\n) {\n  const idxs = await stepExecutor.evaluateConditions({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    // TODO: implement state\n    state: {},\n    emitter: new EventEmitter() as any, // TODO\n    requestContext: new RequestContext(), // TODO\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  const truthyIdxs: Record<number, boolean> = {};\n  for (let i = 0; i < idxs.length; i++) {\n    truthyIdxs[idxs[i]!] = true;\n  }\n\n  let onlyStepToRun: Extract<StepFlowEntry, { type: 'step' }> | undefined;\n\n  if (perStep) {\n    const stepsToRun = step.steps.filter((_, idx) => truthyIdxs[idx]);\n    onlyStepToRun = stepsToRun[0];\n  }\n\n  if (onlyStepToRun) {\n    activeSteps[onlyStepToRun.step.id] = true;\n    const stepIndex = step.steps.findIndex(step => step.step.id === onlyStepToRun.step.id);\n    await pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        workflowId,\n        runId,\n        executionPath: executionPath.concat([stepIndex]),\n        resumeSteps,\n        stepResults,\n        timeTravel,\n        prevResult,\n        resumeData,\n        parentWorkflow,\n        activeSteps,\n        requestContext,\n        perStep,\n      },\n    });\n  } else {\n    await Promise.all(\n      step.steps.map(async (step, idx) => {\n        if (truthyIdxs[idx]) {\n          if (step?.type === 'step') {\n            activeSteps[step.step.id] = true;\n          }\n          return pubsub.publish('workflows', {\n            type: 'workflow.step.run',\n            runId,\n            data: {\n              workflowId,\n              runId,\n              executionPath: executionPath.concat([idx]),\n              resumeSteps,\n              stepResults,\n              timeTravel,\n              prevResult,\n              resumeData,\n              parentWorkflow,\n              activeSteps,\n              requestContext,\n              perStep,\n            },\n          });\n        } else {\n          return pubsub.publish('workflows', {\n            type: 'workflow.step.end',\n            runId,\n            data: {\n              workflowId,\n              runId,\n              executionPath: executionPath.concat([idx]),\n              resumeSteps,\n              stepResults,\n              prevResult: { status: 'skipped' },\n              resumeData,\n              parentWorkflow,\n              activeSteps,\n              requestContext,\n              perStep,\n            },\n          });\n        }\n      }),\n    );\n  }\n}\n","import EventEmitter from 'node:events';\nimport type { StepFlowEntry, WorkflowRunState } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport type { StepExecutor } from '../step-executor';\nimport { getStep } from './utils';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowWaitForEvent(\n  workflowData: ProcessorArgs,\n  {\n    pubsub,\n    eventName,\n    currentState,\n  }: {\n    pubsub: PubSub;\n    eventName: string;\n    currentState: WorkflowRunState;\n  },\n) {\n  const executionPath = currentState?.waitingPaths[eventName];\n  if (!executionPath) {\n    return;\n  }\n\n  const currentStep = getStep(workflowData.workflow, executionPath);\n  const prevResult = {\n    status: 'success',\n    output: currentState?.context[currentStep?.id ?? 'input']?.payload,\n  };\n\n  await pubsub.publish('workflows', {\n    type: 'workflow.step.run',\n    runId: workflowData.runId,\n    data: {\n      workflowId: workflowData.workflowId,\n      runId: workflowData.runId,\n      executionPath,\n      resumeSteps: [],\n      resumeData: workflowData.resumeData,\n      parentWorkflow: workflowData.parentWorkflow,\n      stepResults: currentState?.context,\n      prevResult,\n      activeSteps: [],\n      requestContext: currentState?.requestContext,\n      perStep: workflowData.perStep,\n    },\n  });\n}\n\nexport async function processWorkflowSleep(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'sleep' }>;\n  },\n) {\n  const startedAt = Date.now();\n  await pubsub.publish(`workflow.events.v2.${runId}`, {\n    type: 'watch',\n    runId,\n    data: {\n      type: 'workflow-step-waiting',\n      payload: {\n        id: step.id,\n        status: 'waiting',\n        payload: prevResult.status === 'success' ? prevResult.output : undefined,\n        startedAt,\n      },\n    },\n  });\n\n  const duration = await stepExecutor.resolveSleep({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    emitter: new EventEmitter() as any, // TODO\n    requestContext: new RequestContext(), // TODO\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  setTimeout(\n    async () => {\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.id,\n            status: 'success',\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            output: prevResult.status === 'success' ? prevResult.output : undefined,\n            startedAt,\n            endedAt: Date.now(),\n          },\n        },\n      });\n\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-finish',\n          payload: {\n            id: step.id,\n            metadata: {},\n          },\n        },\n      });\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          timeTravel,\n          stepResults,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    },\n    duration < 0 ? 0 : duration,\n  );\n}\n\nexport async function processWorkflowSleepUntil(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'sleepUntil' }>;\n  },\n) {\n  const startedAt = Date.now();\n  const duration = await stepExecutor.resolveSleepUntil({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    emitter: new EventEmitter() as any, // TODO\n    requestContext: new RequestContext(), // TODO\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  await pubsub.publish(`workflow.events.v2.${runId}`, {\n    type: 'watch',\n    runId,\n    data: {\n      type: 'workflow-step-waiting',\n      payload: {\n        id: step.id,\n        status: 'waiting',\n        payload: prevResult.status === 'success' ? prevResult.output : undefined,\n        startedAt,\n      },\n    },\n  });\n\n  setTimeout(\n    async () => {\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.id,\n            status: 'success',\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            output: prevResult.status === 'success' ? prevResult.output : undefined,\n            startedAt,\n            endedAt: Date.now(),\n          },\n        },\n      });\n\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-finish',\n          payload: {\n            id: step.id,\n            metadata: {},\n          },\n        },\n      });\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          timeTravel,\n          stepResults,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    },\n    duration < 0 ? 0 : duration,\n  );\n}\n","import { randomUUID } from 'node:crypto';\nimport EventEmitter from 'node:events';\nimport { ErrorCategory, ErrorDomain, MastraError, getErrorFromUnknown } from '../../../error';\nimport { EventProcessor } from '../../../events/processor';\nimport type { Event } from '../../../events/types';\nimport type { Mastra } from '../../../mastra';\nimport { RequestContext } from '../../../request-context/';\nimport type {\n  StepFlowEntry,\n  StepResult,\n  StepSuccess,\n  TimeTravelExecutionParams,\n  WorkflowRunState,\n} from '../../../workflows/types';\nimport type { Workflow } from '../../../workflows/workflow';\nimport { createTimeTravelExecutionParams, validateStepResumeData } from '../../utils';\nimport { StepExecutor } from '../step-executor';\nimport { EventedWorkflow } from '../workflow';\nimport { processWorkflowForEach, processWorkflowLoop } from './loop';\nimport { processWorkflowConditional, processWorkflowParallel } from './parallel';\nimport { processWorkflowSleep, processWorkflowSleepUntil, processWorkflowWaitForEvent } from './sleep';\nimport { getNestedWorkflow, getStep, isExecutableStep } from './utils';\n\nexport type ProcessorArgs = {\n  activeSteps: Record<string, boolean>;\n  workflow: Workflow;\n  workflowId: string;\n  runId: string;\n  executionPath: number[];\n  stepResults: Record<string, StepResult<any, any, any, any>>;\n  resumeSteps: string[];\n  prevResult: StepResult<any, any, any, any>;\n  requestContext: Record<string, any>;\n  timeTravel?: TimeTravelExecutionParams;\n  resumeData?: any;\n  parentWorkflow?: ParentWorkflow;\n  parentContext?: {\n    workflowId: string;\n    input: any;\n  };\n  retryCount?: number;\n  perStep?: boolean;\n};\n\nexport type ParentWorkflow = {\n  workflowId: string;\n  runId: string;\n  executionPath: number[];\n  resume: boolean;\n  stepResults: Record<string, StepResult<any, any, any, any>>;\n  parentWorkflow?: ParentWorkflow;\n  stepId: string;\n};\n\nexport class WorkflowEventProcessor extends EventProcessor {\n  private stepExecutor: StepExecutor;\n  // Map of runId -> AbortController for active workflow runs\n  private abortControllers: Map<string, AbortController> = new Map();\n  // Map of child runId -> parent runId for tracking nested workflows\n  private parentChildRelationships: Map<string, string> = new Map();\n\n  constructor({ mastra }: { mastra: Mastra }) {\n    super({ mastra });\n    this.stepExecutor = new StepExecutor({ mastra });\n  }\n\n  /**\n   * Get or create an AbortController for a workflow run\n   */\n  private getOrCreateAbortController(runId: string): AbortController {\n    let controller = this.abortControllers.get(runId);\n    if (!controller) {\n      controller = new AbortController();\n      this.abortControllers.set(runId, controller);\n    }\n    return controller;\n  }\n\n  /**\n   * Cancel a workflow run and all its nested child workflows\n   */\n  private cancelRunAndChildren(runId: string): void {\n    // Abort the controller for this run\n    const controller = this.abortControllers.get(runId);\n    if (controller) {\n      controller.abort();\n    }\n\n    // Find and cancel all child workflows\n    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {\n      if (parentRunId === runId) {\n        this.cancelRunAndChildren(childRunId);\n      }\n    }\n  }\n\n  /**\n   * Clean up abort controller and relationships when a workflow completes.\n   * Also cleans up any orphaned child entries that reference this run as parent.\n   */\n  private cleanupRun(runId: string): void {\n    this.abortControllers.delete(runId);\n    this.parentChildRelationships.delete(runId);\n\n    // Clean up any orphaned child entries pointing to this run as their parent\n    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {\n      if (parentRunId === runId) {\n        this.parentChildRelationships.delete(childRunId);\n      }\n    }\n  }\n\n  __registerMastra(mastra: Mastra) {\n    super.__registerMastra(mastra);\n    this.stepExecutor.__registerMastra(mastra);\n  }\n\n  private async errorWorkflow(\n    {\n      parentWorkflow,\n      workflowId,\n      runId,\n      resumeSteps,\n      stepResults,\n      resumeData,\n      requestContext,\n    }: Omit<ProcessorArgs, 'workflow'>,\n    e: Error,\n  ) {\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.fail',\n      runId,\n      data: {\n        workflowId,\n        runId,\n        executionPath: [],\n        resumeSteps,\n        stepResults,\n        prevResult: { status: 'failed', error: getErrorFromUnknown(e).toJSON() },\n        requestContext,\n        resumeData,\n        activeSteps: {},\n        parentWorkflow: parentWorkflow,\n      },\n    });\n  }\n\n  protected async processWorkflowCancel({ workflowId, runId }: ProcessorArgs) {\n    // Cancel this workflow and all nested child workflows\n    this.cancelRunAndChildren(runId);\n\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const currentState = await workflowsStore?.loadWorkflowSnapshot({\n      workflowName: workflowId,\n      runId,\n    });\n\n    if (!currentState) {\n      this.mastra.getLogger()?.warn('Canceling workflow without loaded state', { workflowId, runId });\n    }\n\n    await this.endWorkflow(\n      {\n        workflow: undefined as any,\n        workflowId,\n        runId,\n        stepResults: (currentState?.context ?? {}) as any,\n        prevResult: { status: 'canceled' } as any,\n        requestContext: (currentState?.requestContext ?? {}) as any,\n        executionPath: [],\n        activeSteps: {},\n        resumeSteps: [],\n        resumeData: undefined,\n        parentWorkflow: undefined,\n      },\n      'canceled',\n    );\n  }\n\n  protected async processWorkflowStart({\n    workflow,\n    parentWorkflow,\n    workflowId,\n    runId,\n    resumeSteps,\n    prevResult,\n    resumeData,\n    timeTravel,\n    executionPath,\n    stepResults,\n    requestContext,\n    perStep,\n  }: ProcessorArgs) {\n    // Create abort controller for this workflow run\n    this.getOrCreateAbortController(runId);\n\n    // Track parent-child relationship if this is a nested workflow\n    if (parentWorkflow?.runId) {\n      this.parentChildRelationships.set(runId, parentWorkflow.runId);\n    }\n    // Preserve resourceId from existing snapshot if present\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const existingRun = await workflowsStore?.getWorkflowRunById({ runId, workflowName: workflow.id });\n    const resourceId = existingRun?.resourceId;\n\n    await workflowsStore?.persistWorkflowSnapshot({\n      workflowName: workflow.id,\n      runId,\n      resourceId,\n      snapshot: {\n        activePaths: [],\n        suspendedPaths: {},\n        resumeLabels: {},\n        waitingPaths: {},\n        activeStepsPath: {},\n        serializedStepGraph: workflow.serializedStepGraph,\n        timestamp: Date.now(),\n        runId,\n        context: stepResults ?? {\n          input: prevResult?.status === 'success' ? prevResult.output : undefined,\n        },\n        status: 'running',\n        value: {},\n      },\n    });\n\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath: executionPath ?? [0],\n        resumeSteps,\n        stepResults: stepResults ?? {\n          input: prevResult?.status === 'success' ? prevResult.output : undefined,\n        },\n        prevResult,\n        timeTravel,\n        requestContext,\n        resumeData,\n        activeSteps: {},\n        perStep,\n      },\n    });\n  }\n\n  protected async endWorkflow(args: ProcessorArgs, status: 'success' | 'failed' | 'canceled' | 'paused' = 'success') {\n    const { workflowId, runId, prevResult, perStep } = args;\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    await workflowsStore?.updateWorkflowState({\n      workflowName: workflowId,\n      runId,\n      opts: {\n        status: perStep && status === 'success' ? 'paused' : status,\n        result: prevResult,\n      },\n    });\n\n    if (perStep) {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-paused',\n          payload: {},\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n      type: 'watch',\n      runId,\n      data: {\n        type: 'workflow-finish',\n        payload: {\n          runId,\n        },\n      },\n    });\n\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.end',\n      runId,\n      data: { ...args, workflow: undefined },\n    });\n  }\n\n  protected async processWorkflowEnd(args: ProcessorArgs) {\n    const {\n      resumeSteps,\n      prevResult,\n      resumeData,\n      parentWorkflow,\n      activeSteps,\n      requestContext,\n      runId,\n      timeTravel,\n      perStep,\n    } = args;\n\n    // Clean up abort controller and parent-child tracking\n    this.cleanupRun(runId);\n\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult,\n          resumeData,\n          activeSteps,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n          requestContext,\n          timeTravel,\n          perStep,\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.end',\n      runId,\n      data: { ...args, workflow: undefined },\n    });\n  }\n\n  protected async processWorkflowSuspend(args: ProcessorArgs) {\n    const { resumeSteps, prevResult, resumeData, parentWorkflow, activeSteps, runId, requestContext, timeTravel } =\n      args;\n\n    // TODO: if there are still active paths don't end the workflow yet\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult: {\n            ...prevResult,\n            suspendPayload: {\n              ...prevResult.suspendPayload,\n              __workflow_meta: {\n                runId: runId,\n                path: parentWorkflow?.stepId\n                  ? [parentWorkflow.stepId].concat(prevResult.suspendPayload?.__workflow_meta?.path ?? [])\n                  : (prevResult.suspendPayload?.__workflow_meta?.path ?? []),\n              },\n            },\n          },\n          timeTravel,\n          resumeData,\n          activeSteps,\n          requestContext,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.suspend',\n      runId,\n      data: { ...args, workflow: undefined },\n    });\n  }\n\n  protected async processWorkflowFail(args: ProcessorArgs) {\n    const {\n      workflowId,\n      runId,\n      resumeSteps,\n      prevResult,\n      resumeData,\n      parentWorkflow,\n      activeSteps,\n      requestContext,\n      timeTravel,\n    } = args;\n\n    // Clean up abort controller and parent-child tracking\n    this.cleanupRun(runId);\n\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    await workflowsStore?.updateWorkflowState({\n      workflowName: workflowId,\n      runId,\n      opts: {\n        status: 'failed',\n        error: (prevResult as any).error,\n      },\n    });\n\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult,\n          timeTravel,\n          resumeData,\n          activeSteps,\n          requestContext,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.fail',\n      runId,\n      data: { ...args, workflow: undefined },\n    });\n  }\n\n  protected async processWorkflowStepRun({\n    workflow,\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    retryCount = 0,\n    perStep,\n  }: ProcessorArgs) {\n    let stepGraph: StepFlowEntry[] = workflow.stepGraph;\n\n    if (!executionPath?.length) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Execution path is empty: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    let step: StepFlowEntry | undefined = stepGraph[executionPath[0]!];\n\n    if (!step) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step not found in step graph: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    if ((step.type === 'parallel' || step.type === 'conditional') && executionPath.length > 1) {\n      step = step.steps[executionPath[1]!] as StepFlowEntry;\n    } else if (step.type === 'parallel') {\n      return processWorkflowParallel(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          step,\n        },\n      );\n    } else if (step?.type === 'conditional') {\n      return processWorkflowConditional(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'sleep') {\n      return processWorkflowSleep(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'sleepUntil') {\n      return processWorkflowSleepUntil(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'foreach' && executionPath.length === 1) {\n      return processWorkflowForEach(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          mastra: this.mastra,\n          step,\n        },\n      );\n    }\n\n    if (!isExecutableStep(step)) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step is not executable: ${step?.type} -- ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    activeSteps[step.step.id] = true;\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n\n    // Run nested workflow\n    if (step.step instanceof EventedWorkflow) {\n      if (resumeSteps?.length > 1) {\n        const stepData = stepResults[step.step.id];\n        const nestedRunId = stepData?.suspendPayload?.__workflow_meta?.runId;\n        if (!nestedRunId) {\n          return this.errorWorkflow(\n            {\n              workflowId,\n              runId,\n              executionPath,\n              stepResults,\n              activeSteps,\n              resumeSteps,\n              prevResult,\n              resumeData,\n              parentWorkflow,\n              requestContext,\n            },\n            new MastraError({\n              id: 'MASTRA_WORKFLOW',\n              text: `Nested workflow run id not found: ${JSON.stringify(stepResults)}`,\n              domain: ErrorDomain.MASTRA_WORKFLOW,\n              category: ErrorCategory.SYSTEM,\n            }),\n          );\n        }\n\n        const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n          workflowName: step.step.id,\n          runId: nestedRunId,\n        });\n\n        const nestedStepResults = snapshot?.context;\n        const nestedSteps = resumeSteps.slice(1);\n\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.resume',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: snapshot?.suspendedPaths?.[nestedSteps[0]!] as any,\n            runId: nestedRunId,\n            resumeSteps: nestedSteps,\n            stepResults: nestedStepResults,\n            prevResult,\n            resumeData,\n            activeSteps,\n            requestContext,\n            perStep,\n          },\n        });\n      } else if (timeTravel && timeTravel.steps?.length > 1 && timeTravel.steps[0] === step.step.id) {\n        const snapshot =\n          (await workflowsStore?.loadWorkflowSnapshot({\n            workflowName: step.step.id,\n            runId,\n          })) ?? ({ context: {} } as WorkflowRunState);\n\n        const timeTravelParams = createTimeTravelExecutionParams({\n          steps: timeTravel.steps.slice(1),\n          inputData: timeTravel.inputData,\n          resumeData: timeTravel.resumeData,\n          context: (timeTravel.nestedStepResults?.[step.step.id] ?? {}) as any,\n          nestedStepsContext: (timeTravel.nestedStepResults ?? {}) as any,\n          snapshot,\n          graph: step.step.buildExecutionGraph(),\n          perStep,\n        });\n\n        // @ts-ignore\n        const nestedPrevStep = getStep(step.step, timeTravelParams.executionPath);\n        const nestedPrevResult = timeTravelParams.stepResults[nestedPrevStep?.id ?? 'input'];\n\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              timeTravel,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: timeTravelParams.executionPath,\n            runId: randomUUID(),\n            stepResults: timeTravelParams.stepResults,\n            prevResult: { status: 'success', output: nestedPrevResult?.payload },\n            timeTravel: timeTravelParams,\n            activeSteps,\n            requestContext,\n            perStep,\n          },\n        });\n      } else {\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: [0],\n            runId: randomUUID(),\n            resumeSteps,\n            prevResult,\n            resumeData,\n            activeSteps,\n            requestContext,\n            perStep,\n          },\n        });\n      }\n\n      return;\n    }\n\n    if (step.type === 'step') {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-start',\n          payload: {\n            id: step.step.id,\n            startedAt: Date.now(),\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            status: 'running',\n          },\n        },\n      });\n    }\n\n    const ee = new EventEmitter();\n    ee.on('watch', async (event: any) => {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: event,\n      });\n    });\n    const rc = new RequestContext();\n    for (const [key, value] of Object.entries(requestContext)) {\n      rc.set(key, value);\n    }\n    const { resumeData: timeTravelResumeData, validationError: timeTravelResumeValidationError } =\n      await validateStepResumeData({\n        resumeData: timeTravel?.stepResults[step.step.id]?.status === 'suspended' ? timeTravel?.resumeData : undefined,\n        step: step.step,\n      });\n\n    let resumeDataToUse;\n    if (timeTravelResumeData && !timeTravelResumeValidationError) {\n      resumeDataToUse = timeTravelResumeData;\n    } else if (timeTravelResumeData && timeTravelResumeValidationError) {\n      this.mastra.getLogger()?.warn('Time travel resume data validation failed', {\n        stepId: step.step.id,\n        error: timeTravelResumeValidationError.message,\n      });\n    } else if (resumeSteps?.length > 0 && resumeSteps?.[0] === step.step.id) {\n      resumeDataToUse = resumeData;\n    }\n\n    // Get the abort controller for this workflow run\n    const abortController = this.getOrCreateAbortController(runId);\n\n    const stepResult = await this.stepExecutor.execute({\n      workflowId,\n      step: step.step,\n      runId,\n      stepResults,\n      // TODO: implement state\n      state: {},\n      emitter: ee,\n      requestContext: rc,\n      input: (prevResult as any)?.output,\n      resumeData: resumeDataToUse,\n      retryCount,\n      foreachIdx: step.type === 'foreach' ? executionPath[1] : undefined,\n      validateInputs: workflow.options.validateInputs,\n      abortController,\n      perStep,\n    });\n    requestContext = Object.fromEntries(rc.entries());\n\n    // @ts-ignore\n    if (stepResult.status === 'bailed') {\n      // @ts-ignore\n      stepResult.status = 'success';\n\n      await this.endWorkflow({\n        workflow,\n        resumeData,\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath,\n        resumeSteps,\n        stepResults: {\n          ...stepResults,\n          [step.step.id]: stepResult,\n        },\n        prevResult: stepResult,\n        activeSteps,\n        requestContext,\n        perStep,\n      });\n      return;\n    }\n\n    if (stepResult.status === 'failed') {\n      const retries = step.step.retries ?? workflow.retryConfig.attempts ?? 0;\n      if (retryCount >= retries) {\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.step.end',\n          runId,\n          data: {\n            parentWorkflow,\n            workflowId,\n            runId,\n            executionPath,\n            resumeSteps,\n            stepResults,\n            prevResult: stepResult,\n            activeSteps,\n            requestContext,\n          },\n        });\n      } else {\n        return this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.step.run',\n          runId,\n          data: {\n            parentWorkflow,\n            workflowId,\n            runId,\n            executionPath,\n            resumeSteps,\n            stepResults,\n            timeTravel,\n            prevResult,\n            activeSteps,\n            requestContext,\n            retryCount: retryCount + 1,\n          },\n        });\n      }\n    }\n\n    if (step.type === 'loop') {\n      //timeTravel is not passed to the processWorkflowLoop function becuase the step already ran the first time\n      // with whatever information it needs from timeTravel, subsequent loop runs use the previous loop run result as it's input.\n      await processWorkflowLoop(\n        {\n          workflow,\n          workflowId,\n          prevResult: stepResult,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          retryCount: retryCount + 1,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n          stepResult,\n        },\n      );\n    } else {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          timeTravel, //timeTravel is passed in as workflow.step.end ends the step, not the workflow, the timeTravel info is passed to the next step to run.\n          stepResults,\n          prevResult: stepResult,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    }\n  }\n\n  protected async processWorkflowStepEnd({\n    workflow,\n    workflowId,\n    runId,\n    executionPath,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    parentWorkflow,\n    stepResults,\n    activeSteps,\n    parentContext,\n    requestContext,\n    perStep,\n  }: ProcessorArgs) {\n    let step = workflow.stepGraph[executionPath[0]!];\n\n    if ((step?.type === 'parallel' || step?.type === 'conditional') && executionPath.length > 1) {\n      step = step.steps[executionPath[1]!];\n    }\n\n    if (!step) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          prevResult,\n          stepResults,\n          activeSteps,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step not found: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    // Cache workflows store to avoid redundant async calls\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n\n    if (step.type === 'foreach') {\n      const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n        workflowName: workflowId,\n        runId,\n      });\n\n      const currentIdx = executionPath[1];\n      const currentResult = (snapshot?.context?.[step.step.id] as any)?.output;\n\n      let newResult = prevResult;\n      if (currentIdx !== undefined) {\n        if (currentResult) {\n          currentResult[currentIdx] = (prevResult as any).output;\n          newResult = { ...prevResult, output: currentResult } as any;\n        } else {\n          newResult = { ...prevResult, output: [(prevResult as any).output] } as any;\n        }\n      }\n      const newStepResults = await workflowsStore?.updateWorkflowResults({\n        workflowName: workflow.id,\n        runId,\n        stepId: step.step.id,\n        result: newResult,\n        requestContext,\n      });\n\n      if (!newStepResults) {\n        return;\n      }\n\n      stepResults = newStepResults;\n    } else if (isExecutableStep(step)) {\n      // clear from activeSteps\n      delete activeSteps[step.step.id];\n\n      // handle nested workflow\n      if (parentContext) {\n        prevResult = stepResults[step.step.id] = {\n          ...prevResult,\n          payload: parentContext.input?.output ?? {},\n        };\n      }\n\n      const newStepResults = await workflowsStore?.updateWorkflowResults({\n        workflowName: workflow.id,\n        runId,\n        stepId: step.step.id,\n        result: prevResult,\n        requestContext,\n      });\n\n      if (!newStepResults) {\n        return;\n      }\n\n      stepResults = newStepResults;\n    }\n\n    if (!prevResult?.status || prevResult.status === 'failed') {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.fail',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          timeTravel,\n          prevResult,\n          activeSteps,\n          requestContext,\n        },\n      });\n\n      return;\n    } else if (prevResult.status === 'suspended') {\n      const suspendedPaths: Record<string, number[]> = {};\n      const suspendedStep = getStep(workflow, executionPath);\n      if (suspendedStep) {\n        suspendedPaths[suspendedStep.id] = executionPath;\n      }\n\n      await workflowsStore?.updateWorkflowState({\n        workflowName: workflowId,\n        runId,\n        opts: {\n          status: 'suspended',\n          result: prevResult,\n          suspendedPaths,\n        },\n      });\n\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.suspend',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          timeTravel,\n        },\n      });\n\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-suspended',\n          payload: {\n            id: (step as any)?.step?.id,\n            ...prevResult,\n            suspendedAt: Date.now(),\n            suspendPayload: prevResult.suspendPayload,\n          },\n        },\n      });\n\n      return;\n    }\n\n    if (step?.type === 'step') {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.step.id,\n            ...prevResult,\n          },\n        },\n      });\n\n      if (prevResult.status === 'success') {\n        await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n          type: 'watch',\n          runId,\n          data: {\n            type: 'workflow-step-finish',\n            payload: {\n              id: step.step.id,\n              metadata: {},\n            },\n          },\n        });\n      }\n    }\n\n    step = workflow.stepGraph[executionPath[0]!];\n    if (perStep) {\n      if (parentWorkflow && executionPath[0]! < workflow.stepGraph.length - 1) {\n        const { endedAt, output, status, ...nestedPrevResult } = prevResult as StepSuccess<any, any, any, any>;\n        await this.endWorkflow({\n          workflow,\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: { ...nestedPrevResult, status: 'paused' },\n          activeSteps,\n          requestContext,\n          perStep,\n        });\n      } else {\n        await this.endWorkflow({\n          workflow,\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          perStep,\n        });\n      }\n    } else if ((step?.type === 'parallel' || step?.type === 'conditional') && executionPath.length > 1) {\n      let skippedCount = 0;\n      const allResults: Record<string, any> = step.steps.reduce(\n        (acc, step) => {\n          if (isExecutableStep(step)) {\n            const res = stepResults?.[step.step.id];\n            if (res && res.status === 'success') {\n              acc[step.step.id] = res?.output;\n              // @ts-ignore\n            } else if (res?.status === 'skipped') {\n              skippedCount++;\n            }\n          }\n\n          return acc;\n        },\n        {} as Record<string, StepResult<any, any, any, any>>,\n      );\n\n      const keys = Object.keys(allResults);\n      if (keys.length + skippedCount < step.steps.length) {\n        return;\n      }\n\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1),\n          resumeSteps,\n          stepResults,\n          prevResult: { status: 'success', output: allResults },\n          activeSteps,\n          requestContext,\n          timeTravel,\n        },\n      });\n    } else if (step?.type === 'foreach') {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1),\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult: { ...prevResult, output: prevResult?.payload },\n          activeSteps,\n          requestContext,\n          timeTravel,\n        },\n      });\n    } else if (executionPath[0]! >= workflow.stepGraph.length - 1) {\n      await this.endWorkflow({\n        workflow,\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath,\n        resumeSteps,\n        stepResults,\n        prevResult,\n        activeSteps,\n        requestContext,\n      });\n    } else {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          timeTravel,\n        },\n      });\n    }\n  }\n\n  async loadData({\n    workflowId,\n    runId,\n  }: {\n    workflowId: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null | undefined> {\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n      workflowName: workflowId,\n      runId,\n    });\n\n    return snapshot;\n  }\n\n  async process(event: Event, ack?: () => Promise<void>) {\n    const { type, data } = event;\n\n    const workflowData = data as Omit<ProcessorArgs, 'workflow'>;\n\n    const currentState = await this.loadData({\n      workflowId: workflowData.workflowId,\n      runId: workflowData.runId,\n    });\n\n    if (currentState?.status === 'canceled' && type !== 'workflow.end' && type !== 'workflow.cancel') {\n      return;\n    }\n\n    if (type.startsWith('workflow.user-event.')) {\n      await processWorkflowWaitForEvent(\n        {\n          ...workflowData,\n          workflow: this.mastra.getWorkflow(workflowData.workflowId),\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          eventName: type.split('.').slice(2).join('.'),\n          currentState: currentState!,\n        },\n      );\n      return;\n    }\n\n    let workflow;\n    if (this.mastra.__hasInternalWorkflow(workflowData.workflowId)) {\n      workflow = this.mastra.__getInternalWorkflow(workflowData.workflowId);\n    } else if (workflowData.parentWorkflow) {\n      workflow = getNestedWorkflow(this.mastra, workflowData.parentWorkflow);\n    } else {\n      workflow = this.mastra.getWorkflow(workflowData.workflowId);\n    }\n\n    if (!workflow) {\n      return this.errorWorkflow(\n        workflowData,\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Workflow not found: ${workflowData.workflowId}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    if (type === 'workflow.start' || type === 'workflow.resume') {\n      const { runId } = workflowData;\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-start',\n          payload: {\n            runId,\n          },\n        },\n      });\n    }\n\n    switch (type) {\n      case 'workflow.cancel':\n        await this.processWorkflowCancel({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.start':\n        await this.processWorkflowStart({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.resume':\n        await this.processWorkflowStart({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.end':\n        await this.processWorkflowEnd({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.step.end':\n        await this.processWorkflowStepEnd({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.step.run':\n        await this.processWorkflowStepRun({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.suspend':\n        await this.processWorkflowSuspend({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.fail':\n        await this.processWorkflowFail({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      default:\n        break;\n    }\n\n    try {\n      await ack?.();\n    } catch (e) {\n      this.mastra.getLogger()?.error('Error acking event', e);\n    }\n  }\n}\n","import { randomUUID } from 'node:crypto';\nimport type { CoreMessage } from '@internal/ai-sdk-v4';\nimport { z } from 'zod';\nimport { Agent } from '../../agent';\nimport type { MastraDBMessage } from '../../agent';\nimport { MessageList } from '../../agent/message-list';\nimport { TripWire } from '../../agent/trip-wire';\nimport { RequestContext } from '../../di';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../error';\nimport type { MastraScorers } from '../../evals';\nimport type { Event } from '../../events';\nimport type { Mastra } from '../../mastra';\nimport type { TracingContext } from '../../observability';\nimport { EntityType, SpanType } from '../../observability';\nimport type { Processor } from '../../processors';\nimport { ProcessorRunner, ProcessorStepOutputSchema, ProcessorStepSchema } from '../../processors';\nimport type { ProcessorStepOutput } from '../../processors/step-schema';\nimport type { InferSchemaOutput, SchemaWithValidation } from '../../stream/base/schema';\nimport type { ChunkType } from '../../stream/types';\nimport { Tool } from '../../tools';\nimport type { ToolExecutionContext } from '../../tools/types';\nimport type { DynamicArgument } from '../../types';\nimport { Workflow, Run } from '../../workflows';\nimport type { AgentStepOptions } from '../../workflows';\nimport type { ExecutionEngine, ExecutionGraph } from '../../workflows/execution-engine';\nimport type { Step } from '../../workflows/step';\nimport type {\n  SerializedStepFlowEntry,\n  WorkflowConfig,\n  WorkflowResult,\n  StepWithComponent,\n  WorkflowStreamEvent,\n  WorkflowEngineType,\n  StepParams,\n  ToolStep,\n  DefaultEngineType,\n} from '../../workflows/types';\nimport { PUBSUB_SYMBOL } from '../constants';\nimport { EventedExecutionEngine } from './execution-engine';\nimport { WorkflowEventProcessor } from './workflow-event-processor';\n\nexport type EventedEngineType = {};\n\nexport function cloneWorkflow<\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    any,\n    EventedEngineType\n  >[],\n  TPrevSchema = TInput,\n>(\n  workflow: Workflow<EventedEngineType, TSteps, string, TState, TInput, TOutput, TPrevSchema>,\n  opts: { id: TWorkflowId },\n): Workflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {\n  const wf: Workflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> = new Workflow({\n    id: opts.id,\n    inputSchema: workflow.inputSchema,\n    outputSchema: workflow.outputSchema,\n    steps: workflow.stepDefs,\n    mastra: workflow.mastra,\n    options: workflow.options,\n  });\n\n  wf.setStepFlow(workflow.stepGraph);\n  wf.commit();\n  return wf;\n}\n\nexport function cloneStep<TStepId extends string>(\n  step: Step<string, any, any, any, any, any, EventedEngineType>,\n  opts: { id: TStepId },\n): Step<TStepId, any, any, any, any, any, EventedEngineType> {\n  return {\n    id: opts.id,\n    description: step.description,\n    inputSchema: step.inputSchema,\n    outputSchema: step.outputSchema,\n    suspendSchema: step.suspendSchema,\n    resumeSchema: step.resumeSchema,\n    stateSchema: step.stateSchema,\n    execute: step.execute,\n    retries: step.retries,\n    scorers: step.scorers,\n    component: step.component,\n  };\n}\n\n// ============================================\n// Type Guards\n// ============================================\n\nfunction isAgent<TStepId extends string>(input: unknown): input is Agent<TStepId, any> {\n  return input instanceof Agent;\n}\n\nfunction isToolStep(input: unknown): input is ToolStep<any, any, any, any, any> {\n  return input instanceof Tool;\n}\n\nfunction isStepParams(input: unknown): input is StepParams<any, any, any, any, any, any> {\n  return (\n    input !== null &&\n    typeof input === 'object' &&\n    'id' in input &&\n    'execute' in input &&\n    !(input instanceof Agent) &&\n    !(input instanceof Tool)\n  );\n}\n\n/**\n * Type guard to check if an object is a Processor.\n * A Processor must have an 'id' property and at least one processor method.\n */\nfunction isProcessor(obj: unknown): obj is Processor {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    'id' in obj &&\n    typeof (obj as any).id === 'string' &&\n    !(obj instanceof Agent) &&\n    !(obj instanceof Tool) &&\n    (typeof (obj as any).processInput === 'function' ||\n      typeof (obj as any).processInputStep === 'function' ||\n      typeof (obj as any).processOutputStream === 'function' ||\n      typeof (obj as any).processOutputResult === 'function' ||\n      typeof (obj as any).processOutputStep === 'function')\n  );\n}\n\n// ============================================\n// Overloads (Public API - clean types for consumers)\n// ============================================\n\n/**\n * Creates a step from explicit params (FIRST overload for best error messages)\n * @param params Configuration parameters for the step\n * @param params.id Unique identifier for the step\n * @param params.description Optional description of what the step does\n * @param params.inputSchema Zod schema defining the input structure\n * @param params.outputSchema Zod schema defining the output structure\n * @param params.execute Function that performs the step's operations\n * @returns A Step object that can be added to the workflow\n */\nexport function createStep<\n  TStepId extends string,\n  TStateSchema extends z.ZodTypeAny | undefined,\n  TInputSchema extends z.ZodTypeAny,\n  TOutputSchema extends z.ZodTypeAny,\n  TResumeSchema extends z.ZodTypeAny | undefined = undefined,\n  TSuspendSchema extends z.ZodTypeAny | undefined = undefined,\n>(\n  params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>,\n): Step<\n  TStepId,\n  TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown,\n  z.infer<TInputSchema>,\n  z.infer<TOutputSchema>,\n  TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown,\n  TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown,\n  DefaultEngineType\n>;\n\n/**\n * Creates a step from an agent with structured output\n */\nexport function createStep<TStepId extends string, TStepOutput>(\n  agent: Agent<TStepId, any>,\n  agentOptions: AgentStepOptions<TStepOutput> & {\n    structuredOutput: { schema: TStepOutput };\n    retries?: number;\n    scorers?: DynamicArgument<MastraScorers>;\n  },\n): Step<TStepId, unknown, { prompt: string }, TStepOutput, unknown, unknown, DefaultEngineType>;\n\n/**\n * Creates a step from an agent (defaults to { text: string } output)\n */\nexport function createStep<\n  TStepId extends string,\n  TStepInput extends { prompt: string },\n  TStepOutput extends { text: string },\n  TResume,\n  TSuspend,\n>(agent: Agent<TStepId, any>): Step<TStepId, any, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType>;\n\n/**\n * Creates a step from a tool\n */\nexport function createStep<\n  TSchemaIn,\n  TSuspend,\n  TResume,\n  TSchemaOut,\n  TContext extends ToolExecutionContext<TSuspend, TResume>,\n  TId extends string,\n>(\n  tool: Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId>,\n  toolOptions?: { retries?: number; scorers?: DynamicArgument<MastraScorers> },\n): Step<TId, any, TSchemaIn, TSchemaOut, TSuspend, TResume, DefaultEngineType>;\n\n/**\n * Creates a step from a Processor - wraps a Processor as a workflow step\n * Note: We require at least one processor method to distinguish from StepParams\n */\nexport function createStep<TProcessorId extends string>(\n  processor:\n    | (Processor<TProcessorId> & { processInput: Function })\n    | (Processor<TProcessorId> & { processInputStream: Function })\n    | (Processor<TProcessorId> & { processInputStep: Function })\n    | (Processor<TProcessorId> & { processOutputStream: Function })\n    | (Processor<TProcessorId> & { processOutputResult: Function })\n    | (Processor<TProcessorId> & { processOutputStep: Function }),\n): Step<\n  `processor:${TProcessorId}`,\n  unknown,\n  InferSchemaOutput<typeof ProcessorStepSchema>,\n  InferSchemaOutput<typeof ProcessorStepOutputSchema>,\n  unknown,\n  unknown,\n  DefaultEngineType\n>;\n\n/**\n * IMPORTANT: Fallback overload - provides better error messages when StepParams doesn't match\n * This should be LAST and will show clearer errors about what's wrong\n * This is a copy of first one, KEEP THIS IN SYNC!\n */\nexport function createStep<\n  TStepId extends string,\n  TStateSchema extends z.ZodTypeAny | undefined,\n  TInputSchema extends z.ZodTypeAny,\n  TOutputSchema extends z.ZodTypeAny,\n  TResumeSchema extends z.ZodTypeAny | undefined = undefined,\n  TSuspendSchema extends z.ZodTypeAny | undefined = undefined,\n>(\n  params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>,\n): Step<\n  TStepId,\n  TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown,\n  z.infer<TInputSchema>,\n  z.infer<TOutputSchema>,\n  TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown,\n  TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown,\n  DefaultEngineType\n>;\n\n// ============================================\n// Implementation (uses type guards for clean logic)\n// ============================================\n\nexport function createStep(params: any, agentOrToolOptions?: any): Step<any, any, any, any, any, any, any> {\n  // Type guards determine the correct factory function\n  // Overloads ensure type safety for consumers\n  if (isAgent(params)) {\n    return createStepFromAgent(params, agentOrToolOptions);\n  }\n\n  if (isToolStep(params)) {\n    return createStepFromTool(params, agentOrToolOptions);\n  }\n\n  if (isProcessor(params)) {\n    return createStepFromProcessor(params);\n  }\n\n  if (isStepParams(params)) {\n    return createStepFromParams(params);\n  }\n\n  throw new Error('Invalid input: expected StepParams, Agent, ToolStep, or Processor');\n}\n\n// ============================================\n// Internal Implementations\n// ============================================\n\nfunction createStepFromParams(\n  params: StepParams<any, any, any, any, any, any>,\n): Step<any, any, any, any, any, any, DefaultEngineType> {\n  return {\n    id: params.id,\n    description: params.description,\n    inputSchema: params.inputSchema,\n    stateSchema: params.stateSchema,\n    outputSchema: params.outputSchema,\n    resumeSchema: params.resumeSchema,\n    suspendSchema: params.suspendSchema,\n    scorers: params.scorers,\n    retries: params.retries,\n    execute: params.execute.bind(params),\n  };\n}\n\nfunction createStepFromAgent<TStepId extends string, TStepOutput>(\n  params: Agent<TStepId, any>,\n  agentOrToolOptions?: Record<string, unknown>,\n): Step<TStepId, any, any, TStepOutput, unknown, unknown, DefaultEngineType> {\n  const options = (agentOrToolOptions ?? {}) as\n    | (AgentStepOptions<TStepOutput> & { retries?: number; scorers?: DynamicArgument<MastraScorers> })\n    | undefined;\n  // Determine output schema based on structuredOutput option\n  const outputSchema = (options?.structuredOutput?.schema ??\n    z.object({ text: z.string() })) as unknown as SchemaWithValidation<TStepOutput>;\n  const { retries, scorers, ...agentOptions } = options ?? {};\n\n  return {\n    id: params.id,\n    description: params.getDescription(),\n    inputSchema: z.object({\n      prompt: z.string(),\n    }),\n    outputSchema,\n    retries,\n    scorers,\n    execute: async ({\n      inputData,\n      runId,\n      [PUBSUB_SYMBOL]: pubsub,\n      requestContext,\n      tracingContext,\n      abortSignal,\n      abort,\n    }) => {\n      // TODO: support stream\n      let streamPromise = {} as {\n        promise: Promise<string>;\n        resolve: (value: string) => void;\n        reject: (reason?: any) => void;\n      };\n\n      streamPromise.promise = new Promise((resolve, reject) => {\n        streamPromise.resolve = resolve;\n        streamPromise.reject = reject;\n      });\n      // TODO: should use regular .stream()\n      const { fullStream } = await params.streamLegacy((inputData as { prompt: string }).prompt, {\n        ...(agentOptions ?? {}),\n        tracingContext,\n        requestContext,\n        onFinish: result => {\n          streamPromise.resolve(result.text);\n        },\n        abortSignal,\n      });\n\n      if (abortSignal.aborted) {\n        return abort() as TStepOutput;\n      }\n\n      const toolData = {\n        name: params.name,\n        args: inputData,\n      };\n\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: { type: 'tool-call-streaming-start', ...(toolData ?? {}) },\n      });\n      for await (const chunk of fullStream) {\n        if (chunk.type === 'text-delta') {\n          await pubsub.publish(`workflow.events.v2.${runId}`, {\n            type: 'watch',\n            runId,\n            data: { type: 'tool-call-delta', ...(toolData ?? {}), argsTextDelta: chunk.textDelta },\n          });\n        }\n      }\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: { type: 'tool-call-streaming-finish', ...(toolData ?? {}) },\n      });\n\n      return {\n        text: await streamPromise.promise,\n      } as TStepOutput;\n    },\n    component: params.component,\n  };\n}\n\nfunction createStepFromTool<TStepInput, TSuspend, TResume, TStepOutput>(\n  params: ToolStep<TStepInput, TSuspend, TResume, TStepOutput, any>,\n  agentOrToolOptions?: Record<string, unknown>,\n): Step<string, any, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType> {\n  const toolOpts = agentOrToolOptions as { retries?: number; scorers?: DynamicArgument<MastraScorers> } | undefined;\n  if (!params.inputSchema || !params.outputSchema) {\n    throw new Error('Tool must have input and output schemas defined');\n  }\n\n  return {\n    id: params.id,\n    description: params.description,\n    inputSchema: params.inputSchema,\n    outputSchema: params.outputSchema,\n    resumeSchema: params.resumeSchema,\n    suspendSchema: params.suspendSchema,\n    retries: toolOpts?.retries,\n    scorers: toolOpts?.scorers,\n    execute: async ({ inputData, mastra, requestContext, suspend, resumeData, runId, workflowId, state, setState }) => {\n      // Tools receive (input, context) - just call the tool's execute\n      if (!params.execute) {\n        throw new Error(`Tool ${params.id} does not have an execute function`);\n      }\n\n      // Build context matching ToolExecutionContext structure\n      const context = {\n        mastra,\n        requestContext,\n        tracingContext: { currentSpan: undefined }, // TODO: Pass proper tracing context when evented workflows support tracing\n        workflow: {\n          runId,\n          workflowId,\n          state,\n          setState,\n          suspend,\n          resumeData,\n        },\n      };\n\n      // Tool.execute already handles the v1.0 signature properly\n      return params.execute(inputData, context) as TStepOutput;\n    },\n    component: 'TOOL',\n  };\n}\n\nfunction createStepFromProcessor<TProcessorId extends string>(\n  processor: Processor<TProcessorId>,\n): Step<\n  `processor:${TProcessorId}`,\n  unknown,\n  InferSchemaOutput<typeof ProcessorStepSchema>,\n  InferSchemaOutput<typeof ProcessorStepOutputSchema>,\n  unknown,\n  unknown,\n  DefaultEngineType\n> {\n  // Helper to map phase to entity type\n  const getProcessorEntityType = (phase: string): EntityType => {\n    switch (phase) {\n      case 'input':\n        return EntityType.INPUT_PROCESSOR;\n      case 'inputStep':\n        return EntityType.INPUT_STEP_PROCESSOR;\n      case 'outputStream':\n      case 'outputResult':\n        return EntityType.OUTPUT_PROCESSOR;\n      case 'outputStep':\n        return EntityType.OUTPUT_STEP_PROCESSOR;\n      default:\n        return EntityType.OUTPUT_PROCESSOR;\n    }\n  };\n\n  // Helper to get span name prefix\n  const getSpanNamePrefix = (phase: string): string => {\n    switch (phase) {\n      case 'input':\n        return 'input processor';\n      case 'inputStep':\n        return 'input step processor';\n      case 'outputStream':\n        return 'output stream processor';\n      case 'outputResult':\n        return 'output processor';\n      case 'outputStep':\n        return 'output step processor';\n      default:\n        return 'processor';\n    }\n  };\n\n  // Helper to check if processor implements a phase\n  const hasPhaseMethod = (phase: string): boolean => {\n    switch (phase) {\n      case 'input':\n        return !!processor.processInput;\n      case 'inputStep':\n        return !!processor.processInputStep;\n      case 'outputStream':\n        return !!processor.processOutputStream;\n      case 'outputResult':\n        return !!processor.processOutputResult;\n      case 'outputStep':\n        return !!processor.processOutputStep;\n      default:\n        return false;\n    }\n  };\n\n  return {\n    id: `processor:${processor.id}`,\n    description: processor.name ?? `Processor ${processor.id}`,\n    inputSchema: ProcessorStepSchema,\n    outputSchema: ProcessorStepOutputSchema,\n    execute: async ({ inputData, requestContext, tracingContext }) => {\n      // Cast to output type for easier property access - the discriminated union\n      // ensures type safety at the schema level, but inside the execute function\n      // we need access to all possible properties\n      const input = inputData as ProcessorStepOutput;\n      const {\n        phase,\n        messages,\n        messageList,\n        stepNumber,\n        systemMessages,\n        part,\n        streamParts,\n        state,\n        finishReason,\n        toolCalls,\n        text,\n        retryCount,\n        // inputStep phase fields for model/tools configuration\n        model,\n        tools,\n        toolChoice,\n        activeTools,\n        providerOptions,\n        modelSettings,\n        structuredOutput,\n        steps,\n      } = input;\n\n      // Create a minimal abort function that throws TripWire\n      const abort = (reason?: string, options?: { retry?: boolean; metadata?: unknown }): never => {\n        throw new TripWire(reason || `Tripwire triggered by ${processor.id}`, options, processor.id);\n      };\n\n      // Early return if processor doesn't implement this phase - no span created\n      // This prevents empty spans for phases the processor doesn't handle\n      if (!hasPhaseMethod(phase)) {\n        return input;\n      }\n\n      // Create processor span for non-stream phases\n      // outputStream phase doesn't need its own span (stream chunks are already tracked)\n      const currentSpan = tracingContext?.currentSpan;\n\n      // Find appropriate parent span:\n      // - For input/outputResult: find AGENT_RUN (processor runs once at start/end)\n      // - For inputStep/outputStep: find MODEL_STEP (processor runs per LLM call)\n      // When workflow is executed, currentSpan is WORKFLOW_STEP, so we walk up the parent chain\n      const parentSpan =\n        phase === 'inputStep' || phase === 'outputStep'\n          ? currentSpan?.findParent(SpanType.MODEL_STEP) || currentSpan\n          : currentSpan?.findParent(SpanType.AGENT_RUN) || currentSpan;\n\n      const processorSpan =\n        phase !== 'outputStream'\n          ? parentSpan?.createChildSpan({\n              type: SpanType.PROCESSOR_RUN,\n              name: `${getSpanNamePrefix(phase)}: ${processor.id}`,\n              entityType: getProcessorEntityType(phase),\n              entityId: processor.id,\n              entityName: processor.name ?? processor.id,\n              input: { phase, messageCount: messages?.length },\n              attributes: {\n                processorExecutor: 'workflow',\n                // Read processorIndex from processor (set in combineProcessorsIntoWorkflow)\n                processorIndex: processor.processorIndex,\n              },\n            })\n          : undefined;\n\n      // Create tracing context with processor span so internal agent calls nest correctly\n      const processorTracingContext: TracingContext | undefined = processorSpan\n        ? { currentSpan: processorSpan }\n        : tracingContext;\n\n      // Base context for all processor methods - includes requestContext for memory processors\n      // and tracingContext for proper span nesting when processors call internal agents\n      const baseContext = {\n        abort,\n        retryCount: retryCount ?? 0,\n        requestContext,\n        tracingContext: processorTracingContext,\n      };\n\n      // Pass-through data that should flow to the next processor in a chain\n      // This enables processor workflows to use .then(), .parallel(), .branch(), etc.\n      const passThrough = {\n        phase,\n        // Auto-create MessageList from messages if not provided\n        // This enables running processor workflows from the UI where messageList can't be serialized\n        messageList:\n          messageList ??\n          (Array.isArray(messages)\n            ? new MessageList()\n                .add(messages as MastraDBMessage[], 'input')\n                .addSystem((systemMessages ?? []) as CoreMessage[])\n            : undefined),\n        stepNumber,\n        systemMessages,\n        streamParts,\n        state,\n        finishReason,\n        toolCalls,\n        text,\n        retryCount,\n        // inputStep phase fields for model/tools configuration\n        model,\n        tools,\n        toolChoice,\n        activeTools,\n        providerOptions,\n        modelSettings,\n        structuredOutput,\n        steps,\n      };\n\n      // Helper to execute phase with proper span lifecycle management\n      const executePhaseWithSpan = async <T>(fn: () => Promise<T>): Promise<T> => {\n        try {\n          const result = await fn();\n          processorSpan?.end({ output: result });\n          return result;\n        } catch (error) {\n          // TripWire errors should end span but bubble up to halt the workflow\n          if (error instanceof TripWire) {\n            processorSpan?.end({ output: { tripwire: error.message } });\n          } else {\n            processorSpan?.error({ error: error as Error, endSpan: true });\n          }\n          throw error;\n        }\n      };\n\n      // Execute the phase with span lifecycle management\n      return executePhaseWithSpan(async () => {\n        switch (phase) {\n          case 'input': {\n            if (processor.processInput) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processInput phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processInput({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'input',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'input',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'inputStep': {\n            if (processor.processInputStep) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processInputStep phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processInputStep({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                stepNumber: stepNumber ?? 0,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n                // Pass model/tools configuration fields - types match ProcessInputStepArgs\n                model: model!,\n                tools,\n                toolChoice,\n                activeTools,\n                providerOptions,\n                modelSettings,\n                structuredOutput,\n                steps: steps ?? [],\n              });\n\n              const validatedResult = await ProcessorRunner.validateAndFormatProcessInputStepResult(result, {\n                messageList: passThrough.messageList,\n                processor,\n                stepNumber: stepNumber ?? 0,\n              });\n\n              if (validatedResult.messages) {\n                ProcessorRunner.applyMessagesToMessageList(\n                  validatedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                );\n              }\n\n              if (validatedResult.systemMessages) {\n                passThrough.messageList!.replaceAllSystemMessages(validatedResult.systemMessages as CoreMessage[]);\n              }\n\n              // Preserve messages in return - passThrough doesn't include messages,\n              // so we must explicitly include it to avoid losing it for subsequent steps\n              return { ...passThrough, messages, ...validatedResult };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'outputStream': {\n            if (processor.processOutputStream) {\n              // Manage per-processor span lifecycle across stream chunks\n              // Use unique key to store span on shared state object\n              const spanKey = `__outputStreamSpan_${processor.id}`;\n              const mutableState = (state ?? {}) as Record<string, unknown>;\n              let processorSpan = mutableState[spanKey] as\n                | ReturnType<NonNullable<typeof parentSpan>['createChildSpan']>\n                | undefined;\n\n              if (!processorSpan && parentSpan) {\n                // First chunk - create span for this processor\n                processorSpan = parentSpan.createChildSpan({\n                  type: SpanType.PROCESSOR_RUN,\n                  name: `output stream processor: ${processor.id}`,\n                  entityType: EntityType.OUTPUT_PROCESSOR,\n                  entityId: processor.id,\n                  entityName: processor.name ?? processor.id,\n                  input: { phase, streamParts: [] },\n                  attributes: {\n                    processorExecutor: 'workflow',\n                    processorIndex: processor.processorIndex,\n                  },\n                });\n                mutableState[spanKey] = processorSpan;\n              }\n\n              // Update span with current chunk data\n              if (processorSpan) {\n                processorSpan.input = {\n                  phase,\n                  streamParts: streamParts ?? [],\n                  totalChunks: (streamParts ?? []).length,\n                };\n              }\n\n              // Create tracing context with processor span for internal agent calls\n              const processorTracingContext = processorSpan\n                ? { currentSpan: processorSpan }\n                : baseContext.tracingContext;\n\n              // Handle outputStream span lifecycle explicitly (not via executePhaseWithSpan)\n              // because outputStream uses a per-processor span stored in mutableState\n              let result: ChunkType | null | undefined;\n              try {\n                result = await processor.processOutputStream({\n                  ...baseContext,\n                  tracingContext: processorTracingContext,\n                  part: part as ChunkType,\n                  streamParts: (streamParts ?? []) as ChunkType[],\n                  state: mutableState,\n                  messageList: passThrough.messageList, // Optional for stream processing\n                });\n\n                // End span on finish chunk\n                if (part && (part as ChunkType).type === 'finish') {\n                  processorSpan?.end({ output: result });\n                  delete mutableState[spanKey];\n                }\n              } catch (error) {\n                // End span with error and clean up state\n                if (error instanceof TripWire) {\n                  processorSpan?.end({ output: { tripwire: error.message } });\n                } else {\n                  processorSpan?.error({ error: error as Error, endSpan: true });\n                }\n                delete mutableState[spanKey];\n                throw error;\n              }\n\n              return { ...passThrough, state: mutableState, part: result };\n            }\n            return { ...passThrough, part };\n          }\n\n          case 'outputResult': {\n            if (processor.processOutputResult) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processOutputResult phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processOutputResult({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'outputStep': {\n            if (processor.processOutputStep) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processOutputStep phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processOutputStep({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                stepNumber: stepNumber ?? 0,\n                finishReason,\n                toolCalls: toolCalls as any,\n                text,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n                steps: steps ?? [],\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          default:\n            return { ...passThrough, messages };\n        }\n      });\n    },\n    component: 'PROCESSOR',\n  };\n}\n\nexport function createWorkflow<\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    any,\n    EventedEngineType\n  >[],\n>(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>) {\n  const eventProcessor = new WorkflowEventProcessor({ mastra: params.mastra! });\n  const executionEngine = new EventedExecutionEngine({\n    mastra: params.mastra!,\n    eventProcessor,\n    options: {\n      validateInputs: params.options?.validateInputs ?? true,\n      shouldPersistSnapshot: params.options?.shouldPersistSnapshot ?? (() => true),\n      tracingPolicy: params.options?.tracingPolicy,\n      onFinish: params.options?.onFinish,\n      onError: params.options?.onError,\n    },\n  });\n  return new EventedWorkflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TInput>({\n    ...params,\n    executionEngine,\n  });\n}\n\nexport class EventedWorkflow<\n  TEngineType = EventedEngineType,\n  TSteps extends Step<string, any, any>[] = Step<string, any, any>[],\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TPrevSchema = TInput,\n> extends Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {\n  constructor(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>) {\n    super(params);\n    this.engineType = 'evented';\n  }\n\n  __registerMastra(mastra: Mastra) {\n    super.__registerMastra(mastra);\n    this.executionEngine.__registerMastra(mastra);\n  }\n\n  async createRun(options?: {\n    runId?: string;\n    resourceId?: string;\n    disableScorers?: boolean;\n  }): Promise<Run<TEngineType, TSteps, TState, TInput, TOutput>> {\n    const runIdToUse = options?.runId || randomUUID();\n\n    // Return a new Run instance with object parameters\n    const run: Run<TEngineType, TSteps, TState, TInput, TOutput> =\n      this.runs.get(runIdToUse) ??\n      new EventedRun({\n        workflowId: this.id,\n        runId: runIdToUse,\n        resourceId: options?.resourceId,\n        executionEngine: this.executionEngine,\n        executionGraph: this.executionGraph,\n        serializedStepGraph: this.serializedStepGraph,\n        mastra: this.mastra,\n        retryConfig: this.retryConfig,\n        cleanup: () => this.runs.delete(runIdToUse),\n        workflowSteps: this.steps,\n        validateInputs: this.options?.validateInputs,\n        workflowEngineType: this.engineType,\n      });\n\n    this.runs.set(runIdToUse, run);\n\n    const shouldPersistSnapshot = this.options?.shouldPersistSnapshot?.({\n      workflowStatus: run.workflowRunStatus,\n      stepResults: {},\n    });\n\n    const existingRun = await this.getWorkflowRunById(runIdToUse, {\n      withNestedWorkflows: false,\n    });\n\n    // Check if run exists in persistent storage (not just in-memory)\n    const existsInStorage = existingRun && !existingRun.isFromInMemory;\n\n    if (!existsInStorage && shouldPersistSnapshot) {\n      const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n      await workflowsStore?.persistWorkflowSnapshot({\n        workflowName: this.id,\n        runId: runIdToUse,\n        resourceId: options?.resourceId,\n        snapshot: {\n          runId: runIdToUse,\n          status: 'pending',\n          value: {},\n          context: {},\n          activePaths: [],\n          serializedStepGraph: this.serializedStepGraph,\n          activeStepsPath: {},\n          suspendedPaths: {},\n          resumeLabels: {},\n          waitingPaths: {},\n          result: undefined,\n          error: undefined,\n          // @ts-ignore\n          timestamp: Date.now(),\n        },\n      });\n    }\n\n    return run;\n  }\n}\n\nexport class EventedRun<\n  TEngineType = EventedEngineType,\n  TSteps extends Step<string, any, any>[] = Step<string, any, any>[],\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n> extends Run<TEngineType, TSteps, TState, TInput, TOutput> {\n  constructor(params: {\n    workflowId: string;\n    runId: string;\n    resourceId?: string;\n    executionEngine: ExecutionEngine;\n    executionGraph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    mastra?: Mastra;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    cleanup?: () => void;\n    workflowSteps: Record<string, StepWithComponent>;\n    validateInputs?: boolean;\n    workflowEngineType: WorkflowEngineType;\n  }) {\n    super(params);\n    this.serializedStepGraph = params.serializedStepGraph;\n  }\n\n  /**\n   * Set up abort signal handler to publish workflow.cancel event when abortController.abort() is called.\n   * This ensures consistent cancellation behavior whether abort() is called directly or via cancel().\n   */\n  private setupAbortHandler(): void {\n    const abortHandler = () => {\n      this.mastra?.pubsub\n        .publish('workflows', {\n          type: 'workflow.cancel',\n          runId: this.runId,\n          data: {\n            workflowId: this.workflowId,\n            runId: this.runId,\n          },\n        })\n        .catch(err => {\n          this.mastra?.getLogger()?.error(`Failed to publish workflow.cancel for runId ${this.runId}:`, err);\n        });\n    };\n    this.abortController.signal.addEventListener('abort', abortHandler, { once: true });\n  }\n\n  async start({\n    inputData,\n    initialState,\n    requestContext,\n    perStep,\n  }: {\n    inputData?: TInput;\n    requestContext?: RequestContext;\n    initialState?: TState;\n    perStep?: boolean;\n  }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    // Add validation checks\n    if (this.serializedStepGraph.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n\n    requestContext = requestContext ?? new RequestContext();\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.persistWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      resourceId: this.resourceId,\n      snapshot: {\n        runId: this.runId,\n        serializedStepGraph: this.serializedStepGraph,\n        status: 'running',\n        value: {},\n        context: {} as any,\n        requestContext: Object.fromEntries(requestContext.entries()),\n        activePaths: [],\n        activeStepsPath: {},\n        suspendedPaths: {},\n        resumeLabels: {},\n        waitingPaths: {},\n        timestamp: Date.now(),\n      },\n    });\n\n    const inputDataToUse = await this._validateInput(inputData ?? ({} as TInput));\n    const initialStateToUse = await this._validateInitialState(initialState ?? ({} as TState));\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    this.setupAbortHandler();\n\n    const result = await this.executionEngine.execute<TState, TInput, WorkflowResult<TState, TInput, TOutput, TSteps>>({\n      workflowId: this.workflowId,\n      runId: this.runId,\n      graph: this.executionGraph,\n      serializedStepGraph: this.serializedStepGraph,\n      input: inputDataToUse,\n      initialState: initialStateToUse,\n      pubsub: this.mastra.pubsub,\n      retryConfig: this.retryConfig,\n      requestContext,\n      abortController: this.abortController,\n      perStep,\n    });\n\n    // console.dir({ startResult: result }, { depth: null });\n\n    if (result.status !== 'suspended') {\n      this.cleanup?.();\n    }\n\n    return result;\n  }\n\n  /**\n   * Starts the workflow execution without waiting for completion (fire-and-forget).\n   * Returns immediately with the runId. The workflow executes in the background via pubsub.\n   * Use this when you don't need to wait for the result or want to avoid polling failures.\n   */\n  async startAsync({\n    inputData,\n    initialState,\n    requestContext,\n    perStep,\n  }: {\n    inputData?: TInput;\n    requestContext?: RequestContext;\n    initialState?: TState;\n    perStep?: boolean;\n  }): Promise<{ runId: string }> {\n    // Add validation checks\n    if (this.serializedStepGraph.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n\n    requestContext = requestContext ?? new RequestContext();\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.persistWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      resourceId: this.resourceId,\n      snapshot: {\n        runId: this.runId,\n        serializedStepGraph: this.serializedStepGraph,\n        status: 'running',\n        value: {},\n        context: {} as any,\n        requestContext: Object.fromEntries(requestContext.entries()),\n        activePaths: [],\n        activeStepsPath: {},\n        suspendedPaths: {},\n        resumeLabels: {},\n        waitingPaths: {},\n        timestamp: Date.now(),\n      },\n    });\n\n    const inputDataToUse = await this._validateInput(inputData ?? ({} as TInput));\n    const initialStateToUse = await this._validateInitialState(initialState ?? ({} as TState));\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    // Fire-and-forget: publish the workflow start event without subscribing for completion\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.start',\n      runId: this.runId,\n      data: {\n        workflowId: this.workflowId,\n        runId: this.runId,\n        prevResult: { status: 'success', output: inputDataToUse },\n        requestContext: Object.fromEntries(requestContext.entries()),\n        initialState: initialStateToUse,\n        perStep,\n      },\n    });\n\n    // Return immediately without waiting for completion\n    return { runId: this.runId };\n  }\n\n  // TODO: stream\n\n  async resume<TResumeSchema>(params: {\n    resumeData?: TResumeSchema;\n    step:\n      | Step<string, any, any, TResumeSchema, any, any, TEngineType>\n      | [\n          ...Step<string, any, any, any, any, any, TEngineType>[],\n          Step<string, any, any, TResumeSchema, any, any, TEngineType>,\n        ]\n      | string\n      | string[];\n    requestContext?: RequestContext;\n    perStep?: boolean;\n  }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    let steps: string[] = [];\n    if (typeof params.step === 'string') {\n      steps = params.step.split('.');\n    } else {\n      steps = (Array.isArray(params.step) ? params.step : [params.step]).map(step =>\n        typeof step === 'string' ? step : step?.id,\n      );\n    }\n\n    if (steps.length === 0) {\n      throw new Error('No steps provided to resume');\n    }\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    if (!workflowsStore) {\n      throw new Error('Cannot resume workflow: workflows store is required');\n    }\n    const snapshot = await workflowsStore.loadWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n    });\n    if (!snapshot) {\n      throw new Error(`Cannot resume workflow: no snapshot found for runId ${this.runId}`);\n    }\n\n    const resumePath = snapshot.suspendedPaths?.[steps[0]!] as any;\n    if (!resumePath) {\n      throw new Error(\n        `No resume path found for step ${JSON.stringify(steps)}, currently suspended paths are ${JSON.stringify(snapshot.suspendedPaths)}`,\n      );\n    }\n\n    console.dir(\n      { resume: { requestContextObj: snapshot.requestContext, requestContext: params.requestContext } },\n      { depth: null },\n    );\n    // Start with the snapshot's request context (old values)\n    const requestContextObj = snapshot.requestContext ?? {};\n    const requestContext = new RequestContext();\n\n    // First, set values from the snapshot\n    for (const [key, value] of Object.entries(requestContextObj)) {\n      requestContext.set(key, value);\n    }\n\n    // Then, override with any values from the passed request context (new values take precedence)\n    if (params.requestContext) {\n      for (const [key, value] of params.requestContext.entries()) {\n        requestContext.set(key, value);\n      }\n    }\n\n    const suspendedStep = this.workflowSteps[steps?.[0] ?? ''];\n\n    const resumeDataToUse = await this._validateResumeData(params.resumeData, suspendedStep);\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    this.setupAbortHandler();\n\n    const executionResultPromise = this.executionEngine\n      .execute<TState, TInput, WorkflowResult<TState, TInput, TOutput, TSteps>>({\n        workflowId: this.workflowId,\n        runId: this.runId,\n        graph: this.executionGraph,\n        serializedStepGraph: this.serializedStepGraph,\n        input: snapshot?.context?.input as TInput,\n        resume: {\n          steps,\n          stepResults: snapshot?.context as any,\n          resumePayload: resumeDataToUse,\n          resumePath,\n        },\n        pubsub: this.mastra.pubsub,\n        requestContext,\n        abortController: this.abortController,\n        perStep: params.perStep,\n      })\n      .then(result => {\n        if (result.status !== 'suspended') {\n          this.closeStreamAction?.().catch(() => {});\n        }\n\n        return result;\n      });\n\n    this.executionResults = executionResultPromise;\n\n    return executionResultPromise;\n  }\n\n  watch(cb: (event: WorkflowStreamEvent) => void): () => void {\n    const watchCb = async (event: Event, ack?: () => Promise<void>) => {\n      if (event.runId !== this.runId) {\n        return;\n      }\n\n      cb(event.data);\n      await ack?.();\n    };\n\n    this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n\n    return () => {\n      this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n    };\n  }\n\n  async watchAsync(cb: (event: WorkflowStreamEvent) => void): Promise<() => void> {\n    const watchCb = async (event: Event, ack?: () => Promise<void>) => {\n      if (event.runId !== this.runId) {\n        return;\n      }\n\n      cb(event.data);\n      await ack?.();\n    };\n\n    await this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n\n    return async () => {\n      await this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n    };\n  }\n\n  async cancel() {\n    // Update storage directly for immediate status update (same pattern as Inngest)\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.updateWorkflowState({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      opts: {\n        status: 'canceled',\n      },\n    });\n\n    // Trigger abort signal - the abort handler will publish the workflow.cancel event\n    // This ensures consistent behavior whether cancel() or abort() is called\n    this.abortController.abort();\n  }\n}\n","import type { Step, StepFlowEntry, Workflow } from '../..';\nimport type { Mastra } from '../../../mastra';\nimport { EventedWorkflow } from '../workflow';\nimport type { ParentWorkflow } from '.';\n\nexport function getNestedWorkflow(\n  mastra: Mastra,\n  { workflowId, executionPath, parentWorkflow }: ParentWorkflow,\n): Workflow | null {\n  let workflow: Workflow | null = null;\n\n  if (parentWorkflow) {\n    const nestedWorkflow = getNestedWorkflow(mastra, parentWorkflow);\n    if (!nestedWorkflow) {\n      return null;\n    }\n\n    workflow = nestedWorkflow;\n  }\n\n  workflow = workflow ?? mastra.getWorkflow(workflowId);\n  const stepGraph = workflow.stepGraph;\n  let parentStep = stepGraph[executionPath[0]!];\n  if (parentStep?.type === 'parallel' || parentStep?.type === 'conditional') {\n    parentStep = parentStep.steps[executionPath[1]!];\n  }\n\n  if (parentStep?.type === 'step' || parentStep?.type === 'loop') {\n    return parentStep.step as Workflow;\n  }\n\n  return null;\n}\n\nexport function getStep(workflow: Workflow, executionPath: number[]): Step<string, any, any, any, any, any> | null {\n  let idx = 0;\n  const stepGraph = workflow.stepGraph;\n  let parentStep = stepGraph[executionPath[0]!];\n  if (parentStep?.type === 'parallel' || parentStep?.type === 'conditional') {\n    parentStep = parentStep.steps[executionPath[1]!];\n    idx++;\n  } else if (parentStep?.type === 'foreach') {\n    return parentStep.step;\n  }\n\n  if (!(parentStep?.type === 'step' || parentStep?.type === 'loop')) {\n    return null;\n  }\n\n  if (parentStep instanceof EventedWorkflow) {\n    return getStep(parentStep, executionPath.slice(idx + 1));\n  }\n\n  return parentStep.step;\n}\n\nexport function isExecutableStep(step: StepFlowEntry<any>) {\n  return step.type === 'step' || step.type === 'loop' || step.type === 'foreach';\n}\n","import type { RequestContext } from '../../di';\nimport type { PubSub } from '../../events/pubsub';\nimport type { Event } from '../../events/types';\nimport type { Mastra } from '../../mastra';\nimport { ExecutionEngine } from '../../workflows/execution-engine';\nimport type { ExecutionEngineOptions, ExecutionGraph } from '../../workflows/execution-engine';\nimport type {\n  SerializedStepFlowEntry,\n  StepResult,\n  RestartExecutionParams,\n  TimeTravelExecutionParams,\n  WorkflowRunStatus,\n} from '../types';\nimport { hydrateSerializedStepErrors } from '../utils';\nimport type { WorkflowEventProcessor } from './workflow-event-processor';\nimport { getStep } from './workflow-event-processor/utils';\n\nexport class EventedExecutionEngine extends ExecutionEngine {\n  protected eventProcessor: WorkflowEventProcessor;\n\n  constructor({\n    mastra,\n    eventProcessor,\n    options,\n  }: {\n    mastra?: Mastra;\n    eventProcessor: WorkflowEventProcessor;\n    options: ExecutionEngineOptions;\n  }) {\n    super({ mastra, options });\n    this.eventProcessor = eventProcessor;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n    this.eventProcessor.__registerMastra(mastra);\n  }\n\n  /**\n   * Executes a workflow run with the provided execution graph and input\n   * @param graph The execution graph to execute\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  async execute<TInput, TOutput>(params: {\n    workflowId: string;\n    runId: string;\n    graph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    input?: TInput;\n    restart?: RestartExecutionParams;\n    timeTravel?: TimeTravelExecutionParams;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    pubsub?: PubSub; // Not used - evented engine uses this.mastra.pubsub directly\n    requestContext: RequestContext;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    abortController: AbortController;\n    format?: 'legacy' | 'vnext' | undefined;\n    perStep?: boolean;\n  }): Promise<TOutput> {\n    const pubsub = this.mastra?.pubsub;\n    if (!pubsub) {\n      throw new Error('No Pubsub adapter configured on the Mastra instance');\n    }\n\n    if (params.resume) {\n      const prevStep = getStep(this.mastra!.getWorkflow(params.workflowId), params.resume.resumePath);\n      const prevResult = params.resume.stepResults[prevStep?.id ?? 'input'];\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.resume',\n        runId: params.runId,\n        data: {\n          workflowId: params.workflowId,\n          runId: params.runId,\n          executionPath: params.resume.resumePath,\n          stepResults: params.resume.stepResults,\n          resumeSteps: params.resume.steps,\n          prevResult: { status: 'success', output: prevResult?.payload },\n          resumeData: params.resume.resumePayload,\n          requestContext: Object.fromEntries(params.requestContext.entries()),\n          format: params.format,\n          perStep: params.perStep,\n        },\n      });\n    } else if (params.timeTravel) {\n      const prevStep = getStep(this.mastra!.getWorkflow(params.workflowId), params.timeTravel.executionPath);\n      const prevResult = params.timeTravel.stepResults[prevStep?.id ?? 'input'];\n      await pubsub.publish('workflows', {\n        type: 'workflow.start',\n        runId: params.runId,\n        data: {\n          workflowId: params.workflowId,\n          runId: params.runId,\n          executionPath: params.timeTravel.executionPath,\n          stepResults: params.timeTravel.stepResults,\n          timeTravel: params.timeTravel,\n          prevResult: { status: 'success', output: prevResult?.payload },\n          requestContext: Object.fromEntries(params.requestContext.entries()),\n          format: params.format,\n          perStep: params.perStep,\n        },\n      });\n    } else {\n      await pubsub.publish('workflows', {\n        type: 'workflow.start',\n        runId: params.runId,\n        data: {\n          workflowId: params.workflowId,\n          runId: params.runId,\n          prevResult: { status: 'success', output: params.input },\n          requestContext: Object.fromEntries(params.requestContext.entries()),\n          format: params.format,\n          perStep: params.perStep,\n        },\n      });\n    }\n\n    const resultData: any = await new Promise((resolve, reject) => {\n      const finishCb = async (event: Event, ack?: () => Promise<void>) => {\n        if (event.runId !== params.runId) {\n          await ack?.();\n          return;\n        }\n\n        if (['workflow.end', 'workflow.fail', 'workflow.suspend'].includes(event.type)) {\n          await ack?.();\n          await pubsub.unsubscribe('workflows-finish', finishCb);\n          // Re-hydrate serialized errors back to Error instances when workflow fails\n          if (event.type === 'workflow.fail' && event.data.stepResults) {\n            event.data.stepResults = hydrateSerializedStepErrors(event.data.stepResults);\n          }\n          resolve(event.data);\n          return;\n        }\n\n        await ack?.();\n      };\n\n      pubsub.subscribe('workflows-finish', finishCb).catch(err => {\n        this.mastra?.getLogger()?.error('Failed to subscribe to workflows-finish:', err);\n        reject(err);\n      });\n    });\n\n    // Build the callback argument with proper typing for invokeLifecycleCallbacks\n    let callbackArg: {\n      status: WorkflowRunStatus;\n      result?: any;\n      error?: any;\n      steps: Record<string, StepResult<any, any, any, any>>;\n    };\n\n    if (resultData.prevResult.status === 'failed') {\n      callbackArg = {\n        status: 'failed',\n        error: resultData.prevResult.error,\n        steps: resultData.stepResults,\n      };\n    } else if (resultData.prevResult.status === 'suspended') {\n      callbackArg = {\n        status: 'suspended',\n        steps: resultData.stepResults,\n      };\n    } else if (resultData.prevResult.status === 'paused' || params.perStep) {\n      callbackArg = {\n        status: 'paused',\n        steps: resultData.stepResults,\n      };\n    } else {\n      callbackArg = {\n        status: resultData.prevResult.status,\n        result: resultData.prevResult?.output,\n        steps: resultData.stepResults,\n      };\n    }\n\n    if (callbackArg.status !== 'paused') {\n      // Invoke lifecycle callbacks before returning\n      await this.invokeLifecycleCallbacks({\n        status: callbackArg.status,\n        result: callbackArg.result,\n        error: callbackArg.error,\n        steps: callbackArg.steps,\n        tripwire: undefined,\n        runId: params.runId,\n        workflowId: params.workflowId,\n        resourceId: undefined,\n        input: params.input,\n        requestContext: params.requestContext,\n        state: {},\n      });\n    }\n\n    // Build the final result with any additional fields needed for the return type\n    let result: TOutput;\n    if (resultData.prevResult.status === 'suspended') {\n      const suspendedSteps = Object.entries(resultData.stepResults)\n        .map(([_stepId, stepResult]: [string, any]) => {\n          if (stepResult.status === 'suspended') {\n            return stepResult.suspendPayload?.__workflow_meta?.path ?? [];\n          }\n          return null;\n        })\n        .filter(Boolean);\n      result = {\n        ...callbackArg,\n        suspended: suspendedSteps,\n      } as TOutput;\n    } else {\n      result = callbackArg as TOutput;\n    }\n\n    return result;\n  }\n}\n"],"names":["validationError","EventEmitter","step","processorSpan","processorTracingContext","randomUUID"],"mappings":"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"}}]
}