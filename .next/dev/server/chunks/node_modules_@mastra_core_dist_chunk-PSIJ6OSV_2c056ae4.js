module.exports = [
"[project]/node_modules/@mastra/core/dist/chunk-PSIJ6OSV.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AIV4Adapter",
    ()=>AIV4Adapter,
    "AIV5Adapter",
    ()=>AIV5Adapter,
    "CacheKeyGenerator",
    ()=>CacheKeyGenerator,
    "DefaultGeneratedFile",
    ()=>DefaultGeneratedFile,
    "DefaultGeneratedFileWithType",
    ()=>DefaultGeneratedFileWithType,
    "MessageList",
    ()=>MessageList,
    "MessageMerger",
    ()=>MessageMerger,
    "MessageStateManager",
    ()=>MessageStateManager,
    "TypeDetector",
    ()=>TypeDetector,
    "aiV4CoreMessageToV1PromptMessage",
    ()=>aiV4CoreMessageToV1PromptMessage,
    "aiV5ModelMessageToV2PromptMessage",
    ()=>aiV5ModelMessageToV2PromptMessage,
    "convertMessages",
    ()=>convertMessages,
    "coreContentToString",
    ()=>coreContentToString,
    "ensureAnthropicCompatibleMessages",
    ()=>ensureAnthropicCompatibleMessages,
    "ensureGeminiCompatibleMessages",
    ()=>ensureGeminiCompatibleMessages,
    "findToolCallArgs",
    ()=>findToolCallArgs,
    "getOpenAIReasoningItemId",
    ()=>getOpenAIReasoningItemId,
    "hasOpenAIReasoningItemId",
    ()=>hasOpenAIReasoningItemId,
    "messagesAreEqual",
    ()=>messagesAreEqual
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-K2LPTKSY.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-6OBQKOBQ.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lukeed$2f$uuid$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lukeed/uuid/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider-utils-v5/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
// src/agent/message-list/detection/TypeDetector.ts
var TypeDetector = class _TypeDetector {
    /**
   * Check if a message is a MastraDBMessage (format 2)
   */ static isMastraDBMessage(msg) {
        return Boolean("content" in msg && msg.content && !Array.isArray(msg.content) && typeof msg.content !== "string" && "format" in msg.content && msg.content.format === 2);
    }
    /**
   * Check if a message is a MastraMessageV1 (legacy format)
   */ static isMastraMessageV1(msg) {
        return !_TypeDetector.isMastraDBMessage(msg) && ("threadId" in msg || "resourceId" in msg);
    }
    /**
   * Check if a message is either Mastra format (V1 or V2/DB)
   */ static isMastraMessage(msg) {
        return _TypeDetector.isMastraDBMessage(msg) || _TypeDetector.isMastraMessageV1(msg);
    }
    /**
   * Check if a message is an AIV4 UIMessage
   */ static isAIV4UIMessage(msg) {
        return !_TypeDetector.isMastraMessage(msg) && !_TypeDetector.isAIV4CoreMessage(msg) && "parts" in msg && !_TypeDetector.hasAIV5UIMessageCharacteristics(msg);
    }
    /**
   * Check if a message is an AIV5 UIMessage
   */ static isAIV5UIMessage(msg) {
        return !_TypeDetector.isMastraMessage(msg) && !_TypeDetector.isAIV5CoreMessage(msg) && "parts" in msg && _TypeDetector.hasAIV5UIMessageCharacteristics(msg);
    }
    /**
   * Check if a message is an AIV4 CoreMessage
   */ static isAIV4CoreMessage(msg) {
        return !_TypeDetector.isMastraMessage(msg) && !("parts" in msg) && "content" in msg && !_TypeDetector.hasAIV5CoreMessageCharacteristics(msg);
    }
    /**
   * Check if a message is an AIV5 ModelMessage (CoreMessage equivalent)
   */ static isAIV5CoreMessage(msg) {
        return !_TypeDetector.isMastraMessage(msg) && !("parts" in msg) && "content" in msg && _TypeDetector.hasAIV5CoreMessageCharacteristics(msg);
    }
    /**
   * Check if a message has AIV5 UIMessage characteristics
   *
   * V5 UIMessages have specific part types and field names that differ from V4
   */ static hasAIV5UIMessageCharacteristics(msg) {
        if ("toolInvocations" in msg || "reasoning" in msg || "experimental_attachments" in msg || "data" in msg || "annotations" in msg) return false;
        if (!msg.parts) return false;
        for (const part of msg.parts){
            if ("metadata" in part) return true;
            if ("toolInvocation" in part) return false;
            if ("toolCallId" in part) return true;
            if (part.type === "source") return false;
            if (part.type === "source-url") return true;
            if (part.type === "reasoning") {
                if ("state" in part || "text" in part) return true;
                if ("reasoning" in part || "details" in part) return false;
            }
            if (part.type === "file" && "mediaType" in part) return true;
        }
        return false;
    }
    /**
   * Check if a message has AIV5 CoreMessage characteristics
   *
   * V5 ModelMessages use different field names (output vs result, input vs args, mediaType vs mimeType)
   */ static hasAIV5CoreMessageCharacteristics(msg) {
        if ("experimental_providerMetadata" in msg) return false;
        if (typeof msg.content === "string") return true;
        for (const part of msg.content){
            if (part.type === "tool-result" && "output" in part) return true;
            if (part.type === "tool-call" && "input" in part) return true;
            if (part.type === "tool-result" && "result" in part) return false;
            if (part.type === "tool-call" && "args" in part) return false;
            if ("mediaType" in part) return true;
            if ("mimeType" in part) return false;
            if ("experimental_providerMetadata" in part) return false;
            if (part.type === "reasoning" && "signature" in part) return false;
            if (part.type === "redacted-reasoning") return false;
        }
        return true;
    }
    /**
   * Get the normalized role for a message
   * Maps 'tool' role to 'assistant' since tool messages are displayed as part of assistant conversation
   */ static getRole(message) {
        if (message.role === "assistant" || message.role === "tool") return "assistant";
        if (message.role === "user") return "user";
        if (message.role === "system") return "system";
        throw new Error(`BUG: add handling for message role ${message.role} in message ${JSON.stringify(message, null, 2)}`);
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>globalThis.Buffer?.isBuffer(value) ?? false, {
        message: "Must be a Buffer"
    })
]);
function convertDataContentToBase64String(content) {
    if (typeof content === "string") {
        return content;
    }
    if (content instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(new Uint8Array(content));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(content);
}
// src/agent/message-list/prompt/image-utils.ts
function parseDataUri(dataUri) {
    if (!dataUri.startsWith("data:")) {
        return {
            isDataUri: false,
            base64Content: dataUri
        };
    }
    const base64Index = dataUri.indexOf(",");
    if (base64Index === -1) {
        return {
            isDataUri: true,
            base64Content: dataUri
        };
    }
    const header = dataUri.substring(5, base64Index);
    const base64Content = dataUri.substring(base64Index + 1);
    const semicolonIndex = header.indexOf(";");
    const mimeType = semicolonIndex !== -1 ? header.substring(0, semicolonIndex) : header;
    return {
        isDataUri: true,
        mimeType: mimeType || void 0,
        base64Content
    };
}
function createDataUri(base64Content, mimeType = "application/octet-stream") {
    if (base64Content.startsWith("data:")) {
        return base64Content;
    }
    return `data:${mimeType};base64,${base64Content}`;
}
function imageContentToString(image, fallbackMimeType) {
    if (typeof image === "string") {
        return image;
    }
    if (image instanceof URL) {
        return image.toString();
    }
    if (image instanceof Uint8Array || image instanceof ArrayBuffer || globalThis.Buffer && Buffer.isBuffer(image)) {
        const base64 = convertDataContentToBase64String(image);
        return base64;
    }
    return String(image);
}
function getImageCacheKey(image) {
    if (image instanceof URL) {
        return image.toString();
    }
    if (typeof image === "string") {
        return image.length;
    }
    if (image instanceof Uint8Array) {
        return image.byteLength;
    }
    if (image instanceof ArrayBuffer) {
        return image.byteLength;
    }
    return image;
}
function isValidUrl(str) {
    try {
        new URL(str);
        return true;
    } catch  {
        if (str.startsWith("//")) {
            try {
                new URL(`https:${str}`);
                return true;
            } catch  {
                return false;
            }
        }
        return false;
    }
}
function categorizeFileData(data, fallbackMimeType) {
    const parsed = parseDataUri(data);
    const mimeType = parsed.isDataUri && parsed.mimeType ? parsed.mimeType : fallbackMimeType;
    if (parsed.isDataUri) {
        return {
            type: "dataUri",
            mimeType,
            data
        };
    }
    if (isValidUrl(data)) {
        return {
            type: "url",
            mimeType,
            data
        };
    }
    return {
        type: "raw",
        mimeType,
        data
    };
}
// src/agent/message-list/utils/provider-compat.ts
function ensureGeminiCompatibleMessages(messages) {
    const result = [
        ...messages
    ];
    const firstNonSystemIndex = result.findIndex((m)=>m.role !== "system");
    if (firstNonSystemIndex === -1) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "NO_USER_OR_ASSISTANT_MESSAGES",
            domain: "AGENT" /* AGENT */ ,
            category: "USER" /* USER */ ,
            text: "This request does not contain any user or assistant messages. At least one user or assistant message is required to generate a response."
        });
    } else if (result[firstNonSystemIndex]?.role === "assistant") {
        result.splice(firstNonSystemIndex, 0, {
            role: "user",
            content: "."
        });
    }
    return result;
}
function ensureAnthropicCompatibleMessages(messages, dbMessages) {
    return messages.map((msg)=>enrichToolResultsWithInput(msg, dbMessages));
}
function enrichToolResultsWithInput(message, dbMessages) {
    if (message.role !== "tool" || !Array.isArray(message.content)) {
        return message;
    }
    return {
        ...message,
        content: message.content.map((part)=>{
            if (part.type === "tool-result") {
                return {
                    ...part,
                    input: findToolCallArgs(dbMessages, part.toolCallId)
                };
            }
            return part;
        })
    };
}
function hasOpenAIReasoningItemId(part) {
    if (!part || typeof part !== "object") return false;
    const partAny = part;
    if (!("providerMetadata" in partAny) || !partAny.providerMetadata) return false;
    const metadata = partAny.providerMetadata;
    if (!("openai" in metadata) || !metadata.openai) return false;
    const openai = metadata.openai;
    return "itemId" in openai && typeof openai.itemId === "string";
}
function getOpenAIReasoningItemId(part) {
    if (!hasOpenAIReasoningItemId(part)) return void 0;
    const partAny = part;
    const metadata = partAny.providerMetadata;
    const openai = metadata.openai;
    return openai.itemId;
}
function findToolCallArgs(messages, toolCallId) {
    for(let i = messages.length - 1; i >= 0; i--){
        const msg = messages[i];
        if (!msg || msg.role !== "assistant") {
            continue;
        }
        if (msg.content.parts) {
            const toolCallPart = msg.content.parts.find((p)=>p.type === "tool-invocation" && p.toolInvocation.toolCallId === toolCallId);
            if (toolCallPart && toolCallPart.type === "tool-invocation") {
                return toolCallPart.toolInvocation.args || {};
            }
        }
        if (msg.content.toolInvocations) {
            const toolInvocation = msg.content.toolInvocations.find((inv)=>inv.toolCallId === toolCallId);
            if (toolInvocation) {
                return toolInvocation.args || {};
            }
        }
    }
    return {};
}
// src/agent/message-list/adapters/AIV4Adapter.ts
function filterDataParts(parts) {
    return parts.filter((part)=>!part.type.startsWith("data-"));
}
var AIV4Adapter = class {
    /**
   * Convert MastraDBMessage to AI SDK V4 UIMessage
   */ static toUIMessage(m) {
        const experimentalAttachments = m.content.experimental_attachments ? [
            ...m.content.experimental_attachments
        ] : [];
        const contentString = typeof m.content.content === `string` && m.content.content !== "" ? m.content.content : (m.content.parts ?? []).reduce((prev, part)=>{
            if (part.type === `text`) {
                return part.text;
            }
            return prev;
        }, "");
        const parts = [];
        const sourceParts = m.content.parts ?? [];
        if (sourceParts.length) {
            for (const part of sourceParts){
                if (part.type === `file`) {
                    let normalizedUrl;
                    if (typeof part.data === "string") {
                        const categorized = categorizeFileData(part.data, part.mimeType);
                        if (categorized.type === "raw") {
                            normalizedUrl = createDataUri(part.data, part.mimeType || "application/octet-stream");
                        } else {
                            normalizedUrl = part.data;
                        }
                    } else {
                        normalizedUrl = part.data;
                    }
                    experimentalAttachments.push({
                        contentType: part.mimeType,
                        url: normalizedUrl
                    });
                } else if (part.type === "tool-invocation" && (part.toolInvocation.state === "call" || part.toolInvocation.state === "partial-call")) {
                    continue;
                } else if (part.type === "tool-invocation") {
                    const toolInvocation = {
                        ...part.toolInvocation
                    };
                    let currentStep = -1;
                    let toolStep = -1;
                    for (const innerPart of sourceParts){
                        if (innerPart.type === `step-start`) currentStep++;
                        if (innerPart.type === `tool-invocation` && innerPart.toolInvocation.toolCallId === part.toolInvocation.toolCallId) {
                            toolStep = currentStep;
                            break;
                        }
                    }
                    if (toolStep >= 0) {
                        const preparedInvocation = {
                            step: toolStep,
                            ...toolInvocation
                        };
                        parts.push({
                            type: "tool-invocation",
                            toolInvocation: preparedInvocation
                        });
                    } else {
                        parts.push({
                            type: "tool-invocation",
                            toolInvocation
                        });
                    }
                } else {
                    parts.push(part);
                }
            }
        }
        if (parts.length === 0 && experimentalAttachments.length > 0) {
            parts.push({
                type: "text",
                text: ""
            });
        }
        const v4Parts = filterDataParts(parts);
        if (m.role === `user`) {
            const uiMessage2 = {
                id: m.id,
                role: m.role,
                content: m.content.content || contentString,
                createdAt: m.createdAt,
                parts: v4Parts,
                experimental_attachments: experimentalAttachments
            };
            if (m.content.metadata) {
                uiMessage2.metadata = m.content.metadata;
            }
            return uiMessage2;
        } else if (m.role === `assistant`) {
            const isSingleTextContentArray = Array.isArray(m.content.content) && m.content.content.length === 1 && m.content.content[0].type === `text`;
            const uiMessage2 = {
                id: m.id,
                role: m.role,
                content: isSingleTextContentArray ? contentString : m.content.content || contentString,
                createdAt: m.createdAt,
                parts: v4Parts,
                reasoning: void 0,
                toolInvocations: `toolInvocations` in m.content ? m.content.toolInvocations?.filter((t)=>t.state === "result") : void 0
            };
            if (m.content.metadata) {
                uiMessage2.metadata = m.content.metadata;
            }
            return uiMessage2;
        }
        const uiMessage = {
            id: m.id,
            role: m.role,
            content: m.content.content || contentString,
            createdAt: m.createdAt,
            parts: v4Parts,
            experimental_attachments: experimentalAttachments
        };
        if (m.content.metadata) {
            uiMessage.metadata = m.content.metadata;
        }
        return uiMessage;
    }
    /**
   * Converts a MastraDBMessage system message directly to AIV4 CoreMessage format
   */ static systemToV4Core(message) {
        if (message.role !== `system` || !message.content.content) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "INVALID_SYSTEM_MESSAGE_FORMAT",
            domain: "AGENT" /* AGENT */ ,
            category: "USER" /* USER */ ,
            text: `Invalid system message format. System messages must include 'role' and 'content' properties. The content should be a string.`,
            details: {
                receivedMessage: JSON.stringify(message, null, 2)
            }
        });
        const coreMessage = {
            role: "system",
            content: message.content.content
        };
        if (message.content.providerMetadata) {
            coreMessage.experimental_providerMetadata = message.content.providerMetadata;
        }
        return coreMessage;
    }
    /**
   * Convert AI SDK V4 UIMessage to MastraDBMessage
   */ static fromUIMessage(message, ctx, messageSource) {
        const content = {
            format: 2,
            parts: message.parts
        };
        if (message.toolInvocations) content.toolInvocations = message.toolInvocations;
        if (message.reasoning) content.reasoning = message.reasoning;
        if (message.annotations) content.annotations = message.annotations;
        if (message.experimental_attachments) {
            content.experimental_attachments = message.experimental_attachments;
        }
        if ("metadata" in message && message.metadata !== null && message.metadata !== void 0) {
            content.metadata = message.metadata;
        }
        return {
            id: message.id || ctx.newMessageId(),
            role: TypeDetector.getRole(message),
            createdAt: ctx.generateCreatedAt(messageSource, message.createdAt),
            threadId: ctx.memoryInfo?.threadId,
            resourceId: ctx.memoryInfo?.resourceId,
            content
        };
    }
    /**
   * Convert AI SDK V4 CoreMessage to MastraDBMessage
   */ static fromCoreMessage(coreMessage, ctx, messageSource) {
        const id = `id` in coreMessage ? coreMessage.id : ctx.newMessageId();
        const parts = [];
        const experimentalAttachments = [];
        const toolInvocations = [];
        const isSingleTextContent = messageSource === `response` && Array.isArray(coreMessage.content) && coreMessage.content.length === 1 && coreMessage.content[0] && coreMessage.content[0].type === `text` && `text` in coreMessage.content[0] && coreMessage.content[0].text;
        if (isSingleTextContent && messageSource === `response`) {
            coreMessage.content = isSingleTextContent;
        }
        if (typeof coreMessage.content === "string") {
            parts.push({
                type: "text",
                text: coreMessage.content
            });
        } else if (Array.isArray(coreMessage.content)) {
            for (const aiV4Part of coreMessage.content){
                switch(aiV4Part.type){
                    case "text":
                        {
                            const prevPart = parts.at(-1);
                            if (coreMessage.role === "assistant" && prevPart && prevPart.type === "tool-invocation") {
                                parts.push({
                                    type: "step-start"
                                });
                            }
                            const part = {
                                type: "text",
                                text: aiV4Part.text
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                            break;
                        }
                    case "tool-call":
                        {
                            const part = {
                                type: "tool-invocation",
                                toolInvocation: {
                                    state: "call",
                                    toolCallId: aiV4Part.toolCallId,
                                    toolName: aiV4Part.toolName,
                                    args: aiV4Part.args
                                }
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                            break;
                        }
                    case "tool-result":
                        {
                            let toolArgs = {};
                            const toolCallInSameMsg = coreMessage.content.find((p)=>p.type === "tool-call" && p.toolCallId === aiV4Part.toolCallId);
                            if (toolCallInSameMsg && toolCallInSameMsg.type === "tool-call") {
                                toolArgs = toolCallInSameMsg.args;
                            }
                            if (Object.keys(toolArgs).length === 0 && ctx.dbMessages) {
                                toolArgs = findToolCallArgs(ctx.dbMessages, aiV4Part.toolCallId);
                            }
                            const invocation = {
                                state: "result",
                                toolCallId: aiV4Part.toolCallId,
                                toolName: aiV4Part.toolName,
                                result: aiV4Part.result ?? "",
                                args: toolArgs
                            };
                            const part = {
                                type: "tool-invocation",
                                toolInvocation: invocation
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                            toolInvocations.push(invocation);
                        }
                        break;
                    case "reasoning":
                        {
                            const part = {
                                type: "reasoning",
                                reasoning: "",
                                details: [
                                    {
                                        type: "text",
                                        text: aiV4Part.text,
                                        signature: aiV4Part.signature
                                    }
                                ]
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                        }
                        break;
                    case "redacted-reasoning":
                        {
                            const part = {
                                type: "reasoning",
                                reasoning: "",
                                details: [
                                    {
                                        type: "redacted",
                                        data: aiV4Part.data
                                    }
                                ]
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                        }
                        break;
                    case "image":
                        {
                            const part = {
                                type: "file",
                                data: imageContentToString(aiV4Part.image),
                                mimeType: aiV4Part.mimeType
                            };
                            if (aiV4Part.providerOptions) {
                                part.providerMetadata = aiV4Part.providerOptions;
                            }
                            parts.push(part);
                            break;
                        }
                    case "file":
                        {
                            if (aiV4Part.data instanceof URL) {
                                const part = {
                                    type: "file",
                                    data: aiV4Part.data.toString(),
                                    mimeType: aiV4Part.mimeType
                                };
                                if (aiV4Part.providerOptions) {
                                    part.providerMetadata = aiV4Part.providerOptions;
                                }
                                parts.push(part);
                            } else if (typeof aiV4Part.data === "string") {
                                const categorized = categorizeFileData(aiV4Part.data, aiV4Part.mimeType);
                                if (categorized.type === "url" || categorized.type === "dataUri") {
                                    const part = {
                                        type: "file",
                                        data: aiV4Part.data,
                                        mimeType: categorized.mimeType || "image/png"
                                    };
                                    if (aiV4Part.providerOptions) {
                                        part.providerMetadata = aiV4Part.providerOptions;
                                    }
                                    parts.push(part);
                                } else {
                                    try {
                                        const part = {
                                            type: "file",
                                            mimeType: categorized.mimeType || "image/png",
                                            data: convertDataContentToBase64String(aiV4Part.data)
                                        };
                                        if (aiV4Part.providerOptions) {
                                            part.providerMetadata = aiV4Part.providerOptions;
                                        }
                                        parts.push(part);
                                    } catch (error) {
                                        console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);
                                    }
                                }
                            } else {
                                try {
                                    const part = {
                                        type: "file",
                                        mimeType: aiV4Part.mimeType,
                                        data: convertDataContentToBase64String(aiV4Part.data)
                                    };
                                    if (aiV4Part.providerOptions) {
                                        part.providerMetadata = aiV4Part.providerOptions;
                                    }
                                    parts.push(part);
                                } catch (error) {
                                    console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);
                                }
                            }
                            break;
                        }
                }
            }
        }
        const content = {
            format: 2,
            parts
        };
        if (toolInvocations.length) content.toolInvocations = toolInvocations;
        if (typeof coreMessage.content === `string`) content.content = coreMessage.content;
        if (experimentalAttachments.length) content.experimental_attachments = experimentalAttachments;
        if (coreMessage.providerOptions) {
            content.providerMetadata = coreMessage.providerOptions;
        } else if ("experimental_providerMetadata" in coreMessage && coreMessage.experimental_providerMetadata) {
            content.providerMetadata = coreMessage.experimental_providerMetadata;
        }
        if ("metadata" in coreMessage && coreMessage.metadata !== null && coreMessage.metadata !== void 0) {
            content.metadata = coreMessage.metadata;
        }
        const rawCreatedAt = "metadata" in coreMessage && coreMessage.metadata && typeof coreMessage.metadata === "object" && "createdAt" in coreMessage.metadata ? coreMessage.metadata.createdAt : void 0;
        return {
            id,
            role: TypeDetector.getRole(coreMessage),
            createdAt: ctx.generateCreatedAt(messageSource, rawCreatedAt),
            threadId: ctx.memoryInfo?.threadId,
            resourceId: ctx.memoryInfo?.resourceId,
            content
        };
    }
};
// src/agent/message-list/adapters/AIV5Adapter.ts
function getToolName(type) {
    if (typeof type === "object" && type && "type" in type) {
        type = type.type;
    }
    if (typeof type !== "string") {
        return "unknown";
    }
    if (type === "dynamic-tool") {
        return "dynamic-tool";
    }
    if (type.startsWith("tool-")) {
        return type.slice("tool-".length);
    }
    return type;
}
var AIV5Adapter = class {
    /**
   * Direct conversion from MastraDBMessage to AIV5 UIMessage
   */ static toUIMessage(dbMsg) {
        const parts = [];
        const metadata = {
            ...dbMsg.content.metadata || {}
        };
        if (dbMsg.createdAt) metadata.createdAt = dbMsg.createdAt;
        if (dbMsg.threadId) metadata.threadId = dbMsg.threadId;
        if (dbMsg.resourceId) metadata.resourceId = dbMsg.resourceId;
        if (dbMsg.content.providerMetadata) {
            metadata.providerMetadata = dbMsg.content.providerMetadata;
        }
        const hasToolInvocationParts = dbMsg.content.parts?.some((p)=>p.type === "tool-invocation");
        if (dbMsg.content.toolInvocations && !hasToolInvocationParts) {
            for (const invocation of dbMsg.content.toolInvocations){
                if (invocation.state === "result") {
                    parts.push({
                        type: `tool-${invocation.toolName}`,
                        toolCallId: invocation.toolCallId,
                        state: "output-available",
                        input: invocation.args,
                        output: invocation.result
                    });
                } else {
                    parts.push({
                        type: `tool-${invocation.toolName}`,
                        toolCallId: invocation.toolCallId,
                        state: invocation.state === "call" ? "input-available" : "input-streaming",
                        input: invocation.args
                    });
                }
            }
        }
        const hasReasoningInParts = dbMsg.content.parts?.some((p)=>p.type === "reasoning");
        const hasFileInParts = dbMsg.content.parts?.some((p)=>p.type === "file");
        if (dbMsg.content.reasoning && !hasReasoningInParts) {
            parts.push({
                type: "reasoning",
                text: dbMsg.content.reasoning
            });
        }
        const attachmentUrls = /* @__PURE__ */ new Set();
        if (dbMsg.content.experimental_attachments && !hasFileInParts) {
            for (const attachment of dbMsg.content.experimental_attachments){
                attachmentUrls.add(attachment.url);
                parts.push({
                    type: "file",
                    url: attachment.url,
                    mediaType: attachment.contentType || "unknown"
                });
            }
        }
        let hasNonToolReasoningParts = false;
        if (dbMsg.content.parts) {
            for (const part of dbMsg.content.parts){
                if (part.type === "tool-invocation" && part.toolInvocation) {
                    const inv = part.toolInvocation;
                    if (inv.state === "result") {
                        parts.push({
                            type: `tool-${inv.toolName}`,
                            toolCallId: inv.toolCallId,
                            input: inv.args,
                            output: inv.result,
                            state: "output-available",
                            callProviderMetadata: part.providerMetadata
                        });
                    } else {
                        parts.push({
                            type: `tool-${inv.toolName}`,
                            toolCallId: inv.toolCallId,
                            input: inv.args,
                            state: "input-available",
                            callProviderMetadata: part.providerMetadata
                        });
                    }
                    continue;
                }
                if (part.type === "reasoning") {
                    const text = part.reasoning || (part.details?.reduce((p, c)=>{
                        if (c.type === `text` && c.text) return p + c.text;
                        return p;
                    }, "") ?? "");
                    if (text || part.details?.length) {
                        const v5UIPart = {
                            type: "reasoning",
                            text: text || "",
                            state: "done"
                        };
                        if (part.providerMetadata) {
                            v5UIPart.providerMetadata = part.providerMetadata;
                        }
                        parts.push(v5UIPart);
                    }
                    continue;
                }
                if (part.type === "tool-invocation" || part.type.startsWith("tool-")) {
                    continue;
                }
                if (part.type === "file") {
                    if (typeof part.data === "string" && attachmentUrls.has(part.data)) {
                        continue;
                    }
                    const categorized = typeof part.data === "string" ? categorizeFileData(part.data, part.mimeType) : {
                        type: "raw",
                        mimeType: part.mimeType
                    };
                    if (categorized.type === "url" && typeof part.data === "string") {
                        const v5UIPart = {
                            type: "file",
                            url: part.data,
                            mediaType: categorized.mimeType || "image/png"
                        };
                        if (part.providerMetadata) {
                            v5UIPart.providerMetadata = part.providerMetadata;
                        }
                        parts.push(v5UIPart);
                    } else {
                        let filePartData;
                        let extractedMimeType = part.mimeType;
                        if (typeof part.data === "string") {
                            const parsed = parseDataUri(part.data);
                            if (parsed.isDataUri) {
                                filePartData = parsed.base64Content;
                                if (parsed.mimeType) {
                                    extractedMimeType = extractedMimeType || parsed.mimeType;
                                }
                            } else {
                                filePartData = part.data;
                            }
                        } else {
                            filePartData = part.data;
                        }
                        const finalMimeType = extractedMimeType || "image/png";
                        let dataUri;
                        if (typeof filePartData === "string" && filePartData.startsWith("data:")) {
                            dataUri = filePartData;
                        } else {
                            dataUri = createDataUri(filePartData, finalMimeType);
                        }
                        const v5UIPart = {
                            type: "file",
                            url: dataUri,
                            mediaType: finalMimeType
                        };
                        if (part.providerMetadata) {
                            v5UIPart.providerMetadata = part.providerMetadata;
                        }
                        parts.push(v5UIPart);
                    }
                } else if (part.type === "source") {
                    const v5UIPart = {
                        type: "source-url",
                        url: part.source.url,
                        sourceId: part.source.id,
                        title: part.source.title
                    };
                    if (part.providerMetadata) {
                        v5UIPart.providerMetadata = part.providerMetadata;
                    }
                    parts.push(v5UIPart);
                } else if (part.type === "text") {
                    const v5UIPart = {
                        type: "text",
                        text: part.text
                    };
                    if (part.providerMetadata) {
                        v5UIPart.providerMetadata = part.providerMetadata;
                    }
                    parts.push(v5UIPart);
                    hasNonToolReasoningParts = true;
                } else {
                    parts.push(part);
                    hasNonToolReasoningParts = true;
                }
            }
        }
        if (dbMsg.content.content && !hasNonToolReasoningParts) {
            parts.push({
                type: "text",
                text: dbMsg.content.content
            });
        }
        return {
            id: dbMsg.id,
            role: dbMsg.role,
            metadata,
            parts
        };
    }
    /**
   * Direct conversion from AIV5 UIMessage to MastraDBMessage
   */ static fromUIMessage(uiMsg) {
        const { parts, metadata: rawMetadata } = uiMsg;
        const metadata = rawMetadata || {};
        const createdAtValue = metadata.createdAt;
        const createdAt = createdAtValue ? typeof createdAtValue === "string" ? new Date(createdAtValue) : createdAtValue instanceof Date ? createdAtValue : /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date();
        const threadId = metadata.threadId;
        const resourceId = metadata.resourceId;
        const cleanMetadata = {
            ...metadata
        };
        delete cleanMetadata.createdAt;
        delete cleanMetadata.threadId;
        delete cleanMetadata.resourceId;
        const toolInvocationParts = parts.filter((p)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(p));
        const reasoningParts = parts.filter((p)=>p.type === "reasoning");
        const fileParts = parts.filter((p)=>p.type === "file");
        const textParts = parts.filter((p)=>p.type === "text");
        let toolInvocations = void 0;
        if (toolInvocationParts.length > 0) {
            toolInvocations = toolInvocationParts.map((p)=>{
                const toolName = getToolName(p);
                if (p.state === "output-available") {
                    return {
                        args: p.input,
                        result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output,
                        toolCallId: p.toolCallId,
                        toolName,
                        state: "result"
                    };
                }
                return {
                    args: p.input,
                    toolCallId: p.toolCallId,
                    toolName,
                    state: "call"
                };
            });
        }
        let reasoning = void 0;
        if (reasoningParts.length > 0) {
            reasoning = reasoningParts.map((p)=>p.text).join("\n");
        }
        let experimental_attachments = void 0;
        if (fileParts.length > 0) {
            experimental_attachments = fileParts.map((p)=>({
                    url: p.url || "",
                    contentType: p.mediaType
                }));
        }
        let content = void 0;
        if (textParts.length > 0) {
            content = textParts.map((p)=>p.text).join("");
        }
        const v2Parts = parts.map((p)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(p)) {
                const toolName = getToolName(p);
                const callProviderMetadata = "callProviderMetadata" in p ? p.callProviderMetadata : void 0;
                if (p.state === "output-available") {
                    return {
                        type: "tool-invocation",
                        toolInvocation: {
                            toolCallId: p.toolCallId,
                            toolName,
                            args: p.input,
                            result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output,
                            state: "result"
                        },
                        providerMetadata: callProviderMetadata
                    };
                }
                return {
                    type: "tool-invocation",
                    toolInvocation: {
                        toolCallId: p.toolCallId,
                        toolName,
                        args: p.input,
                        state: "call"
                    },
                    providerMetadata: callProviderMetadata
                };
            }
            if (p.type === "reasoning") {
                return {
                    type: "reasoning",
                    reasoning: "",
                    details: [
                        {
                            type: "text",
                            text: p.text
                        }
                    ],
                    providerMetadata: p.providerMetadata
                };
            }
            if (p.type === "file") {
                return {
                    type: "file",
                    mimeType: p.mediaType,
                    data: p.url || "",
                    providerMetadata: p.providerMetadata
                };
            }
            if (p.type === "source-url") {
                return {
                    type: "source",
                    source: {
                        url: p.url,
                        sourceType: "url",
                        id: p.url,
                        providerMetadata: p.providerMetadata
                    },
                    providerMetadata: p.providerMetadata
                };
            }
            if (p.type === "text") {
                return {
                    type: "text",
                    text: p.text,
                    providerMetadata: p.providerMetadata
                };
            }
            if (p.type === "step-start") {
                return p;
            }
            if (typeof p.type === "string" && p.type.startsWith("data-")) {
                return {
                    type: p.type,
                    data: "data" in p ? p.data : void 0
                };
            }
            return null;
        }).filter((p)=>p !== null);
        return {
            id: uiMsg.id,
            role: uiMsg.role,
            createdAt,
            threadId,
            resourceId,
            content: {
                format: 2,
                parts: v2Parts,
                toolInvocations,
                reasoning,
                experimental_attachments,
                content,
                metadata: Object.keys(cleanMetadata).length > 0 ? cleanMetadata : void 0
            }
        };
    }
    /**
   * Convert image or file to data URI or URL for V2 file part
   */ static getDataStringFromAIV5DataPart(part) {
        let mimeType;
        let data;
        if ("data" in part) {
            mimeType = part.mediaType || "application/octet-stream";
            data = part.data;
        } else if ("image" in part) {
            mimeType = part.mediaType || "image/jpeg";
            data = part.image;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "MASTRA_AIV5_DATA_PART_INVALID",
                domain: "AGENT" /* AGENT */ ,
                category: "USER" /* USER */ ,
                text: "Invalid AIV5 data part in getDataStringFromAIV5DataPart",
                details: {
                    part
                }
            });
        }
        if (data instanceof URL) {
            return data.toString();
        } else {
            if (data instanceof Buffer) {
                const base64 = data.toString("base64");
                return `data:${mimeType};base64,${base64}`;
            } else if (typeof data === "string") {
                return data.startsWith("data:") || data.startsWith("http") ? data : `data:${mimeType};base64,${data}`;
            } else if (data instanceof Uint8Array) {
                const base64 = Buffer.from(data).toString("base64");
                return `data:${mimeType};base64,${base64}`;
            } else if (data instanceof ArrayBuffer) {
                const base64 = Buffer.from(data).toString("base64");
                return `data:${mimeType};base64,${base64}`;
            } else {
                return "";
            }
        }
    }
    /**
   * Direct conversion from AIV5 ModelMessage to MastraDBMessage
   */ static fromModelMessage(modelMsg, _messageSource) {
        const content = Array.isArray(modelMsg.content) ? modelMsg.content : [
            {
                type: "text",
                text: modelMsg.content
            }
        ];
        const mastraDBParts = [];
        const toolInvocations = [];
        const reasoningParts = [];
        const experimental_attachments = [];
        let lastPartWasToolResult = false;
        for (const part of content){
            if (part.type === "text") {
                const textPart = {
                    type: "text",
                    text: part.text
                };
                if (part.providerOptions) {
                    textPart.providerMetadata = part.providerOptions;
                }
                mastraDBParts.push(textPart);
                lastPartWasToolResult = false;
            } else if (part.type === "tool-call") {
                const toolCallPart = part;
                const toolInvocationPart = {
                    type: "tool-invocation",
                    toolInvocation: {
                        toolCallId: toolCallPart.toolCallId,
                        toolName: toolCallPart.toolName,
                        args: toolCallPart.input,
                        state: "call"
                    }
                };
                if (part.providerOptions) {
                    toolInvocationPart.providerMetadata = part.providerOptions;
                }
                mastraDBParts.push(toolInvocationPart);
                toolInvocations.push({
                    toolCallId: toolCallPart.toolCallId,
                    toolName: toolCallPart.toolName,
                    args: toolCallPart.input,
                    state: "call"
                });
                lastPartWasToolResult = false;
            } else if (part.type === "tool-result") {
                const toolResultPart = part;
                const matchingCall = toolInvocations.find((inv)=>inv.toolCallId === toolResultPart.toolCallId);
                const matchingV2Part = mastraDBParts.find((p)=>p.type === "tool-invocation" && "toolInvocation" in p && p.toolInvocation.toolCallId === toolResultPart.toolCallId);
                const updateMatchingCallInvocationResult = (toolResultPart2, matchingCall2)=>{
                    matchingCall2.state = "result";
                    matchingCall2.result = typeof toolResultPart2.output === "object" && toolResultPart2.output && "value" in toolResultPart2.output ? toolResultPart2.output.value : toolResultPart2.output;
                };
                if (matchingCall) {
                    updateMatchingCallInvocationResult(toolResultPart, matchingCall);
                } else {
                    const call = {
                        state: "call",
                        toolCallId: toolResultPart.toolCallId,
                        toolName: toolResultPart.toolName || "unknown",
                        args: {}
                    };
                    updateMatchingCallInvocationResult(toolResultPart, call);
                    toolInvocations.push(call);
                }
                if (matchingV2Part && matchingV2Part.type === "tool-invocation") {
                    updateMatchingCallInvocationResult(toolResultPart, matchingV2Part.toolInvocation);
                } else {
                    const toolInvocationPart = {
                        type: "tool-invocation",
                        toolInvocation: {
                            toolCallId: toolResultPart.toolCallId,
                            toolName: toolResultPart.toolName || "unknown",
                            args: {},
                            state: "call"
                        }
                    };
                    updateMatchingCallInvocationResult(toolResultPart, toolInvocationPart.toolInvocation);
                    mastraDBParts.push(toolInvocationPart);
                }
                lastPartWasToolResult = true;
            } else if (part.type === "reasoning") {
                const v2ReasoningPart = {
                    type: "reasoning",
                    reasoning: "",
                    details: [
                        {
                            type: "text",
                            text: part.text
                        }
                    ]
                };
                if (part.providerOptions) {
                    v2ReasoningPart.providerMetadata = part.providerOptions;
                }
                mastraDBParts.push(v2ReasoningPart);
                reasoningParts.push(part.text);
                lastPartWasToolResult = false;
            } else if (part.type === "image") {
                const imagePart = part;
                const mimeType = imagePart.mediaType || "image/jpeg";
                const imageData = this.getDataStringFromAIV5DataPart(imagePart);
                const imageFilePart = {
                    type: "file",
                    data: imageData,
                    mimeType
                };
                if (part.providerOptions) {
                    imageFilePart.providerMetadata = part.providerOptions;
                }
                mastraDBParts.push(imageFilePart);
                experimental_attachments.push({
                    url: imageData,
                    contentType: mimeType
                });
                lastPartWasToolResult = false;
            } else if (part.type === "file") {
                const filePart = part;
                const mimeType = filePart.mediaType || "application/octet-stream";
                const fileData = this.getDataStringFromAIV5DataPart(filePart);
                const v2FilePart = {
                    type: "file",
                    data: fileData,
                    mimeType
                };
                if (part.providerOptions) {
                    v2FilePart.providerMetadata = part.providerOptions;
                }
                mastraDBParts.push(v2FilePart);
                experimental_attachments.push({
                    url: fileData,
                    contentType: mimeType
                });
                lastPartWasToolResult = false;
            }
        }
        if (modelMsg.role === "assistant" && lastPartWasToolResult && mastraDBParts.length > 0) {
            const lastPart = mastraDBParts[mastraDBParts.length - 1];
            if (lastPart && lastPart.type !== "text") {
                const emptyTextPart = {
                    type: "text",
                    text: ""
                };
                mastraDBParts.push(emptyTextPart);
            }
        }
        const contentString = mastraDBParts.filter((p)=>p.type === "text").map((p)=>p.text).join("\n");
        const metadata = "metadata" in modelMsg && modelMsg.metadata !== null && modelMsg.metadata !== void 0 ? modelMsg.metadata : {};
        const id = `id` in modelMsg && typeof modelMsg.id === `string` ? modelMsg.id : `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const message = {
            id,
            role: modelMsg.role === "tool" ? "assistant" : modelMsg.role,
            createdAt: /* @__PURE__ */ new Date(),
            content: {
                format: 2,
                parts: mastraDBParts,
                toolInvocations: toolInvocations.length > 0 ? toolInvocations : void 0,
                reasoning: reasoningParts.length > 0 ? reasoningParts.join("\n") : void 0,
                experimental_attachments: experimental_attachments.length > 0 ? experimental_attachments : void 0,
                content: contentString || void 0,
                metadata: Object.keys(metadata).length > 0 ? metadata : void 0
            }
        };
        if (modelMsg.providerOptions) {
            message.content.providerMetadata = modelMsg.providerOptions;
        }
        return message;
    }
};
// src/agent/message-list/cache/CacheKeyGenerator.ts
var CacheKeyGenerator = class _CacheKeyGenerator {
    /**
   * Generate cache key from AIV4 UIMessage parts
   */ static fromAIV4Parts(parts) {
        let key = "";
        for (const part of parts){
            key += part.type;
            key += _CacheKeyGenerator.fromAIV4Part(part);
        }
        return key;
    }
    /**
   * Generate cache key from a single AIV4 UIMessage part
   */ static fromAIV4Part(part) {
        let cacheKey = "";
        if (part.type === "text") {
            cacheKey += part.text;
        }
        if (part.type === "tool-invocation") {
            cacheKey += part.toolInvocation.toolCallId;
            cacheKey += part.toolInvocation.state;
        }
        if (part.type === "reasoning") {
            cacheKey += part.reasoning;
            cacheKey += part.details.reduce((prev, current)=>{
                if (current.type === "text") {
                    return prev + current.text.length + (current.signature?.length || 0);
                }
                return prev;
            }, 0);
            const partAny = part;
            if (partAny && Object.hasOwn(partAny, "providerMetadata") && partAny.providerMetadata && Object.hasOwn(partAny.providerMetadata, "openai") && partAny.providerMetadata.openai && Object.hasOwn(partAny.providerMetadata.openai, "itemId")) {
                const itemId = partAny.providerMetadata.openai.itemId;
                cacheKey += `|${itemId}`;
            }
        }
        if (part.type === "file") {
            cacheKey += part.data;
            cacheKey += part.mimeType;
        }
        return cacheKey;
    }
    /**
   * Generate cache key from MastraDB message parts
   */ static fromDBParts(parts) {
        let key = "";
        for (const part of parts){
            key += part.type;
            if (part.type.startsWith("data-")) {
                const data = part.data;
                key += JSON.stringify(data);
            } else {
                key += _CacheKeyGenerator.fromAIV4Part(part);
            }
        }
        return key;
    }
    /**
   * Generate cache key from AIV4 CoreMessage content
   */ static fromAIV4CoreMessageContent(content) {
        if (typeof content === "string") return content;
        let key = "";
        for (const part of content){
            key += part.type;
            if (part.type === "text") {
                key += part.text.length;
            }
            if (part.type === "reasoning") {
                key += part.text.length;
            }
            if (part.type === "tool-call") {
                key += part.toolCallId;
                key += part.toolName;
            }
            if (part.type === "tool-result") {
                key += part.toolCallId;
                key += part.toolName;
            }
            if (part.type === "file") {
                key += part.filename;
                key += part.mimeType;
            }
            if (part.type === "image") {
                key += getImageCacheKey(part.image);
                key += part.mimeType;
            }
            if (part.type === "redacted-reasoning") {
                key += part.data.length;
            }
        }
        return key;
    }
    /**
   * Generate cache key from AIV5 UIMessage parts
   */ static fromAIV5Parts(parts) {
        let key = "";
        for (const part of parts){
            key += part.type;
            if (part.type === "text") {
                key += part.text;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(part) || part.type === "dynamic-tool") {
                key += part.toolCallId;
                key += part.state;
            }
            if (part.type === "reasoning") {
                key += part.text;
            }
            if (part.type === "file") {
                key += part.url.length;
                key += part.mediaType;
                key += part.filename || "";
            }
        }
        return key;
    }
    /**
   * Generate cache key from AIV5 ModelMessage content
   */ static fromAIV5ModelMessageContent(content) {
        if (typeof content === "string") return content;
        let key = "";
        for (const part of content){
            key += part.type;
            if (part.type === "text") {
                key += part.text.length;
            }
            if (part.type === "reasoning") {
                key += part.text.length;
            }
            if (part.type === "tool-call") {
                key += part.toolCallId;
                key += part.toolName;
            }
            if (part.type === "tool-result") {
                key += part.toolCallId;
                key += part.toolName;
            }
            if (part.type === "file") {
                key += part.filename;
                key += part.mediaType;
            }
            if (part.type === "image") {
                key += getImageCacheKey(part.image);
                key += part.mediaType;
            }
        }
        return key;
    }
};
// src/agent/message-list/conversion/to-prompt.ts
function aiV4CoreMessageToV1PromptMessage(coreMessage) {
    if (coreMessage.role === `system`) {
        return coreMessage;
    }
    if (typeof coreMessage.content === `string` && (coreMessage.role === `assistant` || coreMessage.role === `user`)) {
        return {
            ...coreMessage,
            content: [
                {
                    type: "text",
                    text: coreMessage.content
                }
            ]
        };
    }
    if (typeof coreMessage.content === `string`) {
        throw new Error(`Saw text content for input CoreMessage, but the role is ${coreMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`);
    }
    const roleContent = {
        user: [],
        assistant: [],
        tool: []
    };
    const role = coreMessage.role;
    for (const part of coreMessage.content){
        const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
        switch(part.type){
            case "text":
                {
                    if (role === `tool`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "redacted-reasoning":
            case "reasoning":
                {
                    if (role !== `assistant`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "tool-call":
                {
                    if (role === `tool` || role === `user`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "tool-result":
                {
                    if (role === `assistant` || role === `user`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "image":
                {
                    if (role === `tool` || role === `assistant`) {
                        throw new Error(incompatibleMessage);
                    }
                    let processedImage;
                    if (part.image instanceof URL || part.image instanceof Uint8Array) {
                        processedImage = part.image;
                    } else if (Buffer.isBuffer(part.image) || part.image instanceof ArrayBuffer) {
                        processedImage = new Uint8Array(part.image);
                    } else {
                        const categorized = categorizeFileData(part.image, part.mimeType);
                        if (categorized.type === "raw") {
                            const dataUri = createDataUri(part.image, part.mimeType || "image/png");
                            processedImage = new URL(dataUri);
                        } else {
                            processedImage = new URL(part.image);
                        }
                    }
                    roleContent[role].push({
                        ...part,
                        image: processedImage
                    });
                    break;
                }
            case "file":
                {
                    if (role === `tool`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push({
                        ...part,
                        data: part.data instanceof URL ? part.data : typeof part.data === "string" ? part.data : convertDataContentToBase64String(part.data)
                    });
                    break;
                }
        }
    }
    if (role === `tool`) {
        return {
            ...coreMessage,
            content: roleContent[role]
        };
    }
    if (role === `user`) {
        return {
            ...coreMessage,
            content: roleContent[role]
        };
    }
    if (role === `assistant`) {
        return {
            ...coreMessage,
            content: roleContent[role]
        };
    }
    throw new Error(`Encountered unknown role ${role} when converting V4 CoreMessage -> V4 LanguageModelV1Prompt, input message: ${JSON.stringify(coreMessage, null, 2)}`);
}
function aiV5ModelMessageToV2PromptMessage(modelMessage) {
    if (modelMessage.role === `system`) {
        return modelMessage;
    }
    if (typeof modelMessage.content === `string` && (modelMessage.role === `assistant` || modelMessage.role === `user`)) {
        return {
            role: modelMessage.role,
            content: [
                {
                    type: "text",
                    text: modelMessage.content
                }
            ],
            providerOptions: modelMessage.providerOptions
        };
    }
    if (typeof modelMessage.content === `string`) {
        throw new Error(`Saw text content for input ModelMessage, but the role is ${modelMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`);
    }
    const roleContent = {
        user: [],
        assistant: [],
        tool: []
    };
    const role = modelMessage.role;
    for (const part of modelMessage.content){
        const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
        switch(part.type){
            case "text":
                {
                    if (role === `tool`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "reasoning":
                {
                    if (role === `tool` || role === `user`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "tool-call":
                {
                    if (role !== `assistant`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "tool-result":
                {
                    if (role === `assistant` || role === `user`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push(part);
                    break;
                }
            case "file":
                {
                    if (role === `tool`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push({
                        ...part,
                        data: part.data instanceof ArrayBuffer ? new Uint8Array(part.data) : part.data
                    });
                    break;
                }
            case "image":
                {
                    if (role === `tool`) {
                        throw new Error(incompatibleMessage);
                    }
                    roleContent[role].push({
                        ...part,
                        mediaType: part.mediaType || "image/unknown",
                        type: "file",
                        data: part.image instanceof ArrayBuffer ? new Uint8Array(part.image) : part.image
                    });
                    break;
                }
        }
    }
    if (role === `tool`) {
        return {
            ...modelMessage,
            content: roleContent[role]
        };
    }
    if (role === `user`) {
        return {
            ...modelMessage,
            content: roleContent[role]
        };
    }
    if (role === `assistant`) {
        return {
            ...modelMessage,
            content: roleContent[role]
        };
    }
    throw new Error(`Encountered unknown role ${role} when converting V5 ModelMessage -> V5 LanguageModelV2Message, input message: ${JSON.stringify(modelMessage, null, 2)}`);
}
// src/agent/message-list/conversion/utils.ts
function coreContentToString(content) {
    if (typeof content === `string`) return content;
    return content.reduce((p, c)=>{
        if (c.type === `text`) {
            p += c.text;
        }
        return p;
    }, "");
}
function messagesAreEqual(one, two) {
    const oneUIV4 = TypeDetector.isAIV4UIMessage(one) && one;
    const twoUIV4 = TypeDetector.isAIV4UIMessage(two) && two;
    if (oneUIV4 && !twoUIV4) return false;
    if (oneUIV4 && twoUIV4) {
        return CacheKeyGenerator.fromAIV4Parts(one.parts) === CacheKeyGenerator.fromAIV4Parts(two.parts);
    }
    const oneCMV4 = TypeDetector.isAIV4CoreMessage(one) && one;
    const twoCMV4 = TypeDetector.isAIV4CoreMessage(two) && two;
    if (oneCMV4 && !twoCMV4) return false;
    if (oneCMV4 && twoCMV4) {
        return CacheKeyGenerator.fromAIV4CoreMessageContent(oneCMV4.content) === CacheKeyGenerator.fromAIV4CoreMessageContent(twoCMV4.content);
    }
    const oneMM1 = TypeDetector.isMastraMessageV1(one) && one;
    const twoMM1 = TypeDetector.isMastraMessageV1(two) && two;
    if (oneMM1 && !twoMM1) return false;
    if (oneMM1 && twoMM1) {
        return oneMM1.id === twoMM1.id && CacheKeyGenerator.fromAIV4CoreMessageContent(oneMM1.content) === CacheKeyGenerator.fromAIV4CoreMessageContent(twoMM1.content);
    }
    const oneMM2 = TypeDetector.isMastraDBMessage(one) && one;
    const twoMM2 = TypeDetector.isMastraDBMessage(two) && two;
    if (oneMM2 && !twoMM2) return false;
    if (oneMM2 && twoMM2) {
        return oneMM2.id === twoMM2.id && CacheKeyGenerator.fromDBParts(oneMM2.content.parts) === CacheKeyGenerator.fromDBParts(twoMM2.content.parts);
    }
    const oneUIV5 = TypeDetector.isAIV5UIMessage(one) && one;
    const twoUIV5 = TypeDetector.isAIV5UIMessage(two) && two;
    if (oneUIV5 && !twoUIV5) return false;
    if (oneUIV5 && twoUIV5) {
        return CacheKeyGenerator.fromAIV5Parts(one.parts) === CacheKeyGenerator.fromAIV5Parts(two.parts);
    }
    const oneCMV5 = TypeDetector.isAIV5CoreMessage(one) && one;
    const twoCMV5 = TypeDetector.isAIV5CoreMessage(two) && two;
    if (oneCMV5 && !twoCMV5) return false;
    if (oneCMV5 && twoCMV5) {
        return CacheKeyGenerator.fromAIV5ModelMessageContent(oneCMV5.content) === CacheKeyGenerator.fromAIV5ModelMessageContent(twoCMV5.content);
    }
    return true;
}
// src/agent/message-list/conversion/input-converter.ts
function inputToMastraDBMessage(message, messageSource, context) {
    if (messageSource !== `memory` && `threadId` in message && message.threadId && context.memoryInfo && message.threadId !== context.memoryInfo.threadId) {
        throw new Error(`Received input message with wrong threadId. Input ${message.threadId}, expected ${context.memoryInfo.threadId}`);
    }
    if (`resourceId` in message && message.resourceId && context.memoryInfo?.resourceId && message.resourceId !== context.memoryInfo.resourceId) {
        throw new Error(`Received input message with wrong resourceId. Input ${message.resourceId}, expected ${context.memoryInfo.resourceId}`);
    }
    if (TypeDetector.isMastraMessageV1(message)) {
        return mastraMessageV1ToMastraDBMessage(message, messageSource, context);
    }
    if (TypeDetector.isMastraDBMessage(message)) {
        return hydrateMastraDBMessageFields(message, context);
    }
    if (TypeDetector.isAIV4CoreMessage(message)) {
        return AIV4Adapter.fromCoreMessage(message, context, messageSource);
    }
    if (TypeDetector.isAIV4UIMessage(message)) {
        return AIV4Adapter.fromUIMessage(message, context, messageSource);
    }
    const hasOriginalId = "id" in message && typeof message.id === "string";
    const id = hasOriginalId ? message.id : context.newMessageId();
    if (TypeDetector.isAIV5CoreMessage(message)) {
        const dbMsg = AIV5Adapter.fromModelMessage(message, messageSource);
        const rawCreatedAt = "metadata" in message && message.metadata && typeof message.metadata === "object" && "createdAt" in message.metadata ? message.metadata.createdAt : void 0;
        return {
            ...dbMsg,
            id,
            createdAt: context.generateCreatedAt(messageSource, rawCreatedAt),
            threadId: context.memoryInfo?.threadId,
            resourceId: context.memoryInfo?.resourceId
        };
    }
    if (TypeDetector.isAIV5UIMessage(message)) {
        const dbMsg = AIV5Adapter.fromUIMessage(message);
        const rawCreatedAt = "createdAt" in message ? message.createdAt : void 0;
        return {
            ...dbMsg,
            id,
            createdAt: context.generateCreatedAt(messageSource, rawCreatedAt),
            threadId: context.memoryInfo?.threadId,
            resourceId: context.memoryInfo?.resourceId
        };
    }
    throw new Error(`Found unhandled message ${JSON.stringify(message)}`);
}
function mastraMessageV1ToMastraDBMessage(message, messageSource, context) {
    const coreV2 = AIV4Adapter.fromCoreMessage({
        content: message.content,
        role: message.role
    }, context, messageSource);
    return {
        id: message.id,
        role: coreV2.role,
        createdAt: context.generateCreatedAt(messageSource, message.createdAt),
        threadId: message.threadId,
        resourceId: message.resourceId,
        content: coreV2.content
    };
}
function hydrateMastraDBMessageFields(message, context) {
    if (!message.id) {
        message.id = context.newMessageId();
    }
    if (!(message.createdAt instanceof Date)) {
        message.createdAt = new Date(message.createdAt);
    }
    if (message.content.toolInvocations && message.content.parts) {
        message.content.toolInvocations = message.content.toolInvocations.map((ti)=>{
            if (!ti.args || Object.keys(ti.args).length === 0) {
                const partWithArgs = message.content.parts.find((part)=>part.type === "tool-invocation" && part.toolInvocation && part.toolInvocation.toolCallId === ti.toolCallId && part.toolInvocation.args && Object.keys(part.toolInvocation.args).length > 0);
                if (partWithArgs && partWithArgs.type === "tool-invocation") {
                    return {
                        ...ti,
                        args: partWithArgs.toolInvocation.args
                    };
                }
            }
            return ti;
        });
    }
    if (!message.threadId && context.memoryInfo?.threadId) {
        message.threadId = context.memoryInfo.threadId;
        if (!message.resourceId && context.memoryInfo?.resourceId) {
            message.resourceId = context.memoryInfo.resourceId;
        }
    }
    return message;
}
// src/agent/message-list/conversion/output-converter.ts
function sanitizeAIV4UIMessages(messages) {
    const msgs = messages.map((m)=>{
        if (m.parts.length === 0) return false;
        const safeParts = m.parts.filter((p)=>p.type !== `tool-invocation` || // calls and partial-calls should be updated to be results at this point
            // if they haven't we can't send them back to the llm and need to remove them.
            p.toolInvocation.state !== `call` && p.toolInvocation.state !== `partial-call`);
        if (!safeParts.length) return false;
        const sanitized = {
            ...m,
            parts: safeParts
        };
        if (`toolInvocations` in m && m.toolInvocations) {
            sanitized.toolInvocations = m.toolInvocations.filter((t)=>t.state === `result`);
        }
        return sanitized;
    }).filter((m)=>Boolean(m));
    return msgs;
}
function sanitizeV5UIMessages(messages, filterIncompleteToolCalls = false) {
    const msgs = messages.map((m)=>{
        if (m.parts.length === 0) return false;
        const safeParts = m.parts.filter((p)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(p)) return true;
            if (filterIncompleteToolCalls) {
                return p.state === "output-available" || p.state === "output-error";
            }
            return p.state !== "input-streaming";
        });
        if (!safeParts.length) return false;
        const sanitized = {
            ...m,
            parts: safeParts.map((part)=>{
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(part) && part.state === "output-available") {
                    return {
                        ...part,
                        output: typeof part.output === "object" && part.output && "value" in part.output ? part.output.value : part.output
                    };
                }
                return part;
            })
        };
        return sanitized;
    }).filter((m)=>Boolean(m));
    return msgs;
}
function addStartStepPartsForAIV5(messages) {
    for (const message of messages){
        if (message.role !== `assistant`) continue;
        for (const [index, part] of message.parts.entries()){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(part)) continue;
            const nextPart = message.parts.at(index + 1);
            if (nextPart && nextPart.type !== `step-start` && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToolUIPart"])(nextPart)) {
                message.parts.splice(index + 1, 0, {
                    type: "step-start"
                });
            }
        }
    }
    return messages;
}
function aiV4UIMessagesToAIV4CoreMessages(messages) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$6OBQKOBQ$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertToCoreMessages"])(sanitizeAIV4UIMessages(messages));
}
function aiV5UIMessagesToAIV5ModelMessages(messages, dbMessages, filterIncompleteToolCalls = false) {
    const sanitized = sanitizeV5UIMessages(messages, filterIncompleteToolCalls);
    const preprocessed = addStartStepPartsForAIV5(sanitized);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertToModelMessages"])(preprocessed);
    const withProviderOptions = result.map((modelMsg, index)=>{
        const uiMsg = preprocessed[index];
        if (uiMsg?.metadata && typeof uiMsg.metadata === "object" && "providerMetadata" in uiMsg.metadata && uiMsg.metadata.providerMetadata) {
            return {
                ...modelMsg,
                providerOptions: uiMsg.metadata.providerMetadata
            };
        }
        return modelMsg;
    });
    return ensureAnthropicCompatibleMessages(withProviderOptions, dbMessages);
}
function aiV4CoreMessagesToAIV5ModelMessages(messages, source, adapterContext, dbMessages) {
    return aiV5UIMessagesToAIV5ModelMessages(messages.map((m)=>AIV4Adapter.fromCoreMessage(m, adapterContext, source)).map((m)=>AIV5Adapter.toUIMessage(m)), dbMessages);
}
function systemMessageToAIV4Core(message) {
    if (typeof message === `string`) {
        return {
            role: "system",
            content: message
        };
    }
    if (TypeDetector.isAIV5CoreMessage(message)) {
        const dbMsg = AIV5Adapter.fromModelMessage(message, "system");
        return AIV4Adapter.systemToV4Core(dbMsg);
    }
    if (TypeDetector.isMastraDBMessage(message)) {
        return AIV4Adapter.systemToV4Core(message);
    }
    return message;
}
var DefaultGeneratedFile = class {
    base64Data;
    uint8ArrayData;
    mediaType;
    constructor({ data, mediaType }){
        const isUint8Array = data instanceof Uint8Array;
        this.base64Data = isUint8Array ? void 0 : data;
        this.uint8ArrayData = isUint8Array ? data : void 0;
        this.mediaType = mediaType;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get base64() {
        if (this.base64Data == null) {
            this.base64Data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(this.uint8ArrayData);
        }
        return this.base64Data;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get uint8Array() {
        if (this.uint8ArrayData == null) {
            this.uint8ArrayData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertBase64ToUint8Array"])(this.base64Data);
        }
        return this.uint8ArrayData;
    }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
    type = "file";
    constructor(options){
        super(options);
    }
};
// src/agent/message-list/conversion/step-content.ts
var StepContentExtractor = class _StepContentExtractor {
    /**
   * Extract content for a specific step number from UI messages
   *
   * @param uiMessages - Array of AI SDK V5 UI messages
   * @param stepNumber - Step number to extract (1-indexed, or -1 for last step)
   * @param stepContentFn - Function to convert model messages to step content
   * @returns Step content array
   */ static extractStepContent(uiMessages, stepNumber, stepContentFn) {
        const uiMessagesParts = uiMessages.flatMap((item)=>item.parts);
        const stepBoundaries = [];
        uiMessagesParts.forEach((part, index)=>{
            if (part.type === "step-start") {
                stepBoundaries.push(index);
            }
        });
        if (stepNumber === -1) {
            return _StepContentExtractor.extractLastStep(uiMessagesParts, stepBoundaries, stepContentFn);
        }
        if (stepNumber === 1) {
            return _StepContentExtractor.extractFirstStep(uiMessagesParts, stepBoundaries, stepContentFn);
        }
        return _StepContentExtractor.extractMiddleStep(uiMessagesParts, stepBoundaries, stepNumber, stepContentFn);
    }
    /**
   * Extract the last step content (stepNumber === -1)
   */ static extractLastStep(uiMessagesParts, stepBoundaries, stepContentFn) {
        const toolParts = uiMessagesParts.filter((p)=>p.type?.startsWith("tool-"));
        const hasStepStart = stepBoundaries.length > 0;
        if (!hasStepStart && toolParts.length > 0) {
            const lastToolPart = toolParts[toolParts.length - 1];
            if (!lastToolPart) {
                return [];
            }
            const lastToolIndex = uiMessagesParts.indexOf(lastToolPart);
            const previousToolPart = toolParts[toolParts.length - 2];
            const previousToolIndex = previousToolPart ? uiMessagesParts.indexOf(previousToolPart) : -1;
            const startIndex = previousToolIndex + 1;
            const stepParts2 = uiMessagesParts.slice(startIndex, lastToolIndex + 1);
            return _StepContentExtractor.convertPartsToContent(stepParts2, "last-step", stepContentFn);
        }
        const totalSteps = stepBoundaries.length + 1;
        if (totalSteps === 1 && !hasStepStart) {
            return _StepContentExtractor.convertPartsToContent(uiMessagesParts, "last-step", stepContentFn);
        }
        const lastStepStart = stepBoundaries[stepBoundaries.length - 1];
        if (lastStepStart === void 0) {
            return [];
        }
        const stepParts = uiMessagesParts.slice(lastStepStart + 1);
        if (stepParts.length === 0) {
            return [];
        }
        return _StepContentExtractor.convertPartsToContent(stepParts, "last-step", stepContentFn);
    }
    /**
   * Extract the first step content (stepNumber === 1)
   */ static extractFirstStep(uiMessagesParts, stepBoundaries, stepContentFn) {
        const firstStepStart = stepBoundaries[0] ?? uiMessagesParts.length;
        if (firstStepStart === 0) {
            return [];
        }
        const stepParts = uiMessagesParts.slice(0, firstStepStart);
        return _StepContentExtractor.convertPartsToContent(stepParts, "step-1", stepContentFn);
    }
    /**
   * Extract content for steps 2+ (between step-start markers)
   */ static extractMiddleStep(uiMessagesParts, stepBoundaries, stepNumber, stepContentFn) {
        const stepIndex = stepNumber - 2;
        if (stepIndex < 0 || stepIndex >= stepBoundaries.length) {
            return [];
        }
        const startIndex = (stepBoundaries[stepIndex] ?? 0) + 1;
        const endIndex = stepBoundaries[stepIndex + 1] ?? uiMessagesParts.length;
        if (startIndex >= endIndex) {
            return [];
        }
        const stepParts = uiMessagesParts.slice(startIndex, endIndex);
        return _StepContentExtractor.convertPartsToContent(stepParts, `step-${stepNumber}`, stepContentFn);
    }
    /**
   * Convert UI message parts to step content
   */ static convertPartsToContent(parts, stepId, stepContentFn) {
        const stepUiMessages = [
            {
                id: stepId,
                role: "assistant",
                parts
            }
        ];
        const modelMessages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$K2LPTKSY$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertToModelMessages"])(sanitizeV5UIMessages(stepUiMessages));
        return modelMessages.flatMap(stepContentFn);
    }
    /**
   * Convert a single model message content to step result content
   *
   * This handles:
   * - Tool results: adding input field from DB messages
   * - Files: converting to GeneratedFile format
   * - Images: converting to file format with proper media type
   * - Other content: passed through as-is
   *
   * @param message - Model message to convert (or undefined to use latest)
   * @param dbMessages - Database messages for looking up tool call args
   * @param getLatestMessage - Function to get the latest model message if not provided
   */ static convertToStepContent(message, dbMessages, getLatestMessage) {
        const latest = message ? message : getLatestMessage();
        if (!latest) return [];
        if (typeof latest.content === "string") {
            return [
                {
                    type: "text",
                    text: latest.content
                }
            ];
        }
        return latest.content.map((c)=>{
            if (c.type === "tool-result") {
                return {
                    type: "tool-result",
                    input: findToolCallArgs(dbMessages, c.toolCallId),
                    output: c.output,
                    toolCallId: c.toolCallId,
                    toolName: c.toolName
                };
            }
            if (c.type === "file") {
                return {
                    type: "file",
                    file: new DefaultGeneratedFileWithType({
                        data: typeof c.data === "string" ? parseDataUri(c.data).base64Content : c.data instanceof URL ? c.data.toString() : convertDataContentToBase64String(c.data),
                        mediaType: c.mediaType
                    })
                };
            }
            if (c.type === "image") {
                return {
                    type: "file",
                    file: new DefaultGeneratedFileWithType({
                        data: typeof c.image === "string" ? parseDataUri(c.image).base64Content : c.image instanceof URL ? c.image.toString() : convertDataContentToBase64String(c.image),
                        mediaType: c.mediaType || "unknown"
                    })
                };
            }
            return {
                ...c
            };
        });
    }
};
// src/agent/message-list/merge/MessageMerger.ts
var MessageMerger = class _MessageMerger {
    /**
   * Check if we should merge an incoming message with the latest message
   *
   * @param latestMessage - The most recent message in the list
   * @param incomingMessage - The message being added
   * @param messageSource - The source of the incoming message ('memory', 'input', 'response', 'context')
   * @param isLatestFromMemory - Whether the latest message is from memory
   * @param agentNetworkAppend - Whether agent network append mode is enabled
   */ static shouldMerge(latestMessage, incomingMessage, messageSource, isLatestFromMemory, agentNetworkAppend = false) {
        if (!latestMessage) return false;
        const shouldAppendToLastAssistantMessage = latestMessage.role === "assistant" && incomingMessage.role === "assistant" && latestMessage.threadId === incomingMessage.threadId && // If the message is from memory, don't append to the last assistant message
        messageSource !== "memory";
        const appendNetworkMessage = agentNetworkAppend ? !isLatestFromMemory : true;
        return shouldAppendToLastAssistantMessage && appendNetworkMessage;
    }
    /**
   * Merge an incoming assistant message into the latest assistant message
   *
   * This handles:
   * - Updating tool invocations with their results
   * - Adding new parts in the correct order using anchor maps
   * - Inserting step-start markers where needed
   * - Updating timestamps and content strings
   */ static merge(latestMessage, incomingMessage) {
        latestMessage.createdAt = incomingMessage.createdAt || latestMessage.createdAt;
        const toolResultAnchorMap = /* @__PURE__ */ new Map();
        const partsToAdd = /* @__PURE__ */ new Map();
        for (const [index, part] of incomingMessage.content.parts.entries()){
            if (part.type === "tool-invocation") {
                const existingCallPart = [
                    ...latestMessage.content.parts
                ].reverse().find((p)=>p.type === "tool-invocation" && p.toolInvocation.toolCallId === part.toolInvocation.toolCallId);
                const existingCallToolInvocation = !!existingCallPart && existingCallPart.type === "tool-invocation";
                if (existingCallToolInvocation) {
                    if (part.toolInvocation.state === "result") {
                        existingCallPart.toolInvocation = {
                            ...existingCallPart.toolInvocation,
                            step: part.toolInvocation.step,
                            state: "result",
                            result: part.toolInvocation.result,
                            args: {
                                ...existingCallPart.toolInvocation.args,
                                ...part.toolInvocation.args
                            }
                        };
                        if (!latestMessage.content.toolInvocations) {
                            latestMessage.content.toolInvocations = [];
                        }
                        const toolInvocationIndex = latestMessage.content.toolInvocations.findIndex((t)=>t.toolCallId === existingCallPart.toolInvocation.toolCallId);
                        if (toolInvocationIndex === -1) {
                            latestMessage.content.toolInvocations.push(existingCallPart.toolInvocation);
                        } else {
                            latestMessage.content.toolInvocations[toolInvocationIndex] = existingCallPart.toolInvocation;
                        }
                    }
                    const existingIndex = latestMessage.content.parts.findIndex((p)=>p === existingCallPart);
                    toolResultAnchorMap.set(index, existingIndex);
                } else {
                    partsToAdd.set(index, part);
                }
            } else {
                partsToAdd.set(index, part);
            }
        }
        _MessageMerger.addPartsToMessage({
            latestMessage,
            incomingMessage,
            anchorMap: toolResultAnchorMap,
            partsToAdd
        });
        if (latestMessage.createdAt.getTime() < incomingMessage.createdAt.getTime()) {
            latestMessage.createdAt = incomingMessage.createdAt;
        }
        if (!latestMessage.content.content && incomingMessage.content.content) {
            latestMessage.content.content = incomingMessage.content.content;
        }
        if (latestMessage.content.content && incomingMessage.content.content && latestMessage.content.content !== incomingMessage.content.content) {
            latestMessage.content.content = incomingMessage.content.content;
        }
    }
    /**
   * Add parts from the incoming message to the latest message using anchor positions
   */ static addPartsToMessage({ latestMessage, incomingMessage, anchorMap, partsToAdd }) {
        for(let i = 0; i < incomingMessage.content.parts.length; ++i){
            const part = incomingMessage.content.parts[i];
            if (!part) continue;
            const key = CacheKeyGenerator.fromDBParts([
                part
            ]);
            const partToAdd = partsToAdd.get(i);
            if (!key || !partToAdd) continue;
            if (anchorMap.size > 0) {
                if (anchorMap.has(i)) continue;
                const leftAnchorV2 = [
                    ...anchorMap.keys()
                ].filter((idx)=>idx < i).pop() ?? -1;
                const rightAnchorV2 = [
                    ...anchorMap.keys()
                ].find((idx)=>idx > i) ?? -1;
                const leftAnchorLatest = leftAnchorV2 !== -1 ? anchorMap.get(leftAnchorV2) : 0;
                const offset = leftAnchorV2 === -1 ? i : i - leftAnchorV2;
                const insertAt = leftAnchorLatest + offset;
                const rightAnchorLatest = rightAnchorV2 !== -1 ? anchorMap.get(rightAnchorV2) : latestMessage.content.parts.length;
                if (insertAt >= 0 && insertAt <= rightAnchorLatest && !latestMessage.content.parts.slice(insertAt, rightAnchorLatest).some((p)=>CacheKeyGenerator.fromDBParts([
                        p
                    ]) === CacheKeyGenerator.fromDBParts([
                        part
                    ]))) {
                    _MessageMerger.pushNewPart({
                        latestMessage,
                        newMessage: incomingMessage,
                        part,
                        insertAt
                    });
                    for (const [v2Idx, latestIdx] of anchorMap.entries()){
                        if (latestIdx >= insertAt) {
                            anchorMap.set(v2Idx, latestIdx + 1);
                        }
                    }
                }
            } else {
                _MessageMerger.pushNewPart({
                    latestMessage,
                    newMessage: incomingMessage,
                    part
                });
            }
        }
    }
    /**
   * Push a new message part to the latest message
   */ static pushNewPart({ latestMessage, newMessage, part, insertAt }) {
        const partKey = CacheKeyGenerator.fromDBParts([
            part
        ]);
        const latestPartCount = latestMessage.content.parts.filter((p)=>CacheKeyGenerator.fromDBParts([
                p
            ]) === partKey).length;
        const newPartCount = newMessage.content.parts.filter((p)=>CacheKeyGenerator.fromDBParts([
                p
            ]) === partKey).length;
        if (latestPartCount < newPartCount) {
            const partIndex = newMessage.content.parts.indexOf(part);
            const hasStepStartBefore = partIndex > 0 && newMessage.content.parts[partIndex - 1]?.type === "step-start";
            const needsStepStart = latestMessage.role === "assistant" && part.type === "text" && !hasStepStartBefore && latestMessage.content.parts.length > 0 && latestMessage.content.parts.at(-1)?.type === "tool-invocation";
            if (typeof insertAt === "number") {
                if (needsStepStart) {
                    latestMessage.content.parts.splice(insertAt, 0, {
                        type: "step-start"
                    });
                    latestMessage.content.parts.splice(insertAt + 1, 0, part);
                } else {
                    latestMessage.content.parts.splice(insertAt, 0, part);
                }
            } else {
                if (needsStepStart) {
                    latestMessage.content.parts.push({
                        type: "step-start"
                    });
                }
                latestMessage.content.parts.push(part);
            }
        }
    }
};
// src/stream/aisdk/v5/compat/content.ts
function splitDataUrl(dataUrl) {
    try {
        const [header, base64Content] = dataUrl.split(",");
        return {
            mediaType: header?.split(";")[0]?.split(":")[1],
            base64Content
        };
    } catch  {
        return {
            mediaType: void 0,
            base64Content: void 0
        };
    }
}
function convertToDataContent(content) {
    if (content instanceof Uint8Array) {
        return {
            data: content,
            mediaType: void 0
        };
    }
    if (content instanceof ArrayBuffer) {
        return {
            data: new Uint8Array(content),
            mediaType: void 0
        };
    }
    if (typeof content === "string") {
        try {
            content = new URL(content);
        } catch  {}
    }
    if (content instanceof URL && content.protocol === "data:") {
        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
        if (dataUrlMediaType == null || base64Content == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "INVALID_DATA_URL_FORMAT",
                text: `Invalid data URL format in content ${content.toString()}`,
                domain: "LLM" /* LLM */ ,
                category: "USER" /* USER */ 
            });
        }
        return {
            data: base64Content,
            mediaType: dataUrlMediaType
        };
    }
    return {
        data: content,
        mediaType: void 0
    };
}
var imageMediaTypeSignatures = [
    {
        mediaType: "image/gif",
        bytesPrefix: [
            71,
            73,
            70
        ],
        base64Prefix: "R0lG"
    },
    {
        mediaType: "image/png",
        bytesPrefix: [
            137,
            80,
            78,
            71
        ],
        base64Prefix: "iVBORw"
    },
    {
        mediaType: "image/jpeg",
        bytesPrefix: [
            255,
            216
        ],
        base64Prefix: "/9j/"
    },
    {
        mediaType: "image/webp",
        bytesPrefix: [
            82,
            73,
            70,
            70
        ],
        base64Prefix: "UklGRg"
    },
    {
        mediaType: "image/bmp",
        bytesPrefix: [
            66,
            77
        ],
        base64Prefix: "Qk"
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            73,
            73,
            42,
            0
        ],
        base64Prefix: "SUkqAA"
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            77,
            77,
            0,
            42
        ],
        base64Prefix: "TU0AKg"
    },
    {
        mediaType: "image/avif",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            97,
            118,
            105,
            102
        ],
        base64Prefix: "AAAAIGZ0eXBhdmlm"
    },
    {
        mediaType: "image/heic",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            104,
            101,
            105,
            99
        ],
        base64Prefix: "AAAAIGZ0eXBoZWlj"
    }
];
var stripID3 = (data)=>{
    const bytes = typeof data === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertBase64ToUint8Array"])(data) : data;
    const id3Size = // @ts-ignore
    (bytes[6] & 127) << 21 | // @ts-ignore
    (bytes[7] & 127) << 14 | // @ts-ignore
    (bytes[8] & 127) << 7 | // @ts-ignore
    bytes[9] & 127;
    return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
    const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
    data[1] === 68 && // 'D'
    data[2] === 51;
    return hasId3 ? stripID3(data) : data;
}
function detectMediaType({ data, signatures }) {
    const processedData = stripID3TagsIfPresent(data);
    for (const signature of signatures){
        if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>processedData[index] === byte)) {
            return signature.mediaType;
        }
    }
    return void 0;
}
// src/agent/message-list/prompt/convert-file.ts
function convertImageFilePart(part, downloadedAssets) {
    let originalData;
    const type = part.type;
    switch(type){
        case "image":
            originalData = part.image;
            break;
        case "file":
            originalData = part.data;
            break;
        default:
            throw new Error(`Unsupported part type: ${type}`);
    }
    const { data: convertedData, mediaType: convertedMediaType } = convertToDataContent(originalData);
    let mediaType = convertedMediaType ?? part.mediaType;
    let data = convertedData;
    if (data instanceof URL && downloadedAssets) {
        const downloadedFile = downloadedAssets[data.toString()];
        if (downloadedFile) {
            data = downloadedFile.data;
            mediaType ??= downloadedFile.mediaType;
        }
    }
    switch(type){
        case "image":
            {
                if (data instanceof Uint8Array || typeof data === "string") {
                    mediaType = detectMediaType({
                        data,
                        signatures: imageMediaTypeSignatures
                    }) ?? mediaType;
                }
                return {
                    type: "file",
                    mediaType: mediaType ?? "image/*",
                    // any image
                    filename: void 0,
                    data,
                    providerOptions: part.providerOptions
                };
            }
        case "file":
            {
                if (mediaType == null) {
                    throw new Error(`Media type is missing for file part`);
                }
                return {
                    type: "file",
                    mediaType,
                    filename: part.filename,
                    data,
                    providerOptions: part.providerOptions
                };
            }
    }
}
// src/agent/message-list/prompt/attachments-to-parts.ts
function attachmentsToParts(attachments) {
    const parts = [];
    for (const attachment of attachments){
        const categorized = categorizeFileData(attachment.url, attachment.contentType);
        let urlString = attachment.url;
        if (categorized.type === "raw") {
            urlString = createDataUri(attachment.url, attachment.contentType || "application/octet-stream");
        }
        let url;
        try {
            url = new URL(urlString);
        } catch  {
            throw new Error(`Invalid URL: ${attachment.url}`);
        }
        switch(url.protocol){
            case "http:":
            case "https:":
            // Cloud storage protocols supported by AI providers (e.g., Vertex AI for gs://, Bedrock for s3://)
            case "gs:":
            case "s3:":
                {
                    if (attachment.contentType?.startsWith("image/")) {
                        parts.push({
                            type: "image",
                            image: url.toString(),
                            mimeType: attachment.contentType
                        });
                    } else {
                        if (!attachment.contentType) {
                            throw new Error("If the attachment is not an image, it must specify a content type");
                        }
                        parts.push({
                            type: "file",
                            data: url.toString(),
                            mimeType: attachment.contentType
                        });
                    }
                    break;
                }
            case "data:":
                {
                    if (attachment.contentType?.startsWith("image/")) {
                        parts.push({
                            type: "image",
                            image: urlString,
                            mimeType: attachment.contentType
                        });
                    } else if (attachment.contentType?.startsWith("text/")) {
                        parts.push({
                            type: "file",
                            data: urlString,
                            mimeType: attachment.contentType
                        });
                    } else {
                        if (!attachment.contentType) {
                            throw new Error("If the attachment is not an image or text, it must specify a content type");
                        }
                        parts.push({
                            type: "file",
                            data: urlString,
                            mimeType: attachment.contentType
                        });
                    }
                    break;
                }
            default:
                {
                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);
                }
        }
    }
    return parts;
}
// src/agent/message-list/prompt/convert-to-mastra-v1.ts
var makePushOrCombine = (v1Messages)=>{
    const idUsageCount = /* @__PURE__ */ new Map();
    const SPLIT_SUFFIX_PATTERN = /__split-\d+$/;
    return (msg)=>{
        const previousMessage = v1Messages.at(-1);
        if (msg.role === previousMessage?.role && Array.isArray(previousMessage.content) && Array.isArray(msg.content) && // we were creating new messages for tool calls before and not appending to the assistant message
        // so don't append here so everything works as before
        (msg.role !== `assistant` || msg.role === `assistant` && msg.content.at(-1)?.type !== `tool-call`)) {
            for (const part of msg.content){
                previousMessage.content.push(part);
            }
        } else {
            let baseId = msg.id;
            const hasSplitSuffix = SPLIT_SUFFIX_PATTERN.test(baseId);
            if (hasSplitSuffix) {
                v1Messages.push(msg);
                return;
            }
            const currentCount = idUsageCount.get(baseId) || 0;
            if (currentCount > 0) {
                msg.id = `${baseId}__split-${currentCount}`;
            }
            idUsageCount.set(baseId, currentCount + 1);
            v1Messages.push(msg);
        }
    };
};
function convertToV1Messages(messages) {
    const v1Messages = [];
    const pushOrCombine = makePushOrCombine(v1Messages);
    for(let i = 0; i < messages.length; i++){
        const message = messages[i];
        const isLastMessage = i === messages.length - 1;
        if (!message?.content) continue;
        const { content, experimental_attachments: inputAttachments = [], parts: inputParts } = message.content;
        const { role } = message;
        const fields = {
            id: message.id,
            createdAt: message.createdAt,
            resourceId: message.resourceId,
            threadId: message.threadId
        };
        const experimental_attachments = [
            ...inputAttachments
        ];
        const parts = [];
        for (const part of inputParts){
            if (part.type === "file") {
                experimental_attachments.push({
                    url: part.data,
                    contentType: part.mimeType
                });
            } else {
                parts.push(part);
            }
        }
        switch(role){
            case "user":
                {
                    if (parts == null) {
                        const userContent = experimental_attachments ? [
                            {
                                type: "text",
                                text: content || ""
                            },
                            ...attachmentsToParts(experimental_attachments)
                        ] : {
                            type: "text",
                            text: content || ""
                        };
                        pushOrCombine({
                            role: "user",
                            ...fields,
                            type: "text",
                            // @ts-ignore
                            content: userContent
                        });
                    } else {
                        const textParts = message.content.parts.filter((part)=>part.type === "text").map((part)=>({
                                type: "text",
                                text: part.text
                            }));
                        const userContent = experimental_attachments ? [
                            ...textParts,
                            ...attachmentsToParts(experimental_attachments)
                        ] : textParts;
                        pushOrCombine({
                            role: "user",
                            ...fields,
                            type: "text",
                            content: Array.isArray(userContent) && userContent.length === 1 && userContent[0]?.type === `text` && typeof content !== `undefined` ? content : userContent
                        });
                    }
                    break;
                }
            case "assistant":
                {
                    if (message.content.parts != null) {
                        let processBlock2 = function() {
                            const content2 = [];
                            for (const part of block){
                                switch(part.type){
                                    case "file":
                                    case "text":
                                        {
                                            content2.push(part);
                                            break;
                                        }
                                    case "reasoning":
                                        {
                                            for (const detail of part.details){
                                                switch(detail.type){
                                                    case "text":
                                                        content2.push({
                                                            type: "reasoning",
                                                            text: detail.text,
                                                            signature: detail.signature
                                                        });
                                                        break;
                                                    case "redacted":
                                                        content2.push({
                                                            type: "redacted-reasoning",
                                                            data: detail.data
                                                        });
                                                        break;
                                                }
                                            }
                                            break;
                                        }
                                    case "tool-invocation":
                                        if (part.toolInvocation.toolName !== "updateWorkingMemory") {
                                            content2.push({
                                                type: "tool-call",
                                                toolCallId: part.toolInvocation.toolCallId,
                                                toolName: part.toolInvocation.toolName,
                                                args: part.toolInvocation.args
                                            });
                                        }
                                        break;
                                }
                            }
                            pushOrCombine({
                                role: "assistant",
                                ...fields,
                                type: content2.some((c)=>c.type === `tool-call`) ? "tool-call" : "text",
                                content: typeof content2 !== `string` && Array.isArray(content2) && content2.length === 1 && content2[0]?.type === `text` ? content2[0].text : content2
                            });
                            const stepInvocations = block.filter((part)=>`type` in part && part.type === "tool-invocation").map((part)=>part.toolInvocation).filter((ti)=>ti.toolName !== "updateWorkingMemory");
                            const invocationsWithResults = stepInvocations.filter((ti)=>ti.state === "result" && "result" in ti);
                            if (invocationsWithResults.length > 0) {
                                pushOrCombine({
                                    role: "tool",
                                    ...fields,
                                    type: "tool-result",
                                    content: invocationsWithResults.map((toolInvocation)=>{
                                        const { toolCallId, toolName, result } = toolInvocation;
                                        return {
                                            type: "tool-result",
                                            toolCallId,
                                            toolName,
                                            result
                                        };
                                    })
                                });
                            }
                            block = [];
                            blockHasToolInvocations = false;
                            currentStep++;
                        };
                        let currentStep = 0;
                        let blockHasToolInvocations = false;
                        let block = [];
                        for (const part of message.content.parts){
                            switch(part.type){
                                case "text":
                                    {
                                        if (blockHasToolInvocations) {
                                            processBlock2();
                                        }
                                        block.push(part);
                                        break;
                                    }
                                case "file":
                                case "reasoning":
                                    {
                                        block.push(part);
                                        break;
                                    }
                                case "tool-invocation":
                                    {
                                        const hasNonToolContent = block.some((p)=>p.type === "text" || p.type === "file" || p.type === "reasoning");
                                        if (hasNonToolContent || (part.toolInvocation.step ?? 0) !== currentStep) {
                                            processBlock2();
                                        }
                                        block.push(part);
                                        blockHasToolInvocations = true;
                                        break;
                                    }
                            }
                        }
                        processBlock2();
                        const toolInvocations2 = message.content.toolInvocations;
                        if (toolInvocations2 && toolInvocations2.length > 0) {
                            const processedToolCallIds = /* @__PURE__ */ new Set();
                            for (const part of message.content.parts){
                                if (part.type === "tool-invocation" && part.toolInvocation.toolCallId) {
                                    processedToolCallIds.add(part.toolInvocation.toolCallId);
                                }
                            }
                            const unprocessedToolInvocations = toolInvocations2.filter((ti)=>!processedToolCallIds.has(ti.toolCallId) && ti.toolName !== "updateWorkingMemory");
                            if (unprocessedToolInvocations.length > 0) {
                                const invocationsByStep = /* @__PURE__ */ new Map();
                                for (const inv of unprocessedToolInvocations){
                                    const step = inv.step ?? 0;
                                    if (!invocationsByStep.has(step)) {
                                        invocationsByStep.set(step, []);
                                    }
                                    invocationsByStep.get(step).push(inv);
                                }
                                const sortedSteps = Array.from(invocationsByStep.keys()).sort((a, b)=>a - b);
                                for (const step of sortedSteps){
                                    const stepInvocations = invocationsByStep.get(step);
                                    pushOrCombine({
                                        role: "assistant",
                                        ...fields,
                                        type: "tool-call",
                                        content: [
                                            ...stepInvocations.map(({ toolCallId, toolName, args })=>({
                                                    type: "tool-call",
                                                    toolCallId,
                                                    toolName,
                                                    args
                                                }))
                                        ]
                                    });
                                    const invocationsWithResults = stepInvocations.filter((ti)=>ti.state === "result" && "result" in ti);
                                    if (invocationsWithResults.length > 0) {
                                        pushOrCombine({
                                            role: "tool",
                                            ...fields,
                                            type: "tool-result",
                                            content: invocationsWithResults.map((toolInvocation)=>{
                                                const { toolCallId, toolName, result } = toolInvocation;
                                                return {
                                                    type: "tool-result",
                                                    toolCallId,
                                                    toolName,
                                                    result
                                                };
                                            })
                                        });
                                    }
                                }
                            }
                        }
                        break;
                    }
                    const toolInvocations = message.content.toolInvocations;
                    if (toolInvocations == null || toolInvocations.length === 0) {
                        pushOrCombine({
                            role: "assistant",
                            ...fields,
                            content: content || "",
                            type: "text"
                        });
                        break;
                    }
                    const maxStep = toolInvocations.reduce((max, toolInvocation)=>{
                        return Math.max(max, toolInvocation.step ?? 0);
                    }, 0);
                    for(let i2 = 0; i2 <= maxStep; i2++){
                        const stepInvocations = toolInvocations.filter((toolInvocation)=>(toolInvocation.step ?? 0) === i2 && toolInvocation.toolName !== "updateWorkingMemory");
                        if (stepInvocations.length === 0) {
                            continue;
                        }
                        pushOrCombine({
                            role: "assistant",
                            ...fields,
                            type: "tool-call",
                            content: [
                                ...isLastMessage && content && i2 === 0 ? [
                                    {
                                        type: "text",
                                        text: content
                                    }
                                ] : [],
                                ...stepInvocations.map(({ toolCallId, toolName, args })=>({
                                        type: "tool-call",
                                        toolCallId,
                                        toolName,
                                        args
                                    }))
                            ]
                        });
                        const invocationsWithResults = stepInvocations.filter((ti)=>ti.state === "result" && "result" in ti);
                        if (invocationsWithResults.length > 0) {
                            pushOrCombine({
                                role: "tool",
                                ...fields,
                                type: "tool-result",
                                content: invocationsWithResults.map((toolInvocation)=>{
                                    const { toolCallId, toolName, result } = toolInvocation;
                                    return {
                                        type: "tool-result",
                                        toolCallId,
                                        toolName,
                                        result
                                    };
                                })
                            });
                        }
                    }
                    if (content && !isLastMessage) {
                        pushOrCombine({
                            role: "assistant",
                            ...fields,
                            type: "text",
                            content: content || ""
                        });
                    }
                    break;
                }
        }
    }
    return v1Messages;
}
// src/utils/fetchWithRetry.ts
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    let retryCount = 0;
    let lastError = null;
    while(retryCount < maxRetries){
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                if (response.status >= 400 && response.status < 500) {
                    throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);
                }
                lastError = new Error(`Request failed with status: ${response.status} ${response.statusText}`);
                retryCount++;
                if (retryCount >= maxRetries) {
                    throw lastError;
                }
                const delay = Math.min(1e3 * Math.pow(2, retryCount), 1e4);
                await new Promise((resolve)=>setTimeout(resolve, delay));
                continue;
            }
            return response;
        } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            if (lastError.message.includes("status: 4")) {
                throw lastError;
            }
            retryCount++;
            if (retryCount >= maxRetries) {
                break;
            }
            const delay = Math.min(1e3 * Math.pow(2, retryCount), 1e4);
            await new Promise((resolve)=>setTimeout(resolve, delay));
        }
    }
    throw lastError || new Error("Request failed after multiple retry attempts");
}
// src/agent/message-list/prompt/download-assets.ts
var downloadFromUrl = async ({ url, downloadRetries })=>{
    const urlText = url.toString();
    try {
        const response = await fetchWithRetry(urlText, {
            method: "GET"
        }, downloadRetries);
        if (!response.ok) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "DOWNLOAD_ASSETS_FAILED",
                text: "Failed to download asset",
                domain: "LLM" /* LLM */ ,
                category: "USER" /* USER */ 
            });
        }
        return {
            data: new Uint8Array(await response.arrayBuffer()),
            mediaType: response.headers.get("content-type") ?? void 0
        };
    } catch (error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
            id: "DOWNLOAD_ASSETS_FAILED",
            text: "Failed to download asset",
            domain: "LLM" /* LLM */ ,
            category: "USER" /* USER */ 
        }, error);
    }
};
async function downloadAssetsFromMessages({ messages, downloadConcurrency = 10, downloadRetries = 3, supportedUrls }) {
    const pMap = (await __turbopack_context__.A("[project]/node_modules/p-map/index.js [app-route] (ecmascript, async loader)")).default;
    const filesToDownload = messages.filter((message)=>message.role === "user").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === "image" || part.type === "file").map((part)=>{
        const mediaType = part.mediaType ?? (part.type === "image" ? "image/*" : void 0);
        let data = part.type === "image" ? part.image : part.data;
        if (typeof data === "string") {
            try {
                data = new URL(data);
            } catch  {}
        }
        return {
            mediaType,
            data
        };
    }).filter((part)=>part.data instanceof URL).map((part)=>{
        return {
            url: part.data,
            isUrlSupportedByModel: part.mediaType != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2d$v5$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isUrlSupported"])({
                url: part.data.toString(),
                mediaType: part.mediaType,
                supportedUrls: supportedUrls ?? {}
            })
        };
    });
    const downloadedFiles = await pMap(filesToDownload, async (fileItem)=>{
        if (fileItem.isUrlSupportedByModel) {
            return null;
        }
        return {
            url: fileItem.url.toString(),
            ...await downloadFromUrl({
                url: fileItem.url,
                downloadRetries
            })
        };
    }, {
        concurrency: downloadConcurrency
    });
    const downloadFileList = downloadedFiles.filter((downloadedFile)=>downloadedFile?.data != null).map(({ url, data, mediaType })=>[
            url,
            {
                data,
                mediaType
            }
        ]);
    return Object.fromEntries(downloadFileList);
}
// src/agent/message-list/state/serialization.ts
function serializeMessage(message) {
    return {
        ...message,
        createdAt: message.createdAt.toUTCString()
    };
}
function deserializeMessage(message) {
    return {
        ...message,
        createdAt: new Date(message.createdAt)
    };
}
function serializeMessages(messages) {
    return messages.map(serializeMessage);
}
function deserializeMessages(messages) {
    return messages.map(deserializeMessage);
}
// src/agent/message-list/state/MessageStateManager.ts
var MessageStateManager = class {
    // Messages tracked by source
    memoryMessages = /* @__PURE__ */ new Set();
    newUserMessages = /* @__PURE__ */ new Set();
    newResponseMessages = /* @__PURE__ */ new Set();
    userContextMessages = /* @__PURE__ */ new Set();
    // Persisted message tracking
    memoryMessagesPersisted = /* @__PURE__ */ new Set();
    newUserMessagesPersisted = /* @__PURE__ */ new Set();
    newResponseMessagesPersisted = /* @__PURE__ */ new Set();
    userContextMessagesPersisted = /* @__PURE__ */ new Set();
    /**
   * Add a message to the appropriate source set and persisted set
   */ addToSource(message, source) {
        switch(source){
            case "memory":
                this.memoryMessages.add(message);
                this.memoryMessagesPersisted.add(message);
                break;
            case "response":
                this.newResponseMessages.add(message);
                this.newResponseMessagesPersisted.add(message);
                if (this.newUserMessages.has(message)) {
                    this.newUserMessages.delete(message);
                }
                break;
            case "input":
            case "user":
                this.newUserMessages.add(message);
                this.newUserMessagesPersisted.add(message);
                break;
            case "context":
                this.userContextMessages.add(message);
                this.userContextMessagesPersisted.add(message);
                break;
            default:
                throw new Error(`Missing message source for message ${message}`);
        }
    }
    /**
   * Check if a message belongs to the memory source
   */ isMemoryMessage(message) {
        return this.memoryMessages.has(message);
    }
    /**
   * Check if a message belongs to the input source
   */ isUserMessage(message) {
        return this.newUserMessages.has(message);
    }
    /**
   * Check if a message belongs to the response source
   */ isResponseMessage(message) {
        return this.newResponseMessages.has(message);
    }
    /**
   * Check if a message belongs to the context source
   */ isContextMessage(message) {
        return this.userContextMessages.has(message);
    }
    /**
   * Get all memory messages
   */ getMemoryMessages() {
        return this.memoryMessages;
    }
    /**
   * Get all user/input messages
   */ getUserMessages() {
        return this.newUserMessages;
    }
    /**
   * Get all response messages
   */ getResponseMessages() {
        return this.newResponseMessages;
    }
    /**
   * Get all context messages
   */ getContextMessages() {
        return this.userContextMessages;
    }
    /**
   * Get persisted memory messages
   */ getMemoryMessagesPersisted() {
        return this.memoryMessagesPersisted;
    }
    /**
   * Get persisted user/input messages
   */ getUserMessagesPersisted() {
        return this.newUserMessagesPersisted;
    }
    /**
   * Get persisted response messages
   */ getResponseMessagesPersisted() {
        return this.newResponseMessagesPersisted;
    }
    /**
   * Get persisted context messages
   */ getContextMessagesPersisted() {
        return this.userContextMessagesPersisted;
    }
    /**
   * Remove a message from all source sets
   */ removeMessage(message) {
        this.memoryMessages.delete(message);
        this.newUserMessages.delete(message);
        this.newResponseMessages.delete(message);
        this.userContextMessages.delete(message);
    }
    /**
   * Clear all user messages
   */ clearUserMessages() {
        this.newUserMessages.clear();
    }
    /**
   * Clear all response messages
   */ clearResponseMessages() {
        this.newResponseMessages.clear();
    }
    /**
   * Clear all context messages
   */ clearContextMessages() {
        this.userContextMessages.clear();
    }
    /**
   * Clear all messages from all sources (but not persisted tracking)
   */ clearAll() {
        this.newUserMessages.clear();
        this.newResponseMessages.clear();
        this.userContextMessages.clear();
    }
    /**
   * Create a lookup function to determine message source
   */ createSourceChecker() {
        const sources = {
            memory: new Set(Array.from(this.memoryMessages.values()).map((m)=>m.id)),
            output: new Set(Array.from(this.newResponseMessages.values()).map((m)=>m.id)),
            input: new Set(Array.from(this.newUserMessages.values()).map((m)=>m.id)),
            context: new Set(Array.from(this.userContextMessages.values()).map((m)=>m.id))
        };
        return {
            ...sources,
            getSource: (msg)=>{
                if (sources.memory.has(msg.id)) return "memory";
                if (sources.input.has(msg.id)) return "input";
                if (sources.output.has(msg.id)) return "response";
                if (sources.context.has(msg.id)) return "context";
                return null;
            }
        };
    }
    /**
   * Check if a message is a new (unsaved) user or response message by ID
   */ isNewMessage(messageOrId) {
        const id = typeof messageOrId === "string" ? messageOrId : messageOrId.id;
        if (typeof messageOrId !== "string") {
            if (this.newUserMessages.has(messageOrId) || this.newResponseMessages.has(messageOrId)) {
                return true;
            }
        }
        return Array.from(this.newUserMessages).some((m)=>m.id === id) || Array.from(this.newResponseMessages).some((m)=>m.id === id);
    }
    /**
   * Serialize source tracking state (message IDs only)
   */ serializeSourceTracking() {
        const serializeSet = (set)=>Array.from(set).map((value)=>value.id);
        return {
            memoryMessages: serializeSet(this.memoryMessages),
            newUserMessages: serializeSet(this.newUserMessages),
            newResponseMessages: serializeSet(this.newResponseMessages),
            userContextMessages: serializeSet(this.userContextMessages),
            memoryMessagesPersisted: serializeSet(this.memoryMessagesPersisted),
            newUserMessagesPersisted: serializeSet(this.newUserMessagesPersisted),
            newResponseMessagesPersisted: serializeSet(this.newResponseMessagesPersisted),
            userContextMessagesPersisted: serializeSet(this.userContextMessagesPersisted)
        };
    }
    /**
   * Deserialize source tracking state from message IDs
   */ deserializeSourceTracking(state, messages) {
        const deserializeSet = (ids)=>new Set(ids.map((id)=>messages.find((m)=>m.id === id)).filter(Boolean));
        this.memoryMessages = deserializeSet(state.memoryMessages);
        this.newUserMessages = deserializeSet(state.newUserMessages);
        this.newResponseMessages = deserializeSet(state.newResponseMessages);
        this.userContextMessages = deserializeSet(state.userContextMessages);
        this.memoryMessagesPersisted = deserializeSet(state.memoryMessagesPersisted);
        this.newUserMessagesPersisted = deserializeSet(state.newUserMessagesPersisted);
        this.newResponseMessagesPersisted = deserializeSet(state.newResponseMessagesPersisted);
        this.userContextMessagesPersisted = deserializeSet(state.userContextMessagesPersisted);
    }
    /**
   * Serialize all MessageList state for workflow suspend/resume
   */ serializeAll(data) {
        return {
            messages: serializeMessages(data.messages),
            systemMessages: data.systemMessages,
            taggedSystemMessages: data.taggedSystemMessages,
            memoryInfo: data.memoryInfo,
            _agentNetworkAppend: data.agentNetworkAppend,
            ...this.serializeSourceTracking()
        };
    }
    /**
   * Deserialize all MessageList state from workflow suspend/resume
   */ deserializeAll(state) {
        const messages = deserializeMessages(state.messages);
        this.deserializeSourceTracking({
            memoryMessages: state.memoryMessages,
            newUserMessages: state.newUserMessages,
            newResponseMessages: state.newResponseMessages,
            userContextMessages: state.userContextMessages,
            memoryMessagesPersisted: state.memoryMessagesPersisted,
            newUserMessagesPersisted: state.newUserMessagesPersisted,
            newResponseMessagesPersisted: state.newResponseMessagesPersisted,
            userContextMessagesPersisted: state.userContextMessagesPersisted
        }, messages);
        return {
            messages,
            systemMessages: state.systemMessages,
            taggedSystemMessages: state.taggedSystemMessages,
            memoryInfo: state.memoryInfo,
            agentNetworkAppend: state._agentNetworkAppend
        };
    }
};
// src/agent/message-list/message-list.ts
var MessageList = class {
    messages = [];
    // passed in by dev in input or context
    systemMessages = [];
    // passed in by us for a specific purpose, eg memory system message
    taggedSystemMessages = {};
    memoryInfo = null;
    // Centralized state management for message tracking
    stateManager = new MessageStateManager();
    // Legacy getters for backward compatibility - delegate to stateManager
    get memoryMessages() {
        return this.stateManager.getMemoryMessages();
    }
    get newUserMessages() {
        return this.stateManager.getUserMessages();
    }
    get newResponseMessages() {
        return this.stateManager.getResponseMessages();
    }
    get userContextMessages() {
        return this.stateManager.getContextMessages();
    }
    get memoryMessagesPersisted() {
        return this.stateManager.getMemoryMessagesPersisted();
    }
    get newUserMessagesPersisted() {
        return this.stateManager.getUserMessagesPersisted();
    }
    get newResponseMessagesPersisted() {
        return this.stateManager.getResponseMessagesPersisted();
    }
    get userContextMessagesPersisted() {
        return this.stateManager.getContextMessagesPersisted();
    }
    generateMessageId;
    _agentNetworkAppend = false;
    // Event recording for observability
    isRecording = false;
    recordedEvents = [];
    constructor({ threadId, resourceId, generateMessageId, // @ts-ignore Flag for agent network messages
    _agentNetworkAppend } = {}){
        if (threadId) {
            this.memoryInfo = {
                threadId,
                resourceId
            };
        }
        this.generateMessageId = generateMessageId;
        this._agentNetworkAppend = _agentNetworkAppend || false;
    }
    /**
   * Start recording mutations to the MessageList for observability/tracing
   */ startRecording() {
        this.isRecording = true;
        this.recordedEvents = [];
    }
    /**
   * Stop recording and return the list of recorded events
   */ stopRecording() {
        this.isRecording = false;
        const events = [
            ...this.recordedEvents
        ];
        this.recordedEvents = [];
        return events;
    }
    add(messages, messageSource) {
        if (messageSource === `user`) messageSource = `input`;
        if (!messages) return this;
        const messageArray = Array.isArray(messages) ? messages : [
            messages
        ];
        if (this.isRecording) {
            this.recordedEvents.push({
                type: "add",
                source: messageSource,
                count: messageArray.length
            });
        }
        for (const message of messageArray){
            this.addOne(typeof message === `string` ? {
                role: "user",
                content: message
            } : message, messageSource);
        }
        return this;
    }
    serialize() {
        return this.stateManager.serializeAll({
            messages: this.messages,
            systemMessages: this.systemMessages,
            taggedSystemMessages: this.taggedSystemMessages,
            memoryInfo: this.memoryInfo,
            agentNetworkAppend: this._agentNetworkAppend
        });
    }
    deserialize(state) {
        const data = this.stateManager.deserializeAll(state);
        this.messages = data.messages;
        this.systemMessages = data.systemMessages;
        this.taggedSystemMessages = data.taggedSystemMessages;
        this.memoryInfo = data.memoryInfo;
        this._agentNetworkAppend = data.agentNetworkAppend;
        return this;
    }
    makeMessageSourceChecker() {
        return this.stateManager.createSourceChecker();
    }
    getLatestUserContent() {
        const currentUserMessages = this.all.core().filter((m)=>m.role === "user");
        const content = currentUserMessages.at(-1)?.content;
        if (!content) return null;
        return coreContentToString(content);
    }
    get get() {
        return {
            all: this.all,
            remembered: this.remembered,
            input: this.input,
            response: this.response
        };
    }
    get getPersisted() {
        return {
            remembered: this.rememberedPersisted,
            input: this.inputPersisted,
            taggedSystemMessages: this.taggedSystemMessages,
            response: this.responsePersisted
        };
    }
    get clear() {
        return {
            all: {
                db: ()=>{
                    const allMessages = [
                        ...this.messages
                    ];
                    this.messages = [];
                    this.stateManager.clearAll();
                    if (this.isRecording && allMessages.length > 0) {
                        this.recordedEvents.push({
                            type: "clear",
                            count: allMessages.length
                        });
                    }
                    return allMessages;
                }
            },
            input: {
                db: ()=>{
                    const userMessages = Array.from(this.stateManager.getUserMessages());
                    this.messages = this.messages.filter((m)=>!this.stateManager.isUserMessage(m));
                    this.stateManager.clearUserMessages();
                    if (this.isRecording && userMessages.length > 0) {
                        this.recordedEvents.push({
                            type: "clear",
                            source: "input",
                            count: userMessages.length
                        });
                    }
                    return userMessages;
                }
            },
            response: {
                db: ()=>{
                    const responseMessages = Array.from(this.stateManager.getResponseMessages());
                    this.messages = this.messages.filter((m)=>!this.stateManager.isResponseMessage(m));
                    this.stateManager.clearResponseMessages();
                    if (this.isRecording && responseMessages.length > 0) {
                        this.recordedEvents.push({
                            type: "clear",
                            source: "response",
                            count: responseMessages.length
                        });
                    }
                    return responseMessages;
                }
            }
        };
    }
    /**
   * Remove messages by ID
   * @param ids - Array of message IDs to remove
   * @returns Array of removed messages
   */ removeByIds(ids) {
        const idsSet = new Set(ids);
        const removed = [];
        this.messages = this.messages.filter((m)=>{
            if (idsSet.has(m.id)) {
                removed.push(m);
                this.stateManager.removeMessage(m);
                return false;
            }
            return true;
        });
        if (this.isRecording && removed.length > 0) {
            this.recordedEvents.push({
                type: "removeByIds",
                ids,
                count: removed.length
            });
        }
        return removed;
    }
    all = {
        db: ()=>this.messages,
        v1: ()=>convertToV1Messages(this.all.db()),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui(), this.messages),
            ui: ()=>this.all.db().map(AIV5Adapter.toUIMessage),
            // Used when calling AI SDK streamText/generateText
            prompt: ()=>{
                const systemMessages = aiV4CoreMessagesToAIV5ModelMessages([
                    ...this.systemMessages,
                    ...Object.values(this.taggedSystemMessages).flat()
                ], `system`, this.createAdapterContext(), this.messages);
                const modelMessages = aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui(), this.messages, true);
                const messages = [
                    ...systemMessages,
                    ...modelMessages
                ];
                return ensureGeminiCompatibleMessages(messages);
            },
            // Used for creating LLM prompt messages without AI SDK streamText/generateText
            llmPrompt: async (options = {
                downloadConcurrency: 10,
                downloadRetries: 3
            })=>{
                const modelMessages = aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui(), this.messages, true);
                const systemMessages = aiV4CoreMessagesToAIV5ModelMessages([
                    ...this.systemMessages,
                    ...Object.values(this.taggedSystemMessages).flat()
                ], `system`, this.createAdapterContext(), this.messages);
                const downloadedAssets = await downloadAssetsFromMessages({
                    messages: modelMessages,
                    downloadConcurrency: options?.downloadConcurrency,
                    downloadRetries: options?.downloadRetries,
                    supportedUrls: options?.supportedUrls
                });
                let messages = [
                    ...systemMessages,
                    ...modelMessages
                ];
                const hasImageOrFileContent = modelMessages.some((message)=>message.role === "user" && typeof message.content !== "string" && message.content.some((part)=>part.type === "image" || part.type === "file"));
                if (hasImageOrFileContent) {
                    messages = messages.map((message)=>{
                        if (message.role === "user") {
                            if (typeof message.content === "string") {
                                return {
                                    role: "user",
                                    content: [
                                        {
                                            type: "text",
                                            text: message.content
                                        }
                                    ],
                                    providerOptions: message.providerOptions
                                };
                            }
                            const convertedContent = message.content.map((part)=>{
                                if (part.type === "image" || part.type === "file") {
                                    return convertImageFilePart(part, downloadedAssets);
                                }
                                return part;
                            }).filter((part)=>part.type !== "text" || part.text !== "");
                            return {
                                role: "user",
                                content: convertedContent,
                                providerOptions: message.providerOptions
                            };
                        }
                        return message;
                    });
                }
                messages = ensureGeminiCompatibleMessages(messages);
                return messages.map(aiV5ModelMessageToV2PromptMessage);
            }
        },
        /* @deprecated use list.get.all.aiV4.prompt() instead */ prompt: ()=>this.all.aiV4.prompt(),
        /* @deprecated use list.get.all.aiV4.ui() */ ui: ()=>this.all.db().map(AIV4Adapter.toUIMessage),
        /* @deprecated use list.get.all.aiV4.core() */ core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
        aiV4: {
            ui: ()=>this.all.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
            // Used when calling AI SDK streamText/generateText
            prompt: ()=>{
                const coreMessages = this.all.aiV4.core();
                const messages = [
                    ...this.systemMessages,
                    ...Object.values(this.taggedSystemMessages).flat(),
                    ...coreMessages
                ];
                return ensureGeminiCompatibleMessages(messages);
            },
            // Used for creating LLM prompt messages without AI SDK streamText/generateText
            llmPrompt: ()=>{
                const coreMessages = this.all.aiV4.core();
                const systemMessages = [
                    ...this.systemMessages,
                    ...Object.values(this.taggedSystemMessages).flat()
                ];
                let messages = [
                    ...systemMessages,
                    ...coreMessages
                ];
                messages = ensureGeminiCompatibleMessages(messages);
                return messages.map(aiV4CoreMessageToV1PromptMessage);
            }
        }
    };
    remembered = {
        db: ()=>this.messages.filter((m)=>this.memoryMessages.has(m)),
        v1: ()=>convertToV1Messages(this.remembered.db()),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.remembered.aiV5.ui(), this.messages),
            ui: ()=>this.remembered.db().map(AIV5Adapter.toUIMessage)
        },
        /* @deprecated use list.get.remembered.aiV4.ui() */ ui: ()=>this.remembered.db().map(AIV4Adapter.toUIMessage),
        /* @deprecated use list.get.remembered.aiV4.core() */ core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
        aiV4: {
            ui: ()=>this.remembered.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui())
        }
    };
    rememberedPersisted = {
        db: ()=>this.all.db().filter((m)=>this.memoryMessagesPersisted.has(m)),
        v1: ()=>convertToV1Messages(this.rememberedPersisted.db()),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.rememberedPersisted.aiV5.ui(), this.messages),
            ui: ()=>this.rememberedPersisted.db().map(AIV5Adapter.toUIMessage)
        },
        /* @deprecated use list.getPersisted.remembered.aiV4.ui() */ ui: ()=>this.rememberedPersisted.db().map(AIV4Adapter.toUIMessage),
        /* @deprecated use list.getPersisted.remembered.aiV4.core() */ core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.rememberedPersisted.ui()),
        aiV4: {
            ui: ()=>this.rememberedPersisted.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.rememberedPersisted.aiV4.ui())
        }
    };
    input = {
        db: ()=>this.messages.filter((m)=>this.newUserMessages.has(m)),
        v1: ()=>convertToV1Messages(this.input.db()),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.input.aiV5.ui(), this.messages),
            ui: ()=>this.input.db().map(AIV5Adapter.toUIMessage)
        },
        /* @deprecated use list.get.input.aiV4.ui() instead */ ui: ()=>this.input.db().map(AIV4Adapter.toUIMessage),
        /* @deprecated use list.get.core.aiV4.ui() instead */ core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.input.ui()),
        aiV4: {
            ui: ()=>this.input.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.input.aiV4.ui())
        }
    };
    inputPersisted = {
        db: ()=>this.messages.filter((m)=>this.newUserMessagesPersisted.has(m)),
        v1: ()=>convertToV1Messages(this.inputPersisted.db()),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.inputPersisted.aiV5.ui(), this.messages),
            ui: ()=>this.inputPersisted.db().map(AIV5Adapter.toUIMessage)
        },
        /* @deprecated use list.getPersisted.input.aiV4.ui() */ ui: ()=>this.inputPersisted.db().map(AIV4Adapter.toUIMessage),
        /* @deprecated use list.getPersisted.input.aiV4.core() */ core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.inputPersisted.ui()),
        aiV4: {
            ui: ()=>this.inputPersisted.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.inputPersisted.aiV4.ui())
        }
    };
    response = {
        db: ()=>this.messages.filter((m)=>this.newResponseMessages.has(m)),
        v1: ()=>convertToV1Messages(this.response.db()),
        aiV5: {
            ui: ()=>this.response.db().map(AIV5Adapter.toUIMessage),
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.response.aiV5.ui(), this.messages).filter((m)=>m.role === `tool` || m.role === `assistant`),
            modelContent: (stepNumber)=>{
                if (typeof stepNumber === "number") {
                    return StepContentExtractor.extractStepContent(this.response.aiV5.ui(), stepNumber, this.response.aiV5.stepContent);
                }
                return this.response.aiV5.model().map(this.response.aiV5.stepContent).flat();
            },
            stepContent: (message)=>{
                return StepContentExtractor.convertToStepContent(message, this.messages, ()=>this.response.aiV5.model().at(-1));
            }
        },
        aiV4: {
            ui: ()=>this.response.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.response.aiV4.ui())
        }
    };
    responsePersisted = {
        db: ()=>this.messages.filter((m)=>this.newResponseMessagesPersisted.has(m)),
        aiV5: {
            model: ()=>aiV5UIMessagesToAIV5ModelMessages(this.responsePersisted.aiV5.ui(), this.messages),
            ui: ()=>this.responsePersisted.db().map(AIV5Adapter.toUIMessage)
        },
        /* @deprecated use list.getPersisted.response.aiV4.ui() */ ui: ()=>this.responsePersisted.db().map(AIV4Adapter.toUIMessage),
        aiV4: {
            ui: ()=>this.responsePersisted.db().map(AIV4Adapter.toUIMessage),
            core: ()=>aiV4UIMessagesToAIV4CoreMessages(this.responsePersisted.aiV4.ui())
        }
    };
    drainUnsavedMessages() {
        const messages = this.messages.filter((m)=>this.newUserMessages.has(m) || this.newResponseMessages.has(m));
        this.newUserMessages.clear();
        this.newResponseMessages.clear();
        return messages;
    }
    getEarliestUnsavedMessageTimestamp() {
        const unsavedMessages = this.messages.filter((m)=>this.newUserMessages.has(m) || this.newResponseMessages.has(m));
        if (unsavedMessages.length === 0) return void 0;
        return Math.min(...unsavedMessages.map((m)=>new Date(m.createdAt).getTime()));
    }
    /**
   * Check if a message is a new user or response message that should be saved.
   * Checks by message ID to handle cases where the message object may be a copy.
   */ isNewMessage(messageOrId) {
        return this.stateManager.isNewMessage(messageOrId);
    }
    getSystemMessages(tag) {
        if (tag) {
            return this.taggedSystemMessages[tag] || [];
        }
        return this.systemMessages;
    }
    /**
   * Get all system messages (both tagged and untagged)
   * @returns Array of all system messages
   */ getAllSystemMessages() {
        return [
            ...this.systemMessages,
            ...Object.values(this.taggedSystemMessages).flat()
        ];
    }
    /**
   * Replace all system messages with new ones
   * This clears both tagged and untagged system messages and replaces them with the provided array
   * @param messages - Array of system messages to set
   */ replaceAllSystemMessages(messages) {
        this.systemMessages = [];
        this.taggedSystemMessages = {};
        for (const message of messages){
            if (message.role === "system") {
                this.systemMessages.push(message);
            }
        }
        return this;
    }
    addSystem(messages, tag) {
        if (!messages) return this;
        for (const message of Array.isArray(messages) ? messages : [
            messages
        ]){
            this.addOneSystem(message, tag);
        }
        return this;
    }
    addOneSystem(message, tag) {
        const coreMessage = systemMessageToAIV4Core(message);
        if (coreMessage.role !== `system`) {
            throw new Error(`Expected role "system" but saw ${coreMessage.role} for message ${JSON.stringify(coreMessage, null, 2)}`);
        }
        if (tag && !this.isDuplicateSystem(coreMessage, tag)) {
            this.taggedSystemMessages[tag] ||= [];
            this.taggedSystemMessages[tag].push(coreMessage);
            if (this.isRecording) {
                this.recordedEvents.push({
                    type: "addSystem",
                    tag,
                    message: coreMessage
                });
            }
        } else if (!tag && !this.isDuplicateSystem(coreMessage)) {
            this.systemMessages.push(coreMessage);
            if (this.isRecording) {
                this.recordedEvents.push({
                    type: "addSystem",
                    message: coreMessage
                });
            }
        }
    }
    isDuplicateSystem(message, tag) {
        if (tag) {
            if (!this.taggedSystemMessages[tag]) return false;
            return this.taggedSystemMessages[tag].some((m)=>CacheKeyGenerator.fromAIV4CoreMessageContent(m.content) === CacheKeyGenerator.fromAIV4CoreMessageContent(message.content));
        }
        return this.systemMessages.some((m)=>CacheKeyGenerator.fromAIV4CoreMessageContent(m.content) === CacheKeyGenerator.fromAIV4CoreMessageContent(message.content));
    }
    getMessageById(id) {
        return this.messages.find((m)=>m.id === id);
    }
    shouldReplaceMessage(message) {
        if (!this.messages.length) return {
            exists: false
        };
        if (!(`id` in message) || !message?.id) {
            return {
                exists: false
            };
        }
        const existingMessage = this.getMessageById(message.id);
        if (!existingMessage) return {
            exists: false
        };
        return {
            exists: true,
            shouldReplace: !messagesAreEqual(existingMessage, message),
            id: existingMessage.id
        };
    }
    addOne(message, messageSource) {
        if ((!(`content` in message) || !message.content && // allow empty strings
        typeof message.content !== "string") && (!(`parts` in message) || !message.parts)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "INVALID_MESSAGE_CONTENT",
                domain: "AGENT" /* AGENT */ ,
                category: "USER" /* USER */ ,
                text: `Message with role "${message.role}" must have either a 'content' property (string or array) or a 'parts' property (array) that is not empty, null, or undefined. Received message: ${JSON.stringify(message, null, 2)}`,
                details: {
                    role: message.role,
                    messageSource,
                    hasContent: "content" in message,
                    hasParts: "parts" in message
                }
            });
        }
        if (message.role === `system`) {
            if (messageSource === `memory`) return null;
            const isSupportedSystemFormat = TypeDetector.isAIV4CoreMessage(message) || TypeDetector.isAIV5CoreMessage(message) || TypeDetector.isMastraDBMessage(message);
            if (isSupportedSystemFormat) {
                return this.addSystem(message);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: "INVALID_SYSTEM_MESSAGE_FORMAT",
                domain: "AGENT" /* AGENT */ ,
                category: "USER" /* USER */ ,
                text: `Invalid system message format. System messages must be CoreMessage format with 'role' and 'content' properties. The content should be a string or valid content array.`,
                details: {
                    messageSource,
                    receivedMessage: JSON.stringify(message, null, 2)
                }
            });
        }
        const messageV2 = inputToMastraDBMessage(message, messageSource, this.createAdapterContext());
        const { exists, shouldReplace, id } = this.shouldReplaceMessage(messageV2);
        const latestMessage = this.messages.at(-1);
        if (messageSource === `memory`) {
            for (const existingMessage of this.messages){
                if (messagesAreEqual(existingMessage, messageV2)) {
                    return;
                }
            }
        }
        const isLatestFromMemory = latestMessage ? this.memoryMessages.has(latestMessage) : false;
        const shouldMerge = MessageMerger.shouldMerge(latestMessage, messageV2, messageSource, isLatestFromMemory, this._agentNetworkAppend);
        if (shouldMerge && latestMessage) {
            MessageMerger.merge(latestMessage, messageV2);
            this.pushMessageToSource(latestMessage, messageSource);
        } else {
            let existingIndex = -1;
            if (shouldReplace) {
                existingIndex = this.messages.findIndex((m)=>m.id === id);
            }
            const existingMessage = existingIndex !== -1 && this.messages[existingIndex];
            if (shouldReplace && existingMessage) {
                this.messages[existingIndex] = messageV2;
            } else if (!exists) {
                this.messages.push(messageV2);
            }
            this.pushMessageToSource(messageV2, messageSource);
        }
        this.messages.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());
        return this;
    }
    pushMessageToSource(messageV2, messageSource) {
        this.stateManager.addToSource(messageV2, messageSource);
    }
    lastCreatedAt;
    // this makes sure messages added in order will always have a date atleast 1ms apart.
    generateCreatedAt(messageSource, start) {
        const startDate = start instanceof Date ? start : typeof start === "string" || typeof start === "number" ? new Date(start) : void 0;
        if (startDate && !this.lastCreatedAt) {
            this.lastCreatedAt = startDate.getTime();
            return startDate;
        }
        if (startDate && messageSource === `memory`) {
            return startDate;
        }
        const now = /* @__PURE__ */ new Date();
        const nowTime = startDate?.getTime() || now.getTime();
        const lastTime = this.messages.reduce((p, m)=>{
            if (m.createdAt.getTime() > p) return m.createdAt.getTime();
            return p;
        }, this.lastCreatedAt || 0);
        if (nowTime <= lastTime) {
            const newDate = new Date(lastTime + 1);
            this.lastCreatedAt = newDate.getTime();
            return newDate;
        }
        this.lastCreatedAt = nowTime;
        return now;
    }
    newMessageId(role) {
        if (this.generateMessageId) {
            return this.generateMessageId({
                idType: "message",
                source: "agent",
                threadId: this.memoryInfo?.threadId,
                resourceId: this.memoryInfo?.resourceId,
                role
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lukeed$2f$uuid$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["v4"])();
    }
    createAdapterContext() {
        return {
            memoryInfo: this.memoryInfo,
            newMessageId: ()=>this.newMessageId(),
            generateCreatedAt: (messageSource, start)=>this.generateCreatedAt(messageSource, start),
            dbMessages: this.messages
        };
    }
};
// src/agent/message-list/utils/convert-messages.ts
var MessageConverter = class {
    messageList;
    constructor(messages){
        this.messageList = new MessageList();
        this.messageList.add(messages, "memory");
    }
    to(format) {
        switch(format){
            // Old format keys (backward compatibility)
            case "Mastra.V2":
                return this.messageList.get.all.db();
            case "AIV4.UI":
                return this.messageList.get.all.aiV4.ui();
            case "AIV4.Core":
                return this.messageList.get.all.aiV4.core();
            case "AIV5.UI":
                return this.messageList.get.all.aiV5.ui();
            case "AIV5.Model":
                return this.messageList.get.all.aiV5.model();
            default:
                throw new Error(`Unsupported output format: ${format}`);
        }
    }
};
function convertMessages(messages) {
    return new MessageConverter(messages);
}
;
 //# sourceMappingURL=chunk-PSIJ6OSV.js.map
 //# sourceMappingURL=chunk-PSIJ6OSV.js.map
}),
];

//# sourceMappingURL=node_modules_%40mastra_core_dist_chunk-PSIJ6OSV_2c056ae4.js.map