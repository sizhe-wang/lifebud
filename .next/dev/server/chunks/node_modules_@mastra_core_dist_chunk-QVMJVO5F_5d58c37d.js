module.exports = [
"[project]/node_modules/@mastra/core/dist/chunk-QVMJVO5F.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToolLoopAgent",
    ()=>ToolLoopAgent,
    "embed",
    ()=>embed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-2AU5ZHBL.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/parse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/core/to-json-schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/types.js [app-route] (ecmascript)");
;
;
;
;
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _b;
var AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name142, message, cause }){
        super(message);
        this[_a] = true;
        this.name = name142;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError.hasMarker(error, marker);
    }
    static hasMarker(error, marker152) {
        const markerSymbol = Symbol.for(marker152);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var _b2;
var APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name,
            message,
            cause
        });
        this[_a2] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker2);
    }
};
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var _b3;
var EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}){
        super({
            name: name2,
            message
        });
        this[_a3] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker3);
    }
};
function getErrorMessage(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var _b4;
var InvalidArgumentError = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {
    constructor({ message, cause, argument }){
        super({
            name: name3,
            message,
            cause
        });
        this[_a4] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker4);
    }
};
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var _b5;
var InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {
    constructor({ prompt, message, cause }){
        super({
            name: name4,
            message: `Invalid prompt: ${message}`,
            cause
        });
        this[_a5] = true;
        this.prompt = prompt;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker5);
    }
};
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var _b7;
var JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {
    constructor({ text: text2, cause }){
        super({
            name: name6,
            message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a7] = true;
        this.text = text2;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker7);
    }
};
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _b13;
var TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {
    constructor({ value, cause }){
        super({
            name: name12,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a13] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker13);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({
            value,
            cause
        });
    }
};
var ParseError = class extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
};
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = createParser({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
};
function combineHeaders(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>({
            ...combinedHeaders,
            ...currentHeaders != null ? currentHeaders : {}
        }), {});
}
async function delay(delayInMs, options) {
    if (delayInMs == null) {
        return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve2, reject)=>{
        if (signal == null ? void 0 : signal.aborted) {
            reject(createAbortError());
            return;
        }
        const timeoutId = setTimeout(()=>{
            cleanup();
            resolve2();
        }, delayInMs);
        const cleanup = ()=>{
            clearTimeout(timeoutId);
            signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        };
        const onAbort = ()=>{
            cleanup();
            reject(createAbortError());
        };
        signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
}
function createAbortError() {
    return new DOMException("Delay was aborted", "AbortError");
}
var DelayedPromise = class {
    constructor(){
        this.status = {
            type: "pending"
        };
        this._resolve = void 0;
        this._reject = void 0;
    }
    get promise() {
        if (this._promise) {
            return this._promise;
        }
        this._promise = new Promise((resolve2, reject)=>{
            if (this.status.type === "resolved") {
                resolve2(this.status.value);
            } else if (this.status.type === "rejected") {
                reject(this.status.error);
            }
            this._resolve = resolve2;
            this._reject = reject;
        });
        return this._promise;
    }
    resolve(value) {
        var _a223;
        this.status = {
            type: "resolved",
            value
        };
        if (this._promise) {
            (_a223 = this._resolve) == null ? void 0 : _a223.call(this, value);
        }
    }
    reject(error) {
        var _a223;
        this.status = {
            type: "rejected",
            error
        };
        if (this._promise) {
            (_a223 = this._reject) == null ? void 0 : _a223.call(this, error);
        }
    }
    isResolved() {
        return this.status.type === "resolved";
    }
    isRejected() {
        return this.status.type === "rejected";
    }
    isPending() {
        return this.status.type === "pending";
    }
};
function extractResponseHeaders(response) {
    return Object.fromEntries([
        ...response.headers
    ]);
}
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob(base64Url);
    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array2) {
    let latin1string = "";
    for(let i = 0; i < array2.length; i++){
        latin1string += String.fromCodePoint(array2[i]);
    }
    return btoa(latin1string);
}
var name14 = "AI_DownloadError";
var marker15 = `vercel.ai.error.${name14}`;
var symbol15 = Symbol.for(marker15);
var _a15;
var _b15;
var DownloadError = class extends (_b15 = AISDKError, _a15 = symbol15, _b15) {
    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){
        super({
            name: name14,
            message,
            cause
        });
        this[_a15] = true;
        this.url = url;
        this.statusCode = statusCode;
        this.statusText = statusText;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker15);
    }
};
var createIdGenerator = ({ prefix, size = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = ()=>{
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for(let i = 0; i < size; i++){
            chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
    };
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new InvalidArgumentError({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return ()=>`${prefix}${separator}${generator()}`;
};
createIdGenerator();
function getErrorMessage2(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
function isAbortError(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = [
    "fetch failed",
    "failed to fetch"
];
function handleFetchError({ error, url, requestBodyValues }) {
    if (isAbortError(error)) {
        return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
        const cause = error.cause;
        if (cause != null) {
            return new APICallError({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
            });
        }
    }
    return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
    var _a223, _b222, _c;
    if (globalThisAny.window) {
        return `runtime/browser`;
    }
    if ((_a223 = globalThisAny.navigator) == null ? void 0 : _a223.userAgent) {
        return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b222 = globalThisAny.process) == null ? void 0 : _b222.versions) == null ? void 0 : _c.node) {
        return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
        return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
}
function normalizeHeaders(headers) {
    if (headers == null) {
        return {};
    }
    const normalized = {};
    if (headers instanceof Headers) {
        headers.forEach((value, key)=>{
            normalized[key.toLowerCase()] = value;
        });
    } else {
        if (!Array.isArray(headers)) {
            headers = Object.entries(headers);
        }
        for (const [key, value] of headers){
            if (value != null) {
                normalized[key.toLowerCase()] = value;
            }
        }
    }
    return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
    const normalizedHeaders = new Headers(normalizeHeaders(headers));
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set("user-agent", [
        currentUserAgentHeader,
        ...userAgentSuffixParts
    ].filter(Boolean).join(" "));
    return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION = "4.0.0";
var getOriginalFetch = ()=>globalThis.fetch;
var getFromApi = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch() })=>{
    try {
        const response = await fetch2(url, {
            method: "GET",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: {}
                });
            } catch (error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
                throw new APICallError({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: {}
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: {}
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: {}
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: {}
        });
    }
};
function isUrlSupported({ mediaType, url, supportedUrls }) {
    url = url.toLowerCase();
    mediaType = mediaType.toLowerCase();
    return Object.entries(supportedUrls).map(([key, value])=>{
        const mediaType2 = key.toLowerCase();
        return mediaType2 === "*" || mediaType2 === "*/*" ? {
            mediaTypePrefix: "",
            regexes: value
        } : {
            mediaTypePrefix: mediaType2.replace(/\*/, ""),
            regexes: value
        };
    }).filter(({ mediaTypePrefix })=>mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes })=>regexes).some((pattern)=>pattern.test(url));
}
function loadOptionalSetting({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text2) {
    const obj = JSON.parse(text2);
    if (obj === null || typeof obj !== "object") {
        return obj;
    }
    if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
        return obj;
    }
    return filter(obj);
}
function filter(obj) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === "object") {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function secureJsonParse(text2) {
    const { stackTraceLimit } = Error;
    try {
        Error.stackTraceLimit = 0;
    } catch (e) {
        return _parse(text2);
    }
    try {
        return _parse(text2);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema2) {
    if (jsonSchema2.type === "object") {
        jsonSchema2.additionalProperties = false;
        const properties = jsonSchema2.properties;
        if (properties != null) {
            for(const property in properties){
                properties[property] = addAdditionalPropertiesToJsonSchema(properties[property]);
            }
        }
    }
    if (jsonSchema2.type === "array" && jsonSchema2.items != null) {
        if (Array.isArray(jsonSchema2.items)) {
            jsonSchema2.items = jsonSchema2.items.map((item)=>addAdditionalPropertiesToJsonSchema(item));
        } else {
            jsonSchema2.items = addAdditionalPropertiesToJsonSchema(jsonSchema2.items);
        }
    }
    return jsonSchema2;
}
var ignoreOverride = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
};
var getDefaultOptions = (options)=>typeof options === "string" ? {
        ...defaultOptions,
        name: options
    } : {
        ...defaultOptions,
        ...options
    };
function parseAnyDef() {
    return {};
}
function parseArrayDef(def, refs) {
    var _a223, _b222, _c;
    const res = {
        type: "array"
    };
    if (((_a223 = def.type) == null ? void 0 : _a223._def) && ((_c = (_b222 = def.type) == null ? void 0 : _b222._def) == null ? void 0 : _c.typeName) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        });
    }
    if (def.minLength) {
        res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
        res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
        res.minItems = def.exactLength.value;
        res.maxItems = def.exactLength.value;
    }
    return res;
}
function parseBigintDef(def) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseBooleanDef() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser(def);
    }
}
var integerDateParser = (def)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                res.minimum = check.value;
                break;
            case "max":
                res.maximum = check.value;
                break;
        }
    }
    return res;
};
function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf
    } : void 0;
}
function parseLiteralDef(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex = void 0;
var zodPatterns = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex === void 0) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    break;
                case "max":
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "includes":
                    {
                        addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern(res, zodPatterns.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    res.contentEncoding = "base64";
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern(res, zodPatterns.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern(res, zodPatterns.nanoid, check.message, refs);
                    }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    var _a223;
    if (schema.format || ((_a223 = schema.anyOf) == null ? void 0 : _a223.some((x)=>x.format))) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format
            });
            delete schema.format;
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else {
        schema.format = value;
    }
}
function addPattern(schema, regex, message, refs) {
    var _a223;
    if (schema.pattern || ((_a223 = schema.allOf) == null ? void 0 : _a223.some((x)=>x.pattern))) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern
            });
            delete schema.pattern;
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else {
        schema.pattern = stringifyRegExpWithFlags(regex, refs);
    }
}
function stringifyRegExpWithFlags(regex, refs) {
    var _a223;
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        // Case-insensitive
        m: regex.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && ((_a223 = source[i + 2]) == null ? void 0 : _a223.match(/[a-z]/))) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}
function parseRecordDef(def, refs) {
    var _a223, _b222, _c, _d, _e, _f;
    const schema = {
        type: "object",
        additionalProperties: (_a223 = parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        })) != null ? _a223 : refs.allowedAdditionalProperties
    };
    if (((_b222 = def.keyType) == null ? void 0 : _b222._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values
            }
        };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded && def.keyType._def.type._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || parseAnyDef();
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || parseAnyDef();
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef(def) {
    const object2 = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object2[object2[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object2[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef() {
    return {
        not: parseAnyDef()
    };
}
function parseNullDef() {
    return {
        type: "null"
    };
}
var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf(def, refs);
}
var asAnyOf = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef(def) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                break;
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseObjectDef(def, refs) {
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        const propOptional = safeIsOptional(propDef);
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        });
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        });
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    } catch (e) {
        return true;
    }
}
var parseOptionalDef = (def, refs)=>{
    var _a223;
    if (refs.currentPath.toString() === ((_a223 = refs.propertyPath) == null ? void 0 : _a223.toString())) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef()
            },
            innerSchema
        ]
    } : parseAnyDef();
};
var parsePipelineDef = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
        schema.maxItems = def.maxSize.value;
    }
    return schema;
}
function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            })
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef() {
    return {
        not: parseAnyDef()
    };
}
function parseUnknownDef() {
    return parseAnyDef();
}
var parseReadonlyDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs)=>{
    switch(typeName){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString:
            return parseStringDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNumber:
            return parseNumberDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodObject:
            return parseObjectDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBigInt:
            return parseBigintDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBoolean:
            return parseBooleanDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDate:
            return parseDateDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUndefined:
            return parseUndefinedDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNull:
            return parseNullDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodArray:
            return parseArrayDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnion:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodIntersection:
            return parseIntersectionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodTuple:
            return parseTupleDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodRecord:
            return parseRecordDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLiteral:
            return parseLiteralDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum:
            return parseEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNativeEnum:
            return parseNativeEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNullable:
            return parseNullableDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodOptional:
            return parseOptionalDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodMap:
            return parseMapDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSet:
            return parseSetDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLazy:
            return ()=>def.getter()._def;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPromise:
            return parsePromiseDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNaN:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNever:
            return parseNeverDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEffects:
            return parseEffectsDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny:
            return parseAnyDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnknown:
            return parseUnknownDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDefault:
            return parseDefaultDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded:
            return parseBrandedDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodReadonly:
            return parseReadonlyDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodCatch:
            return parseCatchDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPipeline:
            return parsePipelineDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodFunction:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodVoid:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)();
    }
};
var getRelativePath = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
function parseDef(def, refs, forceResolution = false) {
    var _a223;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = (_a223 = refs.override) == null ? void 0 : _a223.call(refs, def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
        addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
        newItem.jsonSchema = jsonSchema2;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
}
var get$ref = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef();
                }
                return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
            }
    }
};
var addMeta = (def, refs, jsonSchema2)=>{
    if (def.description) {
        jsonSchema2.description = def.description;
    }
    return jsonSchema2;
};
var getRefs = (options)=>{
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name223, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name223
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    };
};
var zod3ToJsonSchema = (schema, options)=>{
    var _a223;
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name323, schema2])=>{
        var _a323;
        return {
            ...acc,
            [name323]: (_a323 = parseDef(schema2._def, {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name323
                ]
            }, true)) != null ? _a323 : parseAnyDef()
        };
    }, {}) : void 0;
    const name223 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a223 = parseDef(schema._def, name223 === void 0 ? refs : {
        ...refs,
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name223
        ]
    }, false)) != null ? _a223 : parseAnyDef();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    const combined = name223 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
    } : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name223
        ].join("/"),
        [refs.definitionPath]: {
            ...definitions,
            [name223]: main
        }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
};
var schemaSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
    let schema;
    return ()=>{
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    };
}
function jsonSchema(jsonSchema2, { validate } = {}) {
    return {
        [schemaSymbol]: true,
        _type: void 0,
        // should never be used directly
        get jsonSchema () {
            if (typeof jsonSchema2 === "function") {
                jsonSchema2 = jsonSchema2();
            }
            return jsonSchema2;
        },
        validate
    };
}
function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
    return schema == null ? jsonSchema({
        properties: {},
        additionalProperties: false
    }) : isSchema(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
    return jsonSchema(()=>standardSchema2["~standard"].jsonSchema.input({
            target: "draft-07"
        }), {
        validate: async (value)=>{
            const result = await standardSchema2["~standard"].validate(value);
            return "value" in result ? {
                success: true,
                value: result.value
            } : {
                success: false,
                error: new TypeValidationError({
                    value,
                    cause: result.issues
                })
            };
        }
    });
}
function zod3Schema(zodSchema2, options) {
    var _a223;
    const useReferences = (_a223 = void 0) != null ? _a223 : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>zod3ToJsonSchema(zodSchema2, {
            $refStrategy: useReferences ? "root" : "none"
        }), {
        validate: async (value)=>{
            const result = await zodSchema2.safeParseAsync(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function zod4Schema(zodSchema2, options) {
    var _a223;
    const useReferences = (_a223 = void 0) != null ? _a223 : false;
    return jsonSchema(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>addAdditionalPropertiesToJsonSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toJSONSchema"](zodSchema2, {
            target: "draft-7",
            io: "input",
            reused: useReferences ? "ref" : "inline"
        })), {
        validate: async (value)=>{
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseAsync"](zodSchema2, value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function isZod4Schema(zodSchema2) {
    return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
    if (isZod4Schema(zodSchema2)) {
        return zod4Schema(zodSchema2);
    } else {
        return zod3Schema(zodSchema2);
    }
}
async function validateTypes({ value, schema }) {
    const result = await safeValidateTypes({
        value,
        schema
    });
    if (!result.success) {
        throw TypeValidationError.wrap({
            value,
            cause: result.error
        });
    }
    return result.value;
}
async function safeValidateTypes({ value, schema }) {
    const actualSchema = asSchema(schema);
    try {
        if (actualSchema.validate == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const result = await actualSchema.validate(value);
        if (result.success) {
            return {
                success: true,
                value: result.value,
                rawValue: value
            };
        }
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: result.error
            }),
            rawValue: value
        };
    } catch (error) {
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: error
            }),
            rawValue: value
        };
    }
}
async function parseJSON({ text: text2, schema }) {
    try {
        const value = secureJsonParse(text2);
        if (schema == null) {
            return value;
        }
        return validateTypes({
            value,
            schema
        });
    } catch (error) {
        if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
            throw error;
        }
        throw new JSONParseError({
            text: text2,
            cause: error
        });
    }
}
async function safeParseJSON({ text: text2, schema }) {
    try {
        const value = secureJsonParse(text2);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        return await safeValidateTypes({
            value,
            schema
        });
    } catch (error) {
        return {
            success: false,
            error: JSONParseError.isInstance(error) ? error : new JSONParseError({
                text: text2,
                cause: error
            }),
            rawValue: void 0
        };
    }
}
function parseJsonEventStream({ stream, schema }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({
        async transform ({ data }, controller) {
            if (data === "[DONE]") {
                return;
            }
            controller.enqueue(await safeParseJSON({
                text: data,
                schema
            }));
        }
    }));
}
var getOriginalFetch2 = ()=>globalThis.fetch;
var postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch: fetch2 })=>postToApi({
        url,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        body: {
            content: JSON.stringify(body),
            values: body
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch: fetch2
    });
var postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch2() })=>{
    try {
        const response = await fetch2(url, {
            method: "POST",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
            body: body.content,
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
                throw new APICallError({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: body.values
        });
    }
};
async function resolve(value) {
    if (typeof value === "function") {
        value = value();
    }
    return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const responseHeaders = extractResponseHeaders(response);
        if (responseBody.trim() === "") {
            return {
                responseHeaders,
                value: new APICallError({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
        try {
            const parsedError = await parseJSON({
                text: responseBody,
                schema: errorSchema
            });
            return {
                responseHeaders,
                value: new APICallError({
                    message: errorToMessage(parsedError),
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    data: parsedError,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                })
            };
        } catch (parseError) {
            return {
                responseHeaders,
                value: new APICallError({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
    };
var createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (response.body == null) {
            throw new EmptyResponseBodyError({});
        }
        return {
            responseHeaders,
            value: parseJsonEventStream({
                stream: response.body,
                schema: chunkSchema
            })
        };
    };
var createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const parsedResult = await safeParseJSON({
            text: responseBody,
            schema: responseSchema
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!parsedResult.success) {
            throw new APICallError({
                message: "Invalid JSON response",
                cause: parsedResult.error,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                url,
                requestBodyValues
            });
        }
        return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
        };
    };
function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] === "function";
}
async function* executeTool({ execute, input, options }) {
    const result = execute(input, options);
    if (isAsyncIterable(result)) {
        let lastOutput;
        for await (const output of result){
            lastOutput = output;
            yield {
                type: "preliminary",
                output
            };
        }
        yield {
            type: "final",
            output: lastOutput
        };
    } else {
        yield {
            type: "final",
            output: await result
        };
    }
}
var require_get_context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames = Object.getOwnPropertyNames;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __export2 = (target, all)=>{
            for(var name142 in all)__defProp2(target, name142, {
                get: all[name142],
                enumerable: true
            });
        };
        var __copyProps = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var get_context_exports = {};
        __export2(get_context_exports, {
            SYMBOL_FOR_REQ_CONTEXT: ()=>SYMBOL_FOR_REQ_CONTEXT,
            getContext: ()=>getContext3
        });
        module.exports = __toCommonJS(get_context_exports);
        var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
        function getContext3() {
            const fromSymbol = globalThis;
            return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
        }
    }
});
var require_get_vercel_oidc_token = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames = Object.getOwnPropertyNames;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __export2 = (target, all)=>{
            for(var name142 in all)__defProp2(target, name142, {
                get: all[name142],
                enumerable: true
            });
        };
        var __copyProps = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var get_vercel_oidc_token_exports = {};
        __export2(get_vercel_oidc_token_exports, {
            getVercelOidcToken: ()=>getVercelOidcToken3,
            getVercelOidcTokenSync: ()=>getVercelOidcTokenSync2
        });
        module.exports = __toCommonJS(get_vercel_oidc_token_exports);
        var import_get_context = require_get_context();
        var import_token_error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["require_token_error"])();
        async function getVercelOidcToken3() {
            let token = "";
            let err;
            try {
                token = getVercelOidcTokenSync2();
            } catch (error) {
                err = error;
            }
            try {
                const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
                    await __turbopack_context__.A("[project]/node_modules/@mastra/core/dist/token-util-NEHG7TUY-QTFZ26EN.js [app-route] (ecmascript, async loader)"),
                    await __turbopack_context__.A("[project]/node_modules/@mastra/core/dist/token-6GSAFR2W-LTZ7QQUP.js [app-route] (ecmascript, async loader)")
                ]);
                if (!token || isExpired(getTokenPayload(token))) {
                    await refreshToken();
                    token = getVercelOidcTokenSync2();
                }
            } catch (error) {
                if (err?.message && error instanceof Error) {
                    error.message = `${err.message}
${error.message}`;
                }
                throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
            }
            return token;
        }
        function getVercelOidcTokenSync2() {
            const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
            if (!token) {
                throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
            }
            return token;
        }
    }
});
var require_dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames = Object.getOwnPropertyNames;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __export2 = (target, all)=>{
            for(var name142 in all)__defProp2(target, name142, {
                get: all[name142],
                enumerable: true
            });
        };
        var __copyProps = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var src_exports = {};
        __export2(src_exports, {
            getContext: ()=>import_get_context.getContext,
            getVercelOidcToken: ()=>import_get_vercel_oidc_token.getVercelOidcToken,
            getVercelOidcTokenSync: ()=>import_get_vercel_oidc_token.getVercelOidcTokenSync
        });
        module.exports = __toCommonJS(src_exports);
        var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
        var import_get_context = require_get_context();
    }
});
var import_oidc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist(), 1);
var import_oidc2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$2AU5ZHBL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist(), 1);
var marker16 = "vercel.ai.gateway.error";
var symbol16 = Symbol.for(marker16);
var _a16;
var _b16;
var GatewayError = class _GatewayError extends (_b16 = Error, _a16 = symbol16, _b16) {
    constructor({ message, statusCode = 500, cause }){
        super(message);
        this[_a16] = true;
        this.statusCode = statusCode;
        this.cause = cause;
    }
    /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */ static isInstance(error) {
        return _GatewayError.hasMarker(error);
    }
    static hasMarker(error) {
        return typeof error === "object" && error !== null && symbol16 in error && error[symbol16] === true;
    }
};
var name15 = "GatewayAuthenticationError";
var marker22 = `vercel.ai.gateway.error.${name15}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var _b22;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b22 = GatewayError, _a22 = symbol22, _b22) {
    constructor({ message = "Authentication failed", statusCode = 401, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a22] = true;
        this.name = name15;
        this.type = "authentication_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol22 in error;
    }
    /**
   * Creates a contextual error message when authentication fails
   */ static createContextualError({ apiKeyProvided, oidcTokenProvided, message = "Authentication failed", statusCode = 401, cause }) {
        let contextualMessage;
        if (apiKeyProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
        } else if (oidcTokenProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
        } else {
            contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
        }
        return new _GatewayAuthenticationError({
            message: contextualMessage,
            statusCode,
            cause
        });
    }
};
var name22 = "GatewayInvalidRequestError";
var marker32 = `vercel.ai.gateway.error.${name22}`;
var symbol32 = Symbol.for(marker32);
var _a32;
var _b32;
var GatewayInvalidRequestError = class extends (_b32 = GatewayError, _a32 = symbol32, _b32) {
    constructor({ message = "Invalid request", statusCode = 400, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a32] = true;
        this.name = name22;
        this.type = "invalid_request_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol32 in error;
    }
};
var name32 = "GatewayRateLimitError";
var marker42 = `vercel.ai.gateway.error.${name32}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var _b42;
var GatewayRateLimitError = class extends (_b42 = GatewayError, _a42 = symbol42, _b42) {
    constructor({ message = "Rate limit exceeded", statusCode = 429, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a42] = true;
        this.name = name32;
        this.type = "rate_limit_exceeded";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol42 in error;
    }
};
var name42 = "GatewayModelNotFoundError";
var marker52 = `vercel.ai.gateway.error.${name42}`;
var symbol52 = Symbol.for(marker52);
var modelNotFoundParamSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })));
var _a52;
var _b52;
var GatewayModelNotFoundError = class extends (_b52 = GatewayError, _a52 = symbol52, _b52) {
    constructor({ message = "Model not found", statusCode = 404, modelId, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a52] = true;
        this.name = name42;
        this.type = "model_not_found";
        this.modelId = modelId;
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol52 in error;
    }
};
var name52 = "GatewayInternalServerError";
var marker62 = `vercel.ai.gateway.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var _b62;
var GatewayInternalServerError = class extends (_b62 = GatewayError, _a62 = symbol62, _b62) {
    constructor({ message = "Internal server error", statusCode = 500, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a62] = true;
        this.name = name52;
        this.type = "internal_server_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol62 in error;
    }
};
var name62 = "GatewayResponseError";
var marker72 = `vercel.ai.gateway.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var _b72;
var GatewayResponseError = class extends (_b72 = GatewayError, _a72 = symbol72, _b72) {
    constructor({ message = "Invalid response from Gateway", statusCode = 502, response, validationError, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a72] = true;
        this.name = name62;
        this.type = "response_error";
        this.response = response;
        this.validationError = validationError;
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol72 in error;
    }
};
async function createGatewayErrorFromResponse({ response, statusCode, defaultMessage = "Gateway request failed", cause, authMethod }) {
    const parseResult = await safeValidateTypes({
        value: response,
        schema: gatewayErrorResponseSchema
    });
    if (!parseResult.success) {
        return new GatewayResponseError({
            message: `Invalid error response format: ${defaultMessage}`,
            statusCode,
            response,
            validationError: parseResult.error,
            cause
        });
    }
    const validatedResponse = parseResult.value;
    const errorType = validatedResponse.error.type;
    const message = validatedResponse.error.message;
    switch(errorType){
        case "authentication_error":
            return GatewayAuthenticationError.createContextualError({
                apiKeyProvided: authMethod === "api-key",
                oidcTokenProvided: authMethod === "oidc",
                statusCode,
                cause
            });
        case "invalid_request_error":
            return new GatewayInvalidRequestError({
                message,
                statusCode,
                cause
            });
        case "rate_limit_exceeded":
            return new GatewayRateLimitError({
                message,
                statusCode,
                cause
            });
        case "model_not_found":
            {
                const modelResult = await safeValidateTypes({
                    value: validatedResponse.error.param,
                    schema: modelNotFoundParamSchema
                });
                return new GatewayModelNotFoundError({
                    message,
                    statusCode,
                    modelId: modelResult.success ? modelResult.value.modelId : void 0,
                    cause
                });
            }
        case "internal_server_error":
            return new GatewayInternalServerError({
                message,
                statusCode,
                cause
            });
        default:
            return new GatewayInternalServerError({
                message,
                statusCode,
                cause
            });
    }
}
var gatewayErrorResponseSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            param: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().nullish(),
            code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
            ]).nullish()
        })
    })));
function asGatewayError(error, authMethod) {
    var _a83;
    if (GatewayError.isInstance(error)) {
        return error;
    }
    if (APICallError.isInstance(error)) {
        return createGatewayErrorFromResponse({
            response: extractApiCallResponse(error),
            statusCode: (_a83 = error.statusCode) != null ? _a83 : 500,
            defaultMessage: "Gateway request failed",
            cause: error,
            authMethod
        });
    }
    return createGatewayErrorFromResponse({
        response: {},
        statusCode: 500,
        defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
        cause: error,
        authMethod
    });
}
function extractApiCallResponse(error) {
    if (error.data !== void 0) {
        return error.data;
    }
    if (error.responseBody != null) {
        try {
            return JSON.parse(error.responseBody);
        } catch (e) {
            return error.responseBody;
        }
    }
    return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
async function parseAuthMethod(headers) {
    const result = await safeValidateTypes({
        value: headers[GATEWAY_AUTH_METHOD_HEADER],
        schema: gatewayAuthMethodSchema
    });
    return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("api-key"),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("oidc")
    ])));
var GatewayFetchMetadata = class {
    constructor(config){
        this.config = config;
    }
    async getAvailableModels() {
        try {
            const { value } = await getFromApi({
                url: `${this.config.baseURL}/config`,
                headers: await resolve(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler(gatewayAvailableModelsResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError(error);
        }
    }
    async getCredits() {
        try {
            const baseUrl = new URL(this.config.baseURL);
            const { value } = await getFromApi({
                url: `${baseUrl.origin}/v1/credits`,
                headers: await resolve(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler(gatewayCreditsResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError(error);
        }
    }
};
var gatewayAvailableModelsResponseSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        models: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            pricing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                input_cache_read: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
                input_cache_write: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish()
            }).transform(({ input, output, input_cache_read, input_cache_write })=>({
                    input,
                    output,
                    ...input_cache_read ? {
                        cachedInputTokens: input_cache_read
                    } : {},
                    ...input_cache_write ? {
                        cacheCreationInputTokens: input_cache_write
                    } : {}
                })).nullish(),
            specification: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                specificationVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("v3"),
                provider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            modelType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "language",
                "embedding",
                "image"
            ]).nullish()
        }))
    })));
var gatewayCreditsResponseSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        balance: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        total_used: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }).transform(({ balance, total_used })=>({
            balance,
            totalUsed: total_used
        }))));
var GatewayLanguageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.supportedUrls = {
            "*/*": [
                /.*/
            ]
        };
    }
    get provider() {
        return this.config.provider;
    }
    async getArgs(options) {
        const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
        return {
            args: this.maybeEncodeFileParts(optionsWithoutSignal),
            warnings: []
        };
    }
    async doGenerate(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue: rawResponse } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, false), await resolve(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createJsonResponseHandler(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                ...responseBody,
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders,
                    body: rawResponse
                },
                warnings
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { value: response, responseHeaders } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, true), await resolve(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createEventSourceResponseHandler(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        if (warnings.length > 0) {
                            controller.enqueue({
                                type: "stream-start",
                                warnings
                            });
                        }
                    },
                    transform (chunk, controller) {
                        if (chunk.success) {
                            const streamPart = chunk.value;
                            if (streamPart.type === "raw" && !options.includeRawChunks) {
                                return;
                            }
                            if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                                streamPart.timestamp = new Date(streamPart.timestamp);
                            }
                            controller.enqueue(streamPart);
                        } else {
                            controller.error(chunk.error);
                        }
                    }
                })),
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    isFilePart(part) {
        return part && typeof part === "object" && "type" in part && part.type === "file";
    }
    /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */ maybeEncodeFileParts(options) {
        for (const message of options.prompt){
            for (const part of message.content){
                if (this.isFilePart(part)) {
                    const filePart = part;
                    if (filePart.data instanceof Uint8Array) {
                        const buffer = Uint8Array.from(filePart.data);
                        const base64Data = Buffer.from(buffer).toString("base64");
                        filePart.data = new URL(`data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`);
                    }
                }
            }
        }
        return options;
    }
    getUrl() {
        return `${this.config.baseURL}/language-model`;
    }
    getModelConfigHeaders(modelId, streaming) {
        return {
            "ai-language-model-specification-version": "2",
            "ai-language-model-id": modelId,
            "ai-language-model-streaming": String(streaming)
        };
    }
};
var GatewayEmbeddingModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
    }
    get provider() {
        return this.config.provider;
    }
    async doEmbed({ values, headers, abortSignal, providerOptions }) {
        var _a83;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
                body: {
                    values,
                    ...providerOptions ? {
                        providerOptions
                    } : {}
                },
                successfulResponseHandler: createJsonResponseHandler(gatewayEmbeddingResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                embeddings: responseBody.embeddings,
                usage: (_a83 = responseBody.usage) != null ? _a83 : void 0,
                providerMetadata: responseBody.providerMetadata,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                },
                warnings: []
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/embedding-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-embedding-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var gatewayEmbeddingResponseSchema = lazySchema(()=>zodSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        embeddings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number())),
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            tokens: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
        }).nullish(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown())).optional()
    })));
var GatewayImageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
    }
    get provider() {
        return this.config.provider;
    }
    async doGenerate({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
        var _a83;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
                body: {
                    prompt,
                    n,
                    ...size && {
                        size
                    },
                    ...aspectRatio && {
                        aspectRatio
                    },
                    ...seed && {
                        seed
                    },
                    ...providerOptions && {
                        providerOptions
                    }
                },
                successfulResponseHandler: createJsonResponseHandler(gatewayImageResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                images: responseBody.images,
                // Always base64 strings from server
                warnings: (_a83 = responseBody.warnings) != null ? _a83 : [],
                providerMetadata: responseBody.providerMetadata,
                response: {
                    timestamp: /* @__PURE__ */ new Date(),
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/image-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-image-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var providerMetadataEntrySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).optional()
}).catchall(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown());
var gatewayImageResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
    // Always base64 strings over the wire
    warnings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("other"),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })).optional(),
    providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), providerMetadataEntrySchema).optional()
});
async function getVercelRequestId() {
    var _a83;
    return (_a83 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a83["x-vercel-id"];
}
var VERSION2 = "3.0.0";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
    var _a83, _b82;
    let pendingMetadata = null;
    let metadataCache = null;
    const cacheRefreshMillis = (_a83 = options.metadataCacheRefreshMillis) != null ? _a83 : 1e3 * 60 * 5;
    let lastFetchTime = 0;
    const baseURL = (_b82 = withoutTrailingSlash(options.baseURL)) != null ? _b82 : "https://ai-gateway.vercel.sh/v3/ai";
    const getHeaders = async ()=>{
        const auth = await getGatewayAuthToken(options);
        if (auth) {
            return withUserAgentSuffix({
                Authorization: `Bearer ${auth.token}`,
                "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
                [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
                ...options.headers
            }, `ai-sdk/gateway/${VERSION2}`);
        }
        throw GatewayAuthenticationError.createContextualError({
            apiKeyProvided: false,
            oidcTokenProvided: false,
            statusCode: 401
        });
    };
    const createO11yHeaders = ()=>{
        const deploymentId = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_DEPLOYMENT_ID"
        });
        const environment = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_ENV"
        });
        const region = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_REGION"
        });
        return async ()=>{
            const requestId = await getVercelRequestId();
            return {
                ...deploymentId && {
                    "ai-o11y-deployment-id": deploymentId
                },
                ...environment && {
                    "ai-o11y-environment": environment
                },
                ...region && {
                    "ai-o11y-region": region
                },
                ...requestId && {
                    "ai-o11y-request-id": requestId
                }
            };
        };
    };
    const createLanguageModel = (modelId)=>{
        return new GatewayLanguageModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    const getAvailableModels = async ()=>{
        var _a922, _b92, _c;
        const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
        if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
            lastFetchTime = now2;
            pendingMetadata = new GatewayFetchMetadata({
                baseURL,
                headers: getHeaders,
                fetch: options.fetch
            }).getAvailableModels().then((metadata)=>{
                metadataCache = metadata;
                return metadata;
            }).catch(async (error)=>{
                throw await asGatewayError(error, await parseAuthMethod(await getHeaders()));
            });
        }
        return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
    };
    const getCredits = async ()=>{
        return new GatewayFetchMetadata({
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        }).getCredits().catch(async (error)=>{
            throw await asGatewayError(error, await parseAuthMethod(await getHeaders()));
        });
    };
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Gateway Provider model function cannot be called with the new keyword.");
        }
        return createLanguageModel(modelId);
    };
    provider.specificationVersion = "v3";
    provider.getAvailableModels = getAvailableModels;
    provider.getCredits = getCredits;
    provider.imageModel = (modelId)=>{
        return new GatewayImageModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    provider.languageModel = createLanguageModel;
    const createEmbeddingModel = (modelId)=>{
        return new GatewayEmbeddingModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    provider.embeddingModel = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
    const apiKey = loadOptionalSetting({
        settingValue: options.apiKey,
        environmentVariableName: "AI_GATEWAY_API_KEY"
    });
    if (apiKey) {
        return {
            token: apiKey,
            authMethod: "api-key"
        };
    }
    try {
        const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
        return {
            token: oidcToken,
            authMethod: "oidc"
        };
    } catch (e) {
        return null;
    }
}
var _globalThis = typeof globalThis === "object" ? globalThis : /*TURBOPACK member replacement*/ __turbopack_context__.g;
var VERSION22 = "1.9.0";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([
        ownVersion
    ]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        return function() {
            return false;
        };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible2(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
var isCompatible = _makeCompatibilityCheck(VERSION22);
var major = VERSION22.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a142;
    if (allowOverride === void 0) {
        allowOverride = false;
    }
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a142 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a142 !== void 0 ? _a142 : {
        version: VERSION22
    };
    if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION22) {
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION22);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION22 + ".");
    return true;
}
function getGlobal(type) {
    var _a142, _b82;
    var globalVersion = (_a142 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a142 === void 0 ? void 0 : _a142.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b82 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b82 === void 0 ? void 0 : _b82[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION22 + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}
var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = /** @class */ function() {
    function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
}();
function logProxy(funcName, namespace, args) {
    var logger = getGlobal("diag");
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function() {};
    }
    return {
        error: _filterFunc("error", DiagLogLevel.ERROR),
        warn: _filterFunc("warn", DiagLogLevel.WARN),
        info: _filterFunc("info", DiagLogLevel.INFO),
        debug: _filterFunc("debug", DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
    };
}
var __read2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray2 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = /** @class */ function() {
    function DiagAPI2() {
        function _logProxy(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal("diag");
                if (!logger) return;
                return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
            };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
            var _a142, _b82, _c;
            if (optionsOrLogLevel === void 0) {
                optionsOrLogLevel = {
                    logLevel: DiagLogLevel.INFO
                };
            }
            if (logger === self) {
                var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                self.error((_a142 = err.stack) !== null && _a142 !== void 0 ? _a142 : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === "number") {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel
                };
            }
            var oldLogger = getGlobal("diag");
            var newLogger = createLogLevelDiagLogger((_b82 = optionsOrLogLevel.logLevel) !== null && _b82 !== void 0 ? _b82 : DiagLogLevel.INFO, logger);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
            unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
        if (!this._instance) {
            this._instance = new DiagAPI2();
        }
        return this._instance;
    };
    return DiagAPI2;
}();
function createContextKey(description) {
    return Symbol.for(description);
}
var BaseContext = /** @class */ /* @__PURE__ */ function() {
    function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext2(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext2(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext2;
}();
var ROOT_CONTEXT = new BaseContext();
var __read3 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray3 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ function() {
    function NoopContextManager2() {}
    NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([
            thisArg
        ], __read3(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
    };
    NoopContextManager2.prototype.enable = function() {
        return this;
    };
    NoopContextManager2.prototype.disable = function() {
        return this;
    };
    return NoopContextManager2;
}();
var __read4 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray4 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = /** @class */ function() {
    function ContextAPI2() {}
    ContextAPI2.getInstance = function() {
        if (!this._instance) {
            this._instance = new ContextAPI2();
        }
        return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context, fn, thisArg) {
        var _a142;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return (_a142 = this._getContextManager()).with.apply(_a142, __spreadArray4([
            context,
            fn,
            thisArg
        ], __read4(args), false));
    };
    ContextAPI2.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
}();
var TraceFlags;
(function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = /** @class */ function() {
    function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
            _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
    };
    NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {};
    NonRecordingSpan2.prototype.isRecording = function() {
        return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {};
    return NonRecordingSpan2;
}();
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
    return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
    var _a142;
    return (_a142 = getSpan(context)) === null || _a142 === void 0 ? void 0 : _a142.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = /** @class */ function() {
    function NoopTracer2() {}
    NoopTracer2.prototype.startSpan = function(name142, options, context) {
        if (context === void 0) {
            context = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        } else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer2.prototype.startActiveSpan = function(name142, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        } else if (arguments.length === 2) {
            fn = arg2;
        } else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name142, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
}();
function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = /** @class */ function() {
    function ProxyTracer2(_provider, name142, version, options) {
        this._provider = _provider;
        this.name = name142;
        this.version = version;
        this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function(name142, options, context) {
        return this._getTracer().startSpan(name142, options, context);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer2;
}();
var NoopTracerProvider = /** @class */ function() {
    function NoopTracerProvider2() {}
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider2;
}();
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = /** @class */ function() {
    function ProxyTracerProvider2() {}
    ProxyTracerProvider2.prototype.getTracer = function(name142, version, options) {
        var _a142;
        return (_a142 = this.getDelegateTracer(name142, version, options)) !== null && _a142 !== void 0 ? _a142 : new ProxyTracer(this, name142, version, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a142;
        return (_a142 = this._delegate) !== null && _a142 !== void 0 ? _a142 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name142, version, options) {
        var _a142;
        return (_a142 = this._delegate) === null || _a142 === void 0 ? void 0 : _a142.getTracer(name142, version, options);
    };
    return ProxyTracerProvider2;
}();
var SpanStatusCode;
(function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
var API_NAME3 = "trace";
var TraceAPI = /** @class */ function() {
    function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
        if (!this._instance) {
            this._instance = new TraceAPI2();
        }
        return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name142, version) {
        return this.getTracerProvider().getTracer(name142, version);
    };
    TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
}();
var trace = TraceAPI.getInstance();
var __defProp = Object.defineProperty;
var __export = (target, all)=>{
    for(var name142 in all)__defProp(target, name142, {
        get: all[name142],
        enumerable: true
    });
};
var name72 = "AI_InvalidArgumentError";
var marker82 = `vercel.ai.error.${name72}`;
var symbol82 = Symbol.for(marker82);
var _a82;
var InvalidArgumentError2 = class extends AISDKError {
    constructor({ parameter, value, message }){
        super({
            name: name72,
            message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a82] = true;
        this.parameter = parameter;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker82);
    }
};
_a82 = symbol82;
var name322 = "AI_InvalidToolInputError";
var marker322 = `vercel.ai.error.${name322}`;
var symbol322 = Symbol.for(marker322);
var _a322;
var InvalidToolInputError = class extends AISDKError {
    constructor({ toolInput, toolName, cause, message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}` }){
        super({
            name: name322,
            message,
            cause
        });
        this[_a322] = true;
        this.toolInput = toolInput;
        this.toolName = toolName;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker322);
    }
};
_a322 = symbol322;
var name522 = "AI_NoObjectGeneratedError";
var marker522 = `vercel.ai.error.${name522}`;
var symbol522 = Symbol.for(marker522);
var _a522;
var NoObjectGeneratedError = class extends AISDKError {
    constructor({ message = "No object generated.", cause, text: text2, response, usage, finishReason }){
        super({
            name: name522,
            message,
            cause
        });
        this[_a522] = true;
        this.text = text2;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker522);
    }
};
_a522 = symbol522;
var name622 = "AI_NoOutputGeneratedError";
var marker622 = `vercel.ai.error.${name622}`;
var symbol622 = Symbol.for(marker622);
var _a622;
var NoOutputGeneratedError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "No output generated.", cause } = {}){
        super({
            name: name622,
            message,
            cause
        });
        this[_a622] = true;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker622);
    }
};
_a622 = symbol622;
var name722 = "AI_NoSuchToolError";
var marker722 = `vercel.ai.error.${name722}`;
var symbol722 = Symbol.for(marker722);
var _a722;
var NoSuchToolError = class extends AISDKError {
    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}` }){
        super({
            name: name722,
            message
        });
        this[_a722] = true;
        this.toolName = toolName;
        this.availableTools = availableTools;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker722);
    }
};
_a722 = symbol722;
var name82 = "AI_ToolCallRepairError";
var marker822 = `vercel.ai.error.${name82}`;
var symbol822 = Symbol.for(marker822);
var _a822;
var ToolCallRepairError = class extends AISDKError {
    constructor({ cause, originalError, message = `Error repairing tool call: ${getErrorMessage(cause)}` }){
        super({
            name: name82,
            message,
            cause
        });
        this[_a822] = true;
        this.originalError = originalError;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker822);
    }
};
_a822 = symbol822;
var UnsupportedModelVersionError = class extends AISDKError {
    constructor(options){
        super({
            name: "AI_UnsupportedModelVersionError",
            message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
        });
        this.version = options.version;
        this.provider = options.provider;
        this.modelId = options.modelId;
    }
};
var name102 = "AI_InvalidMessageRoleError";
var marker102 = `vercel.ai.error.${name102}`;
var symbol102 = Symbol.for(marker102);
var _a102;
var InvalidMessageRoleError = class extends AISDKError {
    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".` }){
        super({
            name: name102,
            message
        });
        this[_a102] = true;
        this.role = role;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker102);
    }
};
_a102 = symbol102;
var name122 = "AI_RetryError";
var marker122 = `vercel.ai.error.${name122}`;
var symbol122 = Symbol.for(marker122);
var _a122;
var RetryError = class extends AISDKError {
    constructor({ message, reason, errors }){
        super({
            name: name122,
            message
        });
        this[_a122] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker122);
    }
};
_a122 = symbol122;
function formatWarning({ warning, provider, model }) {
    const prefix = `AI SDK Warning (${provider} / ${model}):`;
    switch(warning.type){
        case "unsupported":
            {
                let message = `${prefix} The feature "${warning.feature}" is not supported.`;
                if (warning.details) {
                    message += ` ${warning.details}`;
                }
                return message;
            }
        case "compatibility":
            {
                let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
                if (warning.details) {
                    message += ` ${warning.details}`;
                }
                return message;
            }
        case "other":
            {
                return `${prefix} ${warning.message}`;
            }
        default:
            {
                return `${prefix} ${JSON.stringify(warning, null, 2)}`;
            }
    }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (options)=>{
    if (options.warnings.length === 0) {
        return;
    }
    const logger = globalThis.AI_SDK_LOG_WARNINGS;
    if (logger === false) {
        return;
    }
    if (typeof logger === "function") {
        logger(options);
        return;
    }
    if (!hasLoggedBefore) {
        hasLoggedBefore = true;
        console.info(FIRST_WARNING_INFO_MESSAGE);
    }
    for (const warning of options.warnings){
        console.warn(formatWarning({
            warning,
            provider: options.provider,
            model: options.model
        }));
    }
};
function logV2CompatibilityWarning({ provider, modelId }) {
    logWarnings({
        warnings: [
            {
                type: "compatibility",
                feature: "specificationVersion",
                details: `Using v2 specification compatibility mode. Some features may not be available.`
            }
        ],
        provider,
        model: modelId
    });
}
function asEmbeddingModelV3(model) {
    if (model.specificationVersion === "v3") {
        return model;
    }
    logV2CompatibilityWarning({
        provider: model.provider,
        modelId: model.modelId
    });
    return new Proxy(model, {
        get (target, prop) {
            if (prop === "specificationVersion") return "v3";
            return target[prop];
        }
    });
}
function asLanguageModelV3(model) {
    if (model.specificationVersion === "v3") {
        return model;
    }
    logV2CompatibilityWarning({
        provider: model.provider,
        modelId: model.modelId
    });
    return new Proxy(model, {
        get (target, prop) {
            switch(prop){
                case "specificationVersion":
                    return "v3";
                case "doGenerate":
                    return async (...args)=>{
                        const result = await target.doGenerate(...args);
                        return {
                            ...result,
                            finishReason: convertV2FinishReasonToV3(result.finishReason),
                            usage: convertV2UsageToV3(result.usage)
                        };
                    };
                case "doStream":
                    return async (...args)=>{
                        const result = await target.doStream(...args);
                        return {
                            ...result,
                            stream: convertV2StreamToV3(result.stream)
                        };
                    };
                default:
                    return target[prop];
            }
        }
    });
}
function convertV2StreamToV3(stream) {
    return stream.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            switch(chunk.type){
                case "finish":
                    controller.enqueue({
                        ...chunk,
                        finishReason: convertV2FinishReasonToV3(chunk.finishReason),
                        usage: convertV2UsageToV3(chunk.usage)
                    });
                    break;
                default:
                    controller.enqueue(chunk);
                    break;
            }
        }
    }));
}
function convertV2FinishReasonToV3(finishReason) {
    return {
        unified: finishReason === "unknown" ? "other" : finishReason,
        raw: void 0
    };
}
function convertV2UsageToV3(usage) {
    return {
        inputTokens: {
            total: usage.inputTokens,
            noCache: void 0,
            cacheRead: usage.cachedInputTokens,
            cacheWrite: void 0
        },
        outputTokens: {
            total: usage.outputTokens,
            text: void 0,
            reasoning: usage.reasoningTokens
        }
    };
}
function resolveLanguageModel(model) {
    if (typeof model !== "string") {
        if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
            const unsupportedModel = model;
            throw new UnsupportedModelVersionError({
                version: unsupportedModel.specificationVersion,
                provider: unsupportedModel.provider,
                modelId: unsupportedModel.modelId
            });
        }
        return asLanguageModelV3(model);
    }
    return getGlobalProvider().languageModel(model);
}
function resolveEmbeddingModel(model) {
    if (typeof model !== "string") {
        if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
            const unsupportedModel = model;
            throw new UnsupportedModelVersionError({
                version: unsupportedModel.specificationVersion,
                provider: unsupportedModel.provider,
                modelId: unsupportedModel.modelId
            });
        }
        return asEmbeddingModelV3(model);
    }
    return getGlobalProvider().embeddingModel(model);
}
function getGlobalProvider() {
    var _a142;
    return (_a142 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a142 : gateway;
}
var imageMediaTypeSignatures = [
    {
        mediaType: "image/gif",
        bytesPrefix: [
            71,
            73,
            70
        ]
    },
    {
        mediaType: "image/png",
        bytesPrefix: [
            137,
            80,
            78,
            71
        ]
    },
    {
        mediaType: "image/jpeg",
        bytesPrefix: [
            255,
            216
        ]
    },
    {
        mediaType: "image/webp",
        bytesPrefix: [
            82,
            73,
            70,
            70,
            // "RIFF"
            null,
            null,
            null,
            null,
            // file size (variable)
            87,
            69,
            66,
            80
        ]
    },
    {
        mediaType: "image/bmp",
        bytesPrefix: [
            66,
            77
        ]
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            73,
            73,
            42,
            0
        ]
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            77,
            77,
            0,
            42
        ]
    },
    {
        mediaType: "image/avif",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            97,
            118,
            105,
            102
        ]
    },
    {
        mediaType: "image/heic",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            104,
            101,
            105,
            99
        ]
    }
];
var stripID3 = (data)=>{
    const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
    return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
    const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
    data[1] === 68 && // 'D'
    data[2] === 51;
    return hasId3 ? stripID3(data) : data;
}
function detectMediaType({ data, signatures }) {
    const processedData = stripID3TagsIfPresent(data);
    const bytes = typeof processedData === "string" ? convertBase64ToUint8Array(processedData.substring(0, Math.min(processedData.length, 24))) : processedData;
    for (const signature of signatures){
        if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>byte === null || bytes[index] === byte)) {
            return signature.mediaType;
        }
    }
    return void 0;
}
var VERSION3 = "6.0.1";
var download = async ({ url })=>{
    var _a142;
    const urlText = url.toString();
    try {
        const response = await fetch(urlText, {
            headers: withUserAgentSuffix({}, `ai-sdk/${VERSION3}`, getRuntimeEnvironmentUserAgent())
        });
        if (!response.ok) {
            throw new DownloadError({
                url: urlText,
                statusCode: response.status,
                statusText: response.statusText
            });
        }
        return {
            data: new Uint8Array(await response.arrayBuffer()),
            mediaType: (_a142 = response.headers.get("content-type")) != null ? _a142 : void 0
        };
    } catch (error) {
        if (DownloadError.isInstance(error)) {
            throw error;
        }
        throw new DownloadError({
            url: urlText,
            cause: error
        });
    }
};
var createDefaultDownloadFunction = (download2 = download)=>(requestedDownloads)=>Promise.all(requestedDownloads.map(async (requestedDownload)=>requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));
function splitDataUrl(dataUrl) {
    try {
        const [header, base64Content] = dataUrl.split(",");
        return {
            mediaType: header.split(";")[0].split(":")[1],
            base64Content
        };
    } catch (error) {
        return {
            mediaType: void 0,
            base64Content: void 0
        };
    }
}
var dataContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>{
        var _a142, _b82;
        return (_b82 = (_a142 = globalThis.Buffer) == null ? void 0 : _a142.isBuffer(value)) != null ? _b82 : false;
    }, {
        message: "Must be a Buffer"
    })
]);
function convertToLanguageModelV3DataContent(content) {
    if (content instanceof Uint8Array) {
        return {
            data: content,
            mediaType: void 0
        };
    }
    if (content instanceof ArrayBuffer) {
        return {
            data: new Uint8Array(content),
            mediaType: void 0
        };
    }
    if (typeof content === "string") {
        try {
            content = new URL(content);
        } catch (error) {}
    }
    if (content instanceof URL && content.protocol === "data:") {
        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
        if (dataUrlMediaType == null || base64Content == null) {
            throw new AISDKError({
                name: "InvalidDataContentError",
                message: `Invalid data URL format in content ${content.toString()}`
            });
        }
        return {
            data: base64Content,
            mediaType: dataUrlMediaType
        };
    }
    return {
        data: content,
        mediaType: void 0
    };
}
function convertDataContentToBase64String(content) {
    if (typeof content === "string") {
        return content;
    }
    if (content instanceof ArrayBuffer) {
        return convertUint8ArrayToBase64(new Uint8Array(content));
    }
    return convertUint8ArrayToBase64(content);
}
function asArray(value) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [
        value
    ];
}
async function convertToLanguageModelPrompt({ prompt, supportedUrls, download: download2 = createDefaultDownloadFunction() }) {
    const downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls);
    const messages = [
        ...prompt.system != null ? typeof prompt.system === "string" ? [
            {
                role: "system",
                content: prompt.system
            }
        ] : asArray(prompt.system).map((message)=>({
                role: "system",
                content: message.content,
                providerOptions: message.providerOptions
            })) : [],
        ...prompt.messages.map((message)=>convertToLanguageModelMessage({
                message,
                downloadedAssets
            }))
    ];
    const combinedMessages = [];
    for (const message of messages){
        if (message.role !== "tool") {
            combinedMessages.push(message);
            continue;
        }
        const lastCombinedMessage = combinedMessages.at(-1);
        if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === "tool") {
            lastCombinedMessage.content.push(...message.content);
        } else {
            combinedMessages.push(message);
        }
    }
    return combinedMessages;
}
function convertToLanguageModelMessage({ message, downloadedAssets }) {
    const role = message.role;
    switch(role){
        case "system":
            {
                return {
                    role: "system",
                    content: message.content,
                    providerOptions: message.providerOptions
                };
            }
        case "user":
            {
                if (typeof message.content === "string") {
                    return {
                        role: "user",
                        content: [
                            {
                                type: "text",
                                text: message.content
                            }
                        ],
                        providerOptions: message.providerOptions
                    };
                }
                return {
                    role: "user",
                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== "text" || part.text !== ""),
                    providerOptions: message.providerOptions
                };
            }
        case "assistant":
            {
                if (typeof message.content === "string") {
                    return {
                        role: "assistant",
                        content: [
                            {
                                type: "text",
                                text: message.content
                            }
                        ],
                        providerOptions: message.providerOptions
                    };
                }
                return {
                    role: "assistant",
                    content: message.content.filter(// remove empty text parts (no text, and no provider options):
                    (part)=>part.type !== "text" || part.text !== "" || part.providerOptions != null).filter((part)=>part.type !== "tool-approval-request").map((part)=>{
                        const providerOptions = part.providerOptions;
                        switch(part.type){
                            case "file":
                                {
                                    const { data, mediaType } = convertToLanguageModelV3DataContent(part.data);
                                    return {
                                        type: "file",
                                        data,
                                        filename: part.filename,
                                        mediaType: mediaType != null ? mediaType : part.mediaType,
                                        providerOptions
                                    };
                                }
                            case "reasoning":
                                {
                                    return {
                                        type: "reasoning",
                                        text: part.text,
                                        providerOptions
                                    };
                                }
                            case "text":
                                {
                                    return {
                                        type: "text",
                                        text: part.text,
                                        providerOptions
                                    };
                                }
                            case "tool-call":
                                {
                                    return {
                                        type: "tool-call",
                                        toolCallId: part.toolCallId,
                                        toolName: part.toolName,
                                        input: part.input,
                                        providerExecuted: part.providerExecuted,
                                        providerOptions
                                    };
                                }
                            case "tool-result":
                                {
                                    return {
                                        type: "tool-result",
                                        toolCallId: part.toolCallId,
                                        toolName: part.toolName,
                                        output: mapToolResultOutput(part.output),
                                        providerOptions
                                    };
                                }
                        }
                    }),
                    providerOptions: message.providerOptions
                };
            }
        case "tool":
            {
                return {
                    role: "tool",
                    content: message.content.filter((part)=>part.type !== "tool-approval-response").map((part)=>({
                            type: "tool-result",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            output: mapToolResultOutput(part.output),
                            providerOptions: part.providerOptions
                        })),
                    providerOptions: message.providerOptions
                };
            }
        default:
            {
                const _exhaustiveCheck = role;
                throw new InvalidMessageRoleError({
                    role: _exhaustiveCheck
                });
            }
    }
}
async function downloadAssets(messages, download2, supportedUrls) {
    const plannedDownloads = messages.filter((message)=>message.role === "user").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === "image" || part.type === "file").map((part)=>{
        var _a142;
        const mediaType = (_a142 = part.mediaType) != null ? _a142 : part.type === "image" ? "image/*" : void 0;
        let data = part.type === "image" ? part.image : part.data;
        if (typeof data === "string") {
            try {
                data = new URL(data);
            } catch (ignored) {}
        }
        return {
            mediaType,
            data
        };
    }).filter((part)=>part.data instanceof URL).map((part)=>({
            url: part.data,
            isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
                url: part.data.toString(),
                mediaType: part.mediaType,
                supportedUrls
            })
        }));
    const downloadedFiles = await download2(plannedDownloads);
    return Object.fromEntries(downloadedFiles.map((file, index)=>file == null ? null : [
            plannedDownloads[index].url.toString(),
            {
                data: file.data,
                mediaType: file.mediaType
            }
        ]).filter((file)=>file != null));
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
    var _a142;
    if (part.type === "text") {
        return {
            type: "text",
            text: part.text,
            providerOptions: part.providerOptions
        };
    }
    let originalData;
    const type = part.type;
    switch(type){
        case "image":
            originalData = part.image;
            break;
        case "file":
            originalData = part.data;
            break;
        default:
            throw new Error(`Unsupported part type: ${type}`);
    }
    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);
    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
    let data = convertedData;
    if (data instanceof URL) {
        const downloadedFile = downloadedAssets[data.toString()];
        if (downloadedFile) {
            data = downloadedFile.data;
            mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;
        }
    }
    switch(type){
        case "image":
            {
                if (data instanceof Uint8Array || typeof data === "string") {
                    mediaType = (_a142 = detectMediaType({
                        data,
                        signatures: imageMediaTypeSignatures
                    })) != null ? _a142 : mediaType;
                }
                return {
                    type: "file",
                    mediaType: mediaType != null ? mediaType : "image/*",
                    // any image
                    filename: void 0,
                    data,
                    providerOptions: part.providerOptions
                };
            }
        case "file":
            {
                if (mediaType == null) {
                    throw new Error(`Media type is missing for file part`);
                }
                return {
                    type: "file",
                    mediaType,
                    filename: part.filename,
                    data,
                    providerOptions: part.providerOptions
                };
            }
    }
}
function mapToolResultOutput(output) {
    if (output.type !== "content") {
        return output;
    }
    return {
        type: "content",
        value: output.value.map((item)=>{
            if (item.type !== "media") {
                return item;
            }
            if (item.mediaType.startsWith("image/")) {
                return {
                    type: "image-data",
                    data: item.data,
                    mediaType: item.mediaType
                };
            }
            return {
                type: "file-data",
                data: item.data,
                mediaType: item.mediaType
            };
        })
    };
}
async function createToolModelOutput({ toolCallId, input, output, tool: tool2, errorMode }) {
    if (errorMode === "text") {
        return {
            type: "error-text",
            value: getErrorMessage(output)
        };
    } else if (errorMode === "json") {
        return {
            type: "error-json",
            value: toJSONValue(output)
        };
    }
    if (tool2 == null ? void 0 : tool2.toModelOutput) {
        return await tool2.toModelOutput({
            toolCallId,
            input,
            output
        });
    }
    return typeof output === "string" ? {
        type: "text",
        value: output
    } : {
        type: "json",
        value: toJSONValue(output)
    };
}
function toJSONValue(value) {
    return value === void 0 ? null : value;
}
function prepareCallSettings({ maxOutputTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, seed, stopSequences }) {
    if (maxOutputTokens != null) {
        if (!Number.isInteger(maxOutputTokens)) {
            throw new InvalidArgumentError2({
                parameter: "maxOutputTokens",
                value: maxOutputTokens,
                message: "maxOutputTokens must be an integer"
            });
        }
        if (maxOutputTokens < 1) {
            throw new InvalidArgumentError2({
                parameter: "maxOutputTokens",
                value: maxOutputTokens,
                message: "maxOutputTokens must be >= 1"
            });
        }
    }
    if (temperature != null) {
        if (typeof temperature !== "number") {
            throw new InvalidArgumentError2({
                parameter: "temperature",
                value: temperature,
                message: "temperature must be a number"
            });
        }
    }
    if (topP != null) {
        if (typeof topP !== "number") {
            throw new InvalidArgumentError2({
                parameter: "topP",
                value: topP,
                message: "topP must be a number"
            });
        }
    }
    if (topK != null) {
        if (typeof topK !== "number") {
            throw new InvalidArgumentError2({
                parameter: "topK",
                value: topK,
                message: "topK must be a number"
            });
        }
    }
    if (presencePenalty != null) {
        if (typeof presencePenalty !== "number") {
            throw new InvalidArgumentError2({
                parameter: "presencePenalty",
                value: presencePenalty,
                message: "presencePenalty must be a number"
            });
        }
    }
    if (frequencyPenalty != null) {
        if (typeof frequencyPenalty !== "number") {
            throw new InvalidArgumentError2({
                parameter: "frequencyPenalty",
                value: frequencyPenalty,
                message: "frequencyPenalty must be a number"
            });
        }
    }
    if (seed != null) {
        if (!Number.isInteger(seed)) {
            throw new InvalidArgumentError2({
                parameter: "seed",
                value: seed,
                message: "seed must be an integer"
            });
        }
    }
    return {
        maxOutputTokens,
        temperature,
        topP,
        topK,
        presencePenalty,
        frequencyPenalty,
        stopSequences,
        seed
    };
}
function isNonEmptyObject(object2) {
    return object2 != null && Object.keys(object2).length > 0;
}
async function prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {
    if (!isNonEmptyObject(tools)) {
        return {
            tools: void 0,
            toolChoice: void 0
        };
    }
    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name142])=>activeTools.includes(name142)) : Object.entries(tools);
    const languageModelTools = [];
    for (const [name142, tool2] of filteredTools){
        const toolType = tool2.type;
        switch(toolType){
            case void 0:
            case "dynamic":
            case "function":
                languageModelTools.push({
                    type: "function",
                    name: name142,
                    description: tool2.description,
                    inputSchema: await asSchema(tool2.inputSchema).jsonSchema,
                    ...tool2.inputExamples != null ? {
                        inputExamples: tool2.inputExamples
                    } : {},
                    providerOptions: tool2.providerOptions,
                    ...tool2.strict != null ? {
                        strict: tool2.strict
                    } : {}
                });
                break;
            case "provider":
                languageModelTools.push({
                    type: "provider",
                    name: name142,
                    id: tool2.id,
                    args: tool2.args
                });
                break;
            default:
                {
                    const exhaustiveCheck = toolType;
                    throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
                }
        }
    }
    return {
        tools: languageModelTools,
        toolChoice: toolChoice == null ? {
            type: "auto"
        } : typeof toolChoice === "string" ? {
            type: toolChoice
        } : {
            type: "tool",
            toolName: toolChoice.toolName
        }
    };
}
var jsonValueSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema.optional()),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(jsonValueSchema)
    ]));
var providerMetadataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema.optional()));
var textPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var imagePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    providerOptions: providerMetadataSchema.optional()
});
var filePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var reasoningPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var toolCallPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    providerOptions: providerMetadataSchema.optional(),
    providerExecuted: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional()
});
var outputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].discriminatedUnion("type", [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        providerOptions: providerMetadataSchema.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("json"),
        value: jsonValueSchema,
        providerOptions: providerMetadataSchema.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("execution-denied"),
        reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        providerOptions: providerMetadataSchema.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        providerOptions: providerMetadataSchema.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-json"),
        value: jsonValueSchema,
        providerOptions: providerMetadataSchema.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("content"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
                text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("media"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-data"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-url"),
                url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-id"),
                fileId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
                ]),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-data"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-url"),
                url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-file-id"),
                fileId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
                ]),
                providerOptions: providerMetadataSchema.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("custom"),
                providerOptions: providerMetadataSchema.optional()
            })
        ]))
    })
]);
var toolResultPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    output: outputSchema,
    providerOptions: providerMetadataSchema.optional()
});
var toolApprovalRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-approval-request"),
    approvalId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
var toolApprovalResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-approval-response"),
    approvalId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    approved: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
    reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var systemModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("system"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var userModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("user"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            imagePartSchema,
            filePartSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional()
});
var assistantModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("assistant"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            filePartSchema,
            reasoningPartSchema,
            toolCallPartSchema,
            toolResultPartSchema,
            toolApprovalRequestSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional()
});
var toolModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        toolResultPartSchema,
        toolApprovalResponseSchema
    ])),
    providerOptions: providerMetadataSchema.optional()
});
var modelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
]);
async function standardizePrompt(prompt) {
    if (prompt.prompt == null && prompt.messages == null) {
        throw new InvalidPromptError({
            prompt,
            message: "prompt or messages must be defined"
        });
    }
    if (prompt.prompt != null && prompt.messages != null) {
        throw new InvalidPromptError({
            prompt,
            message: "prompt and messages cannot be defined at the same time"
        });
    }
    if (prompt.system != null && typeof prompt.system !== "string" && !asArray(prompt.system).every((message)=>typeof message === "object" && message !== null && "role" in message && message.role === "system")) {
        throw new InvalidPromptError({
            prompt,
            message: "system must be a string, SystemModelMessage, or array of SystemModelMessage"
        });
    }
    let messages;
    if (prompt.prompt != null && typeof prompt.prompt === "string") {
        messages = [
            {
                role: "user",
                content: prompt.prompt
            }
        ];
    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
        messages = prompt.prompt;
    } else if (prompt.messages != null) {
        messages = prompt.messages;
    } else {
        throw new InvalidPromptError({
            prompt,
            message: "prompt or messages must be defined"
        });
    }
    if (messages.length === 0) {
        throw new InvalidPromptError({
            prompt,
            message: "messages must not be empty"
        });
    }
    const validationResult = await safeValidateTypes({
        value: messages,
        schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(modelMessageSchema)
    });
    if (!validationResult.success) {
        throw new InvalidPromptError({
            prompt,
            message: "The messages do not match the ModelMessage[] schema.",
            cause: validationResult.error
        });
    }
    return {
        messages,
        system: prompt.system
    };
}
function wrapGatewayError(error) {
    if (!GatewayAuthenticationError.isInstance(error)) return error;
    const isProductionEnv = (process == null ? void 0 : ("TURBOPACK compile-time value", "development")) === "production";
    const moreInfoURL = "https://ai-sdk.dev/unauthenticated-ai-gateway";
    if (isProductionEnv) {
        return new AISDKError({
            name: "GatewayError",
            message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`
        });
    }
    return Object.assign(new Error(`\x1B[1m\x1B[31mUnauthenticated request to AI Gateway.\x1B[0m

To authenticate, set the \x1B[33mAI_GATEWAY_API_KEY\x1B[0m environment variable with your API key.

Alternatively, you can use a provider module instead of the AI Gateway.

Learn more: \x1B[34m${moreInfoURL}\x1B[0m

`), {
        name: "GatewayAuthenticationError"
    });
}
function assembleOperationName({ operationId, telemetry }) {
    return {
        // standardized operation and resource name:
        "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
        "resource.name": telemetry == null ? void 0 : telemetry.functionId,
        // detailed, AI SDK specific data:
        "ai.operationId": operationId,
        "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
}
function getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {
    var _a142;
    return {
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // settings:
        ...Object.entries(settings).reduce((attributes, [key, value])=>{
            attributes[`ai.settings.${key}`] = value;
            return attributes;
        }, {}),
        // add metadata as attributes:
        ...Object.entries((_a142 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a142 : {}).reduce((attributes, [key, value])=>{
            attributes[`ai.telemetry.metadata.${key}`] = value;
            return attributes;
        }, {}),
        // request headers
        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{
            if (value !== void 0) {
                attributes[`ai.request.headers.${key}`] = value;
            }
            return attributes;
        }, {})
    };
}
var noopTracer = {
    startSpan () {
        return noopSpan;
    },
    startActiveSpan (name142, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
            return arg1(noopSpan);
        }
        if (typeof arg2 === "function") {
            return arg2(noopSpan);
        }
        if (typeof arg3 === "function") {
            return arg3(noopSpan);
        }
    }
};
var noopSpan = {
    spanContext () {
        return noopSpanContext;
    },
    setAttribute () {
        return this;
    },
    setAttributes () {
        return this;
    },
    addEvent () {
        return this;
    },
    addLink () {
        return this;
    },
    addLinks () {
        return this;
    },
    setStatus () {
        return this;
    },
    updateName () {
        return this;
    },
    end () {
        return this;
    },
    isRecording () {
        return false;
    },
    recordException () {
        return this;
    }
};
var noopSpanContext = {
    traceId: "",
    spanId: "",
    traceFlags: 0
};
function getTracer({ isEnabled = false, tracer } = {}) {
    if (!isEnabled) {
        return noopTracer;
    }
    if (tracer) {
        return tracer;
    }
    return trace.getTracer("ai");
}
async function recordSpan({ name: name142, tracer, attributes, fn, endWhenDone = true }) {
    return tracer.startActiveSpan(name142, {
        attributes: await attributes
    }, async (span)=>{
        try {
            const result = await fn(span);
            if (endWhenDone) {
                span.end();
            }
            return result;
        } catch (error) {
            try {
                recordErrorOnSpan(span, error);
            } finally{
                span.end();
            }
            throw error;
        }
    });
}
function recordErrorOnSpan(span, error) {
    if (error instanceof Error) {
        span.recordException({
            name: error.name,
            message: error.message,
            stack: error.stack
        });
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message
        });
    } else {
        span.setStatus({
            code: SpanStatusCode.ERROR
        });
    }
}
async function selectTelemetryAttributes({ telemetry, attributes }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
        return {};
    }
    const resultAttributes = {};
    for (const [key, value] of Object.entries(attributes)){
        if (value == null) {
            continue;
        }
        if (typeof value === "object" && "input" in value && typeof value.input === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
                continue;
            }
            const result = await value.input();
            if (result != null) {
                resultAttributes[key] = result;
            }
            continue;
        }
        if (typeof value === "object" && "output" in value && typeof value.output === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
                continue;
            }
            const result = await value.output();
            if (result != null) {
                resultAttributes[key] = result;
            }
            continue;
        }
        resultAttributes[key] = value;
    }
    return resultAttributes;
}
function stringifyForTelemetry(prompt) {
    return JSON.stringify(prompt.map((message)=>({
            ...message,
            content: typeof message.content === "string" ? message.content : message.content.map((part)=>part.type === "file" ? {
                    ...part,
                    data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
                } : part)
        })));
}
function asLanguageModelUsage(usage) {
    return {
        inputTokens: usage.inputTokens.total,
        inputTokenDetails: {
            noCacheTokens: usage.inputTokens.noCache,
            cacheReadTokens: usage.inputTokens.cacheRead,
            cacheWriteTokens: usage.inputTokens.cacheWrite
        },
        outputTokens: usage.outputTokens.total,
        outputTokenDetails: {
            textTokens: usage.outputTokens.text,
            reasoningTokens: usage.outputTokens.reasoning
        },
        totalTokens: addTokenCounts(usage.inputTokens.total, usage.outputTokens.total),
        raw: usage.raw,
        reasoningTokens: usage.outputTokens.reasoning,
        cachedInputTokens: usage.inputTokens.cacheRead
    };
}
function createNullLanguageModelUsage() {
    return {
        inputTokens: void 0,
        inputTokenDetails: {
            noCacheTokens: void 0,
            cacheReadTokens: void 0,
            cacheWriteTokens: void 0
        },
        outputTokens: void 0,
        outputTokenDetails: {
            textTokens: void 0,
            reasoningTokens: void 0
        },
        totalTokens: void 0,
        raw: void 0
    };
}
function addLanguageModelUsage(usage1, usage2) {
    var _a142, _b82, _c, _d, _e, _f, _g, _h, _i, _j;
    return {
        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
        inputTokenDetails: {
            noCacheTokens: addTokenCounts((_a142 = usage1.inputTokenDetails) == null ? void 0 : _a142.noCacheTokens, (_b82 = usage2.inputTokenDetails) == null ? void 0 : _b82.noCacheTokens),
            cacheReadTokens: addTokenCounts((_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens, (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens),
            cacheWriteTokens: addTokenCounts((_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens, (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens)
        },
        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
        outputTokenDetails: {
            textTokens: addTokenCounts((_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens, (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens),
            reasoningTokens: addTokenCounts((_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens, (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens)
        },
        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
        reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),
        cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)
    };
}
function addTokenCounts(tokenCount1, tokenCount2) {
    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
}
function mergeObjects(base, overrides) {
    if (base === void 0 && overrides === void 0) {
        return void 0;
    }
    if (base === void 0) {
        return overrides;
    }
    if (overrides === void 0) {
        return base;
    }
    const result = {
        ...base
    };
    for(const key in overrides){
        if (Object.prototype.hasOwnProperty.call(overrides, key)) {
            const overridesValue = overrides[key];
            if (overridesValue === void 0) continue;
            const baseValue = key in base ? base[key] : void 0;
            const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
            const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
            if (isSourceObject && isTargetObject) {
                result[key] = mergeObjects(baseValue, overridesValue);
            } else {
                result[key] = overridesValue;
            }
        }
    }
    return result;
}
function getRetryDelayInMs({ error, exponentialBackoffDelay }) {
    const headers = error.responseHeaders;
    if (!headers) return exponentialBackoffDelay;
    let ms;
    const retryAfterMs = headers["retry-after-ms"];
    if (retryAfterMs) {
        const timeoutMs = parseFloat(retryAfterMs);
        if (!Number.isNaN(timeoutMs)) {
            ms = timeoutMs;
        }
    }
    const retryAfter = headers["retry-after"];
    if (retryAfter && ms === void 0) {
        const timeoutSeconds = parseFloat(retryAfter);
        if (!Number.isNaN(timeoutSeconds)) {
            ms = timeoutSeconds * 1e3;
        } else {
            ms = Date.parse(retryAfter) - Date.now();
        }
    }
    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
        return ms;
    }
    return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2, abortSignal } = {})=>async (f)=>_retryWithExponentialBackoff(f, {
            maxRetries,
            delayInMs: initialDelayInMs,
            backoffFactor,
            abortSignal
        });
async function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor, abortSignal }, errors = []) {
    try {
        return await f();
    } catch (error) {
        if (isAbortError(error)) {
            throw error;
        }
        if (maxRetries === 0) {
            throw error;
        }
        const errorMessage = getErrorMessage2(error);
        const newErrors = [
            ...errors,
            error
        ];
        const tryNumber = newErrors.length;
        if (tryNumber > maxRetries) {
            throw new RetryError({
                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
                reason: "maxRetriesExceeded",
                errors: newErrors
            });
        }
        if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
            await delay(getRetryDelayInMs({
                error,
                exponentialBackoffDelay: delayInMs
            }), {
                abortSignal
            });
            return _retryWithExponentialBackoff(f, {
                maxRetries,
                delayInMs: backoffFactor * delayInMs,
                backoffFactor,
                abortSignal
            }, newErrors);
        }
        if (tryNumber === 1) {
            throw error;
        }
        throw new RetryError({
            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
            reason: "errorNotRetryable",
            errors: newErrors
        });
    }
}
function prepareRetries({ maxRetries, abortSignal }) {
    if (maxRetries != null) {
        if (!Number.isInteger(maxRetries)) {
            throw new InvalidArgumentError2({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be an integer"
            });
        }
        if (maxRetries < 0) {
            throw new InvalidArgumentError2({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be >= 0"
            });
        }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
        maxRetries: maxRetriesResult,
        retry: retryWithExponentialBackoffRespectingRetryHeaders({
            maxRetries: maxRetriesResult,
            abortSignal
        })
    };
}
function collectToolApprovals({ messages }) {
    const lastMessage = messages.at(-1);
    if ((lastMessage == null ? void 0 : lastMessage.role) != "tool") {
        return {
            approvedToolApprovals: [],
            deniedToolApprovals: []
        };
    }
    const toolCallsByToolCallId = {};
    for (const message of messages){
        if (message.role === "assistant" && typeof message.content !== "string") {
            const content = message.content;
            for (const part of content){
                if (part.type === "tool-call") {
                    toolCallsByToolCallId[part.toolCallId] = part;
                }
            }
        }
    }
    const toolApprovalRequestsByApprovalId = {};
    for (const message of messages){
        if (message.role === "assistant" && typeof message.content !== "string") {
            const content = message.content;
            for (const part of content){
                if (part.type === "tool-approval-request") {
                    toolApprovalRequestsByApprovalId[part.approvalId] = part;
                }
            }
        }
    }
    const toolResults = {};
    for (const part of lastMessage.content){
        if (part.type === "tool-result") {
            toolResults[part.toolCallId] = part;
        }
    }
    const approvedToolApprovals = [];
    const deniedToolApprovals = [];
    const approvalResponses = lastMessage.content.filter((part)=>part.type === "tool-approval-response");
    for (const approvalResponse of approvalResponses){
        const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];
        if (toolResults[approvalRequest.toolCallId] != null) {
            continue;
        }
        const approval = {
            approvalRequest,
            approvalResponse,
            toolCall: toolCallsByToolCallId[approvalRequest.toolCallId]
        };
        if (approvalResponse.approved) {
            approvedToolApprovals.push(approval);
        } else {
            deniedToolApprovals.push(approval);
        }
    }
    return {
        approvedToolApprovals,
        deniedToolApprovals
    };
}
async function executeToolCall({ toolCall, tools, tracer, telemetry, messages, abortSignal, experimental_context, onPreliminaryToolResult }) {
    const { toolName, toolCallId, input } = toolCall;
    const tool2 = tools == null ? void 0 : tools[toolName];
    if ((tool2 == null ? void 0 : tool2.execute) == null) {
        return void 0;
    }
    return recordSpan({
        name: "ai.toolCall",
        attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
                ...assembleOperationName({
                    operationId: "ai.toolCall",
                    telemetry
                }),
                "ai.toolCall.name": toolName,
                "ai.toolCall.id": toolCallId,
                "ai.toolCall.args": {
                    output: ()=>JSON.stringify(input)
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            let output;
            try {
                const stream = executeTool({
                    execute: tool2.execute.bind(tool2),
                    input,
                    options: {
                        toolCallId,
                        messages,
                        abortSignal,
                        experimental_context
                    }
                });
                for await (const part of stream){
                    if (part.type === "preliminary") {
                        onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({
                            ...toolCall,
                            type: "tool-result",
                            output: part.output,
                            preliminary: true
                        });
                    } else {
                        output = part.output;
                    }
                }
            } catch (error) {
                recordErrorOnSpan(span, error);
                return {
                    type: "tool-error",
                    toolCallId,
                    toolName,
                    input,
                    error,
                    dynamic: tool2.type === "dynamic",
                    ...toolCall.providerMetadata != null ? {
                        providerMetadata: toolCall.providerMetadata
                    } : {}
                };
            }
            try {
                span.setAttributes(await selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.toolCall.result": {
                            output: ()=>JSON.stringify(output)
                        }
                    }
                }));
            } catch (ignored) {}
            return {
                type: "tool-result",
                toolCallId,
                toolName,
                input,
                output,
                dynamic: tool2.type === "dynamic",
                ...toolCall.providerMetadata != null ? {
                    providerMetadata: toolCall.providerMetadata
                } : {}
            };
        }
    });
}
function extractTextContent(content) {
    const parts = content.filter((content2)=>content2.type === "text");
    if (parts.length === 0) {
        return void 0;
    }
    return parts.map((content2)=>content2.text).join("");
}
var DefaultGeneratedFile = class {
    constructor({ data, mediaType }){
        const isUint8Array = data instanceof Uint8Array;
        this.base64Data = isUint8Array ? void 0 : data;
        this.uint8ArrayData = isUint8Array ? data : void 0;
        this.mediaType = mediaType;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get base64() {
        if (this.base64Data == null) {
            this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
        }
        return this.base64Data;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get uint8Array() {
        if (this.uint8ArrayData == null) {
            this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
        }
        return this.uint8ArrayData;
    }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
    constructor(options){
        super(options);
        this.type = "file";
    }
};
async function isApprovalNeeded({ tool: tool2, toolCall, messages, experimental_context }) {
    if (tool2.needsApproval == null) {
        return false;
    }
    if (typeof tool2.needsApproval === "boolean") {
        return tool2.needsApproval;
    }
    return await tool2.needsApproval(toolCall.input, {
        toolCallId: toolCall.toolCallId,
        messages,
        experimental_context
    });
}
var output_exports = {};
__export(output_exports, {
    array: ()=>array,
    choice: ()=>choice,
    json: ()=>json,
    object: ()=>object,
    text: ()=>text
});
function fixJson(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
async function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = await safeParseJSON({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = await safeParseJSON({
        text: fixJson(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
var text = ()=>({
        responseFormat: Promise.resolve({
            type: "text"
        }),
        async parseCompleteOutput ({ text: text2 }) {
            return text2;
        },
        async parsePartialOutput ({ text: text2 }) {
            return {
                partial: text2
            };
        }
    });
var object = ({ schema: inputSchema, name: name142, description })=>{
    const schema = asSchema(inputSchema);
    return {
        responseFormat: resolve(schema.jsonSchema).then((jsonSchema2)=>({
                type: "json",
                schema: jsonSchema2,
                ...name142 != null && {
                    name: name142
                },
                ...description != null && {
                    description
                }
            })),
        async parseCompleteOutput ({ text: text2 }, context) {
            const parseResult = await safeParseJSON({
                text: text2
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const validationResult = await safeValidateTypes({
                value: parseResult.value,
                schema
            });
            if (!validationResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: response did not match schema.",
                    cause: validationResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return validationResult.value;
        },
        async parsePartialOutput ({ text: text2 }) {
            const result = await parsePartialJson(text2);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        return {
                            // Note: currently no validation of partial results:
                            partial: result.value
                        };
                    }
            }
        }
    };
};
var array = ({ element: inputElementSchema, name: name142, description })=>{
    const elementSchema = asSchema(inputElementSchema);
    return {
        // JSON schema that describes an array of elements:
        responseFormat: resolve(elementSchema.jsonSchema).then((jsonSchema2)=>{
            const { $schema, ...itemSchema } = jsonSchema2;
            return {
                type: "json",
                schema: {
                    $schema: "http://json-schema.org/draft-07/schema#",
                    type: "object",
                    properties: {
                        elements: {
                            type: "array",
                            items: itemSchema
                        }
                    },
                    required: [
                        "elements"
                    ],
                    additionalProperties: false
                },
                ...name142 != null && {
                    name: name142
                },
                ...description != null && {
                    description
                }
            };
        }),
        async parseCompleteOutput ({ text: text2 }, context) {
            const parseResult = await safeParseJSON({
                text: text2
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const outerValue = parseResult.value;
            if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: response did not match schema.",
                    cause: new TypeValidationError({
                        value: outerValue,
                        cause: "response must be an object with an elements array"
                    }),
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            for (const element of outerValue.elements){
                const validationResult = await safeValidateTypes({
                    value: element,
                    schema: elementSchema
                });
                if (!validationResult.success) {
                    throw new NoObjectGeneratedError({
                        message: "No object generated: response did not match schema.",
                        cause: validationResult.error,
                        text: text2,
                        response: context.response,
                        usage: context.usage,
                        finishReason: context.finishReason
                    });
                }
            }
            return outerValue.elements;
        },
        async parsePartialOutput ({ text: text2 }) {
            const result = await parsePartialJson(text2);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        const outerValue = result.value;
                        if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
                            return void 0;
                        }
                        const rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;
                        const parsedElements = [];
                        for (const rawElement of rawElements){
                            const validationResult = await safeValidateTypes({
                                value: rawElement,
                                schema: elementSchema
                            });
                            if (validationResult.success) {
                                parsedElements.push(validationResult.value);
                            }
                        }
                        return {
                            partial: parsedElements
                        };
                    }
            }
        }
    };
};
var choice = ({ options: choiceOptions, name: name142, description })=>{
    return {
        // JSON schema that describes an enumeration:
        responseFormat: Promise.resolve({
            type: "json",
            schema: {
                $schema: "http://json-schema.org/draft-07/schema#",
                type: "object",
                properties: {
                    result: {
                        type: "string",
                        enum: choiceOptions
                    }
                },
                required: [
                    "result"
                ],
                additionalProperties: false
            },
            ...name142 != null && {
                name: name142
            },
            ...description != null && {
                description
            }
        }),
        async parseCompleteOutput ({ text: text2 }, context) {
            const parseResult = await safeParseJSON({
                text: text2
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const outerValue = parseResult.value;
            if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result)) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: response did not match schema.",
                    cause: new TypeValidationError({
                        value: outerValue,
                        cause: "response must be an object that contains a choice value."
                    }),
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return outerValue.result;
        },
        async parsePartialOutput ({ text: text2 }) {
            const result = await parsePartialJson(text2);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        const outerValue = result.value;
                        if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string") {
                            return void 0;
                        }
                        const potentialMatches = choiceOptions.filter((choiceOption)=>choiceOption.startsWith(outerValue.result));
                        if (result.state === "successful-parse") {
                            return potentialMatches.includes(outerValue.result) ? {
                                partial: outerValue.result
                            } : void 0;
                        } else {
                            return potentialMatches.length === 1 ? {
                                partial: potentialMatches[0]
                            } : void 0;
                        }
                    }
            }
        }
    };
};
var json = ({ name: name142, description } = {})=>{
    return {
        responseFormat: Promise.resolve({
            type: "json",
            ...name142 != null && {
                name: name142
            },
            ...description != null && {
                description
            }
        }),
        async parseCompleteOutput ({ text: text2 }, context) {
            const parseResult = await safeParseJSON({
                text: text2
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return parseResult.value;
        },
        async parsePartialOutput ({ text: text2 }) {
            const result = await parsePartialJson(text2);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        return result.value === void 0 ? void 0 : {
                            partial: result.value
                        };
                    }
            }
        }
    };
};
async function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {
    var _a142;
    try {
        if (tools == null) {
            if (toolCall.providerExecuted && toolCall.dynamic) {
                return await parseProviderExecutedDynamicToolCall(toolCall);
            }
            throw new NoSuchToolError({
                toolName: toolCall.toolName
            });
        }
        try {
            return await doParseToolCall({
                toolCall,
                tools
            });
        } catch (error) {
            if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {
                throw error;
            }
            let repairedToolCall = null;
            try {
                repairedToolCall = await repairToolCall({
                    toolCall,
                    tools,
                    inputSchema: async ({ toolName })=>{
                        const { inputSchema } = tools[toolName];
                        return await asSchema(inputSchema).jsonSchema;
                    },
                    system,
                    messages,
                    error
                });
            } catch (repairError) {
                throw new ToolCallRepairError({
                    cause: repairError,
                    originalError: error
                });
            }
            if (repairedToolCall == null) {
                throw error;
            }
            return await doParseToolCall({
                toolCall: repairedToolCall,
                tools
            });
        }
    } catch (error) {
        const parsedInput = await safeParseJSON({
            text: toolCall.input
        });
        const input = parsedInput.success ? parsedInput.value : toolCall.input;
        return {
            type: "tool-call",
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            input,
            dynamic: true,
            invalid: true,
            error,
            title: (_a142 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a142.title,
            providerExecuted: toolCall.providerExecuted,
            providerMetadata: toolCall.providerMetadata
        };
    }
}
async function parseProviderExecutedDynamicToolCall(toolCall) {
    const parseResult = toolCall.input.trim() === "" ? {
        success: true,
        value: {}
    } : await safeParseJSON({
        text: toolCall.input
    });
    if (parseResult.success === false) {
        throw new InvalidToolInputError({
            toolName: toolCall.toolName,
            toolInput: toolCall.input,
            cause: parseResult.error
        });
    }
    return {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName: toolCall.toolName,
        input: parseResult.value,
        providerExecuted: true,
        dynamic: true,
        providerMetadata: toolCall.providerMetadata
    };
}
async function doParseToolCall({ toolCall, tools }) {
    const toolName = toolCall.toolName;
    const tool2 = tools[toolName];
    if (tool2 == null) {
        if (toolCall.providerExecuted && toolCall.dynamic) {
            return await parseProviderExecutedDynamicToolCall(toolCall);
        }
        throw new NoSuchToolError({
            toolName: toolCall.toolName,
            availableTools: Object.keys(tools)
        });
    }
    const schema = asSchema(tool2.inputSchema);
    const parseResult = toolCall.input.trim() === "" ? await safeValidateTypes({
        value: {},
        schema
    }) : await safeParseJSON({
        text: toolCall.input,
        schema
    });
    if (parseResult.success === false) {
        throw new InvalidToolInputError({
            toolName,
            toolInput: toolCall.input,
            cause: parseResult.error
        });
    }
    return tool2.type === "dynamic" ? {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName: toolCall.toolName,
        input: parseResult.value,
        providerExecuted: toolCall.providerExecuted,
        providerMetadata: toolCall.providerMetadata,
        dynamic: true,
        title: tool2.title
    } : {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName,
        input: parseResult.value,
        providerExecuted: toolCall.providerExecuted,
        providerMetadata: toolCall.providerMetadata,
        title: tool2.title
    };
}
var DefaultStepResult = class {
    constructor({ content, finishReason, rawFinishReason, usage, warnings, request, response, providerMetadata }){
        this.content = content;
        this.finishReason = finishReason;
        this.rawFinishReason = rawFinishReason;
        this.usage = usage;
        this.warnings = warnings;
        this.request = request;
        this.response = response;
        this.providerMetadata = providerMetadata;
    }
    get text() {
        return this.content.filter((part)=>part.type === "text").map((part)=>part.text).join("");
    }
    get reasoning() {
        return this.content.filter((part)=>part.type === "reasoning");
    }
    get reasoningText() {
        return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part)=>part.text).join("");
    }
    get files() {
        return this.content.filter((part)=>part.type === "file").map((part)=>part.file);
    }
    get sources() {
        return this.content.filter((part)=>part.type === "source");
    }
    get toolCalls() {
        return this.content.filter((part)=>part.type === "tool-call");
    }
    get staticToolCalls() {
        return this.toolCalls.filter((toolCall)=>toolCall.dynamic !== true);
    }
    get dynamicToolCalls() {
        return this.toolCalls.filter((toolCall)=>toolCall.dynamic === true);
    }
    get toolResults() {
        return this.content.filter((part)=>part.type === "tool-result");
    }
    get staticToolResults() {
        return this.toolResults.filter((toolResult)=>toolResult.dynamic !== true);
    }
    get dynamicToolResults() {
        return this.toolResults.filter((toolResult)=>toolResult.dynamic === true);
    }
};
function stepCountIs(stepCount) {
    return ({ steps })=>steps.length === stepCount;
}
async function isStopConditionMet({ stopConditions, steps }) {
    return (await Promise.all(stopConditions.map((condition)=>condition({
            steps
        })))).some((result)=>result);
}
async function toResponseMessages({ content: inputContent, tools }) {
    const responseMessages = [];
    const content = [];
    for (const part of inputContent){
        if (part.type === "source" || (part.type === "tool-result" || part.type === "tool-error") && !part.providerExecuted || part.type === "text" && part.text.length === 0) {
            continue;
        }
        switch(part.type){
            case "text":
                content.push({
                    type: "text",
                    text: part.text,
                    providerOptions: part.providerMetadata
                });
                break;
            case "reasoning":
                content.push({
                    type: "reasoning",
                    text: part.text,
                    providerOptions: part.providerMetadata
                });
                break;
            case "file":
                content.push({
                    type: "file",
                    data: part.file.base64,
                    mediaType: part.file.mediaType,
                    providerOptions: part.providerMetadata
                });
                break;
            case "tool-call":
                content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName: part.toolName,
                    input: part.input,
                    providerExecuted: part.providerExecuted,
                    providerOptions: part.providerMetadata
                });
                break;
            case "tool-result":
                {
                    const output = await createToolModelOutput({
                        toolCallId: part.toolCallId,
                        input: part.input,
                        tool: tools == null ? void 0 : tools[part.toolName],
                        output: part.output,
                        errorMode: "none"
                    });
                    content.push({
                        type: "tool-result",
                        toolCallId: part.toolCallId,
                        toolName: part.toolName,
                        output,
                        providerOptions: part.providerMetadata
                    });
                    break;
                }
            case "tool-error":
                {
                    const output = await createToolModelOutput({
                        toolCallId: part.toolCallId,
                        input: part.input,
                        tool: tools == null ? void 0 : tools[part.toolName],
                        output: part.error,
                        errorMode: "json"
                    });
                    content.push({
                        type: "tool-result",
                        toolCallId: part.toolCallId,
                        toolName: part.toolName,
                        output,
                        providerOptions: part.providerMetadata
                    });
                    break;
                }
            case "tool-approval-request":
                content.push({
                    type: "tool-approval-request",
                    approvalId: part.approvalId,
                    toolCallId: part.toolCall.toolCallId
                });
                break;
        }
    }
    if (content.length > 0) {
        responseMessages.push({
            role: "assistant",
            content
        });
    }
    const toolResultContent = [];
    for (const part of inputContent){
        if (!(part.type === "tool-result" || part.type === "tool-error") || part.providerExecuted) {
            continue;
        }
        const output = await createToolModelOutput({
            toolCallId: part.toolCallId,
            input: part.input,
            tool: tools == null ? void 0 : tools[part.toolName],
            output: part.type === "tool-result" ? part.output : part.error,
            errorMode: part.type === "tool-error" ? "text" : "none"
        });
        toolResultContent.push({
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output,
            ...part.providerMetadata != null ? {
                providerOptions: part.providerMetadata
            } : {}
        });
    }
    if (toolResultContent.length > 0) {
        responseMessages.push({
            role: "tool",
            content: toolResultContent
        });
    }
    return responseMessages;
}
var originalGenerateId = createIdGenerator({
    prefix: "aitxt",
    size: 24
});
async function generateText({ model: modelArg, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_prepareStep, prepareStep = experimental_prepareStep, experimental_repairToolCall: repairToolCall, experimental_download: download2, experimental_context, _internal: { generateId: generateId2 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, onFinish, ...settings }) {
    const model = resolveLanguageModel(modelArg);
    const stopConditions = asArray(stopWhen);
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg,
        abortSignal
    });
    const callSettings = prepareCallSettings(settings);
    const headersWithUserAgent = withUserAgentSuffix(headers != null ? headers : {}, `ai/${VERSION3}`);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers: headersWithUserAgent,
        settings: {
            ...callSettings,
            maxRetries
        }
    });
    const initialPrompt = await standardizePrompt({
        system,
        prompt,
        messages
    });
    const tracer = getTracer(telemetry);
    try {
        return await recordSpan({
            name: "ai.generateText",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.generateText",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // model:
                    "ai.model.provider": model.provider,
                    "ai.model.id": model.modelId,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    }
                }
            }),
            tracer,
            fn: async (span)=>{
                var _a142, _b82, _c, _d, _e, _f, _g, _h;
                const initialMessages = initialPrompt.messages;
                const responseMessages = [];
                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({
                    messages: initialMessages
                });
                if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {
                    const toolOutputs = await executeTools({
                        toolCalls: approvedToolApprovals.map((toolApproval)=>toolApproval.toolCall),
                        tools,
                        tracer,
                        telemetry,
                        messages: initialMessages,
                        abortSignal,
                        experimental_context
                    });
                    const toolContent = [];
                    for (const output2 of toolOutputs){
                        const modelOutput = await createToolModelOutput({
                            toolCallId: output2.toolCallId,
                            input: output2.input,
                            tool: tools == null ? void 0 : tools[output2.toolName],
                            output: output2.type === "tool-result" ? output2.output : output2.error,
                            errorMode: output2.type === "tool-error" ? "json" : "none"
                        });
                        toolContent.push({
                            type: "tool-result",
                            toolCallId: output2.toolCallId,
                            toolName: output2.toolName,
                            output: modelOutput
                        });
                    }
                    for (const toolApproval of deniedToolApprovals){
                        toolContent.push({
                            type: "tool-result",
                            toolCallId: toolApproval.toolCall.toolCallId,
                            toolName: toolApproval.toolCall.toolName,
                            output: {
                                type: "execution-denied",
                                reason: toolApproval.approvalResponse.reason
                            }
                        });
                    }
                    responseMessages.push({
                        role: "tool",
                        content: toolContent
                    });
                }
                const callSettings2 = prepareCallSettings(settings);
                let currentModelResponse;
                let clientToolCalls = [];
                let clientToolOutputs = [];
                const steps = [];
                const pendingDeferredToolCalls = /* @__PURE__ */ new Map();
                do {
                    const stepInputMessages = [
                        ...initialMessages,
                        ...responseMessages
                    ];
                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
                        model,
                        steps,
                        stepNumber: steps.length,
                        messages: stepInputMessages,
                        experimental_context
                    }));
                    const stepModel = resolveLanguageModel((_a142 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a142 : model);
                    const promptMessages = await convertToLanguageModelPrompt({
                        prompt: {
                            system: (_b82 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b82 : initialPrompt.system,
                            messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
                        },
                        supportedUrls: await stepModel.supportedUrls,
                        download: download2
                    });
                    experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;
                    const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
                        tools,
                        toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,
                        activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools
                    });
                    currentModelResponse = await retry(()=>{
                        var _a152;
                        return recordSpan({
                            name: "ai.generateText.doGenerate",
                            attributes: selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName({
                                        operationId: "ai.generateText.doGenerate",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // model:
                                    "ai.model.provider": stepModel.provider,
                                    "ai.model.id": stepModel.modelId,
                                    // prompt:
                                    "ai.prompt.messages": {
                                        input: ()=>stringifyForTelemetry(promptMessages)
                                    },
                                    "ai.prompt.tools": {
                                        // convert the language model level tools:
                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))
                                    },
                                    "ai.prompt.toolChoice": {
                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                                    },
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.system": stepModel.provider,
                                    "gen_ai.request.model": stepModel.modelId,
                                    "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                                    "gen_ai.request.max_tokens": settings.maxOutputTokens,
                                    "gen_ai.request.presence_penalty": settings.presencePenalty,
                                    "gen_ai.request.stop_sequences": settings.stopSequences,
                                    "gen_ai.request.temperature": (_a152 = settings.temperature) != null ? _a152 : void 0,
                                    "gen_ai.request.top_k": settings.topK,
                                    "gen_ai.request.top_p": settings.topP
                                }
                            }),
                            tracer,
                            fn: async (span2)=>{
                                var _a162, _b222, _c2, _d2, _e2, _f2, _g2, _h2;
                                const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);
                                const result = await stepModel.doGenerate({
                                    ...callSettings2,
                                    tools: stepTools,
                                    toolChoice: stepToolChoice,
                                    responseFormat: await (output == null ? void 0 : output.responseFormat),
                                    prompt: promptMessages,
                                    providerOptions: stepProviderOptions,
                                    abortSignal,
                                    headers: headersWithUserAgent
                                });
                                const responseData = {
                                    id: (_b222 = (_a162 = result.response) == null ? void 0 : _a162.id) != null ? _b222 : generateId2(),
                                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                                    modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,
                                    headers: (_g2 = result.response) == null ? void 0 : _g2.headers,
                                    body: (_h2 = result.response) == null ? void 0 : _h2.body
                                };
                                span2.setAttributes(await selectTelemetryAttributes({
                                    telemetry,
                                    attributes: {
                                        "ai.response.finishReason": result.finishReason.unified,
                                        "ai.response.text": {
                                            output: ()=>extractTextContent(result.content)
                                        },
                                        "ai.response.toolCalls": {
                                            output: ()=>{
                                                const toolCalls = asToolCalls(result.content);
                                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                                            }
                                        },
                                        "ai.response.id": responseData.id,
                                        "ai.response.model": responseData.modelId,
                                        "ai.response.timestamp": responseData.timestamp.toISOString(),
                                        "ai.response.providerMetadata": JSON.stringify(result.providerMetadata),
                                        // TODO rename telemetry attributes to inputTokens and outputTokens
                                        "ai.usage.promptTokens": result.usage.inputTokens.total,
                                        "ai.usage.completionTokens": result.usage.outputTokens.total,
                                        // standardized gen-ai llm span attributes:
                                        "gen_ai.response.finish_reasons": [
                                            result.finishReason.unified
                                        ],
                                        "gen_ai.response.id": responseData.id,
                                        "gen_ai.response.model": responseData.modelId,
                                        "gen_ai.usage.input_tokens": result.usage.inputTokens.total,
                                        "gen_ai.usage.output_tokens": result.usage.outputTokens.total
                                    }
                                }));
                                return {
                                    ...result,
                                    response: responseData
                                };
                            }
                        });
                    });
                    const stepToolCalls = await Promise.all(currentModelResponse.content.filter((part)=>part.type === "tool-call").map((toolCall)=>parseToolCall({
                            toolCall,
                            tools,
                            repairToolCall,
                            system,
                            messages: stepInputMessages
                        })));
                    const toolApprovalRequests = {};
                    for (const toolCall of stepToolCalls){
                        if (toolCall.invalid) {
                            continue;
                        }
                        const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                        if (tool2 == null) {
                            continue;
                        }
                        if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {
                            await tool2.onInputAvailable({
                                input: toolCall.input,
                                toolCallId: toolCall.toolCallId,
                                messages: stepInputMessages,
                                abortSignal,
                                experimental_context
                            });
                        }
                        if (await isApprovalNeeded({
                            tool: tool2,
                            toolCall,
                            messages: stepInputMessages,
                            experimental_context
                        })) {
                            toolApprovalRequests[toolCall.toolCallId] = {
                                type: "tool-approval-request",
                                approvalId: generateId2(),
                                toolCall
                            };
                        }
                    }
                    const invalidToolCalls = stepToolCalls.filter((toolCall)=>toolCall.invalid && toolCall.dynamic);
                    clientToolOutputs = [];
                    for (const toolCall of invalidToolCalls){
                        clientToolOutputs.push({
                            type: "tool-error",
                            toolCallId: toolCall.toolCallId,
                            toolName: toolCall.toolName,
                            input: toolCall.input,
                            error: getErrorMessage2(toolCall.error),
                            dynamic: true
                        });
                    }
                    clientToolCalls = stepToolCalls.filter((toolCall)=>!toolCall.providerExecuted);
                    if (tools != null) {
                        clientToolOutputs.push(...await executeTools({
                            toolCalls: clientToolCalls.filter((toolCall)=>!toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null),
                            tools,
                            tracer,
                            telemetry,
                            messages: stepInputMessages,
                            abortSignal,
                            experimental_context
                        }));
                    }
                    for (const toolCall of stepToolCalls){
                        if (!toolCall.providerExecuted) continue;
                        const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                        if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                            const hasResultInResponse = currentModelResponse.content.some((part)=>part.type === "tool-result" && part.toolCallId === toolCall.toolCallId);
                            if (!hasResultInResponse) {
                                pendingDeferredToolCalls.set(toolCall.toolCallId, {
                                    toolName: toolCall.toolName
                                });
                            }
                        }
                    }
                    for (const part of currentModelResponse.content){
                        if (part.type === "tool-result") {
                            pendingDeferredToolCalls.delete(part.toolCallId);
                        }
                    }
                    const stepContent = asContent({
                        content: currentModelResponse.content,
                        toolCalls: stepToolCalls,
                        toolOutputs: clientToolOutputs,
                        toolApprovalRequests: Object.values(toolApprovalRequests),
                        tools
                    });
                    responseMessages.push(...await toResponseMessages({
                        content: stepContent,
                        tools
                    }));
                    const currentStepResult = new DefaultStepResult({
                        content: stepContent,
                        finishReason: currentModelResponse.finishReason.unified,
                        rawFinishReason: currentModelResponse.finishReason.raw,
                        usage: asLanguageModelUsage(currentModelResponse.usage),
                        warnings: currentModelResponse.warnings,
                        providerMetadata: currentModelResponse.providerMetadata,
                        request: (_g = currentModelResponse.request) != null ? _g : {},
                        response: {
                            ...currentModelResponse.response,
                            // deep clone msgs to avoid mutating past messages in multi-step:
                            messages: structuredClone(responseMessages)
                        }
                    });
                    logWarnings({
                        warnings: (_h = currentModelResponse.warnings) != null ? _h : [],
                        provider: stepModel.provider,
                        model: stepModel.modelId
                    });
                    steps.push(currentStepResult);
                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
                }while (// Continue if:
                // 1. There are client tool calls that have all been executed, OR
                // 2. There are pending deferred results from provider-executed tools
                (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:
                !await isStopConditionMet({
                    stopConditions,
                    steps
                }))
                span.setAttributes(await selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.response.finishReason": currentModelResponse.finishReason.unified,
                        "ai.response.text": {
                            output: ()=>extractTextContent(currentModelResponse.content)
                        },
                        "ai.response.toolCalls": {
                            output: ()=>{
                                const toolCalls = asToolCalls(currentModelResponse.content);
                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                            }
                        },
                        "ai.response.providerMetadata": JSON.stringify(currentModelResponse.providerMetadata),
                        // TODO rename telemetry attributes to inputTokens and outputTokens
                        "ai.usage.promptTokens": currentModelResponse.usage.inputTokens.total,
                        "ai.usage.completionTokens": currentModelResponse.usage.outputTokens.total
                    }
                }));
                const lastStep = steps[steps.length - 1];
                const totalUsage = steps.reduce((totalUsage2, step)=>{
                    return addLanguageModelUsage(totalUsage2, step.usage);
                }, {
                    inputTokens: void 0,
                    outputTokens: void 0,
                    totalTokens: void 0,
                    reasoningTokens: void 0,
                    cachedInputTokens: void 0
                });
                await (onFinish == null ? void 0 : onFinish({
                    finishReason: lastStep.finishReason,
                    rawFinishReason: lastStep.rawFinishReason,
                    usage: lastStep.usage,
                    content: lastStep.content,
                    text: lastStep.text,
                    reasoningText: lastStep.reasoningText,
                    reasoning: lastStep.reasoning,
                    files: lastStep.files,
                    sources: lastStep.sources,
                    toolCalls: lastStep.toolCalls,
                    staticToolCalls: lastStep.staticToolCalls,
                    dynamicToolCalls: lastStep.dynamicToolCalls,
                    toolResults: lastStep.toolResults,
                    staticToolResults: lastStep.staticToolResults,
                    dynamicToolResults: lastStep.dynamicToolResults,
                    request: lastStep.request,
                    response: lastStep.response,
                    warnings: lastStep.warnings,
                    providerMetadata: lastStep.providerMetadata,
                    steps,
                    totalUsage,
                    experimental_context
                }));
                let resolvedOutput;
                if (lastStep.finishReason === "stop") {
                    const outputSpecification = output != null ? output : text();
                    resolvedOutput = await outputSpecification.parseCompleteOutput({
                        text: lastStep.text
                    }, {
                        response: lastStep.response,
                        usage: lastStep.usage,
                        finishReason: lastStep.finishReason
                    });
                }
                return new DefaultGenerateTextResult({
                    steps,
                    totalUsage,
                    output: resolvedOutput
                });
            }
        });
    } catch (error) {
        throw wrapGatewayError(error);
    }
}
async function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal, experimental_context }) {
    const toolOutputs = await Promise.all(toolCalls.map(async (toolCall)=>executeToolCall({
            toolCall,
            tools,
            tracer,
            telemetry,
            messages,
            abortSignal,
            experimental_context
        })));
    return toolOutputs.filter((output)=>output != null);
}
var DefaultGenerateTextResult = class {
    constructor(options){
        this.steps = options.steps;
        this._output = options.output;
        this.totalUsage = options.totalUsage;
    }
    get finalStep() {
        return this.steps[this.steps.length - 1];
    }
    get content() {
        return this.finalStep.content;
    }
    get text() {
        return this.finalStep.text;
    }
    get files() {
        return this.finalStep.files;
    }
    get reasoningText() {
        return this.finalStep.reasoningText;
    }
    get reasoning() {
        return this.finalStep.reasoning;
    }
    get toolCalls() {
        return this.finalStep.toolCalls;
    }
    get staticToolCalls() {
        return this.finalStep.staticToolCalls;
    }
    get dynamicToolCalls() {
        return this.finalStep.dynamicToolCalls;
    }
    get toolResults() {
        return this.finalStep.toolResults;
    }
    get staticToolResults() {
        return this.finalStep.staticToolResults;
    }
    get dynamicToolResults() {
        return this.finalStep.dynamicToolResults;
    }
    get sources() {
        return this.finalStep.sources;
    }
    get finishReason() {
        return this.finalStep.finishReason;
    }
    get rawFinishReason() {
        return this.finalStep.rawFinishReason;
    }
    get warnings() {
        return this.finalStep.warnings;
    }
    get providerMetadata() {
        return this.finalStep.providerMetadata;
    }
    get response() {
        return this.finalStep.response;
    }
    get request() {
        return this.finalStep.request;
    }
    get usage() {
        return this.finalStep.usage;
    }
    get experimental_output() {
        return this.output;
    }
    get output() {
        if (this._output == null) {
            throw new NoOutputGeneratedError();
        }
        return this._output;
    }
};
function asToolCalls(content) {
    const parts = content.filter((part)=>part.type === "tool-call");
    if (parts.length === 0) {
        return void 0;
    }
    return parts.map((toolCall)=>({
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            input: toolCall.input
        }));
}
function asContent({ content, toolCalls, toolOutputs, toolApprovalRequests, tools }) {
    const contentParts = [];
    for (const part of content){
        switch(part.type){
            case "text":
            case "reasoning":
            case "source":
                contentParts.push(part);
                break;
            case "file":
                {
                    contentParts.push({
                        type: "file",
                        file: new DefaultGeneratedFile(part),
                        ...part.providerMetadata != null ? {
                            providerMetadata: part.providerMetadata
                        } : {}
                    });
                    break;
                }
            case "tool-call":
                {
                    contentParts.push(toolCalls.find((toolCall)=>toolCall.toolCallId === part.toolCallId));
                    break;
                }
            case "tool-result":
                {
                    const toolCall = toolCalls.find((toolCall2)=>toolCall2.toolCallId === part.toolCallId);
                    if (toolCall == null) {
                        const tool2 = tools == null ? void 0 : tools[part.toolName];
                        const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults;
                        if (!supportsDeferredResults) {
                            throw new Error(`Tool call ${part.toolCallId} not found.`);
                        }
                        if (part.isError) {
                            contentParts.push({
                                type: "tool-error",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                input: void 0,
                                error: part.result,
                                providerExecuted: true,
                                dynamic: part.dynamic
                            });
                        } else {
                            contentParts.push({
                                type: "tool-result",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                input: void 0,
                                output: part.result,
                                providerExecuted: true,
                                dynamic: part.dynamic
                            });
                        }
                        break;
                    }
                    if (part.isError) {
                        contentParts.push({
                            type: "tool-error",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            input: toolCall.input,
                            error: part.result,
                            providerExecuted: true,
                            dynamic: toolCall.dynamic
                        });
                    } else {
                        contentParts.push({
                            type: "tool-result",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            input: toolCall.input,
                            output: part.result,
                            providerExecuted: true,
                            dynamic: toolCall.dynamic
                        });
                    }
                    break;
                }
        }
    }
    return [
        ...contentParts,
        ...toolOutputs,
        ...toolApprovalRequests
    ];
}
function prepareHeaders(headers, defaultHeaders) {
    const responseHeaders = new Headers(headers != null ? headers : {});
    for (const [key, value] of Object.entries(defaultHeaders)){
        if (!responseHeaders.has(key)) {
            responseHeaders.set(key, value);
        }
    }
    return responseHeaders;
}
function createTextStreamResponse({ status, statusText, headers, textStream }) {
    return new Response(textStream.pipeThrough(new TextEncoderStream()), {
        status: status != null ? status : 200,
        statusText,
        headers: prepareHeaders(headers, {
            "content-type": "text/plain; charset=utf-8"
        })
    });
}
function writeToServerResponse({ response, status, statusText, headers, stream }) {
    const statusCode = status != null ? status : 200;
    if (statusText !== void 0) {
        response.writeHead(statusCode, statusText, headers);
    } else {
        response.writeHead(statusCode, headers);
    }
    const reader = stream.getReader();
    const read = async ()=>{
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) break;
                const canContinue = response.write(value);
                if (!canContinue) {
                    await new Promise((resolve3)=>{
                        response.once("drain", resolve3);
                    });
                }
            }
        } catch (error) {
            throw error;
        } finally{
            response.end();
        }
    };
    read();
}
function pipeTextStreamToResponse({ response, status, statusText, headers, textStream }) {
    writeToServerResponse({
        response,
        status,
        statusText,
        headers: Object.fromEntries(prepareHeaders(headers, {
            "content-type": "text/plain; charset=utf-8"
        }).entries()),
        stream: textStream.pipeThrough(new TextEncoderStream())
    });
}
var JsonToSseTransformStream = class extends TransformStream {
    constructor(){
        super({
            transform (part, controller) {
                controller.enqueue(`data: ${JSON.stringify(part)}

`);
            },
            flush (controller) {
                controller.enqueue("data: [DONE]\n\n");
            }
        });
    }
};
var UI_MESSAGE_STREAM_HEADERS = {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-vercel-ai-ui-message-stream": "v1",
    "x-accel-buffering": "no"
};
function createUIMessageStreamResponse({ status, statusText, headers, stream, consumeSseStream }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
        const [stream1, stream2] = sseStream.tee();
        sseStream = stream1;
        consumeSseStream({
            stream: stream2
        });
    }
    return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
        status,
        statusText,
        headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
    });
}
function getResponseUIMessageId({ originalMessages, responseMessageId }) {
    if (originalMessages == null) {
        return void 0;
    }
    const lastMessage = originalMessages[originalMessages.length - 1];
    return (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
}
function isDataUIMessageChunk(chunk) {
    return chunk.type.startsWith("data-");
}
function isStaticToolUIPart(part) {
    return part.type.startsWith("tool-");
}
function isDynamicToolUIPart(part) {
    return part.type === "dynamic-tool";
}
function isToolUIPart(part) {
    return isStaticToolUIPart(part) || isDynamicToolUIPart(part);
}
function getStaticToolName(part) {
    return part.type.split("-").slice(1).join("-");
}
function createStreamingUIMessageState({ lastMessage, messageId }) {
    return {
        message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
            id: messageId,
            metadata: void 0,
            role: "assistant",
            parts: []
        },
        activeTextParts: {},
        activeReasoningParts: {},
        partialToolCalls: {}
    };
}
function processUIMessageStream({ stream, messageMetadataSchema, dataPartSchemas, runUpdateMessageJob, onError, onToolCall, onData }) {
    return stream.pipeThrough(new TransformStream({
        async transform (chunk, controller) {
            await runUpdateMessageJob(async ({ state, write })=>{
                var _a142, _b82, _c, _d;
                function getToolInvocation(toolCallId) {
                    const toolInvocations = state.message.parts.filter(isToolUIPart);
                    const toolInvocation = toolInvocations.find((invocation)=>invocation.toolCallId === toolCallId);
                    if (toolInvocation == null) {
                        throw new Error(`no tool invocation found for tool call ${toolCallId}`);
                    }
                    return toolInvocation;
                }
                function updateToolPart(options) {
                    var _a152;
                    const part = state.message.parts.find((part2)=>isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId);
                    const anyOptions = options;
                    const anyPart = part;
                    if (part != null) {
                        part.state = options.state;
                        anyPart.input = anyOptions.input;
                        anyPart.output = anyOptions.output;
                        anyPart.errorText = anyOptions.errorText;
                        anyPart.rawInput = anyOptions.rawInput;
                        anyPart.preliminary = anyOptions.preliminary;
                        if (options.title !== void 0) {
                            anyPart.title = options.title;
                        }
                        anyPart.providerExecuted = (_a152 = anyOptions.providerExecuted) != null ? _a152 : part.providerExecuted;
                        if (anyOptions.providerMetadata != null && part.state === "input-available") {
                            part.callProviderMetadata = anyOptions.providerMetadata;
                        }
                    } else {
                        state.message.parts.push({
                            type: `tool-${options.toolName}`,
                            toolCallId: options.toolCallId,
                            state: options.state,
                            title: options.title,
                            input: anyOptions.input,
                            output: anyOptions.output,
                            rawInput: anyOptions.rawInput,
                            errorText: anyOptions.errorText,
                            providerExecuted: anyOptions.providerExecuted,
                            preliminary: anyOptions.preliminary,
                            ...anyOptions.providerMetadata != null ? {
                                callProviderMetadata: anyOptions.providerMetadata
                            } : {}
                        });
                    }
                }
                function updateDynamicToolPart(options) {
                    var _a152, _b222;
                    const part = state.message.parts.find((part2)=>part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId);
                    const anyOptions = options;
                    const anyPart = part;
                    if (part != null) {
                        part.state = options.state;
                        anyPart.toolName = options.toolName;
                        anyPart.input = anyOptions.input;
                        anyPart.output = anyOptions.output;
                        anyPart.errorText = anyOptions.errorText;
                        anyPart.rawInput = (_a152 = anyOptions.rawInput) != null ? _a152 : anyPart.rawInput;
                        anyPart.preliminary = anyOptions.preliminary;
                        if (options.title !== void 0) {
                            anyPart.title = options.title;
                        }
                        anyPart.providerExecuted = (_b222 = anyOptions.providerExecuted) != null ? _b222 : part.providerExecuted;
                        if (anyOptions.providerMetadata != null && part.state === "input-available") {
                            part.callProviderMetadata = anyOptions.providerMetadata;
                        }
                    } else {
                        state.message.parts.push({
                            type: "dynamic-tool",
                            toolName: options.toolName,
                            toolCallId: options.toolCallId,
                            state: options.state,
                            input: anyOptions.input,
                            output: anyOptions.output,
                            errorText: anyOptions.errorText,
                            preliminary: anyOptions.preliminary,
                            providerExecuted: anyOptions.providerExecuted,
                            title: options.title,
                            ...anyOptions.providerMetadata != null ? {
                                callProviderMetadata: anyOptions.providerMetadata
                            } : {}
                        });
                    }
                }
                async function updateMessageMetadata(metadata) {
                    if (metadata != null) {
                        const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
                        if (messageMetadataSchema != null) {
                            await validateTypes({
                                value: mergedMetadata,
                                schema: messageMetadataSchema
                            });
                        }
                        state.message.metadata = mergedMetadata;
                    }
                }
                switch(chunk.type){
                    case "text-start":
                        {
                            const textPart = {
                                type: "text",
                                text: "",
                                providerMetadata: chunk.providerMetadata,
                                state: "streaming"
                            };
                            state.activeTextParts[chunk.id] = textPart;
                            state.message.parts.push(textPart);
                            write();
                            break;
                        }
                    case "text-delta":
                        {
                            const textPart = state.activeTextParts[chunk.id];
                            textPart.text += chunk.delta;
                            textPart.providerMetadata = (_a142 = chunk.providerMetadata) != null ? _a142 : textPart.providerMetadata;
                            write();
                            break;
                        }
                    case "text-end":
                        {
                            const textPart = state.activeTextParts[chunk.id];
                            textPart.state = "done";
                            textPart.providerMetadata = (_b82 = chunk.providerMetadata) != null ? _b82 : textPart.providerMetadata;
                            delete state.activeTextParts[chunk.id];
                            write();
                            break;
                        }
                    case "reasoning-start":
                        {
                            const reasoningPart = {
                                type: "reasoning",
                                text: "",
                                providerMetadata: chunk.providerMetadata,
                                state: "streaming"
                            };
                            state.activeReasoningParts[chunk.id] = reasoningPart;
                            state.message.parts.push(reasoningPart);
                            write();
                            break;
                        }
                    case "reasoning-delta":
                        {
                            const reasoningPart = state.activeReasoningParts[chunk.id];
                            reasoningPart.text += chunk.delta;
                            reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;
                            write();
                            break;
                        }
                    case "reasoning-end":
                        {
                            const reasoningPart = state.activeReasoningParts[chunk.id];
                            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;
                            reasoningPart.state = "done";
                            delete state.activeReasoningParts[chunk.id];
                            write();
                            break;
                        }
                    case "file":
                        {
                            state.message.parts.push({
                                type: "file",
                                mediaType: chunk.mediaType,
                                url: chunk.url
                            });
                            write();
                            break;
                        }
                    case "source-url":
                        {
                            state.message.parts.push({
                                type: "source-url",
                                sourceId: chunk.sourceId,
                                url: chunk.url,
                                title: chunk.title,
                                providerMetadata: chunk.providerMetadata
                            });
                            write();
                            break;
                        }
                    case "source-document":
                        {
                            state.message.parts.push({
                                type: "source-document",
                                sourceId: chunk.sourceId,
                                mediaType: chunk.mediaType,
                                title: chunk.title,
                                filename: chunk.filename,
                                providerMetadata: chunk.providerMetadata
                            });
                            write();
                            break;
                        }
                    case "tool-input-start":
                        {
                            const toolInvocations = state.message.parts.filter(isStaticToolUIPart);
                            state.partialToolCalls[chunk.toolCallId] = {
                                text: "",
                                toolName: chunk.toolName,
                                index: toolInvocations.length,
                                dynamic: chunk.dynamic,
                                title: chunk.title
                            };
                            if (chunk.dynamic) {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "input-streaming",
                                    input: void 0,
                                    providerExecuted: chunk.providerExecuted,
                                    title: chunk.title
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "input-streaming",
                                    input: void 0,
                                    providerExecuted: chunk.providerExecuted,
                                    title: chunk.title
                                });
                            }
                            write();
                            break;
                        }
                    case "tool-input-delta":
                        {
                            const partialToolCall = state.partialToolCalls[chunk.toolCallId];
                            partialToolCall.text += chunk.inputTextDelta;
                            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);
                            if (partialToolCall.dynamic) {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: partialToolCall.toolName,
                                    state: "input-streaming",
                                    input: partialArgs,
                                    title: partialToolCall.title
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: partialToolCall.toolName,
                                    state: "input-streaming",
                                    input: partialArgs,
                                    title: partialToolCall.title
                                });
                            }
                            write();
                            break;
                        }
                    case "tool-input-available":
                        {
                            if (chunk.dynamic) {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "input-available",
                                    input: chunk.input,
                                    providerExecuted: chunk.providerExecuted,
                                    providerMetadata: chunk.providerMetadata,
                                    title: chunk.title
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "input-available",
                                    input: chunk.input,
                                    providerExecuted: chunk.providerExecuted,
                                    providerMetadata: chunk.providerMetadata,
                                    title: chunk.title
                                });
                            }
                            write();
                            if (onToolCall && !chunk.providerExecuted) {
                                await onToolCall({
                                    toolCall: chunk
                                });
                            }
                            break;
                        }
                    case "tool-input-error":
                        {
                            if (chunk.dynamic) {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "output-error",
                                    input: chunk.input,
                                    errorText: chunk.errorText,
                                    providerExecuted: chunk.providerExecuted,
                                    providerMetadata: chunk.providerMetadata
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: chunk.toolName,
                                    state: "output-error",
                                    input: void 0,
                                    rawInput: chunk.input,
                                    errorText: chunk.errorText,
                                    providerExecuted: chunk.providerExecuted,
                                    providerMetadata: chunk.providerMetadata
                                });
                            }
                            write();
                            break;
                        }
                    case "tool-approval-request":
                        {
                            const toolInvocation = getToolInvocation(chunk.toolCallId);
                            toolInvocation.state = "approval-requested";
                            toolInvocation.approval = {
                                id: chunk.approvalId
                            };
                            write();
                            break;
                        }
                    case "tool-output-denied":
                        {
                            const toolInvocation = getToolInvocation(chunk.toolCallId);
                            toolInvocation.state = "output-denied";
                            write();
                            break;
                        }
                    case "tool-output-available":
                        {
                            const toolInvocation = getToolInvocation(chunk.toolCallId);
                            if (toolInvocation.type === "dynamic-tool") {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: toolInvocation.toolName,
                                    state: "output-available",
                                    input: toolInvocation.input,
                                    output: chunk.output,
                                    preliminary: chunk.preliminary,
                                    providerExecuted: chunk.providerExecuted,
                                    title: toolInvocation.title
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: getStaticToolName(toolInvocation),
                                    state: "output-available",
                                    input: toolInvocation.input,
                                    output: chunk.output,
                                    providerExecuted: chunk.providerExecuted,
                                    preliminary: chunk.preliminary,
                                    title: toolInvocation.title
                                });
                            }
                            write();
                            break;
                        }
                    case "tool-output-error":
                        {
                            const toolInvocation = getToolInvocation(chunk.toolCallId);
                            if (toolInvocation.type === "dynamic-tool") {
                                updateDynamicToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: toolInvocation.toolName,
                                    state: "output-error",
                                    input: toolInvocation.input,
                                    errorText: chunk.errorText,
                                    providerExecuted: chunk.providerExecuted,
                                    title: toolInvocation.title
                                });
                            } else {
                                updateToolPart({
                                    toolCallId: chunk.toolCallId,
                                    toolName: getStaticToolName(toolInvocation),
                                    state: "output-error",
                                    input: toolInvocation.input,
                                    rawInput: toolInvocation.rawInput,
                                    errorText: chunk.errorText,
                                    providerExecuted: chunk.providerExecuted,
                                    title: toolInvocation.title
                                });
                            }
                            write();
                            break;
                        }
                    case "start-step":
                        {
                            state.message.parts.push({
                                type: "step-start"
                            });
                            break;
                        }
                    case "finish-step":
                        {
                            state.activeTextParts = {};
                            state.activeReasoningParts = {};
                            break;
                        }
                    case "start":
                        {
                            if (chunk.messageId != null) {
                                state.message.id = chunk.messageId;
                            }
                            await updateMessageMetadata(chunk.messageMetadata);
                            if (chunk.messageId != null || chunk.messageMetadata != null) {
                                write();
                            }
                            break;
                        }
                    case "finish":
                        {
                            if (chunk.finishReason != null) {
                                state.finishReason = chunk.finishReason;
                            }
                            await updateMessageMetadata(chunk.messageMetadata);
                            if (chunk.messageMetadata != null) {
                                write();
                            }
                            break;
                        }
                    case "message-metadata":
                        {
                            await updateMessageMetadata(chunk.messageMetadata);
                            if (chunk.messageMetadata != null) {
                                write();
                            }
                            break;
                        }
                    case "error":
                        {
                            onError == null ? void 0 : onError(new Error(chunk.errorText));
                            break;
                        }
                    default:
                        {
                            if (isDataUIMessageChunk(chunk)) {
                                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                                    await validateTypes({
                                        value: chunk.data,
                                        schema: dataPartSchemas[chunk.type]
                                    });
                                }
                                const dataChunk = chunk;
                                if (dataChunk.transient) {
                                    onData == null ? void 0 : onData(dataChunk);
                                    break;
                                }
                                const existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg)=>dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : void 0;
                                if (existingUIPart != null) {
                                    existingUIPart.data = dataChunk.data;
                                } else {
                                    state.message.parts.push(dataChunk);
                                }
                                onData == null ? void 0 : onData(dataChunk);
                                write();
                            }
                        }
                }
                controller.enqueue(chunk);
            });
        }
    }));
}
function handleUIMessageStreamFinish({ messageId, originalMessages = [], onFinish, onError, stream }) {
    let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
    if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
        lastMessage = void 0;
    } else {
        messageId = lastMessage.id;
    }
    let isAborted = false;
    const idInjectedStream = stream.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            if (chunk.type === "start") {
                const startChunk = chunk;
                if (startChunk.messageId == null && messageId != null) {
                    startChunk.messageId = messageId;
                }
            }
            if (chunk.type === "abort") {
                isAborted = true;
            }
            controller.enqueue(chunk);
        }
    }));
    if (onFinish == null) {
        return idInjectedStream;
    }
    const state = createStreamingUIMessageState({
        lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
        messageId: messageId != null ? messageId : ""
    });
    const runUpdateMessageJob = async (job)=>{
        await job({
            state,
            write: ()=>{}
        });
    };
    let finishCalled = false;
    const callOnFinish = async ()=>{
        if (finishCalled || !onFinish) {
            return;
        }
        finishCalled = true;
        const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
        await onFinish({
            isAborted,
            isContinuation,
            responseMessage: state.message,
            messages: [
                ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
                state.message
            ],
            finishReason: state.finishReason
        });
    };
    return processUIMessageStream({
        stream: idInjectedStream,
        runUpdateMessageJob,
        onError
    }).pipeThrough(new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
        },
        // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
        async cancel () {
            await callOnFinish();
        },
        async flush () {
            await callOnFinish();
        }
    }));
}
function pipeUIMessageStreamToResponse({ response, status, statusText, headers, stream, consumeSseStream }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
        const [stream1, stream2] = sseStream.tee();
        sseStream = stream1;
        consumeSseStream({
            stream: stream2
        });
    }
    writeToServerResponse({
        response,
        status,
        statusText,
        headers: Object.fromEntries(prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()),
        stream: sseStream.pipeThrough(new TextEncoderStream())
    });
}
function createAsyncIterableStream(source) {
    const stream = source.pipeThrough(new TransformStream());
    stream[Symbol.asyncIterator] = function() {
        const reader = this.getReader();
        let finished = false;
        async function cleanup(cancelStream) {
            var _a142;
            finished = true;
            try {
                {
                    await ((_a142 = reader.cancel) == null ? void 0 : _a142.call(reader));
                }
            } finally{
                try {
                    reader.releaseLock();
                } catch (e) {}
            }
        }
        return {
            /**
       * Reads the next chunk from the stream.
       * @returns A promise resolving to the next IteratorResult.
       */ async next () {
                if (finished) {
                    return {
                        done: true,
                        value: void 0
                    };
                }
                const { done, value } = await reader.read();
                if (done) {
                    await cleanup();
                    return {
                        done: true,
                        value: void 0
                    };
                }
                return {
                    done: false,
                    value
                };
            },
            /**
       * Called on early exit (e.g., break from for-await).
       * Ensures the stream is cancelled and resources are released.
       * @returns A promise resolving to a completed IteratorResult.
       */ async return () {
                await cleanup();
                return {
                    done: true,
                    value: void 0
                };
            },
            /**
       * Called on early exit with error.
       * Ensures the stream is cancelled and resources are released, then rethrows the error.
       * @param err The error to throw.
       * @returns A promise that rejects with the provided error.
       */ async throw (err) {
                await cleanup();
                throw err;
            }
        };
    };
    return stream;
}
async function consumeStream({ stream, onError }) {
    const reader = stream.getReader();
    try {
        while(true){
            const { done } = await reader.read();
            if (done) break;
        }
    } catch (error) {
        onError == null ? void 0 : onError(error);
    } finally{
        reader.releaseLock();
    }
}
function createResolvablePromise() {
    let resolve3;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve3 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve3,
        reject
    };
}
function createStitchableStream() {
    let innerStreamReaders = [];
    let controller = null;
    let isClosed = false;
    let waitForNewStream = createResolvablePromise();
    const terminate = ()=>{
        isClosed = true;
        waitForNewStream.resolve();
        innerStreamReaders.forEach((reader)=>reader.cancel());
        innerStreamReaders = [];
        controller == null ? void 0 : controller.close();
    };
    const processPull = async ()=>{
        if (isClosed && innerStreamReaders.length === 0) {
            controller == null ? void 0 : controller.close();
            return;
        }
        if (innerStreamReaders.length === 0) {
            waitForNewStream = createResolvablePromise();
            await waitForNewStream.promise;
            return processPull();
        }
        try {
            const { value, done } = await innerStreamReaders[0].read();
            if (done) {
                innerStreamReaders.shift();
                if (innerStreamReaders.length === 0 && isClosed) {
                    controller == null ? void 0 : controller.close();
                } else {
                    await processPull();
                }
            } else {
                controller == null ? void 0 : controller.enqueue(value);
            }
        } catch (error) {
            controller == null ? void 0 : controller.error(error);
            innerStreamReaders.shift();
            terminate();
        }
    };
    return {
        stream: new ReadableStream({
            start (controllerParam) {
                controller = controllerParam;
            },
            pull: processPull,
            async cancel () {
                for (const reader of innerStreamReaders){
                    await reader.cancel();
                }
                innerStreamReaders = [];
                isClosed = true;
            }
        }),
        addStream: (innerStream)=>{
            if (isClosed) {
                throw new Error("Cannot add inner stream: outer stream is closed");
            }
            innerStreamReaders.push(innerStream.getReader());
            waitForNewStream.resolve();
        },
        /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */ close: ()=>{
            isClosed = true;
            waitForNewStream.resolve();
            if (innerStreamReaders.length === 0) {
                controller == null ? void 0 : controller.close();
            }
        },
        /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */ terminate
    };
}
function now() {
    var _a142, _b82;
    return (_b82 = (_a142 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a142.now()) != null ? _b82 : Date.now();
}
function runToolsTransformation({ tools, generatorStream, tracer, telemetry, system, messages, abortSignal, repairToolCall, experimental_context, generateId: generateId2 }) {
    let toolResultsStreamController = null;
    const toolResultsStream = new ReadableStream({
        start (controller) {
            toolResultsStreamController = controller;
        }
    });
    const outstandingToolResults = /* @__PURE__ */ new Set();
    const toolInputs = /* @__PURE__ */ new Map();
    let canClose = false;
    let finishChunk = void 0;
    function attemptClose() {
        if (canClose && outstandingToolResults.size === 0) {
            if (finishChunk != null) {
                toolResultsStreamController.enqueue(finishChunk);
            }
            toolResultsStreamController.close();
        }
    }
    const forwardStream = new TransformStream({
        async transform (chunk, controller) {
            const chunkType = chunk.type;
            switch(chunkType){
                case "stream-start":
                case "text-start":
                case "text-delta":
                case "text-end":
                case "reasoning-start":
                case "reasoning-delta":
                case "reasoning-end":
                case "tool-input-start":
                case "tool-input-delta":
                case "tool-input-end":
                case "source":
                case "response-metadata":
                case "error":
                case "raw":
                    {
                        controller.enqueue(chunk);
                        break;
                    }
                case "file":
                    {
                        controller.enqueue({
                            type: "file",
                            file: new DefaultGeneratedFileWithType({
                                data: chunk.data,
                                mediaType: chunk.mediaType
                            })
                        });
                        break;
                    }
                case "finish":
                    {
                        finishChunk = {
                            type: "finish",
                            finishReason: chunk.finishReason.unified,
                            rawFinishReason: chunk.finishReason.raw,
                            usage: asLanguageModelUsage(chunk.usage),
                            providerMetadata: chunk.providerMetadata
                        };
                        break;
                    }
                case "tool-call":
                    {
                        try {
                            const toolCall = await parseToolCall({
                                toolCall: chunk,
                                tools,
                                repairToolCall,
                                system,
                                messages
                            });
                            controller.enqueue(toolCall);
                            if (toolCall.invalid) {
                                toolResultsStreamController.enqueue({
                                    type: "tool-error",
                                    toolCallId: toolCall.toolCallId,
                                    toolName: toolCall.toolName,
                                    input: toolCall.input,
                                    error: getErrorMessage2(toolCall.error),
                                    dynamic: true,
                                    title: toolCall.title
                                });
                                break;
                            }
                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                            if (tool2 == null) {
                                break;
                            }
                            if (tool2.onInputAvailable != null) {
                                await tool2.onInputAvailable({
                                    input: toolCall.input,
                                    toolCallId: toolCall.toolCallId,
                                    messages,
                                    abortSignal,
                                    experimental_context
                                });
                            }
                            if (await isApprovalNeeded({
                                tool: tool2,
                                toolCall,
                                messages,
                                experimental_context
                            })) {
                                toolResultsStreamController.enqueue({
                                    type: "tool-approval-request",
                                    approvalId: generateId2(),
                                    toolCall
                                });
                                break;
                            }
                            toolInputs.set(toolCall.toolCallId, toolCall.input);
                            if (tool2.execute != null && toolCall.providerExecuted !== true) {
                                const toolExecutionId = generateId2();
                                outstandingToolResults.add(toolExecutionId);
                                executeToolCall({
                                    toolCall,
                                    tools,
                                    tracer,
                                    telemetry,
                                    messages,
                                    abortSignal,
                                    experimental_context,
                                    onPreliminaryToolResult: (result)=>{
                                        toolResultsStreamController.enqueue(result);
                                    }
                                }).then((result)=>{
                                    toolResultsStreamController.enqueue(result);
                                    outstandingToolResults.delete(toolExecutionId);
                                    attemptClose();
                                });
                            }
                        } catch (error) {
                            toolResultsStreamController.enqueue({
                                type: "error",
                                error
                            });
                        }
                        break;
                    }
                case "tool-result":
                    {
                        const toolName = chunk.toolName;
                        if (chunk.isError) {
                            toolResultsStreamController.enqueue({
                                type: "tool-error",
                                toolCallId: chunk.toolCallId,
                                toolName,
                                input: toolInputs.get(chunk.toolCallId),
                                providerExecuted: true,
                                error: chunk.result,
                                dynamic: chunk.dynamic
                            });
                        } else {
                            controller.enqueue({
                                type: "tool-result",
                                toolCallId: chunk.toolCallId,
                                toolName,
                                input: toolInputs.get(chunk.toolCallId),
                                output: chunk.result,
                                providerExecuted: true,
                                dynamic: chunk.dynamic
                            });
                        }
                        break;
                    }
                case "tool-approval-request":
                    {
                        break;
                    }
                default:
                    {
                        const _exhaustiveCheck = chunkType;
                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
                    }
            }
        },
        flush () {
            canClose = true;
            attemptClose();
        }
    });
    return new ReadableStream({
        async start (controller) {
            return Promise.all([
                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({
                    write (chunk) {
                        controller.enqueue(chunk);
                    },
                    close () {}
                })),
                toolResultsStream.pipeTo(new WritableStream({
                    write (chunk) {
                        controller.enqueue(chunk);
                    },
                    close () {
                        controller.close();
                    }
                }))
            ]);
        }
    });
}
var originalGenerateId2 = createIdGenerator({
    prefix: "aitxt",
    size: 24
});
function streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, prepareStep, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, experimental_download: download2, includeRawChunks = false, onChunk, onError = ({ error })=>{
    console.error(error);
}, onFinish, onAbort, onStepFinish, experimental_context, _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {
    return new DefaultStreamTextResult({
        model: resolveLanguageModel(model),
        telemetry,
        headers,
        settings,
        maxRetries,
        abortSignal,
        system,
        prompt,
        messages,
        tools,
        toolChoice,
        transforms: asArray(transform),
        activeTools,
        repairToolCall,
        stopConditions: asArray(stopWhen),
        output,
        providerOptions,
        prepareStep,
        includeRawChunks,
        onChunk,
        onError,
        onFinish,
        onAbort,
        onStepFinish,
        now: now2,
        currentDate,
        generateId: generateId2,
        experimental_context,
        download: download2
    });
}
function createOutputTransformStream(output) {
    let firstTextChunkId = void 0;
    let text2 = "";
    let textChunk = "";
    let textProviderMetadata = void 0;
    let lastPublishedJson = "";
    function publishTextChunk({ controller, partialOutput = void 0 }) {
        controller.enqueue({
            part: {
                type: "text-delta",
                id: firstTextChunkId,
                text: textChunk,
                providerMetadata: textProviderMetadata
            },
            partialOutput
        });
        textChunk = "";
    }
    return new TransformStream({
        async transform (chunk, controller) {
            var _a142;
            if (chunk.type === "finish-step" && textChunk.length > 0) {
                publishTextChunk({
                    controller
                });
            }
            if (chunk.type !== "text-delta" && chunk.type !== "text-start" && chunk.type !== "text-end") {
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
                return;
            }
            if (firstTextChunkId == null) {
                firstTextChunkId = chunk.id;
            } else if (chunk.id !== firstTextChunkId) {
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
                return;
            }
            if (chunk.type === "text-start") {
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
                return;
            }
            if (chunk.type === "text-end") {
                if (textChunk.length > 0) {
                    publishTextChunk({
                        controller
                    });
                }
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
                return;
            }
            text2 += chunk.text;
            textChunk += chunk.text;
            textProviderMetadata = (_a142 = chunk.providerMetadata) != null ? _a142 : textProviderMetadata;
            const result = await output.parsePartialOutput({
                text: text2
            });
            if (result !== void 0) {
                const currentJson = JSON.stringify(result.partial);
                if (currentJson !== lastPublishedJson) {
                    publishTextChunk({
                        controller,
                        partialOutput: result.partial
                    });
                    lastPublishedJson = currentJson;
                }
            }
        }
    });
}
var DefaultStreamTextResult = class {
    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, system, prompt, messages, tools, toolChoice, transforms, activeTools, repairToolCall, stopConditions, output, providerOptions, prepareStep, includeRawChunks, now: now2, currentDate, generateId: generateId2, onChunk, onError, onFinish, onAbort, onStepFinish, experimental_context, download: download2 }){
        this._totalUsage = new DelayedPromise();
        this._finishReason = new DelayedPromise();
        this._rawFinishReason = new DelayedPromise();
        this._steps = new DelayedPromise();
        this.outputSpecification = output;
        this.includeRawChunks = includeRawChunks;
        this.tools = tools;
        let stepFinish;
        let recordedContent = [];
        const recordedResponseMessages = [];
        let recordedFinishReason = void 0;
        let recordedRawFinishReason = void 0;
        let recordedTotalUsage = void 0;
        let recordedRequest = {};
        let recordedWarnings = [];
        const recordedSteps = [];
        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();
        let rootSpan;
        let activeTextContent = {};
        let activeReasoningContent = {};
        const eventProcessor = new TransformStream({
            async transform (chunk, controller) {
                var _a142, _b82, _c, _d;
                controller.enqueue(chunk);
                const { part } = chunk;
                if (part.type === "text-delta" || part.type === "reasoning-delta" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-input-start" || part.type === "tool-input-delta" || part.type === "raw") {
                    await (onChunk == null ? void 0 : onChunk({
                        chunk: part
                    }));
                }
                if (part.type === "error") {
                    await onError({
                        error: wrapGatewayError(part.error)
                    });
                }
                if (part.type === "text-start") {
                    activeTextContent[part.id] = {
                        type: "text",
                        text: "",
                        providerMetadata: part.providerMetadata
                    };
                    recordedContent.push(activeTextContent[part.id]);
                }
                if (part.type === "text-delta") {
                    const activeText = activeTextContent[part.id];
                    if (activeText == null) {
                        controller.enqueue({
                            part: {
                                type: "error",
                                error: `text part ${part.id} not found`
                            },
                            partialOutput: void 0
                        });
                        return;
                    }
                    activeText.text += part.text;
                    activeText.providerMetadata = (_a142 = part.providerMetadata) != null ? _a142 : activeText.providerMetadata;
                }
                if (part.type === "text-end") {
                    const activeText = activeTextContent[part.id];
                    if (activeText == null) {
                        controller.enqueue({
                            part: {
                                type: "error",
                                error: `text part ${part.id} not found`
                            },
                            partialOutput: void 0
                        });
                        return;
                    }
                    activeText.providerMetadata = (_b82 = part.providerMetadata) != null ? _b82 : activeText.providerMetadata;
                    delete activeTextContent[part.id];
                }
                if (part.type === "reasoning-start") {
                    activeReasoningContent[part.id] = {
                        type: "reasoning",
                        text: "",
                        providerMetadata: part.providerMetadata
                    };
                    recordedContent.push(activeReasoningContent[part.id]);
                }
                if (part.type === "reasoning-delta") {
                    const activeReasoning = activeReasoningContent[part.id];
                    if (activeReasoning == null) {
                        controller.enqueue({
                            part: {
                                type: "error",
                                error: `reasoning part ${part.id} not found`
                            },
                            partialOutput: void 0
                        });
                        return;
                    }
                    activeReasoning.text += part.text;
                    activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;
                }
                if (part.type === "reasoning-end") {
                    const activeReasoning = activeReasoningContent[part.id];
                    if (activeReasoning == null) {
                        controller.enqueue({
                            part: {
                                type: "error",
                                error: `reasoning part ${part.id} not found`
                            },
                            partialOutput: void 0
                        });
                        return;
                    }
                    activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;
                    delete activeReasoningContent[part.id];
                }
                if (part.type === "file") {
                    recordedContent.push({
                        type: "file",
                        file: part.file
                    });
                }
                if (part.type === "source") {
                    recordedContent.push(part);
                }
                if (part.type === "tool-call") {
                    recordedContent.push(part);
                }
                if (part.type === "tool-result" && !part.preliminary) {
                    recordedContent.push(part);
                }
                if (part.type === "tool-approval-request") {
                    recordedContent.push(part);
                }
                if (part.type === "tool-error") {
                    recordedContent.push(part);
                }
                if (part.type === "start-step") {
                    recordedContent = [];
                    activeReasoningContent = {};
                    activeTextContent = {};
                    recordedRequest = part.request;
                    recordedWarnings = part.warnings;
                }
                if (part.type === "finish-step") {
                    const stepMessages = await toResponseMessages({
                        content: recordedContent,
                        tools
                    });
                    const currentStepResult = new DefaultStepResult({
                        content: recordedContent,
                        finishReason: part.finishReason,
                        rawFinishReason: part.rawFinishReason,
                        usage: part.usage,
                        warnings: recordedWarnings,
                        request: recordedRequest,
                        response: {
                            ...part.response,
                            messages: [
                                ...recordedResponseMessages,
                                ...stepMessages
                            ]
                        },
                        providerMetadata: part.providerMetadata
                    });
                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
                    logWarnings({
                        warnings: recordedWarnings,
                        provider: model.provider,
                        model: model.modelId
                    });
                    recordedSteps.push(currentStepResult);
                    recordedResponseMessages.push(...stepMessages);
                    stepFinish.resolve();
                }
                if (part.type === "finish") {
                    recordedTotalUsage = part.totalUsage;
                    recordedFinishReason = part.finishReason;
                    recordedRawFinishReason = part.rawFinishReason;
                }
            },
            async flush (controller) {
                try {
                    if (recordedSteps.length === 0) {
                        const error = new NoOutputGeneratedError({
                            message: "No output generated. Check the stream for errors."
                        });
                        self._finishReason.reject(error);
                        self._rawFinishReason.reject(error);
                        self._totalUsage.reject(error);
                        self._steps.reject(error);
                        return;
                    }
                    const finishReason = recordedFinishReason != null ? recordedFinishReason : "other";
                    const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();
                    self._finishReason.resolve(finishReason);
                    self._rawFinishReason.resolve(recordedRawFinishReason);
                    self._totalUsage.resolve(totalUsage);
                    self._steps.resolve(recordedSteps);
                    const finalStep = recordedSteps[recordedSteps.length - 1];
                    await (onFinish == null ? void 0 : onFinish({
                        finishReason: finalStep.finishReason,
                        rawFinishReason: finalStep.rawFinishReason,
                        totalUsage,
                        usage: finalStep.usage,
                        content: finalStep.content,
                        text: finalStep.text,
                        reasoningText: finalStep.reasoningText,
                        reasoning: finalStep.reasoning,
                        files: finalStep.files,
                        sources: finalStep.sources,
                        toolCalls: finalStep.toolCalls,
                        staticToolCalls: finalStep.staticToolCalls,
                        dynamicToolCalls: finalStep.dynamicToolCalls,
                        toolResults: finalStep.toolResults,
                        staticToolResults: finalStep.staticToolResults,
                        dynamicToolResults: finalStep.dynamicToolResults,
                        request: finalStep.request,
                        response: finalStep.response,
                        warnings: finalStep.warnings,
                        providerMetadata: finalStep.providerMetadata,
                        steps: recordedSteps,
                        experimental_context
                    }));
                    rootSpan.setAttributes(await selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                            "ai.response.finishReason": finishReason,
                            "ai.response.text": {
                                output: ()=>finalStep.text
                            },
                            "ai.response.toolCalls": {
                                output: ()=>{
                                    var _a142;
                                    return ((_a142 = finalStep.toolCalls) == null ? void 0 : _a142.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                                }
                            },
                            "ai.response.providerMetadata": JSON.stringify(finalStep.providerMetadata),
                            "ai.usage.inputTokens": totalUsage.inputTokens,
                            "ai.usage.outputTokens": totalUsage.outputTokens,
                            "ai.usage.totalTokens": totalUsage.totalTokens,
                            "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                            "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
                        }
                    }));
                } catch (error) {
                    controller.error(error);
                } finally{
                    rootSpan.end();
                }
            }
        });
        const stitchableStream = createStitchableStream();
        this.addStream = stitchableStream.addStream;
        this.closeStream = stitchableStream.close;
        const reader = stitchableStream.stream.getReader();
        let stream = new ReadableStream({
            async start (controller) {
                controller.enqueue({
                    type: "start"
                });
            },
            async pull (controller) {
                function abort() {
                    onAbort == null ? void 0 : onAbort({
                        steps: recordedSteps
                    });
                    controller.enqueue({
                        type: "abort"
                    });
                    controller.close();
                }
                try {
                    const { done, value } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if (abortSignal == null ? void 0 : abortSignal.aborted) {
                        abort();
                        return;
                    }
                    controller.enqueue(value);
                } catch (error) {
                    if (isAbortError(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {
                        abort();
                    } else {
                        controller.error(error);
                    }
                }
            },
            cancel (reason) {
                return stitchableStream.stream.cancel(reason);
            }
        });
        for (const transform of transforms){
            stream = stream.pipeThrough(transform({
                tools,
                stopStream () {
                    stitchableStream.terminate();
                }
            }));
        }
        this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);
        const { maxRetries, retry } = prepareRetries({
            maxRetries: maxRetriesArg,
            abortSignal
        });
        const tracer = getTracer(telemetry);
        const callSettings = prepareCallSettings(settings);
        const baseTelemetryAttributes = getBaseTelemetryAttributes({
            model,
            telemetry,
            headers,
            settings: {
                ...callSettings,
                maxRetries
            }
        });
        const self = this;
        recordSpan({
            name: "ai.streamText",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.streamText",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    }
                }
            }),
            tracer,
            endWhenDone: false,
            fn: async (rootSpanArg)=>{
                rootSpan = rootSpanArg;
                const initialPrompt = await standardizePrompt({
                    system,
                    prompt,
                    messages
                });
                const initialMessages = initialPrompt.messages;
                const initialResponseMessages = [];
                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({
                    messages: initialMessages
                });
                if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {
                    let toolExecutionStepStreamController;
                    const toolExecutionStepStream = new ReadableStream({
                        start (controller) {
                            toolExecutionStepStreamController = controller;
                        }
                    });
                    self.addStream(toolExecutionStepStream);
                    try {
                        for (const toolApproval of deniedToolApprovals){
                            toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({
                                type: "tool-output-denied",
                                toolCallId: toolApproval.toolCall.toolCallId,
                                toolName: toolApproval.toolCall.toolName
                            });
                        }
                        const toolOutputs = [];
                        await Promise.all(approvedToolApprovals.map(async (toolApproval)=>{
                            const result = await executeToolCall({
                                toolCall: toolApproval.toolCall,
                                tools,
                                tracer,
                                telemetry,
                                messages: initialMessages,
                                abortSignal,
                                experimental_context,
                                onPreliminaryToolResult: (result2)=>{
                                    toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);
                                }
                            });
                            if (result != null) {
                                toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);
                                toolOutputs.push(result);
                            }
                        }));
                        const content = [];
                        for (const output2 of toolOutputs){
                            content.push({
                                type: "tool-result",
                                toolCallId: output2.toolCallId,
                                toolName: output2.toolName,
                                output: await createToolModelOutput({
                                    toolCallId: output2.toolCallId,
                                    input: output2.input,
                                    tool: tools == null ? void 0 : tools[output2.toolName],
                                    output: output2.type === "tool-result" ? output2.output : output2.error,
                                    errorMode: output2.type === "tool-error" ? "json" : "none"
                                })
                            });
                        }
                        for (const toolApproval of deniedToolApprovals){
                            content.push({
                                type: "tool-result",
                                toolCallId: toolApproval.toolCall.toolCallId,
                                toolName: toolApproval.toolCall.toolName,
                                output: {
                                    type: "execution-denied",
                                    reason: toolApproval.approvalResponse.reason
                                }
                            });
                        }
                        initialResponseMessages.push({
                            role: "tool",
                            content
                        });
                    } finally{
                        toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();
                    }
                }
                recordedResponseMessages.push(...initialResponseMessages);
                async function streamStep({ currentStep, responseMessages, usage }) {
                    var _a142, _b82, _c, _d, _e, _f;
                    const includeRawChunks2 = self.includeRawChunks;
                    stepFinish = new DelayedPromise();
                    const stepInputMessages = [
                        ...initialMessages,
                        ...responseMessages
                    ];
                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
                        model,
                        steps: recordedSteps,
                        stepNumber: recordedSteps.length,
                        messages: stepInputMessages,
                        experimental_context
                    }));
                    const stepModel = resolveLanguageModel((_a142 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a142 : model);
                    const promptMessages = await convertToLanguageModelPrompt({
                        prompt: {
                            system: (_b82 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b82 : initialPrompt.system,
                            messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
                        },
                        supportedUrls: await stepModel.supportedUrls,
                        download: download2
                    });
                    const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
                        tools,
                        toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
                        activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
                    });
                    experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;
                    const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);
                    const { result: { stream: stream2, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({
                            name: "ai.streamText.doStream",
                            attributes: selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName({
                                        operationId: "ai.streamText.doStream",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // model:
                                    "ai.model.provider": stepModel.provider,
                                    "ai.model.id": stepModel.modelId,
                                    // prompt:
                                    "ai.prompt.messages": {
                                        input: ()=>stringifyForTelemetry(promptMessages)
                                    },
                                    "ai.prompt.tools": {
                                        // convert the language model level tools:
                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))
                                    },
                                    "ai.prompt.toolChoice": {
                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                                    },
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.system": stepModel.provider,
                                    "gen_ai.request.model": stepModel.modelId,
                                    "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                                    "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                                    "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                                    "gen_ai.request.stop_sequences": callSettings.stopSequences,
                                    "gen_ai.request.temperature": callSettings.temperature,
                                    "gen_ai.request.top_k": callSettings.topK,
                                    "gen_ai.request.top_p": callSettings.topP
                                }
                            }),
                            tracer,
                            endWhenDone: false,
                            fn: async (doStreamSpan2)=>({
                                    startTimestampMs: now2(),
                                    // get before the call
                                    doStreamSpan: doStreamSpan2,
                                    result: await stepModel.doStream({
                                        ...callSettings,
                                        tools: stepTools,
                                        toolChoice: stepToolChoice,
                                        responseFormat: await (output == null ? void 0 : output.responseFormat),
                                        prompt: promptMessages,
                                        providerOptions: stepProviderOptions,
                                        abortSignal,
                                        headers,
                                        includeRawChunks: includeRawChunks2
                                    })
                                })
                        }));
                    const streamWithToolResults = runToolsTransformation({
                        tools,
                        generatorStream: stream2,
                        tracer,
                        telemetry,
                        system,
                        messages: stepInputMessages,
                        repairToolCall,
                        abortSignal,
                        experimental_context,
                        generateId: generateId2
                    });
                    const stepRequest = request != null ? request : {};
                    const stepToolCalls = [];
                    const stepToolOutputs = [];
                    let warnings;
                    const activeToolCallToolNames = {};
                    let stepFinishReason = "other";
                    let stepRawFinishReason = void 0;
                    let stepUsage = createNullLanguageModelUsage();
                    let stepProviderMetadata;
                    let stepFirstChunk = true;
                    let stepResponse = {
                        id: generateId2(),
                        timestamp: currentDate(),
                        modelId: model.modelId
                    };
                    let activeText = "";
                    self.addStream(streamWithToolResults.pipeThrough(new TransformStream({
                        async transform (chunk, controller) {
                            var _a152, _b222, _c2, _d2, _e2;
                            if (chunk.type === "stream-start") {
                                warnings = chunk.warnings;
                                return;
                            }
                            if (stepFirstChunk) {
                                const msToFirstChunk = now2() - startTimestampMs;
                                stepFirstChunk = false;
                                doStreamSpan.addEvent("ai.stream.firstChunk", {
                                    "ai.response.msToFirstChunk": msToFirstChunk
                                });
                                doStreamSpan.setAttributes({
                                    "ai.response.msToFirstChunk": msToFirstChunk
                                });
                                controller.enqueue({
                                    type: "start-step",
                                    request: stepRequest,
                                    warnings: warnings != null ? warnings : []
                                });
                            }
                            const chunkType = chunk.type;
                            switch(chunkType){
                                case "tool-approval-request":
                                case "text-start":
                                case "text-end":
                                    {
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "text-delta":
                                    {
                                        if (chunk.delta.length > 0) {
                                            controller.enqueue({
                                                type: "text-delta",
                                                id: chunk.id,
                                                text: chunk.delta,
                                                providerMetadata: chunk.providerMetadata
                                            });
                                            activeText += chunk.delta;
                                        }
                                        break;
                                    }
                                case "reasoning-start":
                                case "reasoning-end":
                                    {
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "reasoning-delta":
                                    {
                                        controller.enqueue({
                                            type: "reasoning-delta",
                                            id: chunk.id,
                                            text: chunk.delta,
                                            providerMetadata: chunk.providerMetadata
                                        });
                                        break;
                                    }
                                case "tool-call":
                                    {
                                        controller.enqueue(chunk);
                                        stepToolCalls.push(chunk);
                                        break;
                                    }
                                case "tool-result":
                                    {
                                        controller.enqueue(chunk);
                                        if (!chunk.preliminary) {
                                            stepToolOutputs.push(chunk);
                                        }
                                        break;
                                    }
                                case "tool-error":
                                    {
                                        controller.enqueue(chunk);
                                        stepToolOutputs.push(chunk);
                                        break;
                                    }
                                case "response-metadata":
                                    {
                                        stepResponse = {
                                            id: (_a152 = chunk.id) != null ? _a152 : stepResponse.id,
                                            timestamp: (_b222 = chunk.timestamp) != null ? _b222 : stepResponse.timestamp,
                                            modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                                        };
                                        break;
                                    }
                                case "finish":
                                    {
                                        stepUsage = chunk.usage;
                                        stepFinishReason = chunk.finishReason;
                                        stepRawFinishReason = chunk.rawFinishReason;
                                        stepProviderMetadata = chunk.providerMetadata;
                                        const msToFinish = now2() - startTimestampMs;
                                        doStreamSpan.addEvent("ai.stream.finish");
                                        doStreamSpan.setAttributes({
                                            "ai.response.msToFinish": msToFinish,
                                            "ai.response.avgOutputTokensPerSecond": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                                        });
                                        break;
                                    }
                                case "file":
                                    {
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "source":
                                    {
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "tool-input-start":
                                    {
                                        activeToolCallToolNames[chunk.id] = chunk.toolName;
                                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];
                                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {
                                            await tool2.onInputStart({
                                                toolCallId: chunk.id,
                                                messages: stepInputMessages,
                                                abortSignal,
                                                experimental_context
                                            });
                                        }
                                        controller.enqueue({
                                            ...chunk,
                                            dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === "dynamic",
                                            title: tool2 == null ? void 0 : tool2.title
                                        });
                                        break;
                                    }
                                case "tool-input-end":
                                    {
                                        delete activeToolCallToolNames[chunk.id];
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "tool-input-delta":
                                    {
                                        const toolName = activeToolCallToolNames[chunk.id];
                                        const tool2 = tools == null ? void 0 : tools[toolName];
                                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {
                                            await tool2.onInputDelta({
                                                inputTextDelta: chunk.delta,
                                                toolCallId: chunk.id,
                                                messages: stepInputMessages,
                                                abortSignal,
                                                experimental_context
                                            });
                                        }
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "error":
                                    {
                                        controller.enqueue(chunk);
                                        stepFinishReason = "error";
                                        break;
                                    }
                                case "raw":
                                    {
                                        if (includeRawChunks2) {
                                            controller.enqueue(chunk);
                                        }
                                        break;
                                    }
                                default:
                                    {
                                        const exhaustiveCheck = chunkType;
                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                                    }
                            }
                        },
                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                        async flush (controller) {
                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                            try {
                                doStreamSpan.setAttributes(await selectTelemetryAttributes({
                                    telemetry,
                                    attributes: {
                                        "ai.response.finishReason": stepFinishReason,
                                        "ai.response.text": {
                                            output: ()=>activeText
                                        },
                                        "ai.response.toolCalls": {
                                            output: ()=>stepToolCallsJson
                                        },
                                        "ai.response.id": stepResponse.id,
                                        "ai.response.model": stepResponse.modelId,
                                        "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                                        "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                                        "ai.usage.inputTokens": stepUsage.inputTokens,
                                        "ai.usage.outputTokens": stepUsage.outputTokens,
                                        "ai.usage.totalTokens": stepUsage.totalTokens,
                                        "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                                        "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                                        // standardized gen-ai llm span attributes:
                                        "gen_ai.response.finish_reasons": [
                                            stepFinishReason
                                        ],
                                        "gen_ai.response.id": stepResponse.id,
                                        "gen_ai.response.model": stepResponse.modelId,
                                        "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                                        "gen_ai.usage.output_tokens": stepUsage.outputTokens
                                    }
                                }));
                            } catch (error) {} finally{
                                doStreamSpan.end();
                            }
                            controller.enqueue({
                                type: "finish-step",
                                finishReason: stepFinishReason,
                                rawFinishReason: stepRawFinishReason,
                                usage: stepUsage,
                                providerMetadata: stepProviderMetadata,
                                response: {
                                    ...stepResponse,
                                    headers: response == null ? void 0 : response.headers
                                }
                            });
                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                            await stepFinish.promise;
                            const clientToolCalls = stepToolCalls.filter((toolCall)=>toolCall.providerExecuted !== true);
                            const clientToolOutputs = stepToolOutputs.filter((toolOutput)=>toolOutput.providerExecuted !== true);
                            for (const toolCall of stepToolCalls){
                                if (toolCall.providerExecuted !== true) continue;
                                const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                                if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                                    const hasResultInStep = stepToolOutputs.some((output2)=>output2.type === "tool-result" && output2.toolCallId === toolCall.toolCallId);
                                    if (!hasResultInStep) {
                                        pendingDeferredToolCalls.set(toolCall.toolCallId, {
                                            toolName: toolCall.toolName
                                        });
                                    }
                                }
                            }
                            for (const output2 of stepToolOutputs){
                                if (output2.type === "tool-result") {
                                    pendingDeferredToolCalls.delete(output2.toolCallId);
                                }
                            }
                            if (// Continue if:
                            // 1. There are client tool calls that have all been executed, OR
                            // 2. There are pending deferred results from provider-executed tools
                            (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:
                            !await isStopConditionMet({
                                stopConditions,
                                steps: recordedSteps
                            })) {
                                responseMessages.push(...await toResponseMessages({
                                    content: // use transformed content to create the messages for the next step:
                                    recordedSteps[recordedSteps.length - 1].content,
                                    tools
                                }));
                                try {
                                    await streamStep({
                                        currentStep: currentStep + 1,
                                        responseMessages,
                                        usage: combinedUsage
                                    });
                                } catch (error) {
                                    controller.enqueue({
                                        type: "error",
                                        error
                                    });
                                    self.closeStream();
                                }
                            } else {
                                controller.enqueue({
                                    type: "finish",
                                    finishReason: stepFinishReason,
                                    rawFinishReason: stepRawFinishReason,
                                    totalUsage: combinedUsage
                                });
                                self.closeStream();
                            }
                        }
                    })));
                }
                await streamStep({
                    currentStep: 0,
                    responseMessages: initialResponseMessages,
                    usage: createNullLanguageModelUsage()
                });
            }
        }).catch((error)=>{
            self.addStream(new ReadableStream({
                start (controller) {
                    controller.enqueue({
                        type: "error",
                        error
                    });
                    controller.close();
                }
            }));
            self.closeStream();
        });
    }
    get steps() {
        this.consumeStream();
        return this._steps.promise;
    }
    get finalStep() {
        return this.steps.then((steps)=>steps[steps.length - 1]);
    }
    get content() {
        return this.finalStep.then((step)=>step.content);
    }
    get warnings() {
        return this.finalStep.then((step)=>step.warnings);
    }
    get providerMetadata() {
        return this.finalStep.then((step)=>step.providerMetadata);
    }
    get text() {
        return this.finalStep.then((step)=>step.text);
    }
    get reasoningText() {
        return this.finalStep.then((step)=>step.reasoningText);
    }
    get reasoning() {
        return this.finalStep.then((step)=>step.reasoning);
    }
    get sources() {
        return this.finalStep.then((step)=>step.sources);
    }
    get files() {
        return this.finalStep.then((step)=>step.files);
    }
    get toolCalls() {
        return this.finalStep.then((step)=>step.toolCalls);
    }
    get staticToolCalls() {
        return this.finalStep.then((step)=>step.staticToolCalls);
    }
    get dynamicToolCalls() {
        return this.finalStep.then((step)=>step.dynamicToolCalls);
    }
    get toolResults() {
        return this.finalStep.then((step)=>step.toolResults);
    }
    get staticToolResults() {
        return this.finalStep.then((step)=>step.staticToolResults);
    }
    get dynamicToolResults() {
        return this.finalStep.then((step)=>step.dynamicToolResults);
    }
    get usage() {
        return this.finalStep.then((step)=>step.usage);
    }
    get request() {
        return this.finalStep.then((step)=>step.request);
    }
    get response() {
        return this.finalStep.then((step)=>step.response);
    }
    get totalUsage() {
        this.consumeStream();
        return this._totalUsage.promise;
    }
    get finishReason() {
        this.consumeStream();
        return this._finishReason.promise;
    }
    get rawFinishReason() {
        this.consumeStream();
        return this._rawFinishReason.promise;
    }
    /**
  Split out a new stream from the original stream.
  The original stream is replaced to allow for further splitting,
  since we do not know how many times the stream will be split.
  
  Note: this leads to buffering the stream content on the server.
  However, the LLM results are expected to be small enough to not cause issues.
     */ teeStream() {
        const [stream1, stream2] = this.baseStream.tee();
        this.baseStream = stream2;
        return stream1;
    }
    get textStream() {
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ part }, controller) {
                if (part.type === "text-delta") {
                    controller.enqueue(part.text);
                }
            }
        })));
    }
    get fullStream() {
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ part }, controller) {
                controller.enqueue(part);
            }
        })));
    }
    async consumeStream(options) {
        var _a142;
        try {
            await consumeStream({
                stream: this.fullStream,
                onError: options == null ? void 0 : options.onError
            });
        } catch (error) {
            (_a142 = options == null ? void 0 : options.onError) == null ? void 0 : _a142.call(options, error);
        }
    }
    get experimental_partialOutputStream() {
        return this.partialOutputStream;
    }
    get partialOutputStream() {
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ partialOutput }, controller) {
                if (partialOutput != null) {
                    controller.enqueue(partialOutput);
                }
            }
        })));
    }
    get output() {
        return this.finalStep.then((step)=>{
            var _a142;
            const output = (_a142 = this.outputSpecification) != null ? _a142 : text();
            return output.parseCompleteOutput({
                text: step.text
            }, {
                response: step.response,
                usage: step.usage,
                finishReason: step.finishReason
            });
        });
    }
    toUIMessageStream({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning = true, sendSources = false, sendStart = true, sendFinish = true, onError = getErrorMessage } = {}) {
        const responseMessageId = generateMessageId != null ? getResponseUIMessageId({
            originalMessages,
            responseMessageId: generateMessageId
        }) : void 0;
        const isDynamic = (part)=>{
            var _a142;
            const tool2 = (_a142 = this.tools) == null ? void 0 : _a142[part.toolName];
            if (tool2 == null) {
                return part.dynamic;
            }
            return (tool2 == null ? void 0 : tool2.type) === "dynamic" ? true : void 0;
        };
        const baseStream = this.fullStream.pipeThrough(new TransformStream({
            transform: async (part, controller)=>{
                const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({
                    part
                });
                const partType = part.type;
                switch(partType){
                    case "text-start":
                        {
                            controller.enqueue({
                                type: "text-start",
                                id: part.id,
                                ...part.providerMetadata != null ? {
                                    providerMetadata: part.providerMetadata
                                } : {}
                            });
                            break;
                        }
                    case "text-delta":
                        {
                            controller.enqueue({
                                type: "text-delta",
                                id: part.id,
                                delta: part.text,
                                ...part.providerMetadata != null ? {
                                    providerMetadata: part.providerMetadata
                                } : {}
                            });
                            break;
                        }
                    case "text-end":
                        {
                            controller.enqueue({
                                type: "text-end",
                                id: part.id,
                                ...part.providerMetadata != null ? {
                                    providerMetadata: part.providerMetadata
                                } : {}
                            });
                            break;
                        }
                    case "reasoning-start":
                        {
                            controller.enqueue({
                                type: "reasoning-start",
                                id: part.id,
                                ...part.providerMetadata != null ? {
                                    providerMetadata: part.providerMetadata
                                } : {}
                            });
                            break;
                        }
                    case "reasoning-delta":
                        {
                            if (sendReasoning) {
                                controller.enqueue({
                                    type: "reasoning-delta",
                                    id: part.id,
                                    delta: part.text,
                                    ...part.providerMetadata != null ? {
                                        providerMetadata: part.providerMetadata
                                    } : {}
                                });
                            }
                            break;
                        }
                    case "reasoning-end":
                        {
                            controller.enqueue({
                                type: "reasoning-end",
                                id: part.id,
                                ...part.providerMetadata != null ? {
                                    providerMetadata: part.providerMetadata
                                } : {}
                            });
                            break;
                        }
                    case "file":
                        {
                            controller.enqueue({
                                type: "file",
                                mediaType: part.file.mediaType,
                                url: `data:${part.file.mediaType};base64,${part.file.base64}`
                            });
                            break;
                        }
                    case "source":
                        {
                            if (sendSources && part.sourceType === "url") {
                                controller.enqueue({
                                    type: "source-url",
                                    sourceId: part.id,
                                    url: part.url,
                                    title: part.title,
                                    ...part.providerMetadata != null ? {
                                        providerMetadata: part.providerMetadata
                                    } : {}
                                });
                            }
                            if (sendSources && part.sourceType === "document") {
                                controller.enqueue({
                                    type: "source-document",
                                    sourceId: part.id,
                                    mediaType: part.mediaType,
                                    title: part.title,
                                    filename: part.filename,
                                    ...part.providerMetadata != null ? {
                                        providerMetadata: part.providerMetadata
                                    } : {}
                                });
                            }
                            break;
                        }
                    case "tool-input-start":
                        {
                            const dynamic = isDynamic(part);
                            controller.enqueue({
                                type: "tool-input-start",
                                toolCallId: part.id,
                                toolName: part.toolName,
                                ...part.providerExecuted != null ? {
                                    providerExecuted: part.providerExecuted
                                } : {},
                                ...dynamic != null ? {
                                    dynamic
                                } : {},
                                ...part.title != null ? {
                                    title: part.title
                                } : {}
                            });
                            break;
                        }
                    case "tool-input-delta":
                        {
                            controller.enqueue({
                                type: "tool-input-delta",
                                toolCallId: part.id,
                                inputTextDelta: part.delta
                            });
                            break;
                        }
                    case "tool-call":
                        {
                            const dynamic = isDynamic(part);
                            if (part.invalid) {
                                controller.enqueue({
                                    type: "tool-input-error",
                                    toolCallId: part.toolCallId,
                                    toolName: part.toolName,
                                    input: part.input,
                                    ...part.providerExecuted != null ? {
                                        providerExecuted: part.providerExecuted
                                    } : {},
                                    ...part.providerMetadata != null ? {
                                        providerMetadata: part.providerMetadata
                                    } : {},
                                    ...dynamic != null ? {
                                        dynamic
                                    } : {},
                                    errorText: onError(part.error),
                                    ...part.title != null ? {
                                        title: part.title
                                    } : {}
                                });
                            } else {
                                controller.enqueue({
                                    type: "tool-input-available",
                                    toolCallId: part.toolCallId,
                                    toolName: part.toolName,
                                    input: part.input,
                                    ...part.providerExecuted != null ? {
                                        providerExecuted: part.providerExecuted
                                    } : {},
                                    ...part.providerMetadata != null ? {
                                        providerMetadata: part.providerMetadata
                                    } : {},
                                    ...dynamic != null ? {
                                        dynamic
                                    } : {},
                                    ...part.title != null ? {
                                        title: part.title
                                    } : {}
                                });
                            }
                            break;
                        }
                    case "tool-approval-request":
                        {
                            controller.enqueue({
                                type: "tool-approval-request",
                                approvalId: part.approvalId,
                                toolCallId: part.toolCall.toolCallId
                            });
                            break;
                        }
                    case "tool-result":
                        {
                            const dynamic = isDynamic(part);
                            controller.enqueue({
                                type: "tool-output-available",
                                toolCallId: part.toolCallId,
                                output: part.output,
                                ...part.providerExecuted != null ? {
                                    providerExecuted: part.providerExecuted
                                } : {},
                                ...part.preliminary != null ? {
                                    preliminary: part.preliminary
                                } : {},
                                ...dynamic != null ? {
                                    dynamic
                                } : {}
                            });
                            break;
                        }
                    case "tool-error":
                        {
                            const dynamic = isDynamic(part);
                            controller.enqueue({
                                type: "tool-output-error",
                                toolCallId: part.toolCallId,
                                errorText: onError(part.error),
                                ...part.providerExecuted != null ? {
                                    providerExecuted: part.providerExecuted
                                } : {},
                                ...dynamic != null ? {
                                    dynamic
                                } : {}
                            });
                            break;
                        }
                    case "tool-output-denied":
                        {
                            controller.enqueue({
                                type: "tool-output-denied",
                                toolCallId: part.toolCallId
                            });
                            break;
                        }
                    case "error":
                        {
                            controller.enqueue({
                                type: "error",
                                errorText: onError(part.error)
                            });
                            break;
                        }
                    case "start-step":
                        {
                            controller.enqueue({
                                type: "start-step"
                            });
                            break;
                        }
                    case "finish-step":
                        {
                            controller.enqueue({
                                type: "finish-step"
                            });
                            break;
                        }
                    case "start":
                        {
                            if (sendStart) {
                                controller.enqueue({
                                    type: "start",
                                    ...messageMetadataValue != null ? {
                                        messageMetadata: messageMetadataValue
                                    } : {},
                                    ...responseMessageId != null ? {
                                        messageId: responseMessageId
                                    } : {}
                                });
                            }
                            break;
                        }
                    case "finish":
                        {
                            if (sendFinish) {
                                controller.enqueue({
                                    type: "finish",
                                    finishReason: part.finishReason,
                                    ...messageMetadataValue != null ? {
                                        messageMetadata: messageMetadataValue
                                    } : {}
                                });
                            }
                            break;
                        }
                    case "abort":
                        {
                            controller.enqueue(part);
                            break;
                        }
                    case "tool-input-end":
                        {
                            break;
                        }
                    case "raw":
                        {
                            break;
                        }
                    default:
                        {
                            const exhaustiveCheck = partType;
                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                        }
                }
                if (messageMetadataValue != null && partType !== "start" && partType !== "finish") {
                    controller.enqueue({
                        type: "message-metadata",
                        messageMetadata: messageMetadataValue
                    });
                }
            }
        }));
        return createAsyncIterableStream(handleUIMessageStreamFinish({
            stream: baseStream,
            messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),
            originalMessages,
            onFinish,
            onError
        }));
    }
    pipeUIMessageStreamToResponse(response, { originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {
        pipeUIMessageStreamToResponse({
            response,
            stream: this.toUIMessageStream({
                originalMessages,
                generateMessageId,
                onFinish,
                messageMetadata,
                sendReasoning,
                sendSources,
                sendFinish,
                sendStart,
                onError
            }),
            ...init
        });
    }
    pipeTextStreamToResponse(response, init) {
        pipeTextStreamToResponse({
            response,
            textStream: this.textStream,
            ...init
        });
    }
    toUIMessageStreamResponse({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {
        return createUIMessageStreamResponse({
            stream: this.toUIMessageStream({
                originalMessages,
                generateMessageId,
                onFinish,
                messageMetadata,
                sendReasoning,
                sendSources,
                sendFinish,
                sendStart,
                onError
            }),
            ...init
        });
    }
    toTextStreamResponse(init) {
        return createTextStreamResponse({
            textStream: this.textStream,
            ...init
        });
    }
};
var ToolLoopAgent = class {
    constructor(settings){
        this.version = "agent-v1";
        this.settings = settings;
    }
    /**
   * The id of the agent.
   */ get id() {
        return this.settings.id;
    }
    /**
   * The tools that the agent can use.
   */ get tools() {
        return this.settings.tools;
    }
    async prepareCall(options) {
        var _a142, _b82, _c, _d;
        const baseCallArgs = {
            ...this.settings,
            stopWhen: (_a142 = this.settings.stopWhen) != null ? _a142 : stepCountIs(20),
            ...options
        };
        const preparedCallArgs = (_d = await ((_c = (_b82 = this.settings).prepareCall) == null ? void 0 : _c.call(_b82, baseCallArgs))) != null ? _d : baseCallArgs;
        const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;
        return {
            ...callArgs,
            // restore prompt types
            ...{
                system: instructions,
                messages,
                prompt
            }
        };
    }
    /**
   * Generates an output from the agent (non-streaming).
   */ async generate({ abortSignal, ...options }) {
        return generateText({
            ...await this.prepareCall(options),
            abortSignal
        });
    }
    /**
   * Streams an output from the agent (streaming).
   */ async stream({ abortSignal, experimental_transform, ...options }) {
        return streamText({
            ...await this.prepareCall(options),
            abortSignal,
            experimental_transform
        });
    }
};
async function embed({ model: modelArg, value, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {
    const model = resolveEmbeddingModel(modelArg);
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg,
        abortSignal
    });
    const headersWithUserAgent = withUserAgentSuffix(headers != null ? headers : {}, `ai/${VERSION3}`);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers: headersWithUserAgent,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer(telemetry);
    return recordSpan({
        name: "ai.embed",
        attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
                ...assembleOperationName({
                    operationId: "ai.embed",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                "ai.value": {
                    input: ()=>JSON.stringify(value)
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            const { embedding, usage, warnings, response, providerMetadata } = await retry(()=>// nested spans to align with the embedMany telemetry data:
                recordSpan({
                    name: "ai.embed.doEmbed",
                    attributes: selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                            ...assembleOperationName({
                                operationId: "ai.embed.doEmbed",
                                telemetry
                            }),
                            ...baseTelemetryAttributes,
                            // specific settings that only make sense on the outer level:
                            "ai.values": {
                                input: ()=>[
                                        JSON.stringify(value)
                                    ]
                            }
                        }
                    }),
                    tracer,
                    fn: async (doEmbedSpan)=>{
                        var _a142;
                        const modelResponse = await model.doEmbed({
                            values: [
                                value
                            ],
                            abortSignal,
                            headers: headersWithUserAgent,
                            providerOptions
                        });
                        const embedding2 = modelResponse.embeddings[0];
                        const usage2 = (_a142 = modelResponse.usage) != null ? _a142 : {
                            tokens: NaN
                        };
                        doEmbedSpan.setAttributes(await selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                "ai.embeddings": {
                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))
                                },
                                "ai.usage.tokens": usage2.tokens
                            }
                        }));
                        return {
                            embedding: embedding2,
                            usage: usage2,
                            warnings: modelResponse.warnings,
                            providerMetadata: modelResponse.providerMetadata,
                            response: modelResponse.response
                        };
                    }
                }));
            span.setAttributes(await selectTelemetryAttributes({
                telemetry,
                attributes: {
                    "ai.embedding": {
                        output: ()=>JSON.stringify(embedding)
                    },
                    "ai.usage.tokens": usage.tokens
                }
            }));
            logWarnings({
                warnings,
                provider: model.provider,
                model: model.modelId
            });
            return new DefaultEmbedResult({
                value,
                embedding,
                usage,
                warnings,
                providerMetadata,
                response
            });
        }
    });
}
var DefaultEmbedResult = class {
    constructor(options){
        this.value = options.value;
        this.embedding = options.embedding;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.response = options.response;
    }
};
createIdGenerator({
    prefix: "aiobj",
    size: 24
});
createIdGenerator({
    prefix: "aiobj",
    size: 24
});
;
 //# sourceMappingURL=chunk-QVMJVO5F.js.map
 //# sourceMappingURL=chunk-QVMJVO5F.js.map
}),
];

//# sourceMappingURL=node_modules_%40mastra_core_dist_chunk-QVMJVO5F_5d58c37d.js.map