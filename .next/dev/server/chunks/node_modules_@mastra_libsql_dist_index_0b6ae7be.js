module.exports = [
"[project]/node_modules/@mastra/libsql/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "AgentsLibSQL",
    ()=>AgentsLibSQL,
    "DefaultStorage",
    ()=>LibSQLStore,
    "LIBSQL_PROMPT",
    ()=>LIBSQL_PROMPT,
    "LibSQLStore",
    ()=>LibSQLStore,
    "LibSQLVector",
    ()=>LibSQLVector,
    "MemoryLibSQL",
    ()=>MemoryLibSQL,
    "ObservabilityLibSQL",
    ()=>ObservabilityLibSQL,
    "ScoresLibSQL",
    ()=>ScoresLibSQL,
    "WorkflowsLibSQL",
    ()=>WorkflowsLibSQL
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__ = __turbopack_context__.i("[externals]/@libsql/client [external] (@libsql/client, esm_import, [project]/node_modules/@libsql/client)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-FJEVLHJT.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-DDH2PEZG.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-65QFXXAD.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-MCVLH3QV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$vector$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/vector/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$BWYU7D33$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-BWYU7D33.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-LSHPJWM5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-PSIJ6OSV.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__
]);
[__TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
;
;
;
;
// src/vector/index.ts
var LibSQLFilterTranslator = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$BWYU7D33$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseFilterTranslator"] {
    getSupportedOperators() {
        return {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$BWYU7D33$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseFilterTranslator"].DEFAULT_OPERATORS,
            regex: [],
            custom: [
                "$contains",
                "$size"
            ]
        };
    }
    translate(filter) {
        if (this.isEmpty(filter)) {
            return filter;
        }
        this.validateFilter(filter);
        return this.translateNode(filter);
    }
    translateNode(node, currentPath = "") {
        if (this.isRegex(node)) {
            throw new Error("Direct regex pattern format is not supported in LibSQL");
        }
        const withPath = (result2)=>currentPath ? {
                [currentPath]: result2
            } : result2;
        if (this.isPrimitive(node)) {
            return withPath({
                $eq: this.normalizeComparisonValue(node)
            });
        }
        if (Array.isArray(node)) {
            return withPath({
                $in: this.normalizeArrayValues(node)
            });
        }
        const entries = Object.entries(node);
        const result = {};
        for (const [key, value] of entries){
            const newPath = currentPath ? `${currentPath}.${key}` : key;
            if (this.isLogicalOperator(key)) {
                result[key] = Array.isArray(value) ? value.map((filter)=>this.translateNode(filter)) : this.translateNode(value);
            } else if (this.isOperator(key)) {
                if (this.isArrayOperator(key) && !Array.isArray(value) && key !== "$elemMatch") {
                    result[key] = [
                        value
                    ];
                } else if (this.isBasicOperator(key) && Array.isArray(value)) {
                    result[key] = JSON.stringify(value);
                } else {
                    result[key] = value;
                }
            } else if (typeof value === "object" && value !== null) {
                const hasOperators = Object.keys(value).some((k)=>this.isOperator(k));
                if (hasOperators) {
                    result[newPath] = this.translateNode(value);
                } else {
                    Object.assign(result, this.translateNode(value, newPath));
                }
            } else {
                result[newPath] = this.translateNode(value);
            }
        }
        return result;
    }
};
var createBasicOperator = (symbol)=>{
    return (key, value)=>{
        const jsonPath = getJsonPath(key);
        return {
            sql: `CASE 
        WHEN ? IS NULL THEN json_extract(metadata, ${jsonPath}) IS ${symbol === "=" ? "" : "NOT"} NULL
        ELSE json_extract(metadata, ${jsonPath}) ${symbol} ?
      END`,
            needsValue: true,
            transformValue: ()=>{
                return [
                    value,
                    value
                ];
            }
        };
    };
};
var createNumericOperator = (symbol)=>{
    return (key, value)=>{
        const jsonPath = getJsonPath(key);
        const isNumeric = typeof value === "number" || typeof value === "string" && !isNaN(Number(value)) && value.trim() !== "";
        if (isNumeric) {
            return {
                sql: `CAST(json_extract(metadata, ${jsonPath}) AS NUMERIC) ${symbol} ?`,
                needsValue: true
            };
        } else {
            return {
                sql: `CAST(json_extract(metadata, ${jsonPath}) AS TEXT) ${symbol} ?`,
                needsValue: true
            };
        }
    };
};
var validateJsonArray = (key)=>{
    const jsonPath = getJsonPath(key);
    return `json_valid(json_extract(metadata, ${jsonPath}))
   AND json_type(json_extract(metadata, ${jsonPath})) = 'array'`;
};
var pattern = /json_extract\(metadata, '\$\.(?:"[^"]*"(?:\."[^"]*")*|[^']+)'\)/g;
function buildElemMatchConditions(value) {
    const conditions = Object.entries(value).map(([field, fieldValue])=>{
        if (field.startsWith("$")) {
            const { sql, values } = buildCondition("elem.value", {
                [field]: fieldValue
            });
            const elemSql = sql.replace(pattern, "elem.value");
            return {
                sql: elemSql,
                values
            };
        } else if (typeof fieldValue === "object" && !Array.isArray(fieldValue)) {
            const { sql, values } = buildCondition(field, fieldValue);
            const jsonPath = parseJsonPathKey(field);
            const elemSql = sql.replace(pattern, `json_extract(elem.value, '$.${jsonPath}')`);
            return {
                sql: elemSql,
                values
            };
        } else {
            const jsonPath = parseJsonPathKey(field);
            return {
                sql: `json_extract(elem.value, '$.${jsonPath}') = ?`,
                values: [
                    fieldValue
                ]
            };
        }
    });
    return conditions;
}
var FILTER_OPERATORS = {
    $eq: createBasicOperator("="),
    $ne: createBasicOperator("!="),
    $gt: createNumericOperator(">"),
    $gte: createNumericOperator(">="),
    $lt: createNumericOperator("<"),
    $lte: createNumericOperator("<="),
    // Array Operators
    $in: (key, value)=>{
        const jsonPath = getJsonPath(key);
        const arr = Array.isArray(value) ? value : [
            value
        ];
        if (arr.length === 0) {
            return {
                sql: "1 = 0",
                needsValue: true,
                transformValue: ()=>[]
            };
        }
        const paramPlaceholders = arr.map(()=>"?").join(",");
        return {
            sql: `(
      CASE
        WHEN ${validateJsonArray(key)} THEN
          EXISTS (
            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem
            WHERE elem.value IN (SELECT value FROM json_each(?))
          )
        ELSE json_extract(metadata, ${jsonPath}) IN (${paramPlaceholders})
      END
    )`,
            needsValue: true,
            transformValue: ()=>[
                    JSON.stringify(arr),
                    ...arr
                ]
        };
    },
    $nin: (key, value)=>{
        const jsonPath = getJsonPath(key);
        const arr = Array.isArray(value) ? value : [
            value
        ];
        if (arr.length === 0) {
            return {
                sql: "1 = 1",
                needsValue: true,
                transformValue: ()=>[]
            };
        }
        const paramPlaceholders = arr.map(()=>"?").join(",");
        return {
            sql: `(
      CASE
        WHEN ${validateJsonArray(key)} THEN
          NOT EXISTS (
            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem
            WHERE elem.value IN (SELECT value FROM json_each(?))
          )
        ELSE json_extract(metadata, ${jsonPath}) NOT IN (${paramPlaceholders})
      END
    )`,
            needsValue: true,
            transformValue: ()=>[
                    JSON.stringify(arr),
                    ...arr
                ]
        };
    },
    $all: (key, value)=>{
        const jsonPath = getJsonPath(key);
        let sql;
        const arrayValue = Array.isArray(value) ? value : [
            value
        ];
        if (arrayValue.length === 0) {
            sql = "1 = 0";
        } else {
            sql = `(
      CASE
        WHEN ${validateJsonArray(key)} THEN
          NOT EXISTS (
            SELECT value
            FROM json_each(?)
            WHERE value NOT IN (
              SELECT value
              FROM json_each(json_extract(metadata, ${jsonPath}))
            )
          )
        ELSE FALSE
      END
    )`;
        }
        return {
            sql,
            needsValue: true,
            transformValue: ()=>{
                if (arrayValue.length === 0) {
                    return [];
                }
                return [
                    JSON.stringify(arrayValue)
                ];
            }
        };
    },
    $elemMatch: (key, value)=>{
        const jsonPath = getJsonPath(key);
        if (typeof value !== "object" || Array.isArray(value)) {
            throw new Error("$elemMatch requires an object with conditions");
        }
        const conditions = buildElemMatchConditions(value);
        return {
            sql: `(
        CASE
          WHEN ${validateJsonArray(key)} THEN
            EXISTS (
              SELECT 1
              FROM json_each(json_extract(metadata, ${jsonPath})) as elem
              WHERE ${conditions.map((c)=>c.sql).join(" AND ")}
            )
          ELSE FALSE
        END
      )`,
            needsValue: true,
            transformValue: ()=>conditions.flatMap((c)=>c.values)
        };
    },
    // Element Operators
    $exists: (key)=>{
        const jsonPath = getJsonPath(key);
        return {
            sql: `json_extract(metadata, ${jsonPath}) IS NOT NULL`,
            needsValue: false
        };
    },
    // Logical Operators
    $and: (key)=>({
            sql: `(${key})`,
            needsValue: false
        }),
    $or: (key)=>({
            sql: `(${key})`,
            needsValue: false
        }),
    $not: (key)=>({
            sql: `NOT (${key})`,
            needsValue: false
        }),
    $nor: (key)=>({
            sql: `NOT (${key})`,
            needsValue: false
        }),
    $size: (key, paramIndex)=>{
        const jsonPath = getJsonPath(key);
        return {
            sql: `(
    CASE
      WHEN json_type(json_extract(metadata, ${jsonPath})) = 'array' THEN 
        json_array_length(json_extract(metadata, ${jsonPath})) = $${paramIndex}
      ELSE FALSE
    END
  )`,
            needsValue: true
        };
    },
    //   /**
    //    * Regex Operators
    //    * Supports case insensitive and multiline
    //    */
    //   $regex: (key: string): FilterOperator => ({
    //     sql: `json_extract(metadata, '$."${toJsonPathKey(key)}"') = ?`,
    //     needsValue: true,
    //     transformValue: (value: any) => {
    //       const pattern = typeof value === 'object' ? value.$regex : value;
    //       const options = typeof value === 'object' ? value.$options || '' : '';
    //       let sql = `json_extract(metadata, '$."${toJsonPathKey(key)}"')`;
    //       // Handle multiline
    //       //   if (options.includes('m')) {
    //       //     sql = `REPLACE(${sql}, CHAR(10), '\n')`;
    //       //   }
    //       //       let finalPattern = pattern;
    //       // if (options) {
    //       //   finalPattern = `(\\?${options})${pattern}`;
    //       // }
    //       //   // Handle case insensitivity
    //       //   if (options.includes('i')) {
    //       //     sql = `LOWER(${sql}) REGEXP LOWER(?)`;
    //       //   } else {
    //       //     sql = `${sql} REGEXP ?`;
    //       //   }
    //       if (options.includes('m')) {
    //         sql = `EXISTS (
    //         SELECT 1
    //         FROM json_each(
    //           json_array(
    //             ${sql},
    //             REPLACE(${sql}, CHAR(10), CHAR(13))
    //           )
    //         ) as lines
    //         WHERE lines.value REGEXP ?
    //       )`;
    //       } else {
    //         sql = `${sql} REGEXP ?`;
    //       }
    //       // Handle case insensitivity
    //       if (options.includes('i')) {
    //         sql = sql.replace('REGEXP ?', 'REGEXP LOWER(?)');
    //         sql = sql.replace('value REGEXP', 'LOWER(value) REGEXP');
    //       }
    //       // Handle extended - allows whitespace and comments in pattern
    //       if (options.includes('x')) {
    //         // Remove whitespace and comments from pattern
    //         const cleanPattern = pattern.replace(/\s+|#.*$/gm, '');
    //         return {
    //           sql,
    //           values: [cleanPattern],
    //         };
    //       }
    //       return {
    //         sql,
    //         values: [pattern],
    //       };
    //     },
    //   }),
    $contains: (key, value)=>{
        const jsonPathKey = parseJsonPathKey(key);
        let sql;
        if (Array.isArray(value)) {
            sql = `(
        SELECT ${validateJsonArray(jsonPathKey)}
        AND EXISTS (
          SELECT 1
          FROM json_each(json_extract(metadata, '$."${jsonPathKey}"')) as m
          WHERE m.value IN (SELECT value FROM json_each(?))
        )
      )`;
        } else if (typeof value === "string") {
            sql = `lower(json_extract(metadata, '$."${jsonPathKey}"')) LIKE '%' || lower(?) || '%' ESCAPE '\\'`;
        } else {
            sql = `json_extract(metadata, '$."${jsonPathKey}"') = ?`;
        }
        return {
            sql,
            needsValue: true,
            transformValue: ()=>{
                if (Array.isArray(value)) {
                    return [
                        JSON.stringify(value)
                    ];
                }
                if (typeof value === "object" && value !== null) {
                    return [
                        JSON.stringify(value)
                    ];
                }
                if (typeof value === "string") {
                    return [
                        escapeLikePattern(value)
                    ];
                }
                return [
                    value
                ];
            }
        };
    }
};
function isFilterResult(obj) {
    return obj && typeof obj === "object" && typeof obj.sql === "string" && Array.isArray(obj.values);
}
var parseJsonPathKey = (key)=>{
    const parsedKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseFieldKey"])(key);
    if (parsedKey.includes(".")) {
        return parsedKey.split(".").map((segment)=>`"${segment}"`).join(".");
    }
    return parsedKey;
};
var getJsonPath = (key)=>{
    const jsonPathKey = parseJsonPathKey(key);
    return `'$.${jsonPathKey}'`;
};
function escapeLikePattern(str) {
    return str.replace(/([%_\\])/g, "\\$1");
}
function buildFilterQuery(filter) {
    if (!filter) {
        return {
            sql: "",
            values: []
        };
    }
    const values = [];
    const conditions = Object.entries(filter).map(([key, value])=>{
        const condition = buildCondition(key, value);
        values.push(...condition.values);
        return condition.sql;
    }).join(" AND ");
    return {
        sql: conditions ? `WHERE ${conditions}` : "",
        values
    };
}
function buildCondition(key, value, parentPath) {
    if ([
        "$and",
        "$or",
        "$not",
        "$nor"
    ].includes(key)) {
        return handleLogicalOperator(key, value);
    }
    if (!value || typeof value !== "object") {
        const jsonPath = getJsonPath(key);
        return {
            sql: `json_extract(metadata, ${jsonPath}) = ?`,
            values: [
                value
            ]
        };
    }
    return handleOperator(key, value);
}
function handleLogicalOperator(key, value, parentPath) {
    if (!value || Array.isArray(value) && value.length === 0) {
        switch(key){
            case "$and":
            case "$nor":
                return {
                    sql: "true",
                    values: []
                };
            case "$or":
                return {
                    sql: "false",
                    values: []
                };
            case "$not":
                throw new Error("$not operator cannot be empty");
            default:
                return {
                    sql: "true",
                    values: []
                };
        }
    }
    if (key === "$not") {
        const entries = Object.entries(value);
        const conditions2 = entries.map(([fieldKey, fieldValue])=>buildCondition(fieldKey, fieldValue));
        return {
            sql: `NOT (${conditions2.map((c)=>c.sql).join(" AND ")})`,
            values: conditions2.flatMap((c)=>c.values)
        };
    }
    const values = [];
    const joinOperator = key === "$or" || key === "$nor" ? "OR" : "AND";
    const conditions = Array.isArray(value) ? value.map((f)=>{
        const entries = !!f ? Object.entries(f) : [];
        return entries.map(([k, v])=>buildCondition(k, v));
    }) : [
        buildCondition(key, value)
    ];
    const joined = conditions.flat().map((c)=>{
        values.push(...c.values);
        return c.sql;
    }).join(` ${joinOperator} `);
    return {
        sql: key === "$nor" ? `NOT (${joined})` : `(${joined})`,
        values
    };
}
function handleOperator(key, value) {
    if (typeof value === "object" && !Array.isArray(value)) {
        const entries = Object.entries(value);
        const results = entries.map(([operator2, operatorValue2])=>operator2 === "$not" ? {
                sql: `NOT (${Object.entries(operatorValue2).map(([op, val])=>processOperator(key, op, val).sql).join(" AND ")})`,
                values: Object.entries(operatorValue2).flatMap(([op, val])=>processOperator(key, op, val).values)
            } : processOperator(key, operator2, operatorValue2));
        return {
            sql: `(${results.map((r)=>r.sql).join(" AND ")})`,
            values: results.flatMap((r)=>r.values)
        };
    }
    const [[operator, operatorValue] = []] = Object.entries(value);
    return processOperator(key, operator, operatorValue);
}
var processOperator = (key, operator, operatorValue)=>{
    if (!operator.startsWith("$") || !FILTER_OPERATORS[operator]) {
        throw new Error(`Invalid operator: ${operator}`);
    }
    const operatorFn = FILTER_OPERATORS[operator];
    const operatorResult = operatorFn(key, operatorValue);
    if (!operatorResult.needsValue) {
        return {
            sql: operatorResult.sql,
            values: []
        };
    }
    const transformed = operatorResult.transformValue ? operatorResult.transformValue() : operatorValue;
    if (isFilterResult(transformed)) {
        return transformed;
    }
    return {
        sql: operatorResult.sql,
        values: Array.isArray(transformed) ? transformed : [
            transformed
        ]
    };
};
// src/vector/index.ts
var LibSQLVector = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$vector$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MastraVector"] {
    turso;
    maxRetries;
    initialBackoffMs;
    constructor({ url, authToken, syncUrl, syncInterval, maxRetries = 5, initialBackoffMs = 100, id }){
        super({
            id
        });
        this.turso = (0, __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__["createClient"])({
            url,
            syncUrl,
            authToken,
            syncInterval
        });
        this.maxRetries = maxRetries;
        this.initialBackoffMs = initialBackoffMs;
        if (url.includes(`file:`) || url.includes(`:memory:`)) {
            this.turso.execute("PRAGMA journal_mode=WAL;").then(()=>this.logger.debug("LibSQLStore: PRAGMA journal_mode=WAL set.")).catch((err)=>this.logger.warn("LibSQLStore: Failed to set PRAGMA journal_mode=WAL.", err));
            this.turso.execute("PRAGMA busy_timeout = 5000;").then(()=>this.logger.debug("LibSQLStore: PRAGMA busy_timeout=5000 set.")).catch((err)=>this.logger.warn("LibSQLStore: Failed to set PRAGMA busy_timeout=5000.", err));
        }
    }
    async executeWriteOperationWithRetry(operation, isTransaction = false) {
        let attempts = 0;
        let backoff = this.initialBackoffMs;
        while(attempts < this.maxRetries){
            try {
                return await operation();
            } catch (error) {
                if (error.code === "SQLITE_BUSY" || error.message && error.message.toLowerCase().includes("database is locked")) {
                    attempts++;
                    if (attempts >= this.maxRetries) {
                        this.logger.error(`LibSQLVector: Operation failed after ${this.maxRetries} attempts due to: ${error.message}`, error);
                        throw error;
                    }
                    this.logger.warn(`LibSQLVector: Attempt ${attempts} failed due to ${isTransaction ? "transaction " : ""}database lock. Retrying in ${backoff}ms...`);
                    await new Promise((resolve)=>setTimeout(resolve, backoff));
                    backoff *= 2;
                } else {
                    throw error;
                }
            }
        }
        throw new Error("LibSQLVector: Max retries reached, but no error was re-thrown from the loop.");
    }
    transformFilter(filter) {
        const translator = new LibSQLFilterTranslator();
        return translator.translate(filter);
    }
    async query({ indexName, queryVector, topK = 10, filter, includeVector = false, minScore = -1 }) {
        try {
            if (!Number.isInteger(topK) || topK <= 0) {
                throw new Error("topK must be a positive integer");
            }
            if (!Array.isArray(queryVector) || !queryVector.every((x)=>typeof x === "number" && Number.isFinite(x))) {
                throw new Error("queryVector must be an array of finite numbers");
            }
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "QUERY", "INVALID_ARGS"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER
            }, error);
        }
        try {
            const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
            const vectorStr = `[${queryVector.join(",")}]`;
            const translatedFilter = this.transformFilter(filter);
            const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);
            filterValues.push(minScore);
            filterValues.push(topK);
            const query = `
      WITH vector_scores AS (
        SELECT
          vector_id as id,
          (1-vector_distance_cos(embedding, '${vectorStr}')) as score,
          metadata
          ${includeVector ? ", vector_extract(embedding) as embedding" : ""}
        FROM ${parsedIndexName}
        ${filterQuery}
      )
      SELECT *
      FROM vector_scores
      WHERE score > ?
      ORDER BY score DESC
      LIMIT ?`;
            const result = await this.turso.execute({
                sql: query,
                args: filterValues
            });
            return result.rows.map(({ id, score, metadata, embedding })=>({
                    id,
                    score,
                    metadata: JSON.parse(metadata ?? "{}"),
                    ...includeVector && embedding && {
                        vector: JSON.parse(embedding)
                    }
                }));
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "QUERY", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    upsert(args) {
        try {
            return this.executeWriteOperationWithRetry(()=>this.doUpsert(args), true);
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPSERT", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async doUpsert({ indexName, vectors, metadata, ids }) {
        const tx = await this.turso.transaction("write");
        try {
            const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
            const vectorIds = ids || vectors.map(()=>crypto.randomUUID());
            for(let i = 0; i < vectors.length; i++){
                const query = `
            INSERT INTO ${parsedIndexName} (vector_id, embedding, metadata)
            VALUES (?, vector32(?), ?)
            ON CONFLICT(vector_id) DO UPDATE SET
              embedding = vector32(?),
              metadata = ?
          `;
                await tx.execute({
                    sql: query,
                    args: [
                        vectorIds[i],
                        JSON.stringify(vectors[i]),
                        JSON.stringify(metadata?.[i] || {}),
                        JSON.stringify(vectors[i]),
                        JSON.stringify(metadata?.[i] || {})
                    ]
                });
            }
            await tx.commit();
            return vectorIds;
        } catch (error) {
            !tx.closed && await tx.rollback();
            if (error instanceof Error && error.message?.includes("dimensions are different")) {
                const match = error.message.match(/dimensions are different: (\d+) != (\d+)/);
                if (match) {
                    const [, actual, expected] = match;
                    throw new Error(`Vector dimension mismatch: Index "${indexName}" expects ${expected} dimensions but got ${actual} dimensions. Either use a matching embedding model or delete and recreate the index with the new dimension.`);
                }
            }
            throw error;
        }
    }
    createIndex(args) {
        try {
            return this.executeWriteOperationWithRetry(()=>this.doCreateIndex(args));
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "CREATE_INDEX", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName: args.indexName,
                    dimension: args.dimension
                }
            }, error);
        }
    }
    async doCreateIndex({ indexName, dimension }) {
        if (!Number.isInteger(dimension) || dimension <= 0) {
            throw new Error("Dimension must be a positive integer");
        }
        const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
        await this.turso.execute({
            sql: `
          CREATE TABLE IF NOT EXISTS ${parsedIndexName} (
            id SERIAL PRIMARY KEY,
            vector_id TEXT UNIQUE NOT NULL,
            embedding F32_BLOB(${dimension}),
            metadata TEXT DEFAULT '{}'
          );
        `,
            args: []
        });
        await this.turso.execute({
            sql: `
          CREATE INDEX IF NOT EXISTS ${parsedIndexName}_vector_idx
          ON ${parsedIndexName} (libsql_vector_idx(embedding))
        `,
            args: []
        });
    }
    deleteIndex(args) {
        try {
            return this.executeWriteOperationWithRetry(()=>this.doDeleteIndex(args));
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_INDEX", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName: args.indexName
                }
            }, error);
        }
    }
    async doDeleteIndex({ indexName }) {
        const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
        await this.turso.execute({
            sql: `DROP TABLE IF EXISTS ${parsedIndexName}`,
            args: []
        });
    }
    async listIndexes() {
        try {
            const vectorTablesQuery = `
        SELECT name FROM sqlite_master 
        WHERE type='table' 
        AND sql LIKE '%F32_BLOB%';
      `;
            const result = await this.turso.execute({
                sql: vectorTablesQuery,
                args: []
            });
            return result.rows.map((row)=>row.name);
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "LIST_INDEXES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    /**
   * Retrieves statistics about a vector index.
   *
   * @param {string} indexName - The name of the index to describe
   * @returns A promise that resolves to the index statistics including dimension, count and metric
   */ async describeIndex({ indexName }) {
        try {
            const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
            const tableInfoQuery = `
        SELECT sql 
        FROM sqlite_master 
        WHERE type='table' 
        AND name = ?;
      `;
            const tableInfo = await this.turso.execute({
                sql: tableInfoQuery,
                args: [
                    parsedIndexName
                ]
            });
            if (!tableInfo.rows[0]?.sql) {
                throw new Error(`Table ${parsedIndexName} not found`);
            }
            const dimension = parseInt(tableInfo.rows[0].sql.match(/F32_BLOB\((\d+)\)/)?.[1] || "0");
            const countQuery = `
        SELECT COUNT(*) as count
        FROM ${parsedIndexName};
      `;
            const countResult = await this.turso.execute({
                sql: countQuery,
                args: []
            });
            const metric = "cosine";
            return {
                dimension,
                count: countResult?.rows?.[0]?.count ?? 0,
                metric
            };
        } catch (e) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DESCRIBE_INDEX", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName
                }
            }, e);
        }
    }
    /**
   * Updates a vector by its ID with the provided vector and/or metadata.
   *
   * @param indexName - The name of the index containing the vector.
   * @param id - The ID of the vector to update.
   * @param update - An object containing the vector and/or metadata to update.
   * @param update.vector - An optional array of numbers representing the new vector.
   * @param update.metadata - An optional record containing the new metadata.
   * @returns A promise that resolves when the update is complete.
   * @throws Will throw an error if no updates are provided or if the update operation fails.
   */ updateVector(args) {
        return this.executeWriteOperationWithRetry(()=>this.doUpdateVector(args));
    }
    async doUpdateVector(params) {
        const { indexName, update } = params;
        const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
        if ("id" in params && params.id && "filter" in params && params.filter) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "MUTUALLY_EXCLUSIVE"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    indexName
                },
                text: "id and filter are mutually exclusive - provide only one"
            });
        }
        if (!update.vector && !update.metadata) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "NO_PAYLOAD"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    indexName
                },
                text: "No updates provided"
            });
        }
        const updates = [];
        const args = [];
        if (update.vector) {
            updates.push("embedding = vector32(?)");
            args.push(JSON.stringify(update.vector));
        }
        if (update.metadata) {
            updates.push("metadata = ?");
            args.push(JSON.stringify(update.metadata));
        }
        if (updates.length === 0) {
            return;
        }
        let whereClause;
        let whereValues;
        if ("id" in params && params.id) {
            whereClause = "vector_id = ?";
            whereValues = [
                params.id
            ];
        } else if ("filter" in params && params.filter) {
            const filter = params.filter;
            if (!filter || Object.keys(filter).length === 0) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "EMPTY_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName
                    },
                    text: "Cannot update with empty filter"
                });
            }
            const translatedFilter = this.transformFilter(filter);
            const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);
            if (!filterSql || filterSql.trim() === "") {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "INVALID_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName
                    },
                    text: "Filter produced empty WHERE clause"
                });
            }
            const normalizedCondition = filterSql.replace(/^\s*WHERE\s+/i, "").trim().toLowerCase();
            const matchAllPatterns = [
                "true",
                "1 = 1",
                "1=1"
            ];
            if (matchAllPatterns.includes(normalizedCondition)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "MATCH_ALL_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName,
                        filterSql: normalizedCondition
                    },
                    text: "Filter matches all vectors. Provide a specific filter to update targeted vectors."
                });
            }
            whereClause = filterSql.replace(/^WHERE\s+/i, "");
            whereValues = filterValues;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "NO_TARGET"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    indexName
                },
                text: "Either id or filter must be provided"
            });
        }
        const query = `
      UPDATE ${parsedIndexName}
      SET ${updates.join(", ")}
      WHERE ${whereClause};
    `;
        try {
            await this.turso.execute({
                sql: query,
                args: [
                    ...args,
                    ...whereValues
                ]
            });
        } catch (error) {
            const errorDetails = {
                indexName
            };
            if ("id" in params && params.id) {
                errorDetails.id = params.id;
            }
            if ("filter" in params && params.filter) {
                errorDetails.filter = JSON.stringify(params.filter);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "UPDATE_VECTOR", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: errorDetails
            }, error);
        }
    }
    /**
   * Deletes a vector by its ID.
   * @param indexName - The name of the index containing the vector.
   * @param id - The ID of the vector to delete.
   * @returns A promise that resolves when the deletion is complete.
   * @throws Will throw an error if the deletion operation fails.
   */ deleteVector(args) {
        try {
            return this.executeWriteOperationWithRetry(()=>this.doDeleteVector(args));
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTOR", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName: args.indexName,
                    ...args.id && {
                        id: args.id
                    }
                }
            }, error);
        }
    }
    async doDeleteVector({ indexName, id }) {
        const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
        await this.turso.execute({
            sql: `DELETE FROM ${parsedIndexName} WHERE vector_id = ?`,
            args: [
                id
            ]
        });
    }
    deleteVectors(args) {
        return this.executeWriteOperationWithRetry(()=>this.doDeleteVectors(args));
    }
    async doDeleteVectors({ indexName, filter, ids }) {
        const parsedIndexName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name");
        if (!filter && !ids) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "NO_TARGET"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    indexName
                },
                text: "Either filter or ids must be provided"
            });
        }
        if (filter && ids) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "MUTUALLY_EXCLUSIVE"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    indexName
                },
                text: "Cannot provide both filter and ids - they are mutually exclusive"
            });
        }
        let query;
        let values;
        if (ids) {
            if (ids.length === 0) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "EMPTY_IDS"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName
                    },
                    text: "Cannot delete with empty ids array"
                });
            }
            const placeholders = ids.map(()=>"?").join(", ");
            query = `DELETE FROM ${parsedIndexName} WHERE vector_id IN (${placeholders})`;
            values = ids;
        } else {
            if (!filter || Object.keys(filter).length === 0) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "EMPTY_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName
                    },
                    text: "Cannot delete with empty filter. Use deleteIndex to delete all vectors."
                });
            }
            const translatedFilter = this.transformFilter(filter);
            const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);
            if (!filterSql || filterSql.trim() === "") {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "INVALID_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName
                    },
                    text: "Filter produced empty WHERE clause"
                });
            }
            const normalizedCondition = filterSql.replace(/^\s*WHERE\s+/i, "").trim().toLowerCase();
            const matchAllPatterns = [
                "true",
                "1 = 1",
                "1=1"
            ];
            if (matchAllPatterns.includes(normalizedCondition)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "MATCH_ALL_FILTER"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    details: {
                        indexName,
                        filterSql: normalizedCondition
                    },
                    text: "Filter matches all vectors. Use deleteIndex to delete all vectors from an index."
                });
            }
            query = `DELETE FROM ${parsedIndexName} ${filterSql}`;
            values = filterValues;
        }
        try {
            await this.turso.execute({
                sql: query,
                args: values
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "DELETE_VECTORS", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName,
                    ...filter && {
                        filter: JSON.stringify(filter)
                    },
                    ...ids && {
                        idsCount: ids.length
                    }
                }
            }, error);
        }
    }
    truncateIndex(args) {
        try {
            return this.executeWriteOperationWithRetry(()=>this._doTruncateIndex(args));
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createVectorErrorId"])("LIBSQL", "TRUNCATE_INDEX", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    indexName: args.indexName
                }
            }, error);
        }
    }
    async _doTruncateIndex({ indexName }) {
        await this.turso.execute({
            sql: `DELETE FROM ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(indexName, "index name")}`,
            args: []
        });
    }
};
function buildSelectColumns(tableName) {
    const schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName];
    return Object.keys(schema).map((col)=>{
        const colDef = schema[col];
        const parsedCol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(col, "column name");
        return colDef?.type === "jsonb" ? `json(${parsedCol}) as ${parsedCol}` : parsedCol;
    }).join(", ");
}
function isLockError(error) {
    return error.code === "SQLITE_BUSY" || error.code === "SQLITE_LOCKED" || error.message?.toLowerCase().includes("database is locked") || error.message?.toLowerCase().includes("database table is locked") || error.message?.toLowerCase().includes("table is locked") || error.constructor.name === "SqliteError" && error.message?.toLowerCase().includes("locked");
}
function createExecuteWriteOperationWithRetry({ logger, maxRetries, initialBackoffMs }) {
    return async function executeWriteOperationWithRetry(operationFn, operationDescription) {
        let attempts = 0;
        let backoff = initialBackoffMs;
        while(attempts < maxRetries){
            try {
                return await operationFn();
            } catch (error) {
                logger.debug(`LibSQLStore: Error caught in retry loop for ${operationDescription}`, {
                    errorType: error.constructor.name,
                    errorCode: error.code,
                    errorMessage: error.message,
                    attempts,
                    maxRetries
                });
                if (isLockError(error)) {
                    attempts++;
                    if (attempts >= maxRetries) {
                        logger.error(`LibSQLStore: Operation failed after ${maxRetries} attempts due to database lock: ${error.message}`, {
                            error,
                            attempts,
                            maxRetries
                        });
                        throw error;
                    }
                    logger.warn(`LibSQLStore: Attempt ${attempts} failed due to database lock during ${operationDescription}. Retrying in ${backoff}ms...`, {
                        errorMessage: error.message,
                        attempts,
                        backoff,
                        maxRetries
                    });
                    await new Promise((resolve)=>setTimeout(resolve, backoff));
                    backoff *= 2;
                } else {
                    logger.error(`LibSQLStore: Non-lock error during ${operationDescription}, not retrying`, {
                        error
                    });
                    throw error;
                }
            }
        }
        throw new Error(`LibSQLStore: Unexpected exit from retry loop for ${operationDescription}`);
    };
}
function prepareStatement({ tableName, record }) {
    const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
    const schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName];
    const columnNames = Object.keys(record);
    const columns = columnNames.map((col)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(col, "column name"));
    const values = columnNames.map((col)=>{
        const v = record[col];
        if (typeof v === `undefined` || v === null) {
            return null;
        }
        const colDef = schema[col];
        if (colDef?.type === "jsonb") {
            return JSON.stringify(v);
        }
        if (v instanceof Date) {
            return v.toISOString();
        }
        return typeof v === "object" ? JSON.stringify(v) : v;
    });
    const placeholders = columnNames.map((col)=>{
        const colDef = schema[col];
        return colDef?.type === "jsonb" ? "jsonb(?)" : "?";
    }).join(", ");
    return {
        sql: `INSERT OR REPLACE INTO ${parsedTableName} (${columns.join(", ")}) VALUES (${placeholders})`,
        args: values
    };
}
function prepareUpdateStatement({ tableName, updates, keys }) {
    const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
    const schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName];
    const updateColumnNames = Object.keys(updates);
    const updateColumns = updateColumnNames.map((col)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(col, "column name"));
    const updateValues = updateColumnNames.map((col)=>{
        const colDef = schema[col];
        const v = updates[col];
        if (colDef?.type === "jsonb") {
            return transformToSqlValue(v, true);
        }
        return transformToSqlValue(v, false);
    });
    const setClause = updateColumns.map((col, i)=>{
        const colDef = schema[updateColumnNames[i]];
        return colDef?.type === "jsonb" ? `${col} = jsonb(?)` : `${col} = ?`;
    }).join(", ");
    const whereClause = prepareWhereClause(keys, schema);
    return {
        sql: `UPDATE ${parsedTableName} SET ${setClause}${whereClause.sql}`,
        args: [
            ...updateValues,
            ...whereClause.args
        ]
    };
}
function transformToSqlValue(value, forceJsonStringify = false) {
    if (typeof value === "undefined" || value === null) {
        return null;
    }
    if (forceJsonStringify) {
        return JSON.stringify(value);
    }
    if (value instanceof Date) {
        return value.toISOString();
    }
    return typeof value === "object" ? JSON.stringify(value) : value;
}
function prepareDeleteStatement({ tableName, keys }) {
    const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
    const whereClause = prepareWhereClause(keys, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName]);
    return {
        sql: `DELETE FROM ${parsedTableName}${whereClause.sql}`,
        args: whereClause.args
    };
}
function prepareWhereClause(filters, schema) {
    const conditions = [];
    const args = [];
    for (const [columnName, filterValue] of Object.entries(filters)){
        const column = schema[columnName];
        if (!column) {
            throw new Error(`Unknown column: ${columnName}`);
        }
        const parsedColumn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(columnName, "column name");
        const result = buildCondition2(parsedColumn, filterValue);
        conditions.push(result.condition);
        args.push(...result.args);
    }
    return {
        sql: conditions.length > 0 ? ` WHERE ${conditions.join(" AND ")}` : "",
        args
    };
}
function buildCondition2(columnName, filterValue) {
    if (filterValue === null) {
        return {
            condition: `${columnName} IS NULL`,
            args: []
        };
    }
    if (typeof filterValue === "object" && filterValue !== null && ("startAt" in filterValue || "endAt" in filterValue)) {
        return buildDateRangeCondition(columnName, filterValue);
    }
    return {
        condition: `${columnName} = ?`,
        args: [
            transformToSqlValue(filterValue)
        ]
    };
}
function buildDateRangeCondition(columnName, range) {
    const conditions = [];
    const args = [];
    if (range.startAt !== void 0) {
        conditions.push(`${columnName} >= ?`);
        args.push(transformToSqlValue(range.startAt));
    }
    if (range.endAt !== void 0) {
        conditions.push(`${columnName} <= ?`);
        args.push(transformToSqlValue(range.endAt));
    }
    if (conditions.length === 0) {
        throw new Error("Date range must specify at least startAt or endAt");
    }
    return {
        condition: conditions.join(" AND "),
        args
    };
}
function transformFromSqlRow({ tableName, sqlRow }) {
    const result = {};
    const jsonColumns = new Set(Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName]).filter((key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName][key].type === "jsonb").map((key)=>key));
    const dateColumns = new Set(Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName]).filter((key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][tableName][key].type === "timestamp").map((key)=>key));
    for (const [key, value] of Object.entries(sqlRow)){
        if (value === null || value === void 0) {
            result[key] = value;
            continue;
        }
        if (dateColumns.has(key) && typeof value === "string") {
            result[key] = new Date(value);
            continue;
        }
        if (jsonColumns.has(key) && typeof value === "string") {
            result[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safelyParseJSON"])(value);
            continue;
        }
        result[key] = value;
    }
    return result;
}
// src/storage/db/index.ts
function resolveClient(config) {
    if ("client" in config) {
        return config.client;
    }
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__["createClient"])({
        url: config.url,
        ...config.authToken ? {
            authToken: config.authToken
        } : {}
    });
}
var LibSQLDB = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$LSHPJWM5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraBase"] {
    client;
    maxRetries;
    initialBackoffMs;
    executeWriteOperationWithRetry;
    constructor({ client, maxRetries, initialBackoffMs }){
        super({
            component: "STORAGE",
            name: "LIBSQL_DB_LAYER"
        });
        this.client = client;
        this.maxRetries = maxRetries ?? 5;
        this.initialBackoffMs = initialBackoffMs ?? 100;
        this.executeWriteOperationWithRetry = createExecuteWriteOperationWithRetry({
            logger: this.logger,
            maxRetries: this.maxRetries,
            initialBackoffMs: this.initialBackoffMs
        });
    }
    /**
   * Checks if a column exists in the specified table.
   *
   * @param table - The name of the table to check
   * @param column - The name of the column to look for
   * @returns `true` if the column exists in the table, `false` otherwise
   */ async hasColumn(table, column) {
        const sanitizedTable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(table, "table name");
        const result = await this.client.execute({
            sql: `PRAGMA table_info("${sanitizedTable}")`
        });
        return result.rows?.some((row)=>row.name === column);
    }
    /**
   * Internal insert implementation without retry logic.
   */ async doInsert({ tableName, record }) {
        await this.client.execute(prepareStatement({
            tableName,
            record
        }));
    }
    /**
   * Inserts or replaces a record in the specified table with automatic retry on lock errors.
   *
   * @param args - The insert arguments
   * @param args.tableName - The name of the table to insert into
   * @param args.record - The record to insert (key-value pairs)
   */ insert(args) {
        return this.executeWriteOperationWithRetry(()=>this.doInsert(args), `insert into table ${args.tableName}`);
    }
    /**
   * Internal update implementation without retry logic.
   */ async doUpdate({ tableName, keys, data }) {
        await this.client.execute(prepareUpdateStatement({
            tableName,
            updates: data,
            keys
        }));
    }
    /**
   * Updates a record in the specified table with automatic retry on lock errors.
   *
   * @param args - The update arguments
   * @param args.tableName - The name of the table to update
   * @param args.keys - The key(s) identifying the record to update
   * @param args.data - The fields to update (key-value pairs)
   */ update(args) {
        return this.executeWriteOperationWithRetry(()=>this.doUpdate(args), `update table ${args.tableName}`);
    }
    /**
   * Internal batch insert implementation without retry logic.
   */ async doBatchInsert({ tableName, records }) {
        if (records.length === 0) return;
        const batchStatements = records.map((r)=>prepareStatement({
                tableName,
                record: r
            }));
        await this.client.batch(batchStatements, "write");
    }
    /**
   * Inserts multiple records in a single batch transaction with automatic retry on lock errors.
   *
   * @param args - The batch insert arguments
   * @param args.tableName - The name of the table to insert into
   * @param args.records - Array of records to insert
   * @throws {MastraError} When the batch insert fails after retries
   */ async batchInsert(args) {
        return this.executeWriteOperationWithRetry(()=>this.doBatchInsert(args), `batch insert into table ${args.tableName}`).catch((error)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_INSERT", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName: args.tableName
                }
            }, error);
        });
    }
    /**
   * Internal batch update implementation without retry logic.
   * Each record can be updated based on single or composite keys.
   */ async doBatchUpdate({ tableName, updates }) {
        if (updates.length === 0) return;
        const batchStatements = updates.map(({ keys, data })=>prepareUpdateStatement({
                tableName,
                updates: data,
                keys
            }));
        await this.client.batch(batchStatements, "write");
    }
    /**
   * Updates multiple records in a single batch transaction with automatic retry on lock errors.
   * Each record can be updated based on single or composite keys.
   *
   * @param args - The batch update arguments
   * @param args.tableName - The name of the table to update
   * @param args.updates - Array of update operations, each containing keys and data
   * @throws {MastraError} When the batch update fails after retries
   */ async batchUpdate(args) {
        return this.executeWriteOperationWithRetry(()=>this.doBatchUpdate(args), `batch update in table ${args.tableName}`).catch((error)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_UPDATE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName: args.tableName
                }
            }, error);
        });
    }
    /**
   * Internal batch delete implementation without retry logic.
   * Each record can be deleted based on single or composite keys.
   */ async doBatchDelete({ tableName, keys }) {
        if (keys.length === 0) return;
        const batchStatements = keys.map((keyObj)=>prepareDeleteStatement({
                tableName,
                keys: keyObj
            }));
        await this.client.batch(batchStatements, "write");
    }
    /**
   * Deletes multiple records in a single batch transaction with automatic retry on lock errors.
   * Each record can be deleted based on single or composite keys.
   *
   * @param args - The batch delete arguments
   * @param args.tableName - The name of the table to delete from
   * @param args.keys - Array of key objects identifying records to delete
   * @throws {MastraError} When the batch delete fails after retries
   */ async batchDelete({ tableName, keys }) {
        return this.executeWriteOperationWithRetry(()=>this.doBatchDelete({
                tableName,
                keys
            }), `batch delete from table ${tableName}`).catch((error)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_DELETE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName
                }
            }, error);
        });
    }
    /**
   * Internal single-record delete implementation without retry logic.
   */ async doDelete({ tableName, keys }) {
        await this.client.execute(prepareDeleteStatement({
            tableName,
            keys
        }));
    }
    /**
   * Deletes a single record from the specified table with automatic retry on lock errors.
   *
   * @param args - The delete arguments
   * @param args.tableName - The name of the table to delete from
   * @param args.keys - The key(s) identifying the record to delete
   * @throws {MastraError} When the delete fails after retries
   */ async delete(args) {
        return this.executeWriteOperationWithRetry(()=>this.doDelete(args), `delete from table ${args.tableName}`).catch((error)=>{
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "DELETE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName: args.tableName
                }
            }, error);
        });
    }
    /**
   * Selects a single record from the specified table by key(s).
   * Returns the most recently created record if multiple matches exist.
   * Automatically parses JSON string values back to objects/arrays.
   *
   * @typeParam R - The expected return type of the record
   * @param args - The select arguments
   * @param args.tableName - The name of the table to select from
   * @param args.keys - The key(s) identifying the record to select
   * @returns The matching record or `null` if not found
   */ async select({ tableName, keys }) {
        const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
        const columns = buildSelectColumns(tableName);
        const parsedKeys = Object.keys(keys).map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(key, "column name"));
        const conditions = parsedKeys.map((key)=>`${key} = ?`).join(" AND ");
        const values = Object.values(keys);
        const result = await this.client.execute({
            sql: `SELECT ${columns} FROM ${parsedTableName} WHERE ${conditions} ORDER BY createdAt DESC LIMIT 1`,
            args: values
        });
        if (!result.rows || result.rows.length === 0) {
            return null;
        }
        const row = result.rows[0];
        const parsed = Object.fromEntries(Object.entries(row || {}).map(([k, v])=>{
            try {
                return [
                    k,
                    typeof v === "string" ? v.startsWith("{") || v.startsWith("[") ? JSON.parse(v) : v : v
                ];
            } catch  {
                return [
                    k,
                    v
                ];
            }
        }));
        return parsed;
    }
    /**
   * Selects multiple records from the specified table with optional filtering, ordering, and pagination.
   *
   * @typeParam R - The expected return type of each record
   * @param args - The select arguments
   * @param args.tableName - The name of the table to select from
   * @param args.whereClause - Optional WHERE clause with SQL string and arguments
   * @param args.orderBy - Optional ORDER BY clause (e.g., "createdAt DESC")
   * @param args.offset - Optional offset for pagination
   * @param args.limit - Optional limit for pagination
   * @param args.args - Optional additional query arguments
   * @returns Array of matching records
   */ async selectMany({ tableName, whereClause, orderBy, offset, limit, args }) {
        const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
        const columns = buildSelectColumns(tableName);
        let statement = `SELECT ${columns} FROM ${parsedTableName}`;
        if (whereClause?.sql) {
            statement += ` ${whereClause.sql}`;
        }
        if (orderBy) {
            statement += ` ORDER BY ${orderBy}`;
        }
        if (limit) {
            statement += ` LIMIT ${limit}`;
        }
        if (offset) {
            statement += ` OFFSET ${offset}`;
        }
        const result = await this.client.execute({
            sql: statement,
            args: [
                ...whereClause?.args ?? [],
                ...args ?? []
            ]
        });
        return (result.rows ?? []).map((row)=>{
            return Object.fromEntries(Object.entries(row || {}).map(([k, v])=>{
                try {
                    return [
                        k,
                        typeof v === "string" ? v.startsWith("{") || v.startsWith("[") ? JSON.parse(v) : v : v
                    ];
                } catch  {
                    return [
                        k,
                        v
                    ];
                }
            }));
        });
    }
    /**
   * Returns the total count of records matching the optional WHERE clause.
   *
   * @param args - The count arguments
   * @param args.tableName - The name of the table to count from
   * @param args.whereClause - Optional WHERE clause with SQL string and arguments
   * @returns The total count of matching records
   */ async selectTotalCount({ tableName, whereClause }) {
        const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
        const statement = `SELECT COUNT(*) as count FROM ${parsedTableName} ${whereClause ? `${whereClause.sql}` : ""}`;
        const result = await this.client.execute({
            sql: statement,
            args: whereClause?.args ?? []
        });
        if (!result.rows || result.rows.length === 0) {
            return 0;
        }
        return result.rows[0]?.count ?? 0;
    }
    /**
   * Maps a storage column type to its SQLite equivalent.
   */ getSqlType(type) {
        switch(type){
            case "bigint":
                return "INTEGER";
            // SQLite uses INTEGER for all integer sizes
            case "timestamp":
                return "TEXT";
            // Store timestamps as ISO strings in SQLite
            case "float":
                return "REAL";
            // SQLite's floating point type
            case "boolean":
                return "INTEGER";
            // SQLite uses 0/1 for booleans
            case "jsonb":
                return "TEXT";
            // SQLite: column stores TEXT, we use jsonb()/json() functions for binary optimization
            default:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSqlType"])(type);
        }
    }
    /**
   * Creates a table if it doesn't exist based on the provided schema.
   *
   * @param args - The create table arguments
   * @param args.tableName - The name of the table to create
   * @param args.schema - The schema definition for the table columns
   */ async createTable({ tableName, schema }) {
        try {
            const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
            const columnDefinitions = Object.entries(schema).map(([colName, colDef])=>{
                const type = this.getSqlType(colDef.type);
                const nullable = colDef.nullable === false ? "NOT NULL" : "";
                const primaryKey = colDef.primaryKey ? "PRIMARY KEY" : "";
                return `"${colName}" ${type} ${nullable} ${primaryKey}`.trim();
            });
            const tableConstraints = [];
            if (tableName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]) {
                tableConstraints.push("UNIQUE (workflow_name, run_id)");
            }
            const allDefinitions = [
                ...columnDefinitions,
                ...tableConstraints
            ].join(",\n  ");
            const sql = `CREATE TABLE IF NOT EXISTS ${parsedTableName} (
  ${allDefinitions}
)`;
            await this.client.execute(sql);
            this.logger.debug(`LibSQLDB: Created table ${tableName}`);
            if (tableName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]) {
                await this.migrateSpansTable();
            }
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CREATE_TABLE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName
                }
            }, error);
        }
    }
    /**
   * Migrates the spans table schema from OLD_SPAN_SCHEMA to current SPAN_SCHEMA.
   * This adds new columns that don't exist in old schema.
   */ async migrateSpansTable() {
        const schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]];
        try {
            for (const [columnName, columnDef] of Object.entries(schema)){
                const columnExists = await this.hasColumn(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"], columnName);
                if (!columnExists) {
                    const sqlType = this.getSqlType(columnDef.type);
                    const alterSql = `ALTER TABLE "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]}" ADD COLUMN "${columnName}" ${sqlType}`;
                    await this.client.execute(alterSql);
                    this.logger.debug(`LibSQLDB: Added column '${columnName}' to ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]}`);
                }
            }
            this.logger.info(`LibSQLDB: Migration completed for ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]}`);
        } catch (error) {
            this.logger.warn(`LibSQLDB: Failed to migrate spans table ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]}:`, error);
        }
    }
    /**
   * Gets a default value for a column type (used when adding NOT NULL columns).
   */ getDefaultValue(type) {
        switch(type){
            case "text":
            case "uuid":
                return "DEFAULT ''";
            case "integer":
            case "bigint":
            case "float":
                return "DEFAULT 0";
            case "boolean":
                return "DEFAULT 0";
            case "jsonb":
                return "DEFAULT '{}'";
            case "timestamp":
                return "DEFAULT CURRENT_TIMESTAMP";
            default:
                return "DEFAULT ''";
        }
    }
    /**
   * Alters an existing table to add missing columns.
   * Used for schema migrations when new columns are added.
   *
   * @param args - The alter table arguments
   * @param args.tableName - The name of the table to alter
   * @param args.schema - The full schema definition for the table
   * @param args.ifNotExists - Array of column names to add if they don't exist
   */ async alterTable({ tableName, schema, ifNotExists }) {
        const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
        try {
            const tableInfo = await this.client.execute({
                sql: `PRAGMA table_info("${parsedTableName}")`
            });
            const existingColumns = new Set((tableInfo.rows || []).map((row)=>row.name?.toLowerCase()));
            for (const columnName of ifNotExists){
                if (!existingColumns.has(columnName.toLowerCase()) && schema[columnName]) {
                    const columnDef = schema[columnName];
                    const sqlType = this.getSqlType(columnDef.type);
                    const defaultValue = this.getDefaultValue(columnDef.type);
                    const alterSql = `ALTER TABLE ${parsedTableName} ADD COLUMN "${columnName}" ${sqlType} ${defaultValue}`;
                    await this.client.execute(alterSql);
                    this.logger.debug(`LibSQLDB: Added column ${columnName} to table ${tableName}`);
                }
            }
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "ALTER_TABLE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName
                }
            }, error);
        }
    }
    /**
   * Deletes all records from the specified table.
   * Errors are logged but not thrown.
   *
   * @param args - The delete arguments
   * @param args.tableName - The name of the table to clear
   */ async deleteData({ tableName }) {
        const parsedTableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(tableName, "table name");
        try {
            await this.client.execute(`DELETE FROM ${parsedTableName}`);
        } catch (e) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CLEAR_TABLE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    tableName
                }
            }, e);
            this.logger?.trackException?.(mastraError);
            this.logger?.error?.(mastraError.toString());
        }
    }
};
// src/storage/domains/agents/index.ts
var AgentsLibSQL = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AgentsStorage"] {
    #db;
    constructor(config){
        super();
        const client = resolveClient(config);
        this.#db = new LibSQLDB({
            client,
            maxRetries: config.maxRetries,
            initialBackoffMs: config.initialBackoffMs
        });
    }
    async init() {
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AGENTS_SCHEMA"]
        });
    }
    async dangerouslyClearAll() {
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"]
        });
    }
    parseJson(value, fieldName) {
        if (!value) return void 0;
        if (typeof value !== "string") return value;
        try {
            return JSON.parse(value);
        } catch (error) {
            const details = {
                value: value.length > 100 ? value.substring(0, 100) + "..." : value
            };
            if (fieldName) {
                details.field = fieldName;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "PARSE_JSON", "INVALID_JSON"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].SYSTEM,
                text: `Failed to parse JSON${fieldName ? ` for field "${fieldName}"` : ""}: ${error instanceof Error ? error.message : "Unknown error"}`,
                details
            }, error);
        }
    }
    parseRow(row) {
        return {
            id: row.id,
            name: row.name,
            description: row.description,
            instructions: row.instructions,
            model: this.parseJson(row.model, "model"),
            tools: this.parseJson(row.tools, "tools"),
            defaultOptions: this.parseJson(row.defaultOptions, "defaultOptions"),
            workflows: this.parseJson(row.workflows, "workflows"),
            agents: this.parseJson(row.agents, "agents"),
            inputProcessors: this.parseJson(row.inputProcessors, "inputProcessors"),
            outputProcessors: this.parseJson(row.outputProcessors, "outputProcessors"),
            memory: this.parseJson(row.memory, "memory"),
            scorers: this.parseJson(row.scorers, "scorers"),
            metadata: this.parseJson(row.metadata, "metadata"),
            createdAt: new Date(row.createdAt),
            updatedAt: new Date(row.updatedAt)
        };
    }
    async getAgentById({ id }) {
        try {
            const result = await this.#db.select({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
                keys: {
                    id
                }
            });
            return result ? this.parseRow(result) : null;
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_AGENT_BY_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    agentId: id
                }
            }, error);
        }
    }
    async createAgent({ agent }) {
        try {
            const now = /* @__PURE__ */ new Date();
            await this.#db.insert({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
                record: {
                    id: agent.id,
                    name: agent.name,
                    description: agent.description ?? null,
                    instructions: agent.instructions,
                    model: agent.model,
                    tools: agent.tools ?? null,
                    defaultOptions: agent.defaultOptions ?? null,
                    workflows: agent.workflows ?? null,
                    agents: agent.agents ?? null,
                    inputProcessors: agent.inputProcessors ?? null,
                    outputProcessors: agent.outputProcessors ?? null,
                    memory: agent.memory ?? null,
                    scorers: agent.scorers ?? null,
                    metadata: agent.metadata ?? null,
                    createdAt: now,
                    updatedAt: now
                }
            });
            return {
                ...agent,
                createdAt: now,
                updatedAt: now
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CREATE_AGENT", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    agentId: agent.id
                }
            }, error);
        }
    }
    async updateAgent({ id, ...updates }) {
        try {
            const existingAgent = await this.getAgentById({
                id
            });
            if (!existingAgent) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_AGENT", "NOT_FOUND"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                    text: `Agent ${id} not found`,
                    details: {
                        agentId: id
                    }
                });
            }
            const data = {
                updatedAt: /* @__PURE__ */ new Date()
            };
            if (updates.name !== void 0) data.name = updates.name;
            if (updates.description !== void 0) data.description = updates.description;
            if (updates.instructions !== void 0) data.instructions = updates.instructions;
            if (updates.model !== void 0) data.model = updates.model;
            if (updates.tools !== void 0) data.tools = updates.tools;
            if (updates.defaultOptions !== void 0) data.defaultOptions = updates.defaultOptions;
            if (updates.workflows !== void 0) data.workflows = updates.workflows;
            if (updates.agents !== void 0) data.agents = updates.agents;
            if (updates.inputProcessors !== void 0) data.inputProcessors = updates.inputProcessors;
            if (updates.outputProcessors !== void 0) data.outputProcessors = updates.outputProcessors;
            if (updates.memory !== void 0) data.memory = updates.memory;
            if (updates.scorers !== void 0) data.scorers = updates.scorers;
            if (updates.metadata !== void 0) {
                data.metadata = {
                    ...existingAgent.metadata,
                    ...updates.metadata
                };
            }
            if (Object.keys(data).length > 1) {
                await this.#db.update({
                    tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
                    keys: {
                        id
                    },
                    data
                });
            }
            const updatedAgent = await this.getAgentById({
                id
            });
            if (!updatedAgent) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_AGENT", "NOT_FOUND_AFTER_UPDATE"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].SYSTEM,
                    text: `Agent ${id} not found after update`,
                    details: {
                        agentId: id
                    }
                });
            }
            return updatedAgent;
        } catch (error) {
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]) {
                throw error;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_AGENT", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    agentId: id
                }
            }, error);
        }
    }
    async deleteAgent({ id }) {
        try {
            await this.#db.delete({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
                keys: {
                    id
                }
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "DELETE_AGENT", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    agentId: id
                }
            }, error);
        }
    }
    async listAgents(args) {
        const { page = 0, perPage: perPageInput, orderBy } = args || {};
        const { field, direction } = this.parseOrderBy(orderBy);
        if (page < 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_AGENTS", "INVALID_PAGE"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    page
                }
            }, new Error("page must be >= 0"));
        }
        const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
        const { offset, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
        try {
            const total = await this.#db.selectTotalCount({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"]
            });
            if (total === 0) {
                return {
                    agents: [],
                    total: 0,
                    page,
                    perPage: perPageForResponse,
                    hasMore: false
                };
            }
            const limitValue = perPageInput === false ? total : perPage;
            const rows = await this.#db.selectMany({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_AGENTS"],
                orderBy: `"${field}" ${direction}`,
                limit: limitValue,
                offset
            });
            const agents = rows.map((row)=>this.parseRow(row));
            return {
                agents,
                total,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : offset + perPage < total
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_AGENTS", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
};
var MemoryLibSQL = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MemoryStorage"] {
    #client;
    #db;
    constructor(config){
        super();
        const client = resolveClient(config);
        this.#client = client;
        this.#db = new LibSQLDB({
            client,
            maxRetries: config.maxRetries,
            initialBackoffMs: config.initialBackoffMs
        });
    }
    async init() {
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]]
        });
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]]
        });
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"]]
        });
        await this.#db.alterTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]],
            ifNotExists: [
                "resourceId"
            ]
        });
    }
    async dangerouslyClearAll() {
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]
        });
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]
        });
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"]
        });
    }
    parseRow(row) {
        let content = row.content;
        try {
            content = JSON.parse(row.content);
        } catch  {}
        const result = {
            id: row.id,
            content,
            role: row.role,
            createdAt: new Date(row.createdAt),
            threadId: row.thread_id,
            resourceId: row.resourceId
        };
        if (row.type && row.type !== `v2`) result.type = row.type;
        return result;
    }
    async _getIncludedMessages({ include }) {
        if (!include || include.length === 0) return null;
        const unionQueries = [];
        const params = [];
        for (const inc of include){
            const { id, withPreviousMessages = 0, withNextMessages = 0 } = inc;
            unionQueries.push(`
                SELECT * FROM (
                  WITH target_thread AS (
                    SELECT thread_id FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" WHERE id = ?
                  ),
                  numbered_messages AS (
                    SELECT
                      id, content, role, type, "createdAt", thread_id, "resourceId",
                      ROW_NUMBER() OVER (ORDER BY "createdAt" ASC) as row_num
                    FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}"
                    WHERE thread_id = (SELECT thread_id FROM target_thread)
                  ),
                  target_positions AS (
                    SELECT row_num as target_pos
                    FROM numbered_messages
                    WHERE id = ?
                  )
                  SELECT DISTINCT m.*
                  FROM numbered_messages m
                  CROSS JOIN target_positions t
                  WHERE m.row_num BETWEEN (t.target_pos - ?) AND (t.target_pos + ?)
                ) 
                `);
            params.push(id, id, withPreviousMessages, withNextMessages);
        }
        const finalQuery = unionQueries.join(" UNION ALL ") + ' ORDER BY "createdAt" ASC';
        const includedResult = await this.#client.execute({
            sql: finalQuery,
            args: params
        });
        const includedRows = includedResult.rows?.map((row)=>this.parseRow(row));
        const seen = /* @__PURE__ */ new Set();
        const dedupedRows = includedRows.filter((row)=>{
            if (seen.has(row.id)) return false;
            seen.add(row.id);
            return true;
        });
        return dedupedRows;
    }
    async listMessagesById({ messageIds }) {
        if (messageIds.length === 0) return {
            messages: []
        };
        try {
            const sql = `
        SELECT 
          id, 
          content, 
          role, 
          type,
          "createdAt", 
          thread_id,
          "resourceId"
        FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}"
        WHERE id IN (${messageIds.map(()=>"?").join(", ")})
        ORDER BY "createdAt" DESC
      `;
            const result = await this.#client.execute({
                sql,
                args: messageIds
            });
            if (!result.rows) return {
                messages: []
            };
            const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]().add(result.rows.map(this.parseRow), "memory");
            return {
                messages: list.get.all.db()
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_MESSAGES_BY_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    messageIds: JSON.stringify(messageIds)
                }
            }, error);
        }
    }
    async listMessages(args) {
        const { threadId, resourceId, include, filter, perPage: perPageInput, page = 0, orderBy } = args;
        const threadIds = Array.isArray(threadId) ? threadId : [
            threadId
        ];
        if (threadIds.length === 0 || threadIds.some((id)=>!id.trim())) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_MESSAGES", "INVALID_THREAD_ID"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    threadId: Array.isArray(threadId) ? threadId.join(",") : threadId
                }
            }, new Error("threadId must be a non-empty string or array of non-empty strings"));
        }
        if (page < 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_MESSAGES", "INVALID_PAGE"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    page
                }
            }, new Error("page must be >= 0"));
        }
        const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 40);
        const { offset, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
        try {
            const { field, direction } = this.parseOrderBy(orderBy, "ASC");
            const orderByStatement = `ORDER BY "${field}" ${direction}`;
            const threadPlaceholders = threadIds.map(()=>"?").join(", ");
            const conditions = [
                `thread_id IN (${threadPlaceholders})`
            ];
            const queryParams = [
                ...threadIds
            ];
            if (resourceId) {
                conditions.push(`"resourceId" = ?`);
                queryParams.push(resourceId);
            }
            if (filter?.dateRange?.start) {
                const startOp = filter.dateRange.startExclusive ? ">" : ">=";
                conditions.push(`"createdAt" ${startOp} ?`);
                queryParams.push(filter.dateRange.start instanceof Date ? filter.dateRange.start.toISOString() : filter.dateRange.start);
            }
            if (filter?.dateRange?.end) {
                const endOp = filter.dateRange.endExclusive ? "<" : "<=";
                conditions.push(`"createdAt" ${endOp} ?`);
                queryParams.push(filter.dateRange.end instanceof Date ? filter.dateRange.end.toISOString() : filter.dateRange.end);
            }
            const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
            const countResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]} ${whereClause}`,
                args: queryParams
            });
            const total = Number(countResult.rows?.[0]?.count ?? 0);
            const limitValue = perPageInput === false ? total : perPage;
            const dataResult = await this.#client.execute({
                sql: `SELECT id, content, role, type, "createdAt", "resourceId", "thread_id" FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]} ${whereClause} ${orderByStatement} LIMIT ? OFFSET ?`,
                args: [
                    ...queryParams,
                    limitValue,
                    offset
                ]
            });
            const messages = (dataResult.rows || []).map((row)=>this.parseRow(row));
            if (total === 0 && messages.length === 0 && (!include || include.length === 0)) {
                return {
                    messages: [],
                    total: 0,
                    page,
                    perPage: perPageForResponse,
                    hasMore: false
                };
            }
            const messageIds = new Set(messages.map((m)=>m.id));
            if (include && include.length > 0) {
                const includeMessages = await this._getIncludedMessages({
                    include
                });
                if (includeMessages) {
                    for (const includeMsg of includeMessages){
                        if (!messageIds.has(includeMsg.id)) {
                            messages.push(includeMsg);
                            messageIds.add(includeMsg.id);
                        }
                    }
                }
            }
            const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]().add(messages, "memory");
            let finalMessages = list.get.all.db();
            finalMessages = finalMessages.sort((a, b)=>{
                const isDateField = field === "createdAt" || field === "updatedAt";
                const aValue = isDateField ? new Date(a[field]).getTime() : a[field];
                const bValue = isDateField ? new Date(b[field]).getTime() : b[field];
                if (typeof aValue === "number" && typeof bValue === "number") {
                    return direction === "ASC" ? aValue - bValue : bValue - aValue;
                }
                return direction === "ASC" ? String(aValue).localeCompare(String(bValue)) : String(bValue).localeCompare(String(aValue));
            });
            const threadIdSet = new Set(threadIds);
            const returnedThreadMessageIds = new Set(finalMessages.filter((m)=>m.threadId && threadIdSet.has(m.threadId)).map((m)=>m.id));
            const allThreadMessagesReturned = returnedThreadMessageIds.size >= total;
            const hasMore = perPageInput !== false && !allThreadMessagesReturned && offset + perPage < total;
            return {
                messages: finalMessages,
                total,
                page,
                perPage: perPageForResponse,
                hasMore
            };
        } catch (error) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_MESSAGES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    threadId: Array.isArray(threadId) ? threadId.join(",") : threadId,
                    resourceId: resourceId ?? ""
                }
            }, error);
            this.logger?.error?.(mastraError.toString());
            this.logger?.trackException?.(mastraError);
            return {
                messages: [],
                total: 0,
                page,
                perPage: perPageForResponse,
                hasMore: false
            };
        }
    }
    async saveMessages({ messages }) {
        if (messages.length === 0) return {
            messages
        };
        try {
            const threadId = messages[0]?.threadId;
            if (!threadId) {
                throw new Error("Thread ID is required");
            }
            const batchStatements = messages.map((message)=>{
                const time = message.createdAt || /* @__PURE__ */ new Date();
                if (!message.threadId) {
                    throw new Error(`Expected to find a threadId for message, but couldn't find one. An unexpected error has occurred.`);
                }
                if (!message.resourceId) {
                    throw new Error(`Expected to find a resourceId for message, but couldn't find one. An unexpected error has occurred.`);
                }
                return {
                    sql: `INSERT INTO "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" (id, thread_id, content, role, type, "createdAt", "resourceId") 
                  VALUES (?, ?, ?, ?, ?, ?, ?)
                  ON CONFLICT(id) DO UPDATE SET
                    thread_id=excluded.thread_id,
                    content=excluded.content,
                    role=excluded.role,
                    type=excluded.type,
                    "resourceId"=excluded."resourceId"
                `,
                    args: [
                        message.id,
                        message.threadId,
                        typeof message.content === "object" ? JSON.stringify(message.content) : message.content,
                        message.role,
                        message.type || "v2",
                        time instanceof Date ? time.toISOString() : time,
                        message.resourceId
                    ]
                };
            });
            const now = /* @__PURE__ */ new Date().toISOString();
            batchStatements.push({
                sql: `UPDATE "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]}" SET "updatedAt" = ? WHERE id = ?`,
                args: [
                    now,
                    threadId
                ]
            });
            const BATCH_SIZE = 50;
            const messageStatements = batchStatements.slice(0, -1);
            const threadUpdateStatement = batchStatements[batchStatements.length - 1];
            for(let i = 0; i < messageStatements.length; i += BATCH_SIZE){
                const batch = messageStatements.slice(i, i + BATCH_SIZE);
                if (batch.length > 0) {
                    await this.#client.batch(batch, "write");
                }
            }
            if (threadUpdateStatement) {
                await this.#client.execute(threadUpdateStatement);
            }
            const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]().add(messages, "memory");
            return {
                messages: list.get.all.db()
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "SAVE_MESSAGES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async updateMessages({ messages }) {
        if (messages.length === 0) {
            return [];
        }
        const messageIds = messages.map((m)=>m.id);
        const placeholders = messageIds.map(()=>"?").join(",");
        const selectSql = `SELECT * FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]} WHERE id IN (${placeholders})`;
        const existingResult = await this.#client.execute({
            sql: selectSql,
            args: messageIds
        });
        const existingMessages = existingResult.rows.map((row)=>this.parseRow(row));
        if (existingMessages.length === 0) {
            return [];
        }
        const batchStatements = [];
        const threadIdsToUpdate = /* @__PURE__ */ new Set();
        const columnMapping = {
            threadId: "thread_id"
        };
        for (const existingMessage of existingMessages){
            const updatePayload = messages.find((m)=>m.id === existingMessage.id);
            if (!updatePayload) continue;
            const { id, ...fieldsToUpdate } = updatePayload;
            if (Object.keys(fieldsToUpdate).length === 0) continue;
            threadIdsToUpdate.add(existingMessage.threadId);
            if (updatePayload.threadId && updatePayload.threadId !== existingMessage.threadId) {
                threadIdsToUpdate.add(updatePayload.threadId);
            }
            const setClauses = [];
            const args = [];
            const updatableFields = {
                ...fieldsToUpdate
            };
            if (updatableFields.content) {
                const newContent = {
                    ...existingMessage.content,
                    ...updatableFields.content,
                    // Deep merge metadata if it exists on both
                    ...existingMessage.content?.metadata && updatableFields.content.metadata ? {
                        metadata: {
                            ...existingMessage.content.metadata,
                            ...updatableFields.content.metadata
                        }
                    } : {}
                };
                setClauses.push(`${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])("content", "column name")} = ?`);
                args.push(JSON.stringify(newContent));
                delete updatableFields.content;
            }
            for(const key in updatableFields){
                if (Object.prototype.hasOwnProperty.call(updatableFields, key)) {
                    const dbKey = columnMapping[key] || key;
                    setClauses.push(`${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(dbKey, "column name")} = ?`);
                    let value = updatableFields[key];
                    if (typeof value === "object" && value !== null) {
                        value = JSON.stringify(value);
                    }
                    args.push(value);
                }
            }
            if (setClauses.length === 0) continue;
            args.push(id);
            const sql = `UPDATE ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]} SET ${setClauses.join(", ")} WHERE id = ?`;
            batchStatements.push({
                sql,
                args
            });
        }
        if (batchStatements.length === 0) {
            return existingMessages;
        }
        const now = /* @__PURE__ */ new Date().toISOString();
        for (const threadId of threadIdsToUpdate){
            if (threadId) {
                batchStatements.push({
                    sql: `UPDATE ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]} SET updatedAt = ? WHERE id = ?`,
                    args: [
                        now,
                        threadId
                    ]
                });
            }
        }
        await this.#client.batch(batchStatements, "write");
        const updatedResult = await this.#client.execute({
            sql: selectSql,
            args: messageIds
        });
        return updatedResult.rows.map((row)=>this.parseRow(row));
    }
    async deleteMessages(messageIds) {
        if (!messageIds || messageIds.length === 0) {
            return;
        }
        try {
            const BATCH_SIZE = 100;
            const threadIds = /* @__PURE__ */ new Set();
            const tx = await this.#client.transaction("write");
            try {
                for(let i = 0; i < messageIds.length; i += BATCH_SIZE){
                    const batch = messageIds.slice(i, i + BATCH_SIZE);
                    const placeholders = batch.map(()=>"?").join(",");
                    const result = await tx.execute({
                        sql: `SELECT DISTINCT thread_id FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" WHERE id IN (${placeholders})`,
                        args: batch
                    });
                    result.rows?.forEach((row)=>{
                        if (row.thread_id) threadIds.add(row.thread_id);
                    });
                    await tx.execute({
                        sql: `DELETE FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" WHERE id IN (${placeholders})`,
                        args: batch
                    });
                }
                if (threadIds.size > 0) {
                    const now = /* @__PURE__ */ new Date().toISOString();
                    for (const threadId of threadIds){
                        await tx.execute({
                            sql: `UPDATE "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]}" SET "updatedAt" = ? WHERE id = ?`,
                            args: [
                                now,
                                threadId
                            ]
                        });
                    }
                }
                await tx.commit();
            } catch (error) {
                await tx.rollback();
                throw error;
            }
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "DELETE_MESSAGES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    messageIds: messageIds.join(", ")
                }
            }, error);
        }
    }
    async getResourceById({ resourceId }) {
        const result = await this.#db.select({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"],
            keys: {
                id: resourceId
            }
        });
        if (!result) {
            return null;
        }
        return {
            ...result,
            // Ensure workingMemory is always returned as a string, even if auto-parsed as JSON
            workingMemory: result.workingMemory && typeof result.workingMemory === "object" ? JSON.stringify(result.workingMemory) : result.workingMemory,
            metadata: typeof result.metadata === "string" ? JSON.parse(result.metadata) : result.metadata,
            createdAt: new Date(result.createdAt),
            updatedAt: new Date(result.updatedAt)
        };
    }
    async saveResource({ resource }) {
        await this.#db.insert({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"],
            record: {
                ...resource
            }
        });
        return resource;
    }
    async updateResource({ resourceId, workingMemory, metadata }) {
        const existingResource = await this.getResourceById({
            resourceId
        });
        if (!existingResource) {
            const newResource = {
                id: resourceId,
                workingMemory,
                metadata: metadata || {},
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
            };
            return this.saveResource({
                resource: newResource
            });
        }
        const updatedResource = {
            ...existingResource,
            workingMemory: workingMemory !== void 0 ? workingMemory : existingResource.workingMemory,
            metadata: {
                ...existingResource.metadata,
                ...metadata
            },
            updatedAt: /* @__PURE__ */ new Date()
        };
        const updates = [];
        const values = [];
        if (workingMemory !== void 0) {
            updates.push("workingMemory = ?");
            values.push(workingMemory);
        }
        if (metadata) {
            updates.push("metadata = jsonb(?)");
            values.push(JSON.stringify(updatedResource.metadata));
        }
        updates.push("updatedAt = ?");
        values.push(updatedResource.updatedAt.toISOString());
        values.push(resourceId);
        await this.#client.execute({
            sql: `UPDATE ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_RESOURCES"]} SET ${updates.join(", ")} WHERE id = ?`,
            args: values
        });
        return updatedResource;
    }
    async getThreadById({ threadId }) {
        try {
            const result = await this.#db.select({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"],
                keys: {
                    id: threadId
                }
            });
            if (!result) {
                return null;
            }
            return {
                ...result,
                metadata: typeof result.metadata === "string" ? JSON.parse(result.metadata) : result.metadata,
                createdAt: new Date(result.createdAt),
                updatedAt: new Date(result.updatedAt)
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_THREAD_BY_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    threadId
                }
            }, error);
        }
    }
    async listThreadsByResourceId(args) {
        const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;
        if (page < 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_THREADS_BY_RESOURCE_ID", "INVALID_PAGE"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    page
                }
            }, new Error("page must be >= 0"));
        }
        const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
        const { offset, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
        const { field, direction } = this.parseOrderBy(orderBy);
        try {
            const baseQuery = `FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]} WHERE resourceId = ?`;
            const queryParams = [
                resourceId
            ];
            const mapRowToStorageThreadType = (row)=>({
                    id: row.id,
                    resourceId: row.resourceId,
                    title: row.title,
                    createdAt: new Date(row.createdAt),
                    // Convert string to Date
                    updatedAt: new Date(row.updatedAt),
                    // Convert string to Date
                    metadata: typeof row.metadata === "string" ? JSON.parse(row.metadata) : row.metadata
                });
            const countResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count ${baseQuery}`,
                args: queryParams
            });
            const total = Number(countResult.rows?.[0]?.count ?? 0);
            if (total === 0) {
                return {
                    threads: [],
                    total: 0,
                    page,
                    perPage: perPageForResponse,
                    hasMore: false
                };
            }
            const limitValue = perPageInput === false ? total : perPage;
            const dataResult = await this.#client.execute({
                sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"])} ${baseQuery} ORDER BY "${field}" ${direction} LIMIT ? OFFSET ?`,
                args: [
                    ...queryParams,
                    limitValue,
                    offset
                ]
            });
            const threads = (dataResult.rows || []).map(mapRowToStorageThreadType);
            return {
                threads,
                total,
                page,
                perPage: perPageForResponse,
                hasMore: perPageInput === false ? false : offset + perPage < total
            };
        } catch (error) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_THREADS_BY_RESOURCE_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    resourceId
                }
            }, error);
            this.logger?.trackException?.(mastraError);
            this.logger?.error?.(mastraError.toString());
            return {
                threads: [],
                total: 0,
                page,
                perPage: perPageForResponse,
                hasMore: false
            };
        }
    }
    async saveThread({ thread }) {
        try {
            await this.#db.insert({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"],
                record: {
                    ...thread
                }
            });
            return thread;
        } catch (error) {
            const mastraError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "SAVE_THREAD", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    threadId: thread.id
                }
            }, error);
            this.logger?.trackException?.(mastraError);
            this.logger?.error?.(mastraError.toString());
            throw mastraError;
        }
    }
    async updateThread({ id, title, metadata }) {
        const thread = await this.getThreadById({
            threadId: id
        });
        if (!thread) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_THREAD", "NOT_FOUND"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                text: `Thread ${id} not found`,
                details: {
                    status: 404,
                    threadId: id
                }
            });
        }
        const updatedThread = {
            ...thread,
            title,
            metadata: {
                ...thread.metadata,
                ...metadata
            }
        };
        try {
            await this.#client.execute({
                sql: `UPDATE ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]} SET title = ?, metadata = jsonb(?) WHERE id = ?`,
                args: [
                    title,
                    JSON.stringify(updatedThread.metadata),
                    id
                ]
            });
            return updatedThread;
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_THREAD", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                text: `Failed to update thread ${id}`,
                details: {
                    threadId: id
                }
            }, error);
        }
    }
    async deleteThread({ threadId }) {
        try {
            await this.#client.execute({
                sql: `DELETE FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]} WHERE thread_id = ?`,
                args: [
                    threadId
                ]
            });
            await this.#client.execute({
                sql: `DELETE FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]} WHERE id = ?`,
                args: [
                    threadId
                ]
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "DELETE_THREAD", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    threadId
                }
            }, error);
        }
    }
    async cloneThread(args) {
        const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;
        const sourceThread = await this.getThreadById({
            threadId: sourceThreadId
        });
        if (!sourceThread) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CLONE_THREAD", "SOURCE_NOT_FOUND"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                text: `Source thread with id ${sourceThreadId} not found`,
                details: {
                    sourceThreadId
                }
            });
        }
        const newThreadId = providedThreadId || crypto.randomUUID();
        const existingThread = await this.getThreadById({
            threadId: newThreadId
        });
        if (existingThread) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CLONE_THREAD", "THREAD_EXISTS"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                text: `Thread with id ${newThreadId} already exists`,
                details: {
                    newThreadId
                }
            });
        }
        try {
            let messageQuery = `SELECT id, content, role, type, "createdAt", thread_id, "resourceId"
                          FROM "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" WHERE thread_id = ?`;
            const messageParams = [
                sourceThreadId
            ];
            if (options?.messageFilter?.startDate) {
                messageQuery += ` AND "createdAt" >= ?`;
                messageParams.push(options.messageFilter.startDate instanceof Date ? options.messageFilter.startDate.toISOString() : options.messageFilter.startDate);
            }
            if (options?.messageFilter?.endDate) {
                messageQuery += ` AND "createdAt" <= ?`;
                messageParams.push(options.messageFilter.endDate instanceof Date ? options.messageFilter.endDate.toISOString() : options.messageFilter.endDate);
            }
            if (options?.messageFilter?.messageIds && options.messageFilter.messageIds.length > 0) {
                messageQuery += ` AND id IN (${options.messageFilter.messageIds.map(()=>"?").join(", ")})`;
                messageParams.push(...options.messageFilter.messageIds);
            }
            messageQuery += ` ORDER BY "createdAt" ASC`;
            if (options?.messageLimit && options.messageLimit > 0) {
                const limitQuery = `SELECT * FROM (${messageQuery.replace('ORDER BY "createdAt" ASC', 'ORDER BY "createdAt" DESC')} LIMIT ?) ORDER BY "createdAt" ASC`;
                messageParams.push(options.messageLimit);
                messageQuery = limitQuery;
            }
            const sourceMessagesResult = await this.#client.execute({
                sql: messageQuery,
                args: messageParams
            });
            const sourceMessages = sourceMessagesResult.rows || [];
            const now = /* @__PURE__ */ new Date();
            const nowStr = now.toISOString();
            const lastMessageId = sourceMessages.length > 0 ? sourceMessages[sourceMessages.length - 1].id : void 0;
            const cloneMetadata = {
                sourceThreadId,
                clonedAt: now,
                ...lastMessageId && {
                    lastMessageId
                }
            };
            const newThread = {
                id: newThreadId,
                resourceId: resourceId || sourceThread.resourceId,
                title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : void 0),
                metadata: {
                    ...metadata,
                    clone: cloneMetadata
                },
                createdAt: now,
                updatedAt: now
            };
            const tx = await this.#client.transaction("write");
            try {
                await tx.execute({
                    sql: `INSERT INTO "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_THREADS"]}" (id, "resourceId", title, metadata, "createdAt", "updatedAt")
                VALUES (?, ?, ?, jsonb(?), ?, ?)`,
                    args: [
                        newThread.id,
                        newThread.resourceId,
                        newThread.title || null,
                        JSON.stringify(newThread.metadata),
                        nowStr,
                        nowStr
                    ]
                });
                const clonedMessages = [];
                const targetResourceId = resourceId || sourceThread.resourceId;
                for (const sourceMsg of sourceMessages){
                    const newMessageId = crypto.randomUUID();
                    const contentStr = sourceMsg.content;
                    let parsedContent;
                    try {
                        parsedContent = JSON.parse(contentStr);
                    } catch  {
                        parsedContent = {
                            format: 2,
                            parts: [
                                {
                                    type: "text",
                                    text: contentStr
                                }
                            ]
                        };
                    }
                    await tx.execute({
                        sql: `INSERT INTO "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_MESSAGES"]}" (id, thread_id, content, role, type, "createdAt", "resourceId")
                  VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        args: [
                            newMessageId,
                            newThreadId,
                            contentStr,
                            sourceMsg.role,
                            sourceMsg.type || "v2",
                            sourceMsg.createdAt,
                            targetResourceId
                        ]
                    });
                    clonedMessages.push({
                        id: newMessageId,
                        threadId: newThreadId,
                        content: parsedContent,
                        role: sourceMsg.role,
                        type: sourceMsg.type || void 0,
                        createdAt: new Date(sourceMsg.createdAt),
                        resourceId: targetResourceId
                    });
                }
                await tx.commit();
                return {
                    thread: newThread,
                    clonedMessages
                };
            } catch (error) {
                await tx.rollback();
                throw error;
            }
        } catch (error) {
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]) {
                throw error;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CLONE_THREAD", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                details: {
                    sourceThreadId,
                    newThreadId
                }
            }, error);
        }
    }
};
var ObservabilityLibSQL = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObservabilityStorage"] {
    #db;
    constructor(config){
        super();
        const client = resolveClient(config);
        this.#db = new LibSQLDB({
            client,
            maxRetries: config.maxRetries,
            initialBackoffMs: config.initialBackoffMs
        });
    }
    async init() {
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SPAN_SCHEMA"]
        });
    }
    async dangerouslyClearAll() {
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"]
        });
    }
    get tracingStrategy() {
        return {
            preferred: "batch-with-updates",
            supported: [
                "batch-with-updates",
                "insert-only"
            ]
        };
    }
    async createSpan(args) {
        const { span } = args;
        try {
            const startedAt = span.startedAt instanceof Date ? span.startedAt.toISOString() : span.startedAt;
            const endedAt = span.endedAt instanceof Date ? span.endedAt.toISOString() : span.endedAt;
            const now = /* @__PURE__ */ new Date().toISOString();
            const record = {
                ...span,
                startedAt,
                endedAt,
                createdAt: now,
                updatedAt: now
            };
            return this.#db.insert({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                record
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "CREATE_SPAN", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    spanId: span.spanId,
                    traceId: span.traceId,
                    spanType: span.spanType,
                    name: span.name
                }
            }, error);
        }
    }
    async getSpan(args) {
        const { traceId, spanId } = args;
        try {
            const rows = await this.#db.selectMany({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                whereClause: {
                    sql: " WHERE traceId = ? AND spanId = ?",
                    args: [
                        traceId,
                        spanId
                    ]
                },
                limit: 1
            });
            if (!rows || rows.length === 0) {
                return null;
            }
            return {
                span: transformFromSqlRow({
                    tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                    sqlRow: rows[0]
                })
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_SPAN", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    traceId,
                    spanId
                }
            }, error);
        }
    }
    async getRootSpan(args) {
        const { traceId } = args;
        try {
            const rows = await this.#db.selectMany({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                whereClause: {
                    sql: " WHERE traceId = ? AND parentSpanId IS NULL",
                    args: [
                        traceId
                    ]
                },
                limit: 1
            });
            if (!rows || rows.length === 0) {
                return null;
            }
            return {
                span: transformFromSqlRow({
                    tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                    sqlRow: rows[0]
                })
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_ROOT_SPAN", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    traceId
                }
            }, error);
        }
    }
    async getTrace(args) {
        const { traceId } = args;
        try {
            const spans = await this.#db.selectMany({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                whereClause: {
                    sql: " WHERE traceId = ?",
                    args: [
                        traceId
                    ]
                },
                orderBy: "startedAt ASC"
            });
            if (!spans || spans.length === 0) {
                return null;
            }
            return {
                traceId,
                spans: spans.map((span)=>transformFromSqlRow({
                        tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                        sqlRow: span
                    }))
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_TRACE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    traceId
                }
            }, error);
        }
    }
    async updateSpan(args) {
        const { traceId, spanId, updates } = args;
        try {
            const data = {
                ...updates
            };
            if (data.endedAt instanceof Date) {
                data.endedAt = data.endedAt.toISOString();
            }
            if (data.startedAt instanceof Date) {
                data.startedAt = data.startedAt.toISOString();
            }
            data.updatedAt = /* @__PURE__ */ new Date().toISOString();
            await this.#db.update({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                keys: {
                    spanId,
                    traceId
                },
                data
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "UPDATE_SPAN", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    spanId,
                    traceId
                }
            }, error);
        }
    }
    async listTraces(args) {
        const { filters, pagination, orderBy } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["listTracesArgsSchema"].parse(args);
        const { page, perPage } = pagination;
        const tableName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSqlIdentifier"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"], "table name");
        try {
            const conditions = [
                "parentSpanId IS NULL"
            ];
            const queryArgs = [];
            if (filters) {
                if (filters.startedAt?.start) {
                    conditions.push(`startedAt >= ?`);
                    queryArgs.push(filters.startedAt.start.toISOString());
                }
                if (filters.startedAt?.end) {
                    conditions.push(`startedAt <= ?`);
                    queryArgs.push(filters.startedAt.end.toISOString());
                }
                if (filters.endedAt?.start) {
                    conditions.push(`endedAt >= ?`);
                    queryArgs.push(filters.endedAt.start.toISOString());
                }
                if (filters.endedAt?.end) {
                    conditions.push(`endedAt <= ?`);
                    queryArgs.push(filters.endedAt.end.toISOString());
                }
                if (filters.spanType !== void 0) {
                    conditions.push(`spanType = ?`);
                    queryArgs.push(filters.spanType);
                }
                if (filters.entityType !== void 0) {
                    conditions.push(`entityType = ?`);
                    queryArgs.push(filters.entityType);
                }
                if (filters.entityId !== void 0) {
                    conditions.push(`entityId = ?`);
                    queryArgs.push(filters.entityId);
                }
                if (filters.entityName !== void 0) {
                    conditions.push(`entityName = ?`);
                    queryArgs.push(filters.entityName);
                }
                if (filters.userId !== void 0) {
                    conditions.push(`userId = ?`);
                    queryArgs.push(filters.userId);
                }
                if (filters.organizationId !== void 0) {
                    conditions.push(`organizationId = ?`);
                    queryArgs.push(filters.organizationId);
                }
                if (filters.resourceId !== void 0) {
                    conditions.push(`resourceId = ?`);
                    queryArgs.push(filters.resourceId);
                }
                if (filters.runId !== void 0) {
                    conditions.push(`runId = ?`);
                    queryArgs.push(filters.runId);
                }
                if (filters.sessionId !== void 0) {
                    conditions.push(`sessionId = ?`);
                    queryArgs.push(filters.sessionId);
                }
                if (filters.threadId !== void 0) {
                    conditions.push(`threadId = ?`);
                    queryArgs.push(filters.threadId);
                }
                if (filters.requestId !== void 0) {
                    conditions.push(`requestId = ?`);
                    queryArgs.push(filters.requestId);
                }
                if (filters.environment !== void 0) {
                    conditions.push(`environment = ?`);
                    queryArgs.push(filters.environment);
                }
                if (filters.source !== void 0) {
                    conditions.push(`source = ?`);
                    queryArgs.push(filters.source);
                }
                if (filters.serviceName !== void 0) {
                    conditions.push(`serviceName = ?`);
                    queryArgs.push(filters.serviceName);
                }
                if (filters.scope != null) {
                    for (const [key, value] of Object.entries(filters.scope)){
                        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_TRACES", "INVALID_FILTER_KEY"),
                                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                                details: {
                                    key
                                }
                            });
                        }
                        conditions.push(`json_extract(scope, '$.${key}') = ?`);
                        queryArgs.push(typeof value === "string" ? value : JSON.stringify(value));
                    }
                }
                if (filters.metadata != null) {
                    for (const [key, value] of Object.entries(filters.metadata)){
                        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_TRACES", "INVALID_FILTER_KEY"),
                                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                                details: {
                                    key
                                }
                            });
                        }
                        conditions.push(`json_extract(metadata, '$.${key}') = ?`);
                        queryArgs.push(typeof value === "string" ? value : JSON.stringify(value));
                    }
                }
                if (filters.tags != null && filters.tags.length > 0) {
                    for (const tag of filters.tags){
                        conditions.push(`EXISTS (SELECT 1 FROM json_each(${tableName}.tags) WHERE value = ?)`);
                        queryArgs.push(tag);
                    }
                }
                if (filters.status !== void 0) {
                    switch(filters.status){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TraceStatus"].ERROR:
                            conditions.push(`error IS NOT NULL`);
                            break;
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TraceStatus"].RUNNING:
                            conditions.push(`endedAt IS NULL AND error IS NULL`);
                            break;
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TraceStatus"].SUCCESS:
                            conditions.push(`endedAt IS NOT NULL AND error IS NULL`);
                            break;
                    }
                }
                if (filters.hasChildError !== void 0) {
                    if (filters.hasChildError) {
                        conditions.push(`EXISTS (
              SELECT 1 FROM ${tableName} c
              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL
            )`);
                    } else {
                        conditions.push(`NOT EXISTS (
              SELECT 1 FROM ${tableName} c
              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL
            )`);
                    }
                }
            }
            const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
            const sortField = orderBy.field;
            const sortDirection = orderBy.direction;
            let orderByClause;
            if (sortField === "endedAt") {
                orderByClause = sortDirection === "DESC" ? `CASE WHEN ${sortField} IS NULL THEN 0 ELSE 1 END, ${sortField} DESC` : `CASE WHEN ${sortField} IS NULL THEN 1 ELSE 0 END, ${sortField} ASC`;
            } else {
                orderByClause = `${sortField} ${sortDirection}`;
            }
            const count = await this.#db.selectTotalCount({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                whereClause: {
                    sql: whereClause,
                    args: queryArgs
                }
            });
            if (count === 0) {
                return {
                    pagination: {
                        total: 0,
                        page,
                        perPage,
                        hasMore: false
                    },
                    spans: []
                };
            }
            const spans = await this.#db.selectMany({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                whereClause: {
                    sql: whereClause,
                    args: queryArgs
                },
                orderBy: orderByClause,
                offset: page * perPage,
                limit: perPage
            });
            return {
                pagination: {
                    total: count,
                    page,
                    perPage,
                    hasMore: (page + 1) * perPage < count
                },
                spans: spans.map((span)=>transformFromSqlRow({
                        tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                        sqlRow: span
                    }))
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_TRACES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER
            }, error);
        }
    }
    async batchCreateSpans(args) {
        try {
            const now = /* @__PURE__ */ new Date().toISOString();
            const records = args.records.map((record)=>{
                const startedAt = record.startedAt instanceof Date ? record.startedAt.toISOString() : record.startedAt;
                const endedAt = record.endedAt instanceof Date ? record.endedAt.toISOString() : record.endedAt;
                return {
                    ...record,
                    startedAt,
                    endedAt,
                    createdAt: now,
                    updatedAt: now
                };
            });
            return this.#db.batchInsert({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                records
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_CREATE_SPANS", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER
            }, error);
        }
    }
    async batchUpdateSpans(args) {
        const now = /* @__PURE__ */ new Date().toISOString();
        try {
            return this.#db.batchUpdate({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                updates: args.records.map((record)=>{
                    const data = {
                        ...record.updates
                    };
                    if (data.endedAt instanceof Date) {
                        data.endedAt = data.endedAt.toISOString();
                    }
                    if (data.startedAt instanceof Date) {
                        data.startedAt = data.startedAt.toISOString();
                    }
                    data.updatedAt = now;
                    return {
                        keys: {
                            spanId: record.spanId,
                            traceId: record.traceId
                        },
                        data
                    };
                })
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_UPDATE_SPANS", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER
            }, error);
        }
    }
    async batchDeleteTraces(args) {
        try {
            const keys = args.traceIds.map((traceId)=>({
                    traceId
                }));
            return this.#db.batchDelete({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SPANS"],
                keys
            });
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "BATCH_DELETE_TRACES", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER
            }, error);
        }
    }
};
var ScoresLibSQL = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ScoresStorage"] {
    #db;
    #client;
    constructor(config){
        super();
        const client = resolveClient(config);
        this.#client = client;
        this.#db = new LibSQLDB({
            client,
            maxRetries: config.maxRetries,
            initialBackoffMs: config.initialBackoffMs
        });
    }
    async init() {
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SCORERS_SCHEMA"]
        });
        await this.#db.alterTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"],
            schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SCORERS_SCHEMA"],
            ifNotExists: [
                "spanId",
                "requestContext"
            ]
        });
    }
    async dangerouslyClearAll() {
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]
        });
    }
    async listScoresByRunId({ runId, pagination }) {
        try {
            const { page, perPage: perPageInput } = pagination;
            const countResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE runId = ?`,
                args: [
                    runId
                ]
            });
            const total = Number(countResult.rows?.[0]?.count ?? 0);
            if (total === 0) {
                return {
                    pagination: {
                        total: 0,
                        page,
                        perPage: perPageInput,
                        hasMore: false
                    },
                    scores: []
                };
            }
            const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
            const { offset: start, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
            const limitValue = perPageInput === false ? total : perPage;
            const end = perPageInput === false ? total : start + perPage;
            const result = await this.#client.execute({
                sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"])} FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE runId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
                args: [
                    runId,
                    limitValue,
                    start
                ]
            });
            const scores = result.rows?.map((row)=>this.transformScoreRow(row)) ?? [];
            return {
                scores,
                pagination: {
                    total,
                    page,
                    perPage: perPageForResponse,
                    hasMore: end < total
                }
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_SCORES_BY_RUN_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async listScoresByScorerId({ scorerId, entityId, entityType, source, pagination }) {
        try {
            const { page, perPage: perPageInput } = pagination;
            const conditions = [];
            const queryParams = [];
            if (scorerId) {
                conditions.push(`scorerId = ?`);
                queryParams.push(scorerId);
            }
            if (entityId) {
                conditions.push(`entityId = ?`);
                queryParams.push(entityId);
            }
            if (entityType) {
                conditions.push(`entityType = ?`);
                queryParams.push(entityType);
            }
            if (source) {
                conditions.push(`source = ?`);
                queryParams.push(source);
            }
            const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
            const countResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} ${whereClause}`,
                args: queryParams
            });
            const total = Number(countResult.rows?.[0]?.count ?? 0);
            if (total === 0) {
                return {
                    pagination: {
                        total: 0,
                        page,
                        perPage: perPageInput,
                        hasMore: false
                    },
                    scores: []
                };
            }
            const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
            const { offset: start, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
            const limitValue = perPageInput === false ? total : perPage;
            const end = perPageInput === false ? total : start + perPage;
            const result = await this.#client.execute({
                sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"])} FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} ${whereClause} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
                args: [
                    ...queryParams,
                    limitValue,
                    start
                ]
            });
            const scores = result.rows?.map((row)=>this.transformScoreRow(row)) ?? [];
            return {
                scores,
                pagination: {
                    total,
                    page,
                    perPage: perPageForResponse,
                    hasMore: end < total
                }
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_SCORES_BY_SCORER_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    /**
   * LibSQL-specific score row transformation.
   */ transformScoreRow(row) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["transformScoreRow"])(row);
    }
    async getScoreById({ id }) {
        const result = await this.#client.execute({
            sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"])} FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE id = ?`,
            args: [
                id
            ]
        });
        return result.rows?.[0] ? this.transformScoreRow(result.rows[0]) : null;
    }
    async saveScore(score) {
        let parsedScore;
        try {
            parsedScore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["saveScorePayloadSchema"].parse(score);
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "SAVE_SCORE", "VALIDATION_FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].USER,
                details: {
                    scorer: typeof score.scorer?.id === "string" ? score.scorer.id : String(score.scorer?.id ?? "unknown"),
                    entityId: score.entityId ?? "unknown",
                    entityType: score.entityType ?? "unknown",
                    traceId: score.traceId ?? "",
                    spanId: score.spanId ?? ""
                }
            }, error);
        }
        try {
            const id = crypto.randomUUID();
            const now = /* @__PURE__ */ new Date();
            await this.#db.insert({
                tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"],
                record: {
                    ...parsedScore,
                    id,
                    createdAt: now.toISOString(),
                    updatedAt: now.toISOString()
                }
            });
            return {
                score: {
                    ...parsedScore,
                    id,
                    createdAt: now,
                    updatedAt: now
                }
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "SAVE_SCORE", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async listScoresByEntityId({ entityId, entityType, pagination }) {
        try {
            const { page, perPage: perPageInput } = pagination;
            const countResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE entityId = ? AND entityType = ?`,
                args: [
                    entityId,
                    entityType
                ]
            });
            const total = Number(countResult.rows?.[0]?.count ?? 0);
            if (total === 0) {
                return {
                    pagination: {
                        total: 0,
                        page,
                        perPage: perPageInput,
                        hasMore: false
                    },
                    scores: []
                };
            }
            const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
            const { offset: start, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
            const limitValue = perPageInput === false ? total : perPage;
            const end = perPageInput === false ? total : start + perPage;
            const result = await this.#client.execute({
                sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"])} FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE entityId = ? AND entityType = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
                args: [
                    entityId,
                    entityType,
                    limitValue,
                    start
                ]
            });
            const scores = result.rows?.map((row)=>this.transformScoreRow(row)) ?? [];
            return {
                scores,
                pagination: {
                    total,
                    page,
                    perPage: perPageForResponse,
                    hasMore: end < total
                }
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_SCORES_BY_ENTITY_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async listScoresBySpan({ traceId, spanId, pagination }) {
        try {
            const { page, perPage: perPageInput } = pagination;
            const perPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPageInput, 100);
            const { offset: start, perPage: perPageForResponse } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["calculatePagination"])(page, perPageInput, perPage);
            const countSQLResult = await this.#client.execute({
                sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE traceId = ? AND spanId = ?`,
                args: [
                    traceId,
                    spanId
                ]
            });
            const total = Number(countSQLResult.rows?.[0]?.count ?? 0);
            const limitValue = perPageInput === false ? total : perPage;
            const end = perPageInput === false ? total : start + perPage;
            const result = await this.#client.execute({
                sql: `SELECT ${buildSelectColumns(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"])} FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCORERS"]} WHERE traceId = ? AND spanId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
                args: [
                    traceId,
                    spanId,
                    limitValue,
                    start
                ]
            });
            const scores = result.rows?.map((row)=>this.transformScoreRow(row)) ?? [];
            return {
                scores,
                pagination: {
                    total,
                    page,
                    perPage: perPageForResponse,
                    hasMore: end < total
                }
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_SCORES_BY_SPAN", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
};
var WorkflowsLibSQL = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WorkflowsStorage"] {
    #db;
    #client;
    executeWithRetry;
    constructor(config){
        super();
        const client = resolveClient(config);
        const maxRetries = config.maxRetries ?? 5;
        const initialBackoffMs = config.initialBackoffMs ?? 500;
        this.#client = client;
        this.#db = new LibSQLDB({
            client,
            maxRetries,
            initialBackoffMs
        });
        this.executeWithRetry = createExecuteWriteOperationWithRetry({
            logger: this.logger,
            maxRetries,
            initialBackoffMs
        });
        this.setupPragmaSettings().catch((err)=>this.logger.warn("LibSQL Workflows: Failed to setup PRAGMA settings.", err));
    }
    parseWorkflowRun(row) {
        let parsedSnapshot = row.snapshot;
        if (typeof parsedSnapshot === "string") {
            try {
                parsedSnapshot = JSON.parse(row.snapshot);
            } catch (e) {
                this.logger.warn(`Failed to parse snapshot for workflow ${row.workflow_name}: ${e}`);
            }
        }
        return {
            workflowName: row.workflow_name,
            runId: row.run_id,
            snapshot: parsedSnapshot,
            resourceId: row.resourceId,
            createdAt: new Date(row.createdAt),
            updatedAt: new Date(row.updatedAt)
        };
    }
    async init() {
        const schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_SCHEMAS"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]];
        await this.#db.createTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"],
            schema
        });
        await this.#db.alterTable({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"],
            schema,
            ifNotExists: [
                "resourceId"
            ]
        });
    }
    async dangerouslyClearAll() {
        await this.#db.deleteData({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]
        });
    }
    async setupPragmaSettings() {
        try {
            await this.#client.execute("PRAGMA busy_timeout = 10000;");
            this.logger.debug("LibSQL Workflows: PRAGMA busy_timeout=10000 set.");
            try {
                await this.#client.execute("PRAGMA journal_mode = WAL;");
                this.logger.debug("LibSQL Workflows: PRAGMA journal_mode=WAL set.");
            } catch  {
                this.logger.debug("LibSQL Workflows: WAL mode not supported, using default journal mode.");
            }
            try {
                await this.#client.execute("PRAGMA synchronous = NORMAL;");
                this.logger.debug("LibSQL Workflows: PRAGMA synchronous=NORMAL set.");
            } catch  {
                this.logger.debug("LibSQL Workflows: Failed to set synchronous mode.");
            }
        } catch (err) {
            this.logger.warn("LibSQL Workflows: Failed to set PRAGMA settings.", err);
        }
    }
    async updateWorkflowResults({ workflowName, runId, stepId, result, requestContext }) {
        return this.executeWithRetry(async ()=>{
            const tx = await this.#client.transaction("write");
            try {
                const existingSnapshotResult = await tx.execute({
                    sql: `SELECT json(snapshot) as snapshot FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} WHERE workflow_name = ? AND run_id = ?`,
                    args: [
                        workflowName,
                        runId
                    ]
                });
                let snapshot;
                if (!existingSnapshotResult.rows?.[0]) {
                    snapshot = {
                        context: {},
                        activePaths: [],
                        timestamp: Date.now(),
                        suspendedPaths: {},
                        activeStepsPath: {},
                        resumeLabels: {},
                        serializedStepGraph: [],
                        status: "pending",
                        value: {},
                        waitingPaths: {},
                        runId,
                        requestContext: {}
                    };
                } else {
                    const existingSnapshot = existingSnapshotResult.rows[0].snapshot;
                    snapshot = typeof existingSnapshot === "string" ? JSON.parse(existingSnapshot) : existingSnapshot;
                }
                snapshot.context[stepId] = result;
                snapshot.requestContext = {
                    ...snapshot.requestContext,
                    ...requestContext
                };
                const now = /* @__PURE__ */ new Date().toISOString();
                await tx.execute({
                    sql: `INSERT INTO ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} (workflow_name, run_id, snapshot, createdAt, updatedAt)
                VALUES (?, ?, jsonb(?), ?, ?)
                ON CONFLICT(workflow_name, run_id)
                DO UPDATE SET snapshot = excluded.snapshot, updatedAt = excluded.updatedAt`,
                    args: [
                        workflowName,
                        runId,
                        JSON.stringify(snapshot),
                        now,
                        now
                    ]
                });
                await tx.commit();
                return snapshot.context;
            } catch (error) {
                if (!tx.closed) {
                    await tx.rollback();
                }
                throw error;
            }
        }, "updateWorkflowResults");
    }
    async updateWorkflowState({ workflowName, runId, opts }) {
        return this.executeWithRetry(async ()=>{
            const tx = await this.#client.transaction("write");
            try {
                const existingSnapshotResult = await tx.execute({
                    sql: `SELECT json(snapshot) as snapshot FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} WHERE workflow_name = ? AND run_id = ?`,
                    args: [
                        workflowName,
                        runId
                    ]
                });
                if (!existingSnapshotResult.rows?.[0]) {
                    await tx.rollback();
                    return void 0;
                }
                const existingSnapshot = existingSnapshotResult.rows[0].snapshot;
                const snapshot = typeof existingSnapshot === "string" ? JSON.parse(existingSnapshot) : existingSnapshot;
                if (!snapshot || !snapshot?.context) {
                    await tx.rollback();
                    throw new Error(`Snapshot not found for runId ${runId}`);
                }
                const updatedSnapshot = {
                    ...snapshot,
                    ...opts
                };
                await tx.execute({
                    sql: `UPDATE ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} SET snapshot = jsonb(?) WHERE workflow_name = ? AND run_id = ?`,
                    args: [
                        JSON.stringify(updatedSnapshot),
                        workflowName,
                        runId
                    ]
                });
                await tx.commit();
                return updatedSnapshot;
            } catch (error) {
                if (!tx.closed) {
                    await tx.rollback();
                }
                throw error;
            }
        }, "updateWorkflowState");
    }
    async persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot, createdAt, updatedAt }) {
        const now = /* @__PURE__ */ new Date();
        const data = {
            workflow_name: workflowName,
            run_id: runId,
            resourceId,
            snapshot,
            createdAt: createdAt ?? now,
            updatedAt: updatedAt ?? now
        };
        this.logger.debug("Persisting workflow snapshot", {
            workflowName,
            runId,
            data
        });
        await this.#db.insert({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"],
            record: data
        });
    }
    async loadWorkflowSnapshot({ workflowName, runId }) {
        this.logger.debug("Loading workflow snapshot", {
            workflowName,
            runId
        });
        const d = await this.#db.select({
            tableName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"],
            keys: {
                workflow_name: workflowName,
                run_id: runId
            }
        });
        return d ? d.snapshot : null;
    }
    async getWorkflowRunById({ runId, workflowName }) {
        const conditions = [];
        const args = [];
        if (runId) {
            conditions.push("run_id = ?");
            args.push(runId);
        }
        if (workflowName) {
            conditions.push("workflow_name = ?");
            args.push(workflowName);
        }
        const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
        try {
            const result = await this.#client.execute({
                sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} ${whereClause} ORDER BY createdAt DESC LIMIT 1`,
                args
            });
            if (!result.rows?.[0]) {
                return null;
            }
            return this.parseWorkflowRun(result.rows[0]);
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "GET_WORKFLOW_RUN_BY_ID", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
    async deleteWorkflowRunById({ runId, workflowName }) {
        return this.executeWithRetry(async ()=>{
            try {
                await this.#client.execute({
                    sql: `DELETE FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} WHERE workflow_name = ? AND run_id = ?`,
                    args: [
                        workflowName,
                        runId
                    ]
                });
            } catch (error) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "DELETE_WORKFLOW_RUN_BY_ID", "FAILED"),
                    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                    category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY,
                    details: {
                        runId,
                        workflowName
                    }
                }, error);
            }
        }, "deleteWorkflowRunById");
    }
    async listWorkflowRuns({ workflowName, fromDate, toDate, page, perPage, resourceId, status } = {}) {
        try {
            const conditions = [];
            const args = [];
            if (workflowName) {
                conditions.push("workflow_name = ?");
                args.push(workflowName);
            }
            if (status) {
                conditions.push("json_extract(snapshot, '$.status') = ?");
                args.push(status);
            }
            if (fromDate) {
                conditions.push("createdAt >= ?");
                args.push(fromDate.toISOString());
            }
            if (toDate) {
                conditions.push("createdAt <= ?");
                args.push(toDate.toISOString());
            }
            if (resourceId) {
                const hasResourceId = await this.#db.hasColumn(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"], "resourceId");
                if (hasResourceId) {
                    conditions.push("resourceId = ?");
                    args.push(resourceId);
                } else {
                    this.logger.warn(`[${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]}] resourceId column not found. Skipping resourceId filter.`);
                }
            }
            const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
            let total = 0;
            const usePagination = typeof perPage === "number" && typeof page === "number";
            if (usePagination) {
                const countResult = await this.#client.execute({
                    sql: `SELECT COUNT(*) as count FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} ${whereClause}`,
                    args
                });
                total = Number(countResult.rows?.[0]?.count ?? 0);
            }
            const normalizedPerPage = usePagination ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizePerPage"])(perPage, Number.MAX_SAFE_INTEGER) : 0;
            const offset = usePagination ? page * normalizedPerPage : 0;
            const result = await this.#client.execute({
                sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$65QFXXAD$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TABLE_WORKFLOW_SNAPSHOT"]} ${whereClause} ORDER BY createdAt DESC${usePagination ? ` LIMIT ? OFFSET ?` : ""}`,
                args: usePagination ? [
                    ...args,
                    normalizedPerPage,
                    offset
                ] : args
            });
            const runs = (result.rows || []).map((row)=>this.parseWorkflowRun(row));
            return {
                runs,
                total: total || runs.length
            };
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraError"]({
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStorageErrorId"])("LIBSQL", "LIST_WORKFLOW_RUNS", "FAILED"),
                domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorDomain"].STORAGE,
                category: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$FJEVLHJT$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrorCategory"].THIRD_PARTY
            }, error);
        }
    }
};
// src/storage/index.ts
var LibSQLStore = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$DDH2PEZG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraStorage"] {
    client;
    maxRetries;
    initialBackoffMs;
    stores;
    constructor(config){
        if (!config.id || typeof config.id !== "string" || config.id.trim() === "") {
            throw new Error("LibSQLStore: id must be provided and cannot be empty.");
        }
        super({
            id: config.id,
            name: `LibSQLStore`,
            disableInit: config.disableInit
        });
        this.maxRetries = config.maxRetries ?? 5;
        this.initialBackoffMs = config.initialBackoffMs ?? 100;
        if ("url" in config) {
            if (config.url.endsWith(":memory:")) {
                this.shouldCacheInit = false;
            }
            this.client = (0, __TURBOPACK__imported__module__$5b$externals$5d2f40$libsql$2f$client__$5b$external$5d$__$2840$libsql$2f$client$2c$__esm_import$2c$__$5b$project$5d2f$node_modules$2f40$libsql$2f$client$29$__["createClient"])({
                url: config.url,
                ...config.authToken ? {
                    authToken: config.authToken
                } : {}
            });
            if (config.url.startsWith("file:") || config.url.includes(":memory:")) {
                this.client.execute("PRAGMA journal_mode=WAL;").then(()=>this.logger.debug("LibSQLStore: PRAGMA journal_mode=WAL set.")).catch((err)=>this.logger.warn("LibSQLStore: Failed to set PRAGMA journal_mode=WAL.", err));
                this.client.execute("PRAGMA busy_timeout = 5000;").then(()=>this.logger.debug("LibSQLStore: PRAGMA busy_timeout=5000 set.")).catch((err)=>this.logger.warn("LibSQLStore: Failed to set PRAGMA busy_timeout.", err));
            }
        } else {
            this.client = config.client;
        }
        const domainConfig = {
            client: this.client,
            maxRetries: this.maxRetries,
            initialBackoffMs: this.initialBackoffMs
        };
        const scores = new ScoresLibSQL(domainConfig);
        const workflows = new WorkflowsLibSQL(domainConfig);
        const memory = new MemoryLibSQL(domainConfig);
        const observability = new ObservabilityLibSQL(domainConfig);
        const agents = new AgentsLibSQL(domainConfig);
        this.stores = {
            scores,
            workflows,
            memory,
            observability,
            agents
        };
    }
};
// src/vector/prompt.ts
var LIBSQL_PROMPT = `When querying LibSQL Vector, you can ONLY use the operators listed below. Any other operators will be rejected.
Important: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.
If a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.

Basic Comparison Operators:
- $eq: Exact match (default when using field: value)
  Example: { "category": "electronics" }
- $ne: Not equal
  Example: { "category": { "$ne": "electronics" } }
- $gt: Greater than
  Example: { "price": { "$gt": 100 } }
- $gte: Greater than or equal
  Example: { "price": { "$gte": 100 } }
- $lt: Less than
  Example: { "price": { "$lt": 100 } }
- $lte: Less than or equal
  Example: { "price": { "$lte": 100 } }

Array Operators:
- $in: Match any value in array
  Example: { "category": { "$in": ["electronics", "books"] } }
- $nin: Does not match any value in array
  Example: { "category": { "$nin": ["electronics", "books"] } }
- $all: Match all values in array
  Example: { "tags": { "$all": ["premium", "sale"] } }
- $elemMatch: Match array elements that meet all specified conditions
  Example: { "items": { "$elemMatch": { "price": { "$gt": 100 } } } }
- $contains: Check if array contains value
  Example: { "tags": { "$contains": "premium" } }

Logical Operators:
- $and: Logical AND (implicit when using multiple conditions)
  Example: { "$and": [{ "price": { "$gt": 100 } }, { "category": "electronics" }] }
- $or: Logical OR
  Example: { "$or": [{ "price": { "$lt": 50 } }, { "category": "books" }] }
- $not: Logical NOT
  Example: { "$not": { "category": "electronics" } }
- $nor: Logical NOR
  Example: { "$nor": [{ "price": { "$lt": 50 } }, { "category": "books" }] }

Element Operators:
- $exists: Check if field exists
  Example: { "rating": { "$exists": true } }

Special Operators:
- $size: Array length check
  Example: { "tags": { "$size": 2 } }

Restrictions:
- Regex patterns are not supported
- Direct RegExp patterns will throw an error
- Nested fields are supported using dot notation
- Multiple conditions on the same field are supported with both implicit and explicit $and
- Array operations work on array fields only
- Basic operators handle array values as JSON strings
- Empty arrays in conditions are handled gracefully
- Only logical operators ($and, $or, $not, $nor) can be used at the top level
- All other operators must be used within a field condition
  Valid: { "field": { "$gt": 100 } }
  Valid: { "$and": [...] }
  Invalid: { "$gt": 100 }
  Invalid: { "$contains": "value" }
- Logical operators must contain field conditions, not direct operators
  Valid: { "$and": [{ "field": { "$gt": 100 } }] }
  Invalid: { "$and": [{ "$gt": 100 }] }
- $not operator:
  - Must be an object
  - Cannot be empty
  - Can be used at field level or top level
  - Valid: { "$not": { "field": "value" } }
  - Valid: { "field": { "$not": { "$eq": "value" } } }
- Other logical operators ($and, $or, $nor):
  - Can only be used at top level or nested within other logical operators
  - Can not be used on a field level, or be nested inside a field
  - Can not be used inside an operator
  - Valid: { "$and": [{ "field": { "$gt": 100 } }] }
  - Valid: { "$or": [{ "$and": [{ "field": { "$gt": 100 } }] }] }
  - Invalid: { "field": { "$and": [{ "$gt": 100 }] } }
  - Invalid: { "field": { "$or": [{ "$gt": 100 }] } }
  - Invalid: { "field": { "$gt": { "$and": [{...}] } } }
- $elemMatch requires an object with conditions
  Valid: { "array": { "$elemMatch": { "field": "value" } } }
  Invalid: { "array": { "$elemMatch": "value" } }

Example Complex Query:
{
  "$and": [
    { "category": { "$in": ["electronics", "computers"] } },
    { "price": { "$gte": 100, "$lte": 1000 } },
    { "tags": { "$all": ["premium", "sale"] } },
    { "items": { "$elemMatch": { "price": { "$gt": 50 }, "inStock": true } } },
    { "$or": [
      { "stock": { "$gt": 0 } },
      { "preorder": true }
    ]}
  ]
}`;
;
 //# sourceMappingURL=index.js.map
 //# sourceMappingURL=index.js.map
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=node_modules_%40mastra_libsql_dist_index_0b6ae7be.js.map