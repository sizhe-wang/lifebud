{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/libsql/dist/index.js","sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/vector/filter.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/vector/sql-builder.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/vector/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/db/utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/db/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/domains/agents/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/domains/memory/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/domains/observability/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/domains/scores/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/domains/workflows/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/storage/index.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/libsql/src/vector/prompt.ts"],"sourcesContent":["import { BaseFilterTranslator } from '@mastra/core/vector/filter';\nimport type { VectorFilter, OperatorSupport, OperatorValueMap, VectorFieldValue } from '@mastra/core/vector/filter';\n\ntype LibSQLOperatorValueMap = Omit<\n  OperatorValueMap,\n  '$regex' | '$options' | '$in' | '$all' | '$nin' | '$eq' | '$ne'\n> & {\n  $size: number;\n  $contains: VectorFieldValue | Record<string, unknown>;\n  $all: VectorFieldValue;\n  $in: VectorFieldValue;\n  $nin: VectorFieldValue;\n  $eq: VectorFieldValue;\n  $ne: VectorFieldValue;\n};\nexport type LibSQLVectorFilter = VectorFilter<keyof LibSQLOperatorValueMap, LibSQLOperatorValueMap>;\n\n/**\n * Translates MongoDB-style filters to LibSQL compatible filters.\n *\n * Key differences from MongoDB:\n *\n * Logical Operators ($and, $or, $nor):\n * - Can be used at the top level or nested within fields\n * - Can take either a single condition or an array of conditions\n *\n */\nexport class LibSQLFilterTranslator extends BaseFilterTranslator<LibSQLVectorFilter> {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      regex: [],\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: LibSQLVectorFilter): LibSQLVectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: LibSQLVectorFilter, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Direct regex pattern format is not supported in LibSQL');\n    }\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    // Handle regex\n    // TODO: Look more into regex support for LibSQL\n    // if (node instanceof RegExp) {\n    //   return withPath(this.translateRegexPattern(node.source, node.flags));\n    // }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    // if ('$options' in node && !('$regex' in node)) {\n    //   throw new Error('$options is not valid without $regex');\n    // }\n\n    // TODO: Look more into regex support for LibSQL\n    // // Handle special regex object format\n    // if ('$regex' in node) {\n    //   const options = (node as any).$options || '';\n    //   return withPath(this.translateRegexPattern(node.$regex, options));\n    // }\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      // // Skip options as they're handled with $regex\n      // if (key === '$options') continue;\n\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: LibSQLVectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  // TODO: Look more into regex support for LibSQL\n  // private translateRegexPattern(pattern: string, options: string = ''): any {\n  //   if (!options) return { $regex: pattern };\n\n  //   const flags = options\n  //     .split('')\n  //     .filter(f => 'imsux'.includes(f))\n  //     .join('');\n\n  //   return {\n  //     $regex: pattern,\n  //     $options: flags,\n  //   };\n  // }\n}\n","import type { InValue } from '@libsql/client';\nimport { parseFieldKey } from '@mastra/core/utils';\nimport type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n} from '@mastra/core/vector/filter';\nimport type { LibSQLVectorFilter } from './filter';\n\ntype OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | '$size';\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: () => any;\n};\n\ntype OperatorFn = (key: string, value?: any) => FilterOperator;\n\n// Helper functions to create operators\nconst createBasicOperator = (symbol: string) => {\n  return (key: string, value: any): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `CASE \n        WHEN ? IS NULL THEN json_extract(metadata, ${jsonPath}) IS ${symbol === '=' ? '' : 'NOT'} NULL\n        ELSE json_extract(metadata, ${jsonPath}) ${symbol} ?\n      END`,\n      needsValue: true,\n      transformValue: () => {\n        // Return the values directly, not in an object\n        return [value, value];\n      },\n    };\n  };\n};\nconst createNumericOperator = (symbol: string) => {\n  return (key: string, value: any): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n\n    // Check if the value is numeric or a string (like ISO date)\n    const isNumeric =\n      typeof value === 'number' || (typeof value === 'string' && !isNaN(Number(value)) && value.trim() !== '');\n\n    if (isNumeric) {\n      // For numeric values, cast to NUMERIC for proper comparison\n      return {\n        sql: `CAST(json_extract(metadata, ${jsonPath}) AS NUMERIC) ${symbol} ?`,\n        needsValue: true,\n      };\n    } else {\n      // For non-numeric strings (like ISO dates), compare as text\n      return {\n        sql: `CAST(json_extract(metadata, ${jsonPath}) AS TEXT) ${symbol} ?`,\n        needsValue: true,\n      };\n    }\n  };\n};\n\nconst validateJsonArray = (key: string) => {\n  const jsonPath = getJsonPath(key);\n  return `json_valid(json_extract(metadata, ${jsonPath}))\n   AND json_type(json_extract(metadata, ${jsonPath})) = 'array'`;\n};\n\nconst pattern = /json_extract\\(metadata, '\\$\\.(?:\"[^\"]*\"(?:\\.\"[^\"]*\")*|[^']+)'\\)/g;\n\nfunction buildElemMatchConditions(value: any) {\n  const conditions = Object.entries(value).map(([field, fieldValue]) => {\n    if (field.startsWith('$')) {\n      // Direct operators on array elements ($in, $gt, etc)\n      const { sql, values } = buildCondition('elem.value', { [field]: fieldValue }, '');\n      // Replace the metadata path with elem.value\n      const elemSql = sql.replace(pattern, 'elem.value');\n      return { sql: elemSql, values };\n    } else if (typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {\n      // Nested field with operators (count: { $gt: 20 })\n      const { sql, values } = buildCondition(field, fieldValue, '');\n      // Replace the field path with elem.value path\n      const jsonPath = parseJsonPathKey(field);\n      const elemSql = sql.replace(pattern, `json_extract(elem.value, '$.${jsonPath}')`);\n      return { sql: elemSql, values };\n    } else {\n      const jsonPath = parseJsonPathKey(field);\n      // Simple field equality (warehouse: 'A')\n      return {\n        sql: `json_extract(elem.value, '$.${jsonPath}') = ?`,\n        values: [fieldValue],\n      };\n    }\n  });\n\n  return conditions;\n}\n\n// Define all filter operators\nconst FILTER_OPERATORS: Record<OperatorType, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 0', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n\n  $nin: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 1', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) NOT IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n  $all: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    let sql: string;\n    const arrayValue = Array.isArray(value) ? value : [value];\n\n    if (arrayValue.length === 0) {\n      // If the array is empty, always return false (no matches)\n      sql = '1 = 0';\n    } else {\n      sql = `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT value\n            FROM json_each(?)\n            WHERE value NOT IN (\n              SELECT value\n              FROM json_each(json_extract(metadata, ${jsonPath}))\n            )\n          )\n        ELSE FALSE\n      END\n    )`;\n    }\n\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (arrayValue.length === 0) {\n          return [];\n        }\n        return [JSON.stringify(arrayValue)];\n      },\n    };\n  },\n  $elemMatch: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    if (typeof value !== 'object' || Array.isArray(value)) {\n      throw new Error('$elemMatch requires an object with conditions');\n    }\n\n    // For nested object conditions\n    const conditions = buildElemMatchConditions(value);\n\n    return {\n      sql: `(\n        CASE\n          WHEN ${validateJsonArray(key)} THEN\n            EXISTS (\n              SELECT 1\n              FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n              WHERE ${conditions.map(c => c.sql).join(' AND ')}\n            )\n          ELSE FALSE\n        END\n      )`,\n      needsValue: true,\n      transformValue: () => conditions.flatMap(c => c.values),\n    };\n  },\n\n  // Element Operators\n  $exists: (key: string) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) IS NOT NULL`,\n      needsValue: false,\n    };\n  },\n\n  // Logical Operators\n  $and: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $or: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: (key: string) => ({\n    sql: `NOT (${key})`,\n    needsValue: false,\n  }),\n  $size: (key: string, paramIndex: number) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `(\n    CASE\n      WHEN json_type(json_extract(metadata, ${jsonPath})) = 'array' THEN \n        json_array_length(json_extract(metadata, ${jsonPath})) = $${paramIndex}\n      ELSE FALSE\n    END\n  )`,\n      needsValue: true,\n    };\n  },\n  //   /**\n  //    * Regex Operators\n  //    * Supports case insensitive and multiline\n  //    */\n  //   $regex: (key: string): FilterOperator => ({\n  //     sql: `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"') = ?`,\n  //     needsValue: true,\n  //     transformValue: (value: any) => {\n  //       const pattern = typeof value === 'object' ? value.$regex : value;\n  //       const options = typeof value === 'object' ? value.$options || '' : '';\n  //       let sql = `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`;\n\n  //       // Handle multiline\n  //       //   if (options.includes('m')) {\n  //       //     sql = `REPLACE(${sql}, CHAR(10), '\\n')`;\n  //       //   }\n\n  //       //       let finalPattern = pattern;\n  //       // if (options) {\n  //       //   finalPattern = `(\\\\?${options})${pattern}`;\n  //       // }\n\n  //       //   // Handle case insensitivity\n  //       //   if (options.includes('i')) {\n  //       //     sql = `LOWER(${sql}) REGEXP LOWER(?)`;\n  //       //   } else {\n  //       //     sql = `${sql} REGEXP ?`;\n  //       //   }\n\n  //       if (options.includes('m')) {\n  //         sql = `EXISTS (\n  //         SELECT 1\n  //         FROM json_each(\n  //           json_array(\n  //             ${sql},\n  //             REPLACE(${sql}, CHAR(10), CHAR(13))\n  //           )\n  //         ) as lines\n  //         WHERE lines.value REGEXP ?\n  //       )`;\n  //       } else {\n  //         sql = `${sql} REGEXP ?`;\n  //       }\n\n  //       // Handle case insensitivity\n  //       if (options.includes('i')) {\n  //         sql = sql.replace('REGEXP ?', 'REGEXP LOWER(?)');\n  //         sql = sql.replace('value REGEXP', 'LOWER(value) REGEXP');\n  //       }\n\n  //       // Handle extended - allows whitespace and comments in pattern\n  //       if (options.includes('x')) {\n  //         // Remove whitespace and comments from pattern\n  //         const cleanPattern = pattern.replace(/\\s+|#.*$/gm, '');\n  //         return {\n  //           sql,\n  //           values: [cleanPattern],\n  //         };\n  //       }\n\n  //       return {\n  //         sql,\n  //         values: [pattern],\n  //       };\n  //     },\n  //   }),\n  $contains: (key: string, value: any) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    let sql;\n    if (Array.isArray(value)) {\n      sql = `(\n        SELECT ${validateJsonArray(jsonPathKey)}\n        AND EXISTS (\n          SELECT 1\n          FROM json_each(json_extract(metadata, '$.\"${jsonPathKey}\"')) as m\n          WHERE m.value IN (SELECT value FROM json_each(?))\n        )\n      )`;\n    } else if (typeof value === 'string') {\n      sql = `lower(json_extract(metadata, '$.\"${jsonPathKey}\"')) LIKE '%' || lower(?) || '%' ESCAPE '\\\\'`;\n    } else {\n      sql = `json_extract(metadata, '$.\"${jsonPathKey}\"') = ?`;\n    }\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (Array.isArray(value)) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'object' && value !== null) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'string') {\n          return [escapeLikePattern(value)];\n        }\n        return [value];\n      },\n    };\n  },\n  /**\n   * $objectContains: True JSON containment for advanced use (deep sub-object match).\n   * Usage: { field: { $objectContains: { ...subobject } } }\n   */\n  // $objectContains: (key: string) => ({\n  //   sql: '', // Will be overridden by transformValue\n  //   needsValue: true,\n  //   transformValue: (value: any) => ({\n  //     sql: `json_type(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')) = 'object'\n  //         AND json_patch(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"'), ?) = json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`,\n  //     values: [JSON.stringify(value)],\n  //   }),\n  // }),\n};\n\ninterface FilterResult {\n  sql: string;\n  values: InValue[];\n}\n\nfunction isFilterResult(obj: any): obj is FilterResult {\n  return obj && typeof obj === 'object' && typeof obj.sql === 'string' && Array.isArray(obj.values);\n}\n\nconst parseJsonPathKey = (key: string) => {\n  const parsedKey = parseFieldKey(key);\n  // Only add quotes around path segments if they contain dots\n  if (parsedKey.includes('.')) {\n    return parsedKey\n      .split('.')\n      .map(segment => `\"${segment}\"`)\n      .join('.');\n  }\n  return parsedKey;\n};\n\n// Helper to generate the correct JSON path format for LibSQL\nconst getJsonPath = (key: string) => {\n  const jsonPathKey = parseJsonPathKey(key);\n  // Always use quotes for consistency\n  return `'$.${jsonPathKey}'`;\n};\n\nfunction escapeLikePattern(str: string): string {\n  return str.replace(/([%_\\\\])/g, '\\\\$1');\n}\n\nexport function buildFilterQuery(filter: LibSQLVectorFilter): FilterResult {\n  if (!filter) {\n    return { sql: '', values: [] };\n  }\n\n  const values: InValue[] = [];\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => {\n      const condition = buildCondition(key, value, '');\n      values.push(...condition.values);\n      return condition.sql;\n    })\n    .join(' AND ');\n\n  return {\n    sql: conditions ? `WHERE ${conditions}` : '',\n    values,\n  };\n}\n\nfunction buildCondition(key: string, value: any, parentPath: string): FilterResult {\n  // Handle logical operators ($and/$or)\n  if (['$and', '$or', '$not', '$nor'].includes(key)) {\n    return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n  }\n\n  // If condition is not a FilterCondition object, assume it's an equality check\n  if (!value || typeof value !== 'object') {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) = ?`,\n      values: [value],\n    };\n  }\n\n  //TODO: Add regex support\n  //   if ('$regex' in value) {\n  //     return handleRegexOperator(key, value);\n  //   }\n\n  // Handle operator conditions\n  return handleOperator(key, value);\n}\n\n// function handleRegexOperator(key: string, value: any): FilterResult {\n//   const operatorFn = FILTER_OPERATORS['$regex']!;\n//   const operatorResult = operatorFn(key, value);\n//   const transformed = operatorResult.transformValue ? operatorResult.transformValue(value) : value;\n\n//   return {\n//     sql: transformed.sql,\n//     values: transformed.values,\n//   };\n// }\n\nfunction handleLogicalOperator(\n  key: '$and' | '$or' | '$not' | '$nor',\n  value: LibSQLVectorFilter[] | LibSQLVectorFilter,\n  parentPath: string,\n): FilterResult {\n  // Handle empty conditions\n  if (!value || (Array.isArray(value) && value.length === 0)) {\n    switch (key) {\n      case '$and':\n      case '$nor':\n        return { sql: 'true', values: [] };\n      case '$or':\n        return { sql: 'false', values: [] };\n      case '$not':\n        throw new Error('$not operator cannot be empty');\n      default:\n        return { sql: 'true', values: [] };\n    }\n  }\n\n  if (key === '$not') {\n    // For top-level $not\n    const entries = Object.entries(value);\n    const conditions = entries.map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key));\n    return {\n      sql: `NOT (${conditions.map(c => c.sql).join(' AND ')})`,\n      values: conditions.flatMap(c => c.values),\n    };\n  }\n\n  const values: InValue[] = [];\n  const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n  const conditions = Array.isArray(value)\n    ? value.map(f => {\n        const entries = !!f ? Object.entries(f) : [];\n        return entries.map(([k, v]) => buildCondition(k, v, key));\n      })\n    : [buildCondition(key, value, parentPath)];\n\n  const joined = conditions\n    .flat()\n    .map(c => {\n      values.push(...c.values);\n      return c.sql;\n    })\n    .join(` ${joinOperator} `);\n\n  return {\n    sql: key === '$nor' ? `NOT (${joined})` : `(${joined})`,\n    values,\n  };\n}\n\nfunction handleOperator(key: string, value: any): FilterResult {\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    const entries = Object.entries(value);\n    const results = entries.map(([operator, operatorValue]) =>\n      operator === '$not'\n        ? {\n            sql: `NOT (${Object.entries(operatorValue as Record<string, any>)\n              .map(([op, val]) => processOperator(key, op as OperatorType, val).sql)\n              .join(' AND ')})`,\n            values: Object.entries(operatorValue as Record<string, any>).flatMap(\n              ([op, val]) => processOperator(key, op as OperatorType, val).values,\n            ),\n          }\n        : processOperator(key, operator as OperatorType, operatorValue),\n    );\n\n    return {\n      sql: `(${results.map(r => r.sql).join(' AND ')})`,\n      values: results.flatMap(r => r.values),\n    };\n  }\n\n  // Handle single operator\n  const [[operator, operatorValue] = []] = Object.entries(value);\n  return processOperator(key, operator as OperatorType, operatorValue);\n}\n\nconst processOperator = (key: string, operator: OperatorType, operatorValue: any): FilterResult => {\n  if (!operator.startsWith('$') || !FILTER_OPERATORS[operator]) {\n    throw new Error(`Invalid operator: ${operator}`);\n  }\n  const operatorFn = FILTER_OPERATORS[operator]!;\n  const operatorResult = operatorFn(key, operatorValue);\n\n  if (!operatorResult.needsValue) {\n    return { sql: operatorResult.sql, values: [] };\n  }\n\n  const transformed = operatorResult.transformValue ? operatorResult.transformValue() : operatorValue;\n\n  if (isFilterResult(transformed)) {\n    return transformed;\n  }\n\n  return {\n    sql: operatorResult.sql,\n    values: Array.isArray(transformed) ? transformed : [transformed],\n  };\n};\n","import { createClient } from '@libsql/client';\nimport type { Client as TursoClient, InValue } from '@libsql/client';\n\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { createVectorErrorId } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { MastraVector } from '@mastra/core/vector';\nimport type {\n  IndexStats,\n  QueryResult,\n  QueryVectorParams,\n  CreateIndexParams,\n  UpsertVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n  DeleteVectorParams,\n  UpdateVectorParams,\n  DeleteVectorsParams,\n} from '@mastra/core/vector';\nimport type { LibSQLVectorFilter } from './filter';\nimport { LibSQLFilterTranslator } from './filter';\nimport { buildFilterQuery } from './sql-builder';\n\ninterface LibSQLQueryVectorParams extends QueryVectorParams<LibSQLVectorFilter> {\n  minScore?: number;\n}\n\nexport interface LibSQLVectorConfig {\n  /**\n   * The URL of the LibSQL database.\n   * Examples: 'file:./dev.db', 'file::memory:', 'libsql://your-db.turso.io'\n   */\n  url: string;\n  authToken?: string;\n  syncUrl?: string;\n  syncInterval?: number;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n}\n\nexport class LibSQLVector extends MastraVector<LibSQLVectorFilter> {\n  private turso: TursoClient;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  constructor({\n    url,\n    authToken,\n    syncUrl,\n    syncInterval,\n    maxRetries = 5,\n    initialBackoffMs = 100,\n    id,\n  }: LibSQLVectorConfig & { id: string }) {\n    super({ id });\n\n    this.turso = createClient({\n      url,\n      syncUrl,\n      authToken,\n      syncInterval,\n    });\n    this.maxRetries = maxRetries;\n    this.initialBackoffMs = initialBackoffMs;\n\n    if (url.includes(`file:`) || url.includes(`:memory:`)) {\n      this.turso\n        .execute('PRAGMA journal_mode=WAL;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n      this.turso\n        .execute('PRAGMA busy_timeout = 5000;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout=5000.', err));\n    }\n  }\n\n  private async executeWriteOperationWithRetry<T>(operation: () => Promise<T>, isTransaction = false): Promise<T> {\n    let attempts = 0;\n    let backoff = this.initialBackoffMs;\n    while (attempts < this.maxRetries) {\n      try {\n        return await operation();\n      } catch (error: any) {\n        if (\n          error.code === 'SQLITE_BUSY' ||\n          (error.message && error.message.toLowerCase().includes('database is locked'))\n        ) {\n          attempts++;\n          if (attempts >= this.maxRetries) {\n            this.logger.error(\n              `LibSQLVector: Operation failed after ${this.maxRetries} attempts due to: ${error.message}`,\n              error,\n            );\n            throw error;\n          }\n          this.logger.warn(\n            `LibSQLVector: Attempt ${attempts} failed due to ${isTransaction ? 'transaction ' : ''}database lock. Retrying in ${backoff}ms...`,\n          );\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          backoff *= 2;\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('LibSQLVector: Max retries reached, but no error was re-thrown from the loop.');\n  }\n\n  transformFilter(filter?: LibSQLVectorFilter) {\n    const translator = new LibSQLFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query({\n    indexName,\n    queryVector,\n    topK = 10,\n    filter,\n    includeVector = false,\n    minScore = -1, // Default to -1 to include all results (cosine similarity ranges from -1 to 1)\n  }: LibSQLQueryVectorParams): Promise<QueryResult[]> {\n    try {\n      if (!Number.isInteger(topK) || topK <= 0) {\n        throw new Error('topK must be a positive integer');\n      }\n      if (!Array.isArray(queryVector) || !queryVector.every(x => typeof x === 'number' && Number.isFinite(x))) {\n        throw new Error('queryVector must be an array of finite numbers');\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'QUERY', 'INVALID_ARGS'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n      const vectorStr = `[${queryVector.join(',')}]`;\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);\n      filterValues.push(minScore);\n      filterValues.push(topK);\n\n      const query = `\n      WITH vector_scores AS (\n        SELECT\n          vector_id as id,\n          (1-vector_distance_cos(embedding, '${vectorStr}')) as score,\n          metadata\n          ${includeVector ? ', vector_extract(embedding) as embedding' : ''}\n        FROM ${parsedIndexName}\n        ${filterQuery}\n      )\n      SELECT *\n      FROM vector_scores\n      WHERE score > ?\n      ORDER BY score DESC\n      LIMIT ?`;\n\n      const result = await this.turso.execute({\n        sql: query,\n        args: filterValues,\n      });\n\n      return result.rows.map(({ id, score, metadata, embedding }) => ({\n        id: id as string,\n        score: score as number,\n        metadata: JSON.parse((metadata as string) ?? '{}'),\n        ...(includeVector && embedding && { vector: JSON.parse(embedding as string) }),\n      }));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'QUERY', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  public upsert(args: UpsertVectorParams): Promise<string[]> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doUpsert(args), true);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'UPSERT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  private async doUpsert({ indexName, vectors, metadata, ids }: UpsertVectorParams): Promise<string[]> {\n    const tx = await this.turso.transaction('write');\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n      for (let i = 0; i < vectors.length; i++) {\n        const query = `\n            INSERT INTO ${parsedIndexName} (vector_id, embedding, metadata)\n            VALUES (?, vector32(?), ?)\n            ON CONFLICT(vector_id) DO UPDATE SET\n              embedding = vector32(?),\n              metadata = ?\n          `;\n        await tx.execute({\n          sql: query,\n          args: [\n            vectorIds[i] as InValue,\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n          ],\n        });\n      }\n      await tx.commit();\n      return vectorIds;\n    } catch (error) {\n      !tx.closed && (await tx.rollback());\n      if (error instanceof Error && error.message?.includes('dimensions are different')) {\n        const match = error.message.match(/dimensions are different: (\\d+) != (\\d+)/);\n        if (match) {\n          const [, actual, expected] = match;\n          throw new Error(\n            `Vector dimension mismatch: Index \"${indexName}\" expects ${expected} dimensions but got ${actual} dimensions. ` +\n              `Either use a matching embedding model or delete and recreate the index with the new dimension.`,\n          );\n        }\n      }\n      throw error;\n    }\n  }\n\n  public createIndex(args: CreateIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doCreateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'CREATE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName, dimension: args.dimension },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doCreateIndex({ indexName, dimension }: CreateIndexParams): Promise<void> {\n    if (!Number.isInteger(dimension) || dimension <= 0) {\n      throw new Error('Dimension must be a positive integer');\n    }\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `\n          CREATE TABLE IF NOT EXISTS ${parsedIndexName} (\n            id SERIAL PRIMARY KEY,\n            vector_id TEXT UNIQUE NOT NULL,\n            embedding F32_BLOB(${dimension}),\n            metadata TEXT DEFAULT '{}'\n          );\n        `,\n      args: [],\n    });\n    await this.turso.execute({\n      sql: `\n          CREATE INDEX IF NOT EXISTS ${parsedIndexName}_vector_idx\n          ON ${parsedIndexName} (libsql_vector_idx(embedding))\n        `,\n      args: [],\n    });\n  }\n\n  public deleteIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DROP TABLE IF EXISTS ${parsedIndexName}`,\n      args: [],\n    });\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const vectorTablesQuery = `\n        SELECT name FROM sqlite_master \n        WHERE type='table' \n        AND sql LIKE '%F32_BLOB%';\n      `;\n      const result = await this.turso.execute({\n        sql: vectorTablesQuery,\n        args: [],\n      });\n      return result.rows.map(row => row.name as string);\n    } catch (error: any) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'LIST_INDEXES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Retrieves statistics about a vector index.\n   *\n   * @param {string} indexName - The name of the index to describe\n   * @returns A promise that resolves to the index statistics including dimension, count and metric\n   */\n  async describeIndex({ indexName }: DescribeIndexParams): Promise<IndexStats> {\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      // Get table info including column info\n      const tableInfoQuery = `\n        SELECT sql \n        FROM sqlite_master \n        WHERE type='table' \n        AND name = ?;\n      `;\n      const tableInfo = await this.turso.execute({\n        sql: tableInfoQuery,\n        args: [parsedIndexName],\n      });\n\n      if (!tableInfo.rows[0]?.sql) {\n        throw new Error(`Table ${parsedIndexName} not found`);\n      }\n\n      // Extract dimension from F32_BLOB definition\n      const dimension = parseInt((tableInfo.rows[0].sql as string).match(/F32_BLOB\\((\\d+)\\)/)?.[1] || '0');\n\n      // Get row count\n      const countQuery = `\n        SELECT COUNT(*) as count\n        FROM ${parsedIndexName};\n      `;\n      const countResult = await this.turso.execute({\n        sql: countQuery,\n        args: [],\n      });\n\n      // LibSQL only supports cosine similarity currently\n      const metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine';\n\n      return {\n        dimension,\n        count: (countResult?.rows?.[0]?.count as number) ?? 0,\n        metric,\n      };\n    } catch (e: any) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DESCRIBE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName },\n        },\n        e,\n      );\n    }\n  }\n\n  /**\n   * Updates a vector by its ID with the provided vector and/or metadata.\n   *\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  public updateVector(args: UpdateVectorParams<LibSQLVectorFilter>): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doUpdateVector(args));\n  }\n\n  private async doUpdateVector(params: UpdateVectorParams<LibSQLVectorFilter>): Promise<void> {\n    const { indexName, update } = params;\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n    // Validate that both id and filter are not provided at the same time\n    if ('id' in params && params.id && 'filter' in params && params.filter) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'MUTUALLY_EXCLUSIVE'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'id and filter are mutually exclusive - provide only one',\n      });\n    }\n\n    if (!update.vector && !update.metadata) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'NO_PAYLOAD'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'No updates provided',\n      });\n    }\n\n    const updates: string[] = [];\n    const args: InValue[] = [];\n\n    if (update.vector) {\n      updates.push('embedding = vector32(?)');\n      args.push(JSON.stringify(update.vector));\n    }\n\n    if (update.metadata) {\n      updates.push('metadata = ?');\n      args.push(JSON.stringify(update.metadata));\n    }\n\n    if (updates.length === 0) {\n      return;\n    }\n\n    let whereClause: string;\n    let whereValues: InValue[];\n\n    // Type narrowing: check if updating by id or by filter\n    if ('id' in params && params.id) {\n      // Update by ID\n      whereClause = 'vector_id = ?';\n      whereValues = [params.id];\n    } else if ('filter' in params && params.filter) {\n      // Update by filter\n      const filter = params.filter;\n\n      if (!filter || Object.keys(filter).length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'EMPTY_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot update with empty filter',\n        });\n      }\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);\n\n      if (!filterSql || filterSql.trim() === '') {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'INVALID_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Filter produced empty WHERE clause',\n        });\n      }\n\n      // Guard against match-all patterns that would update all vectors\n      // Normalize SQL by removing WHERE prefix and extra whitespace for pattern matching\n      const normalizedCondition = filterSql\n        .replace(/^\\s*WHERE\\s+/i, '')\n        .trim()\n        .toLowerCase();\n      const matchAllPatterns = ['true', '1 = 1', '1=1'];\n\n      if (matchAllPatterns.includes(normalizedCondition)) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'MATCH_ALL_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName, filterSql: normalizedCondition },\n          text: 'Filter matches all vectors. Provide a specific filter to update targeted vectors.',\n        });\n      }\n\n      // buildFilterQuery already includes \"WHERE\" in the SQL, so we need to extract just the condition\n      whereClause = filterSql.replace(/^WHERE\\s+/i, '');\n      whereValues = filterValues;\n    } else {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'NO_TARGET'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Either id or filter must be provided',\n      });\n    }\n\n    const query = `\n      UPDATE ${parsedIndexName}\n      SET ${updates.join(', ')}\n      WHERE ${whereClause};\n    `;\n\n    try {\n      await this.turso.execute({\n        sql: query,\n        args: [...args, ...whereValues],\n      });\n    } catch (error) {\n      const errorDetails: Record<string, any> = { indexName };\n\n      if ('id' in params && params.id) {\n        errorDetails.id = params.id;\n      }\n\n      if ('filter' in params && params.filter) {\n        errorDetails.filter = JSON.stringify(params.filter);\n      }\n\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: errorDetails,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes a vector by its ID.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   * @throws Will throw an error if the deletion operation fails.\n   */\n  public deleteVector(args: DeleteVectorParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteVector(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTOR', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName: args.indexName,\n            ...(args.id && { id: args.id }),\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteVector({ indexName, id }: DeleteVectorParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DELETE FROM ${parsedIndexName} WHERE vector_id = ?`,\n      args: [id],\n    });\n  }\n\n  public deleteVectors(args: DeleteVectorsParams<LibSQLVectorFilter>): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doDeleteVectors(args));\n  }\n\n  private async doDeleteVectors({ indexName, filter, ids }: DeleteVectorsParams<LibSQLVectorFilter>): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n    // Validate that exactly one of filter or ids is provided\n    if (!filter && !ids) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'NO_TARGET'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Either filter or ids must be provided',\n      });\n    }\n\n    if (filter && ids) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'MUTUALLY_EXCLUSIVE'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Cannot provide both filter and ids - they are mutually exclusive',\n      });\n    }\n\n    let query: string;\n    let values: InValue[];\n\n    if (ids) {\n      // Delete by IDs\n      if (ids.length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'EMPTY_IDS'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot delete with empty ids array',\n        });\n      }\n\n      const placeholders = ids.map(() => '?').join(', ');\n      query = `DELETE FROM ${parsedIndexName} WHERE vector_id IN (${placeholders})`;\n      values = ids;\n    } else {\n      // Delete by filter\n      // Safety check: Don't allow empty filters to prevent accidental deletion of all vectors\n      if (!filter || Object.keys(filter).length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'EMPTY_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot delete with empty filter. Use deleteIndex to delete all vectors.',\n        });\n      }\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);\n\n      if (!filterSql || filterSql.trim() === '') {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'INVALID_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Filter produced empty WHERE clause',\n        });\n      }\n\n      // Guard against match-all patterns that would delete all vectors\n      // Normalize SQL by removing WHERE prefix and extra whitespace for pattern matching\n      const normalizedCondition = filterSql\n        .replace(/^\\s*WHERE\\s+/i, '')\n        .trim()\n        .toLowerCase();\n      const matchAllPatterns = ['true', '1 = 1', '1=1'];\n\n      if (matchAllPatterns.includes(normalizedCondition)) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'MATCH_ALL_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName, filterSql: normalizedCondition },\n          text: 'Filter matches all vectors. Use deleteIndex to delete all vectors from an index.',\n        });\n      }\n\n      // buildFilterQuery already includes \"WHERE\" in the SQL\n      query = `DELETE FROM ${parsedIndexName} ${filterSql}`;\n      values = filterValues;\n    }\n\n    try {\n      await this.turso.execute({\n        sql: query,\n        args: values,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n            ...(filter && { filter: JSON.stringify(filter) }),\n            ...(ids && { idsCount: ids.length }),\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  public truncateIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this._doTruncateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'TRUNCATE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async _doTruncateIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    await this.turso.execute({\n      sql: `DELETE FROM ${parseSqlIdentifier(indexName, 'index name')}`,\n      args: [],\n    });\n  }\n}\n","import type { InValue } from '@libsql/client';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport { safelyParseJSON, TABLE_SCHEMAS } from '@mastra/core/storage';\nimport type { StorageColumn, TABLE_NAMES } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\n\n/**\n * Builds a SQL column list for SELECT statements, wrapping JSONB columns with json()\n * to convert binary JSONB to TEXT.\n *\n * The json() function handles both:\n * - Binary JSONB data (converts to TEXT)\n * - Legacy TEXT JSON data (returns as-is)\n *\n * Note: json_valid() was considered for guarding against malformed legacy TEXT,\n * but it doesn't work correctly with binary JSONB data (returns false for valid JSONB blobs).\n *\n * @param tableName - The table name to get the schema for\n * @returns A comma-separated column list with json() wrappers for JSONB columns\n */\nexport function buildSelectColumns(tableName: TABLE_NAMES): string {\n  const schema = TABLE_SCHEMAS[tableName];\n  return Object.keys(schema)\n    .map(col => {\n      const colDef = schema[col];\n      const parsedCol = parseSqlIdentifier(col, 'column name');\n      return colDef?.type === 'jsonb' ? `json(${parsedCol}) as ${parsedCol}` : parsedCol;\n    })\n    .join(', ');\n}\n\n/**\n * Checks if an error is a SQLite lock/busy error that should be retried\n */\nexport function isLockError(error: any): boolean {\n  return (\n    error.code === 'SQLITE_BUSY' ||\n    error.code === 'SQLITE_LOCKED' ||\n    error.message?.toLowerCase().includes('database is locked') ||\n    error.message?.toLowerCase().includes('database table is locked') ||\n    error.message?.toLowerCase().includes('table is locked') ||\n    (error.constructor.name === 'SqliteError' && error.message?.toLowerCase().includes('locked'))\n  );\n}\n\nexport function createExecuteWriteOperationWithRetry({\n  logger,\n  maxRetries,\n  initialBackoffMs,\n}: {\n  logger: IMastraLogger;\n  maxRetries: number;\n  initialBackoffMs: number;\n}) {\n  return async function executeWriteOperationWithRetry<T>(\n    operationFn: () => Promise<T>,\n    operationDescription: string,\n  ): Promise<T> {\n    let attempts = 0;\n    let backoff = initialBackoffMs;\n\n    while (attempts < maxRetries) {\n      try {\n        return await operationFn();\n      } catch (error: any) {\n        logger.debug(`LibSQLStore: Error caught in retry loop for ${operationDescription}`, {\n          errorType: error.constructor.name,\n          errorCode: error.code,\n          errorMessage: error.message,\n          attempts,\n          maxRetries,\n        });\n\n        if (isLockError(error)) {\n          attempts++;\n          if (attempts >= maxRetries) {\n            logger.error(\n              `LibSQLStore: Operation failed after ${maxRetries} attempts due to database lock: ${error.message}`,\n              { error, attempts, maxRetries },\n            );\n            throw error;\n          }\n          logger.warn(\n            `LibSQLStore: Attempt ${attempts} failed due to database lock during ${operationDescription}. Retrying in ${backoff}ms...`,\n            { errorMessage: error.message, attempts, backoff, maxRetries },\n          );\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          backoff *= 2;\n        } else {\n          logger.error(`LibSQLStore: Non-lock error during ${operationDescription}, not retrying`, { error });\n          throw error;\n        }\n      }\n    }\n    // TypeScript requires a return/throw here for type safety, but this is unreachable\n    // because the loop always exits via return (success) or throw (error)\n    throw new Error(`LibSQLStore: Unexpected exit from retry loop for ${operationDescription}`);\n  };\n}\n\nexport function prepareStatement({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const schema = TABLE_SCHEMAS[tableName];\n  const columnNames = Object.keys(record);\n  const columns = columnNames.map(col => parseSqlIdentifier(col, 'column name'));\n  const values = columnNames.map(col => {\n    const v = record[col];\n    if (typeof v === `undefined` || v === null) {\n      // returning an undefined value will cause libsql to throw\n      return null;\n    }\n    // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n    // Must check jsonb BEFORE Date, because JSON.stringify properly serializes Dates\n    const colDef = schema[col];\n    if (colDef?.type === 'jsonb') {\n      return JSON.stringify(v);\n    }\n    if (v instanceof Date) {\n      return v.toISOString();\n    }\n    return typeof v === 'object' ? JSON.stringify(v) : v;\n  });\n  const placeholders = columnNames\n    .map(col => {\n      const colDef = schema[col];\n      return colDef?.type === 'jsonb' ? 'jsonb(?)' : '?';\n    })\n    .join(', ');\n\n  return {\n    sql: `INSERT OR REPLACE INTO ${parsedTableName} (${columns.join(', ')}) VALUES (${placeholders})`,\n    args: values,\n  };\n}\n\nexport function prepareUpdateStatement({\n  tableName,\n  updates,\n  keys,\n}: {\n  tableName: TABLE_NAMES;\n  updates: Record<string, any>;\n  keys: Record<string, any>;\n}): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const schema = TABLE_SCHEMAS[tableName];\n\n  // Prepare SET clause\n  const updateColumnNames = Object.keys(updates);\n  const updateColumns = updateColumnNames.map(col => parseSqlIdentifier(col, 'column name'));\n  const updateValues = updateColumnNames.map(col => {\n    const colDef = schema[col];\n    const v = updates[col];\n    // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n    if (colDef?.type === 'jsonb') {\n      return transformToSqlValue(v, true);\n    }\n    return transformToSqlValue(v, false);\n  });\n  const setClause = updateColumns\n    .map((col, i) => {\n      const colDef = schema[updateColumnNames[i]!];\n      return colDef?.type === 'jsonb' ? `${col} = jsonb(?)` : `${col} = ?`;\n    })\n    .join(', ');\n\n  const whereClause = prepareWhereClause(keys, schema);\n\n  return {\n    sql: `UPDATE ${parsedTableName} SET ${setClause}${whereClause.sql}`,\n    args: [...updateValues, ...whereClause.args],\n  };\n}\n\nexport function transformToSqlValue(value: any, forceJsonStringify: boolean = false): InValue {\n  if (typeof value === 'undefined' || value === null) {\n    return null;\n  }\n  // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n  // Must check jsonb BEFORE Date, because JSON.stringify properly serializes Dates\n  if (forceJsonStringify) {\n    return JSON.stringify(value);\n  }\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  return typeof value === 'object' ? JSON.stringify(value) : value;\n}\n\nexport function prepareDeleteStatement({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const whereClause = prepareWhereClause(keys, TABLE_SCHEMAS[tableName]);\n\n  return {\n    sql: `DELETE FROM ${parsedTableName}${whereClause.sql}`,\n    args: whereClause.args,\n  };\n}\n\ntype WhereValue = InValue | { startAt?: InValue; endAt?: InValue };\n\nexport function prepareWhereClause(\n  filters: Record<string, WhereValue>,\n  schema: Record<string, StorageColumn>,\n): {\n  sql: string;\n  args: InValue[];\n} {\n  const conditions: string[] = [];\n  const args: InValue[] = [];\n\n  for (const [columnName, filterValue] of Object.entries(filters)) {\n    const column = schema[columnName];\n    if (!column) {\n      throw new Error(`Unknown column: ${columnName}`);\n    }\n\n    const parsedColumn = parseSqlIdentifier(columnName, 'column name');\n    const result = buildCondition(parsedColumn, filterValue);\n\n    conditions.push(result.condition);\n    args.push(...result.args);\n  }\n\n  return {\n    sql: conditions.length > 0 ? ` WHERE ${conditions.join(' AND ')}` : '',\n    args,\n  };\n}\n\nfunction buildCondition(columnName: string, filterValue: WhereValue): { condition: string; args: InValue[] } {\n  // Handle null values - IS NULL\n  if (filterValue === null) {\n    return { condition: `${columnName} IS NULL`, args: [] };\n  }\n\n  // Handle date range objects\n  if (typeof filterValue === 'object' && filterValue !== null && ('startAt' in filterValue || 'endAt' in filterValue)) {\n    return buildDateRangeCondition(columnName, filterValue);\n  }\n\n  // Handle exact match\n  return {\n    condition: `${columnName} = ?`,\n    args: [transformToSqlValue(filterValue)],\n  };\n}\n\nfunction buildDateRangeCondition(\n  columnName: string,\n  range: { startAt?: InValue; endAt?: InValue },\n): { condition: string; args: InValue[] } {\n  const conditions: string[] = [];\n  const args: InValue[] = [];\n\n  if (range.startAt !== undefined) {\n    conditions.push(`${columnName} >= ?`);\n    args.push(transformToSqlValue(range.startAt));\n  }\n\n  if (range.endAt !== undefined) {\n    conditions.push(`${columnName} <= ?`);\n    args.push(transformToSqlValue(range.endAt));\n  }\n\n  if (conditions.length === 0) {\n    throw new Error('Date range must specify at least startAt or endAt');\n  }\n\n  return {\n    condition: conditions.join(' AND '),\n    args,\n  };\n}\n\n/**\n * Transforms SQL row data back to a typed object format\n * Reverses the transformations done in prepareStatement\n */\nexport function transformFromSqlRow<T>({\n  tableName,\n  sqlRow,\n}: {\n  tableName: TABLE_NAMES;\n  sqlRow: Record<string, any>;\n}): T {\n  const result: Record<string, any> = {};\n  const jsonColumns = new Set(\n    Object.keys(TABLE_SCHEMAS[tableName])\n      .filter(key => TABLE_SCHEMAS[tableName][key]!.type === 'jsonb')\n      .map(key => key),\n  );\n  const dateColumns = new Set(\n    Object.keys(TABLE_SCHEMAS[tableName])\n      .filter(key => TABLE_SCHEMAS[tableName][key]!.type === 'timestamp')\n      .map(key => key),\n  );\n\n  for (const [key, value] of Object.entries(sqlRow)) {\n    if (value === null || value === undefined) {\n      result[key] = value;\n      continue;\n    }\n\n    if (dateColumns.has(key) && typeof value === 'string') {\n      result[key] = new Date(value);\n      continue;\n    }\n\n    if (jsonColumns.has(key) && typeof value === 'string') {\n      result[key] = safelyParseJSON(value);\n      continue;\n    }\n\n    result[key] = value;\n  }\n\n  return result as T;\n}\n","import { createClient } from '@libsql/client';\nimport type { Client, InValue } from '@libsql/client';\nimport { MastraBase } from '@mastra/core/base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  createStorageErrorId,\n  getSqlType,\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_SPANS,\n  TABLE_SCHEMAS,\n} from '@mastra/core/storage';\nimport type { TABLE_NAMES, StorageColumn } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport {\n  buildSelectColumns,\n  createExecuteWriteOperationWithRetry,\n  prepareDeleteStatement,\n  prepareStatement,\n  prepareUpdateStatement,\n} from './utils';\n\n/**\n * Base configuration options shared across LibSQL domain configurations\n */\nexport type LibSQLDomainBaseConfig = {\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n};\n\n/**\n * Configuration for LibSQL domains - accepts either credentials or an existing client\n */\nexport type LibSQLDomainConfig =\n  | (LibSQLDomainBaseConfig & {\n      /** The database connection URL (e.g., \"file:local.db\", \"libsql://...\", \"file::memory:\") */\n      url: string;\n      /** Optional authentication token for remote databases */\n      authToken?: string;\n    })\n  | (LibSQLDomainBaseConfig & {\n      /** An existing LibSQL client instance */\n      client: Client;\n    });\n\n/**\n * Resolves a LibSQLDomainConfig to a Client instance.\n * Creates a new client if credentials are provided, or returns the existing client.\n *\n * @param config - The domain configuration\n * @returns The resolved LibSQL client\n */\nexport function resolveClient(config: LibSQLDomainConfig): Client {\n  if ('client' in config) {\n    return config.client;\n  }\n  return createClient({\n    url: config.url,\n    ...(config.authToken ? { authToken: config.authToken } : {}),\n  });\n}\n\nexport class LibSQLDB extends MastraBase {\n  private client: Client;\n  maxRetries: number;\n  initialBackoffMs: number;\n  executeWriteOperationWithRetry: <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;\n\n  constructor({\n    client,\n    maxRetries,\n    initialBackoffMs,\n  }: {\n    client: Client;\n    maxRetries?: number;\n    initialBackoffMs?: number;\n  }) {\n    super({\n      component: 'STORAGE',\n      name: 'LIBSQL_DB_LAYER',\n    });\n\n    this.client = client;\n    this.maxRetries = maxRetries ?? 5;\n    this.initialBackoffMs = initialBackoffMs ?? 100;\n\n    this.executeWriteOperationWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    });\n  }\n\n  /**\n   * Checks if a column exists in the specified table.\n   *\n   * @param table - The name of the table to check\n   * @param column - The name of the column to look for\n   * @returns `true` if the column exists in the table, `false` otherwise\n   */\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    const sanitizedTable = parseSqlIdentifier(table, 'table name');\n    const result = await this.client.execute({\n      sql: `PRAGMA table_info(\"${sanitizedTable}\")`,\n    });\n    return result.rows?.some((row: any) => row.name === column);\n  }\n\n  /**\n   * Internal insert implementation without retry logic.\n   */\n  private async doInsert({\n    tableName,\n    record,\n  }: {\n    tableName: TABLE_NAMES;\n    record: Record<string, any>;\n  }): Promise<void> {\n    await this.client.execute(\n      prepareStatement({\n        tableName,\n        record,\n      }),\n    );\n  }\n\n  /**\n   * Inserts or replaces a record in the specified table with automatic retry on lock errors.\n   *\n   * @param args - The insert arguments\n   * @param args.tableName - The name of the table to insert into\n   * @param args.record - The record to insert (key-value pairs)\n   */\n  public insert(args: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doInsert(args), `insert into table ${args.tableName}`);\n  }\n\n  /**\n   * Internal update implementation without retry logic.\n   */\n  private async doUpdate({\n    tableName,\n    keys,\n    data,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Record<string, any>;\n    data: Record<string, any>;\n  }): Promise<void> {\n    await this.client.execute(prepareUpdateStatement({ tableName, updates: data, keys }));\n  }\n\n  /**\n   * Updates a record in the specified table with automatic retry on lock errors.\n   *\n   * @param args - The update arguments\n   * @param args.tableName - The name of the table to update\n   * @param args.keys - The key(s) identifying the record to update\n   * @param args.data - The fields to update (key-value pairs)\n   */\n  public update(args: { tableName: TABLE_NAMES; keys: Record<string, any>; data: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doUpdate(args), `update table ${args.tableName}`);\n  }\n\n  /**\n   * Internal batch insert implementation without retry logic.\n   */\n  private async doBatchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void> {\n    if (records.length === 0) return;\n    const batchStatements = records.map(r => prepareStatement({ tableName, record: r }));\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Inserts multiple records in a single batch transaction with automatic retry on lock errors.\n   *\n   * @param args - The batch insert arguments\n   * @param args.tableName - The name of the table to insert into\n   * @param args.records - Array of records to insert\n   * @throws {MastraError} When the batch insert fails after retries\n   */\n  public async batchInsert(args: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchInsert(args),\n      `batch insert into table ${args.tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_INSERT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName: args.tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal batch update implementation without retry logic.\n   * Each record can be updated based on single or composite keys.\n   */\n  private async doBatchUpdate({\n    tableName,\n    updates,\n  }: {\n    tableName: TABLE_NAMES;\n    updates: Array<{\n      keys: Record<string, any>;\n      data: Record<string, any>;\n    }>;\n  }): Promise<void> {\n    if (updates.length === 0) return;\n\n    const batchStatements = updates.map(({ keys, data }) =>\n      prepareUpdateStatement({\n        tableName,\n        updates: data,\n        keys,\n      }),\n    );\n\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Updates multiple records in a single batch transaction with automatic retry on lock errors.\n   * Each record can be updated based on single or composite keys.\n   *\n   * @param args - The batch update arguments\n   * @param args.tableName - The name of the table to update\n   * @param args.updates - Array of update operations, each containing keys and data\n   * @throws {MastraError} When the batch update fails after retries\n   */\n  public async batchUpdate(args: {\n    tableName: TABLE_NAMES;\n    updates: Array<{\n      keys: Record<string, any>;\n      data: Record<string, any>;\n    }>;\n  }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchUpdate(args),\n      `batch update in table ${args.tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_UPDATE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName: args.tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal batch delete implementation without retry logic.\n   * Each record can be deleted based on single or composite keys.\n   */\n  private async doBatchDelete({\n    tableName,\n    keys,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Array<Record<string, any>>;\n  }): Promise<void> {\n    if (keys.length === 0) return;\n\n    const batchStatements = keys.map(keyObj =>\n      prepareDeleteStatement({\n        tableName,\n        keys: keyObj,\n      }),\n    );\n\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Deletes multiple records in a single batch transaction with automatic retry on lock errors.\n   * Each record can be deleted based on single or composite keys.\n   *\n   * @param args - The batch delete arguments\n   * @param args.tableName - The name of the table to delete from\n   * @param args.keys - Array of key objects identifying records to delete\n   * @throws {MastraError} When the batch delete fails after retries\n   */\n  public async batchDelete({\n    tableName,\n    keys,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Array<Record<string, any>>;\n  }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchDelete({ tableName, keys }),\n      `batch delete from table ${tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_DELETE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal single-record delete implementation without retry logic.\n   */\n  private async doDelete({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<void> {\n    await this.client.execute(prepareDeleteStatement({ tableName, keys }));\n  }\n\n  /**\n   * Deletes a single record from the specified table with automatic retry on lock errors.\n   *\n   * @param args - The delete arguments\n   * @param args.tableName - The name of the table to delete from\n   * @param args.keys - The key(s) identifying the record to delete\n   * @throws {MastraError} When the delete fails after retries\n   */\n  public async delete(args: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doDelete(args), `delete from table ${args.tableName}`).catch(\n      error => {\n        throw new MastraError(\n          {\n            id: createStorageErrorId('LIBSQL', 'DELETE', 'FAILED'),\n            domain: ErrorDomain.STORAGE,\n            category: ErrorCategory.THIRD_PARTY,\n            details: {\n              tableName: args.tableName,\n            },\n          },\n          error,\n        );\n      },\n    );\n  }\n\n  /**\n   * Selects a single record from the specified table by key(s).\n   * Returns the most recently created record if multiple matches exist.\n   * Automatically parses JSON string values back to objects/arrays.\n   *\n   * @typeParam R - The expected return type of the record\n   * @param args - The select arguments\n   * @param args.tableName - The name of the table to select from\n   * @param args.keys - The key(s) identifying the record to select\n   * @returns The matching record or `null` if not found\n   */\n  async select<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    const columns = buildSelectColumns(tableName);\n\n    const parsedKeys = Object.keys(keys).map(key => parseSqlIdentifier(key, 'column name'));\n\n    const conditions = parsedKeys.map(key => `${key} = ?`).join(' AND ');\n    const values = Object.values(keys);\n\n    const result = await this.client.execute({\n      sql: `SELECT ${columns} FROM ${parsedTableName} WHERE ${conditions} ORDER BY createdAt DESC LIMIT 1`,\n      args: values,\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    // Checks whether the string looks like a JSON object ({}) or array ([])\n    // If the string starts with { or [, it assumes it's JSON and parses it\n    // Otherwise, it just returns, preventing unintended number conversions\n    const parsed = Object.fromEntries(\n      Object.entries(row || {}).map(([k, v]) => {\n        try {\n          return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n        } catch {\n          return [k, v];\n        }\n      }),\n    );\n\n    return parsed as R;\n  }\n\n  /**\n   * Selects multiple records from the specified table with optional filtering, ordering, and pagination.\n   *\n   * @typeParam R - The expected return type of each record\n   * @param args - The select arguments\n   * @param args.tableName - The name of the table to select from\n   * @param args.whereClause - Optional WHERE clause with SQL string and arguments\n   * @param args.orderBy - Optional ORDER BY clause (e.g., \"createdAt DESC\")\n   * @param args.offset - Optional offset for pagination\n   * @param args.limit - Optional limit for pagination\n   * @param args.args - Optional additional query arguments\n   * @returns Array of matching records\n   */\n  async selectMany<R>({\n    tableName,\n    whereClause,\n    orderBy,\n    offset,\n    limit,\n    args,\n  }: {\n    tableName: TABLE_NAMES;\n    whereClause?: { sql: string; args: InValue[] };\n    orderBy?: string;\n    offset?: number;\n    limit?: number;\n    args?: any[];\n  }): Promise<R[]> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    const columns = buildSelectColumns(tableName);\n\n    let statement = `SELECT ${columns} FROM ${parsedTableName}`;\n\n    if (whereClause?.sql) {\n      statement += ` ${whereClause.sql}`;\n    }\n\n    if (orderBy) {\n      statement += ` ORDER BY ${orderBy}`;\n    }\n\n    if (limit) {\n      statement += ` LIMIT ${limit}`;\n    }\n\n    if (offset) {\n      statement += ` OFFSET ${offset}`;\n    }\n\n    const result = await this.client.execute({\n      sql: statement,\n      args: [...(whereClause?.args ?? []), ...(args ?? [])],\n    });\n\n    // Parse JSON columns (same as select())\n    return (result.rows ?? []).map(row => {\n      return Object.fromEntries(\n        Object.entries(row || {}).map(([k, v]) => {\n          try {\n            return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n          } catch {\n            return [k, v];\n          }\n        }),\n      );\n    }) as R[];\n  }\n\n  /**\n   * Returns the total count of records matching the optional WHERE clause.\n   *\n   * @param args - The count arguments\n   * @param args.tableName - The name of the table to count from\n   * @param args.whereClause - Optional WHERE clause with SQL string and arguments\n   * @returns The total count of matching records\n   */\n  async selectTotalCount({\n    tableName,\n    whereClause,\n  }: {\n    tableName: TABLE_NAMES;\n    whereClause?: { sql: string; args: InValue[] };\n  }): Promise<number> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    const statement = `SELECT COUNT(*) as count FROM ${parsedTableName} ${whereClause ? `${whereClause.sql}` : ''}`;\n\n    const result = await this.client.execute({\n      sql: statement,\n      args: whereClause?.args ?? [],\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return 0;\n    }\n\n    return (result.rows[0]?.count as number) ?? 0;\n  }\n\n  /**\n   * Maps a storage column type to its SQLite equivalent.\n   */\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'bigint':\n        return 'INTEGER'; // SQLite uses INTEGER for all integer sizes\n      case 'timestamp':\n        return 'TEXT'; // Store timestamps as ISO strings in SQLite\n      case 'float':\n        return 'REAL'; // SQLite's floating point type\n      case 'boolean':\n        return 'INTEGER'; // SQLite uses 0/1 for booleans\n      case 'jsonb':\n        return 'TEXT'; // SQLite: column stores TEXT, we use jsonb()/json() functions for binary optimization\n      default:\n        return getSqlType(type); // text, integer, uuid all map correctly\n    }\n  }\n\n  /**\n   * Creates a table if it doesn't exist based on the provided schema.\n   *\n   * @param args - The create table arguments\n   * @param args.tableName - The name of the table to create\n   * @param args.schema - The schema definition for the table columns\n   */\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n      // Build column definitions\n      const columnDefinitions = Object.entries(schema).map(([colName, colDef]) => {\n        const type = this.getSqlType(colDef.type);\n        const nullable = colDef.nullable === false ? 'NOT NULL' : '';\n        const primaryKey = colDef.primaryKey ? 'PRIMARY KEY' : '';\n        return `\"${colName}\" ${type} ${nullable} ${primaryKey}`.trim();\n      });\n\n      // Add table-level constraints\n      const tableConstraints: string[] = [];\n      if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n        tableConstraints.push('UNIQUE (workflow_name, run_id)');\n      }\n\n      const allDefinitions = [...columnDefinitions, ...tableConstraints].join(',\\n  ');\n\n      const sql = `CREATE TABLE IF NOT EXISTS ${parsedTableName} (\\n  ${allDefinitions}\\n)`;\n\n      await this.client.execute(sql);\n      this.logger.debug(`LibSQLDB: Created table ${tableName}`);\n\n      // Run migrations for Spans table to add any new columns\n      if (tableName === TABLE_SPANS) {\n        await this.migrateSpansTable();\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { tableName },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Migrates the spans table schema from OLD_SPAN_SCHEMA to current SPAN_SCHEMA.\n   * This adds new columns that don't exist in old schema.\n   */\n  private async migrateSpansTable(): Promise<void> {\n    const schema = TABLE_SCHEMAS[TABLE_SPANS];\n\n    try {\n      // Add any columns from current schema that don't exist in the database\n      for (const [columnName, columnDef] of Object.entries(schema)) {\n        const columnExists = await this.hasColumn(TABLE_SPANS, columnName);\n        if (!columnExists) {\n          const sqlType = this.getSqlType(columnDef.type);\n          // For new columns, use nullable (no default needed) since existing rows will have NULL\n          const alterSql = `ALTER TABLE \"${TABLE_SPANS}\" ADD COLUMN \"${columnName}\" ${sqlType}`;\n          await this.client.execute(alterSql);\n          this.logger.debug(`LibSQLDB: Added column '${columnName}' to ${TABLE_SPANS}`);\n        }\n      }\n\n      this.logger.info(`LibSQLDB: Migration completed for ${TABLE_SPANS}`);\n    } catch (error) {\n      // Log warning but don't fail - migrations should be best-effort\n      this.logger.warn(`LibSQLDB: Failed to migrate spans table ${TABLE_SPANS}:`, error);\n    }\n  }\n\n  /**\n   * Gets a default value for a column type (used when adding NOT NULL columns).\n   */\n  private getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'boolean':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      case 'timestamp':\n        return 'DEFAULT CURRENT_TIMESTAMP';\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  /**\n   * Alters an existing table to add missing columns.\n   * Used for schema migrations when new columns are added.\n   *\n   * @param args - The alter table arguments\n   * @param args.tableName - The name of the table to alter\n   * @param args.schema - The full schema definition for the table\n   * @param args.ifNotExists - Array of column names to add if they don't exist\n   */\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    try {\n      // Get existing columns\n      const tableInfo = await this.client.execute({\n        sql: `PRAGMA table_info(\"${parsedTableName}\")`,\n      });\n      const existingColumns = new Set((tableInfo.rows || []).map((row: any) => row.name?.toLowerCase()));\n\n      // Add missing columns\n      for (const columnName of ifNotExists) {\n        if (!existingColumns.has(columnName.toLowerCase()) && schema[columnName]) {\n          const columnDef = schema[columnName];\n          const sqlType = this.getSqlType(columnDef.type);\n          const defaultValue = this.getDefaultValue(columnDef.type);\n\n          // SQLite doesn't support ADD COLUMN IF NOT EXISTS, but we checked above\n          const alterSql = `ALTER TABLE ${parsedTableName} ADD COLUMN \"${columnName}\" ${sqlType} ${defaultValue}`;\n          await this.client.execute(alterSql);\n          this.logger.debug(`LibSQLDB: Added column ${columnName} to table ${tableName}`);\n        }\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'ALTER_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { tableName },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes all records from the specified table.\n   * Errors are logged but not thrown.\n   *\n   * @param args - The delete arguments\n   * @param args.tableName - The name of the table to clear\n   */\n  async deleteData({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    try {\n      await this.client.execute(`DELETE FROM ${parsedTableName}`);\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CLEAR_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        e,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  AgentsStorage,\n  createStorageErrorId,\n  normalizePerPage,\n  calculatePagination,\n  TABLE_AGENTS,\n  AGENTS_SCHEMA,\n} from '@mastra/core/storage';\nimport type {\n  StorageAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n} from '@mastra/core/storage';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\n\nexport class AgentsLibSQL extends AgentsStorage {\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_AGENTS, schema: AGENTS_SCHEMA });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_AGENTS });\n  }\n\n  private parseJson(value: any, fieldName?: string): any {\n    if (!value) return undefined;\n    if (typeof value !== 'string') return value;\n\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      const details: Record<string, string> = {\n        value: value.length > 100 ? value.substring(0, 100) + '...' : value,\n      };\n      if (fieldName) {\n        details.field = fieldName;\n      }\n\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'PARSE_JSON', 'INVALID_JSON'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.SYSTEM,\n          text: `Failed to parse JSON${fieldName ? ` for field \"${fieldName}\"` : ''}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          details,\n        },\n        error,\n      );\n    }\n  }\n\n  private parseRow(row: any): StorageAgentType {\n    return {\n      id: row.id as string,\n      name: row.name as string,\n      description: row.description as string | undefined,\n      instructions: row.instructions as string,\n      model: this.parseJson(row.model, 'model'),\n      tools: this.parseJson(row.tools, 'tools'),\n      defaultOptions: this.parseJson(row.defaultOptions, 'defaultOptions'),\n      workflows: this.parseJson(row.workflows, 'workflows'),\n      agents: this.parseJson(row.agents, 'agents'),\n      inputProcessors: this.parseJson(row.inputProcessors, 'inputProcessors'),\n      outputProcessors: this.parseJson(row.outputProcessors, 'outputProcessors'),\n      memory: this.parseJson(row.memory, 'memory'),\n      scorers: this.parseJson(row.scorers, 'scorers'),\n      metadata: this.parseJson(row.metadata, 'metadata'),\n      createdAt: new Date(row.createdAt as string),\n      updatedAt: new Date(row.updatedAt as string),\n    };\n  }\n\n  async getAgentById({ id }: { id: string }): Promise<StorageAgentType | null> {\n    try {\n      const result = await this.#db.select<Record<string, any>>({\n        tableName: TABLE_AGENTS,\n        keys: { id },\n      });\n\n      return result ? this.parseRow(result) : null;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_AGENT_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async createAgent({ agent }: { agent: StorageCreateAgentInput }): Promise<StorageAgentType> {\n    try {\n      const now = new Date();\n\n      await this.#db.insert({\n        tableName: TABLE_AGENTS,\n        record: {\n          id: agent.id,\n          name: agent.name,\n          description: agent.description ?? null,\n          instructions: agent.instructions,\n          model: agent.model,\n          tools: agent.tools ?? null,\n          defaultOptions: agent.defaultOptions ?? null,\n          workflows: agent.workflows ?? null,\n          agents: agent.agents ?? null,\n          inputProcessors: agent.inputProcessors ?? null,\n          outputProcessors: agent.outputProcessors ?? null,\n          memory: agent.memory ?? null,\n          scorers: agent.scorers ?? null,\n          metadata: agent.metadata ?? null,\n          createdAt: now,\n          updatedAt: now,\n        },\n      });\n\n      return {\n        ...agent,\n        createdAt: now,\n        updatedAt: now,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: agent.id },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateAgent({ id, ...updates }: StorageUpdateAgentInput): Promise<StorageAgentType> {\n    try {\n      // First, get the existing agent\n      const existingAgent = await this.getAgentById({ id });\n      if (!existingAgent) {\n        throw new MastraError({\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'NOT_FOUND'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          text: `Agent ${id} not found`,\n          details: { agentId: id },\n        });\n      }\n\n      // Build the data object with only the fields that are being updated\n      const data: Record<string, any> = {\n        updatedAt: new Date(),\n      };\n\n      if (updates.name !== undefined) data.name = updates.name;\n      if (updates.description !== undefined) data.description = updates.description;\n      if (updates.instructions !== undefined) data.instructions = updates.instructions;\n      if (updates.model !== undefined) data.model = updates.model;\n      if (updates.tools !== undefined) data.tools = updates.tools;\n      if (updates.defaultOptions !== undefined) data.defaultOptions = updates.defaultOptions;\n      if (updates.workflows !== undefined) data.workflows = updates.workflows;\n      if (updates.agents !== undefined) data.agents = updates.agents;\n      if (updates.inputProcessors !== undefined) data.inputProcessors = updates.inputProcessors;\n      if (updates.outputProcessors !== undefined) data.outputProcessors = updates.outputProcessors;\n      if (updates.memory !== undefined) data.memory = updates.memory;\n      if (updates.scorers !== undefined) data.scorers = updates.scorers;\n      if (updates.metadata !== undefined) {\n        // Merge metadata\n        data.metadata = { ...existingAgent.metadata, ...updates.metadata };\n      }\n\n      // Only update if there's more than just updatedAt\n      if (Object.keys(data).length > 1) {\n        await this.#db.update({\n          tableName: TABLE_AGENTS,\n          keys: { id },\n          data,\n        });\n      }\n\n      // Return the updated agent\n      const updatedAgent = await this.getAgentById({ id });\n      if (!updatedAgent) {\n        throw new MastraError({\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'NOT_FOUND_AFTER_UPDATE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.SYSTEM,\n          text: `Agent ${id} not found after update`,\n          details: { agentId: id },\n        });\n      }\n\n      return updatedAgent;\n    } catch (error) {\n      if (error instanceof MastraError) {\n        throw error;\n      }\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteAgent({ id }: { id: string }): Promise<void> {\n    try {\n      await this.#db.delete({\n        tableName: TABLE_AGENTS,\n        keys: { id },\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async listAgents(args?: StorageListAgentsInput): Promise<StorageListAgentsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_AGENTS', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    try {\n      // Get total count\n      const total = await this.#db.selectTotalCount({ tableName: TABLE_AGENTS });\n\n      if (total === 0) {\n        return {\n          agents: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      // Get paginated results\n      const limitValue = perPageInput === false ? total : perPage;\n      const rows = await this.#db.selectMany<Record<string, any>>({\n        tableName: TABLE_AGENTS,\n        orderBy: `\"${field}\" ${direction}`,\n        limit: limitValue,\n        offset,\n      });\n\n      const agents = rows.map(row => this.parseRow(row));\n\n      return {\n        agents,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : offset + perPage < total,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_AGENTS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport type { MastraMessageContentV2 } from '@mastra/core/agent';\nimport { MessageList } from '@mastra/core/agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MastraDBMessage, StorageThreadType } from '@mastra/core/memory';\nimport type {\n  StorageResourceType,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n  ThreadCloneMetadata,\n} from '@mastra/core/storage';\nimport {\n  createStorageErrorId,\n  MemoryStorage,\n  normalizePerPage,\n  calculatePagination,\n  TABLE_MESSAGES,\n  TABLE_RESOURCES,\n  TABLE_THREADS,\n  TABLE_SCHEMAS,\n} from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { buildSelectColumns } from '../../db/utils';\n\nexport class MemoryLibSQL extends MemoryStorage {\n  #client: Client;\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_THREADS, schema: TABLE_SCHEMAS[TABLE_THREADS] });\n    await this.#db.createTable({ tableName: TABLE_MESSAGES, schema: TABLE_SCHEMAS[TABLE_MESSAGES] });\n    await this.#db.createTable({ tableName: TABLE_RESOURCES, schema: TABLE_SCHEMAS[TABLE_RESOURCES] });\n    // Add resourceId column for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_MESSAGES,\n      schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      ifNotExists: ['resourceId'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_MESSAGES });\n    await this.#db.deleteData({ tableName: TABLE_THREADS });\n    await this.#db.deleteData({ tableName: TABLE_RESOURCES });\n  }\n\n  private parseRow(row: any): MastraDBMessage {\n    let content = row.content;\n    try {\n      content = JSON.parse(row.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    const result = {\n      id: row.id,\n      content,\n      role: row.role,\n      createdAt: new Date(row.createdAt as string),\n      threadId: row.thread_id,\n      resourceId: row.resourceId,\n    } as MastraDBMessage;\n    if (row.type && row.type !== `v2`) result.type = row.type;\n    return result;\n  }\n\n  private async _getIncludedMessages({ include }: { include: StorageListMessagesInput['include'] }) {\n    if (!include || include.length === 0) return null;\n\n    const unionQueries: string[] = [];\n    const params: any[] = [];\n\n    for (const inc of include) {\n      const { id, withPreviousMessages = 0, withNextMessages = 0 } = inc;\n      // Query by message ID directly - get the threadId from the message itself via subquery\n      unionQueries.push(\n        `\n                SELECT * FROM (\n                  WITH target_thread AS (\n                    SELECT thread_id FROM \"${TABLE_MESSAGES}\" WHERE id = ?\n                  ),\n                  numbered_messages AS (\n                    SELECT\n                      id, content, role, type, \"createdAt\", thread_id, \"resourceId\",\n                      ROW_NUMBER() OVER (ORDER BY \"createdAt\" ASC) as row_num\n                    FROM \"${TABLE_MESSAGES}\"\n                    WHERE thread_id = (SELECT thread_id FROM target_thread)\n                  ),\n                  target_positions AS (\n                    SELECT row_num as target_pos\n                    FROM numbered_messages\n                    WHERE id = ?\n                  )\n                  SELECT DISTINCT m.*\n                  FROM numbered_messages m\n                  CROSS JOIN target_positions t\n                  WHERE m.row_num BETWEEN (t.target_pos - ?) AND (t.target_pos + ?)\n                ) \n                `, // Keep ASC for final sorting after fetching context\n      );\n      params.push(id, id, withPreviousMessages, withNextMessages);\n    }\n    const finalQuery = unionQueries.join(' UNION ALL ') + ' ORDER BY \"createdAt\" ASC';\n    const includedResult = await this.#client.execute({ sql: finalQuery, args: params });\n    const includedRows = includedResult.rows?.map(row => this.parseRow(row));\n    const seen = new Set<string>();\n    const dedupedRows = includedRows.filter(row => {\n      if (seen.has(row.id)) return false;\n      seen.add(row.id);\n      return true;\n    });\n    return dedupedRows;\n  }\n\n  public async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    if (messageIds.length === 0) return { messages: [] };\n\n    try {\n      const sql = `\n        SELECT \n          id, \n          content, \n          role, \n          type,\n          \"createdAt\", \n          thread_id,\n          \"resourceId\"\n        FROM \"${TABLE_MESSAGES}\"\n        WHERE id IN (${messageIds.map(() => '?').join(', ')})\n        ORDER BY \"createdAt\" DESC\n      `;\n      const result = await this.#client.execute({ sql, args: messageIds });\n      if (!result.rows) return { messages: [] };\n\n      const list = new MessageList().add(result.rows.map(this.parseRow), 'memory');\n      return { messages: list.get.all.db() };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: JSON.stringify(messageIds) },\n        },\n        error,\n      );\n    }\n  }\n\n  public async listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    const { threadId, resourceId, include, filter, perPage: perPageInput, page = 0, orderBy } = args;\n\n    // Normalize threadId to array\n    const threadIds = Array.isArray(threadId) ? threadId : [threadId];\n\n    if (threadIds.length === 0 || threadIds.some(id => !id.trim())) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'INVALID_THREAD_ID'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId: Array.isArray(threadId) ? threadId.join(',') : threadId },\n        },\n        new Error('threadId must be a non-empty string or array of non-empty strings'),\n      );\n    }\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 40);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    try {\n      // Determine sort field and direction\n      const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n      const orderByStatement = `ORDER BY \"${field}\" ${direction}`;\n\n      // Build WHERE conditions - use IN for multiple thread IDs\n      const threadPlaceholders = threadIds.map(() => '?').join(', ');\n      const conditions: string[] = [`thread_id IN (${threadPlaceholders})`];\n      const queryParams: InValue[] = [...threadIds];\n\n      if (resourceId) {\n        conditions.push(`\"resourceId\" = ?`);\n        queryParams.push(resourceId);\n      }\n\n      if (filter?.dateRange?.start) {\n        const startOp = filter.dateRange.startExclusive ? '>' : '>=';\n        conditions.push(`\"createdAt\" ${startOp} ?`);\n        queryParams.push(\n          filter.dateRange.start instanceof Date ? filter.dateRange.start.toISOString() : filter.dateRange.start,\n        );\n      }\n\n      if (filter?.dateRange?.end) {\n        const endOp = filter.dateRange.endExclusive ? '<' : '<=';\n        conditions.push(`\"createdAt\" ${endOp} ?`);\n        queryParams.push(\n          filter.dateRange.end instanceof Date ? filter.dateRange.end.toISOString() : filter.dateRange.end,\n        );\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get total count\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_MESSAGES} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      // Step 1: Get paginated messages from the thread first (without excluding included ones)\n      const limitValue = perPageInput === false ? total : perPage;\n      const dataResult = await this.#client.execute({\n        sql: `SELECT id, content, role, type, \"createdAt\", \"resourceId\", \"thread_id\" FROM ${TABLE_MESSAGES} ${whereClause} ${orderByStatement} LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, offset],\n      });\n      const messages: MastraDBMessage[] = (dataResult.rows || []).map((row: any) => this.parseRow(row));\n\n      // Only return early if there are no messages AND no includes to process\n      if (total === 0 && messages.length === 0 && (!include || include.length === 0)) {\n        return {\n          messages: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      // Step 2: Add included messages with context (if any), excluding duplicates\n      const messageIds = new Set(messages.map(m => m.id));\n      if (include && include.length > 0) {\n        const includeMessages = await this._getIncludedMessages({ include });\n        if (includeMessages) {\n          // Deduplicate: only add messages that aren't already in the paginated results\n          for (const includeMsg of includeMessages) {\n            if (!messageIds.has(includeMsg.id)) {\n              messages.push(includeMsg);\n              messageIds.add(includeMsg.id);\n            }\n          }\n        }\n      }\n\n      // Use MessageList for proper deduplication and format conversion to V2\n      const list = new MessageList().add(messages, 'memory');\n      let finalMessages = list.get.all.db();\n\n      // Sort all messages (paginated + included) for final output\n      finalMessages = finalMessages.sort((a, b) => {\n        const isDateField = field === 'createdAt' || field === 'updatedAt';\n        const aValue = isDateField ? new Date((a as any)[field]).getTime() : (a as any)[field];\n        const bValue = isDateField ? new Date((b as any)[field]).getTime() : (b as any)[field];\n\n        if (typeof aValue === 'number' && typeof bValue === 'number') {\n          return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n        }\n        return direction === 'ASC'\n          ? String(aValue).localeCompare(String(bValue))\n          : String(bValue).localeCompare(String(aValue));\n      });\n\n      // Calculate hasMore based on pagination window\n      // If all thread messages have been returned (through pagination or include), hasMore = false\n      // Otherwise, check if there are more pages in the pagination window\n      const threadIdSet = new Set(threadIds);\n      const returnedThreadMessageIds = new Set(\n        finalMessages.filter(m => m.threadId && threadIdSet.has(m.threadId)).map(m => m.id),\n      );\n      const allThreadMessagesReturned = returnedThreadMessageIds.size >= total;\n      const hasMore = perPageInput !== false && !allThreadMessagesReturned && offset + perPage < total;\n\n      return {\n        messages: finalMessages,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId: Array.isArray(threadId) ? threadId.join(',') : threadId,\n            resourceId: resourceId ?? '',\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException?.(mastraError);\n      return {\n        messages: [],\n        total: 0,\n        page,\n        perPage: perPageForResponse,\n        hasMore: false,\n      };\n    }\n  }\n\n  async saveMessages({ messages }: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    if (messages.length === 0) return { messages };\n\n    try {\n      const threadId = messages[0]?.threadId;\n      if (!threadId) {\n        throw new Error('Thread ID is required');\n      }\n\n      // Prepare batch statements for all messages\n      const batchStatements = messages.map(message => {\n        const time = message.createdAt || new Date();\n        if (!message.threadId) {\n          throw new Error(\n            `Expected to find a threadId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        if (!message.resourceId) {\n          throw new Error(\n            `Expected to find a resourceId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        return {\n          sql: `INSERT INTO \"${TABLE_MESSAGES}\" (id, thread_id, content, role, type, \"createdAt\", \"resourceId\") \n                  VALUES (?, ?, ?, ?, ?, ?, ?)\n                  ON CONFLICT(id) DO UPDATE SET\n                    thread_id=excluded.thread_id,\n                    content=excluded.content,\n                    role=excluded.role,\n                    type=excluded.type,\n                    \"resourceId\"=excluded.\"resourceId\"\n                `,\n          args: [\n            message.id,\n            message.threadId!,\n            typeof message.content === 'object' ? JSON.stringify(message.content) : message.content,\n            message.role,\n            message.type || 'v2',\n            time instanceof Date ? time.toISOString() : time,\n            message.resourceId,\n          ],\n        };\n      });\n\n      const now = new Date().toISOString();\n      batchStatements.push({\n        sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n        args: [now, threadId],\n      });\n\n      // Execute in batches to avoid potential limitations\n      const BATCH_SIZE = 50; // Safe batch size for libsql\n\n      // Separate message statements from thread update\n      const messageStatements = batchStatements.slice(0, -1);\n      const threadUpdateStatement = batchStatements[batchStatements.length - 1];\n\n      // Process message statements in batches\n      for (let i = 0; i < messageStatements.length; i += BATCH_SIZE) {\n        const batch = messageStatements.slice(i, i + BATCH_SIZE);\n        if (batch.length > 0) {\n          await this.#client.batch(batch, 'write');\n        }\n      }\n\n      // Execute thread update separately\n      if (threadUpdateStatement) {\n        await this.#client.execute(threadUpdateStatement);\n      }\n\n      const list = new MessageList().add(messages as any, 'memory');\n      return { messages: list.get.all.db() };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraDBMessage[]> {\n    if (messages.length === 0) {\n      return [];\n    }\n\n    const messageIds = messages.map(m => m.id);\n    const placeholders = messageIds.map(() => '?').join(',');\n\n    const selectSql = `SELECT * FROM ${TABLE_MESSAGES} WHERE id IN (${placeholders})`;\n    const existingResult = await this.#client.execute({ sql: selectSql, args: messageIds });\n    const existingMessages: MastraDBMessage[] = existingResult.rows.map(row => this.parseRow(row));\n\n    if (existingMessages.length === 0) {\n      return [];\n    }\n\n    const batchStatements = [];\n    const threadIdsToUpdate = new Set<string>();\n    const columnMapping: Record<string, string> = {\n      threadId: 'thread_id',\n    };\n\n    for (const existingMessage of existingMessages) {\n      const updatePayload = messages.find(m => m.id === existingMessage.id);\n      if (!updatePayload) continue;\n\n      const { id, ...fieldsToUpdate } = updatePayload;\n      if (Object.keys(fieldsToUpdate).length === 0) continue;\n\n      threadIdsToUpdate.add(existingMessage.threadId!);\n      if (updatePayload.threadId && updatePayload.threadId !== existingMessage.threadId) {\n        threadIdsToUpdate.add(updatePayload.threadId);\n      }\n\n      const setClauses = [];\n      const args: InValue[] = [];\n      const updatableFields = { ...fieldsToUpdate };\n\n      // Special handling for the 'content' field to merge instead of overwrite\n      if (updatableFields.content) {\n        const newContent = {\n          ...existingMessage.content,\n          ...updatableFields.content,\n          // Deep merge metadata if it exists on both\n          ...(existingMessage.content?.metadata && updatableFields.content.metadata\n            ? {\n                metadata: {\n                  ...existingMessage.content.metadata,\n                  ...updatableFields.content.metadata,\n                },\n              }\n            : {}),\n        };\n        setClauses.push(`${parseSqlIdentifier('content', 'column name')} = ?`);\n        args.push(JSON.stringify(newContent));\n        delete updatableFields.content;\n      }\n\n      for (const key in updatableFields) {\n        if (Object.prototype.hasOwnProperty.call(updatableFields, key)) {\n          const dbKey = columnMapping[key] || key;\n          setClauses.push(`${parseSqlIdentifier(dbKey, 'column name')} = ?`);\n          let value = updatableFields[key as keyof typeof updatableFields];\n\n          if (typeof value === 'object' && value !== null) {\n            value = JSON.stringify(value);\n          }\n          args.push(value as InValue);\n        }\n      }\n\n      if (setClauses.length === 0) continue;\n\n      args.push(id);\n\n      const sql = `UPDATE ${TABLE_MESSAGES} SET ${setClauses.join(', ')} WHERE id = ?`;\n      batchStatements.push({ sql, args });\n    }\n\n    if (batchStatements.length === 0) {\n      return existingMessages;\n    }\n\n    const now = new Date().toISOString();\n    for (const threadId of threadIdsToUpdate) {\n      if (threadId) {\n        batchStatements.push({\n          sql: `UPDATE ${TABLE_THREADS} SET updatedAt = ? WHERE id = ?`,\n          args: [now, threadId],\n        });\n      }\n    }\n\n    await this.#client.batch(batchStatements, 'write');\n\n    const updatedResult = await this.#client.execute({ sql: selectSql, args: messageIds });\n    return updatedResult.rows.map(row => this.parseRow(row));\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    try {\n      // Process in batches to avoid SQL parameter limits\n      const BATCH_SIZE = 100;\n      const threadIds = new Set<string>();\n\n      // Use a transaction to ensure consistency\n      const tx = await this.#client.transaction('write');\n\n      try {\n        for (let i = 0; i < messageIds.length; i += BATCH_SIZE) {\n          const batch = messageIds.slice(i, i + BATCH_SIZE);\n          const placeholders = batch.map(() => '?').join(',');\n\n          // Get thread IDs for this batch\n          const result = await tx.execute({\n            sql: `SELECT DISTINCT thread_id FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n\n          result.rows?.forEach(row => {\n            if (row.thread_id) threadIds.add(row.thread_id as string);\n          });\n\n          // Delete messages in this batch\n          await tx.execute({\n            sql: `DELETE FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n        }\n\n        // Update thread timestamps within the transaction\n        if (threadIds.size > 0) {\n          const now = new Date().toISOString();\n          for (const threadId of threadIds) {\n            await tx.execute({\n              sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n              args: [now, threadId],\n            });\n          }\n        }\n\n        // Commit the transaction\n        await tx.commit();\n      } catch (error) {\n        // Rollback on error\n        await tx.rollback();\n        throw error;\n      }\n\n      // TODO: Delete from vector store if semantic recall is enabled\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: messageIds.join(', ') },\n        },\n        error,\n      );\n    }\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    const result = await this.#db.select<StorageResourceType>({\n      tableName: TABLE_RESOURCES,\n      keys: { id: resourceId },\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      ...result,\n      // Ensure workingMemory is always returned as a string, even if auto-parsed as JSON\n      workingMemory:\n        result.workingMemory && typeof result.workingMemory === 'object'\n          ? JSON.stringify(result.workingMemory)\n          : result.workingMemory,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n      createdAt: new Date(result.createdAt),\n      updatedAt: new Date(result.updatedAt),\n    };\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    await this.#db.insert({\n      tableName: TABLE_RESOURCES,\n      record: {\n        ...resource,\n        // metadata is handled by prepareStatement which stringifies jsonb columns\n      },\n    });\n\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    const existingResource = await this.getResourceById({ resourceId });\n\n    if (!existingResource) {\n      // Create new resource if it doesn't exist\n      const newResource: StorageResourceType = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n      return this.saveResource({ resource: newResource });\n    }\n\n    const updatedResource = {\n      ...existingResource,\n      workingMemory: workingMemory !== undefined ? workingMemory : existingResource.workingMemory,\n      metadata: {\n        ...existingResource.metadata,\n        ...metadata,\n      },\n      updatedAt: new Date(),\n    };\n\n    const updates: string[] = [];\n    const values: InValue[] = [];\n\n    if (workingMemory !== undefined) {\n      updates.push('workingMemory = ?');\n      values.push(workingMemory);\n    }\n\n    if (metadata) {\n      updates.push('metadata = jsonb(?)');\n      values.push(JSON.stringify(updatedResource.metadata));\n    }\n\n    updates.push('updatedAt = ?');\n    values.push(updatedResource.updatedAt.toISOString());\n\n    values.push(resourceId);\n\n    await this.#client.execute({\n      sql: `UPDATE ${TABLE_RESOURCES} SET ${updates.join(', ')} WHERE id = ?`,\n      args: values,\n    });\n\n    return updatedResource;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    try {\n      const result = await this.#db.select<\n        Omit<StorageThreadType, 'createdAt' | 'updatedAt'> & { createdAt: string; updatedAt: string }\n      >({\n        tableName: TABLE_THREADS,\n        keys: { id: threadId },\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      return {\n        ...result,\n        metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n        createdAt: new Date(result.createdAt),\n        updatedAt: new Date(result.updatedAt),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_THREAD_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  public async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_THREADS_BY_RESOURCE_ID', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    try {\n      const baseQuery = `FROM ${TABLE_THREADS} WHERE resourceId = ?`;\n      const queryParams: InValue[] = [resourceId];\n\n      const mapRowToStorageThreadType = (row: any): StorageThreadType => ({\n        id: row.id as string,\n        resourceId: row.resourceId as string,\n        title: row.title as string,\n        createdAt: new Date(row.createdAt as string), // Convert string to Date\n        updatedAt: new Date(row.updatedAt as string), // Convert string to Date\n        metadata: typeof row.metadata === 'string' ? JSON.parse(row.metadata) : row.metadata,\n      });\n\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count ${baseQuery}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          threads: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      const limitValue = perPageInput === false ? total : perPage;\n      const dataResult = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_THREADS)} ${baseQuery} ORDER BY \"${field}\" ${direction} LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, offset],\n      });\n\n      const threads = (dataResult.rows || []).map(mapRowToStorageThreadType);\n\n      return {\n        threads,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : offset + perPage < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_THREADS_BY_RESOURCE_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { resourceId },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      return {\n        threads: [],\n        total: 0,\n        page,\n        perPage: perPageForResponse,\n        hasMore: false,\n      };\n    }\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    try {\n      await this.#db.insert({\n        tableName: TABLE_THREADS,\n        record: {\n          ...thread,\n          // metadata is handled by prepareStatement which stringifies jsonb columns\n        },\n      });\n\n      return thread;\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId: thread.id },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      throw mastraError;\n    }\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const thread = await this.getThreadById({ threadId: id });\n    if (!thread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'UPDATE_THREAD', 'NOT_FOUND'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread ${id} not found`,\n        details: {\n          status: 404,\n          threadId: id,\n        },\n      });\n    }\n\n    const updatedThread = {\n      ...thread,\n      title,\n      metadata: {\n        ...thread.metadata,\n        ...metadata,\n      },\n    };\n\n    try {\n      await this.#client.execute({\n        sql: `UPDATE ${TABLE_THREADS} SET title = ?, metadata = jsonb(?) WHERE id = ?`,\n        args: [title, JSON.stringify(updatedThread.metadata), id],\n      });\n\n      return updatedThread;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          text: `Failed to update thread ${id}`,\n          details: { threadId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    try {\n      // Delete messages first (child records), then thread\n      // Note: Not using a transaction to avoid SQLITE_BUSY errors when multiple\n      // deleteThread calls run concurrently. The two deletes are independent and\n      // orphaned messages (if thread delete fails) would be cleaned up on next delete attempt.\n      await this.#client.execute({\n        sql: `DELETE FROM ${TABLE_MESSAGES} WHERE thread_id = ?`,\n        args: [threadId],\n      });\n      await this.#client.execute({\n        sql: `DELETE FROM ${TABLE_THREADS} WHERE id = ?`,\n        args: [threadId],\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  async cloneThread(args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;\n\n    // Get the source thread\n    const sourceThread = await this.getThreadById({ threadId: sourceThreadId });\n    if (!sourceThread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'SOURCE_NOT_FOUND'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Source thread with id ${sourceThreadId} not found`,\n        details: { sourceThreadId },\n      });\n    }\n\n    // Use provided ID or generate a new one\n    const newThreadId = providedThreadId || crypto.randomUUID();\n\n    // Check if the new thread ID already exists\n    const existingThread = await this.getThreadById({ threadId: newThreadId });\n    if (existingThread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'THREAD_EXISTS'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread with id ${newThreadId} already exists`,\n        details: { newThreadId },\n      });\n    }\n\n    try {\n      // Build message query with filters\n      let messageQuery = `SELECT id, content, role, type, \"createdAt\", thread_id, \"resourceId\"\n                          FROM \"${TABLE_MESSAGES}\" WHERE thread_id = ?`;\n      const messageParams: InValue[] = [sourceThreadId];\n\n      // Apply date filters\n      if (options?.messageFilter?.startDate) {\n        messageQuery += ` AND \"createdAt\" >= ?`;\n        messageParams.push(\n          options.messageFilter.startDate instanceof Date\n            ? options.messageFilter.startDate.toISOString()\n            : options.messageFilter.startDate,\n        );\n      }\n      if (options?.messageFilter?.endDate) {\n        messageQuery += ` AND \"createdAt\" <= ?`;\n        messageParams.push(\n          options.messageFilter.endDate instanceof Date\n            ? options.messageFilter.endDate.toISOString()\n            : options.messageFilter.endDate,\n        );\n      }\n\n      // Apply message ID filter\n      if (options?.messageFilter?.messageIds && options.messageFilter.messageIds.length > 0) {\n        messageQuery += ` AND id IN (${options.messageFilter.messageIds.map(() => '?').join(', ')})`;\n        messageParams.push(...options.messageFilter.messageIds);\n      }\n\n      messageQuery += ` ORDER BY \"createdAt\" ASC`;\n\n      // Apply message limit (from most recent, so we need to reverse order for limit then sort back)\n      if (options?.messageLimit && options.messageLimit > 0) {\n        const limitQuery = `SELECT * FROM (${messageQuery.replace('ORDER BY \"createdAt\" ASC', 'ORDER BY \"createdAt\" DESC')} LIMIT ?) ORDER BY \"createdAt\" ASC`;\n        messageParams.push(options.messageLimit);\n        messageQuery = limitQuery;\n      }\n\n      const sourceMessagesResult = await this.#client.execute({ sql: messageQuery, args: messageParams });\n      const sourceMessages = sourceMessagesResult.rows || [];\n\n      const now = new Date();\n      const nowStr = now.toISOString();\n\n      // Determine the last message ID for clone metadata\n      const lastMessageId =\n        sourceMessages.length > 0 ? (sourceMessages[sourceMessages.length - 1]!.id as string) : undefined;\n\n      // Create clone metadata\n      const cloneMetadata: ThreadCloneMetadata = {\n        sourceThreadId,\n        clonedAt: now,\n        ...(lastMessageId && { lastMessageId }),\n      };\n\n      // Create the new thread\n      const newThread: StorageThreadType = {\n        id: newThreadId,\n        resourceId: resourceId || sourceThread.resourceId,\n        title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : undefined),\n        metadata: {\n          ...metadata,\n          clone: cloneMetadata,\n        },\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      // Use transaction for consistency\n      const tx = await this.#client.transaction('write');\n\n      try {\n        // Insert the new thread\n        await tx.execute({\n          sql: `INSERT INTO \"${TABLE_THREADS}\" (id, \"resourceId\", title, metadata, \"createdAt\", \"updatedAt\")\n                VALUES (?, ?, ?, jsonb(?), ?, ?)`,\n          args: [\n            newThread.id,\n            newThread.resourceId,\n            newThread.title || null,\n            JSON.stringify(newThread.metadata),\n            nowStr,\n            nowStr,\n          ],\n        });\n\n        // Clone messages with new IDs\n        const clonedMessages: MastraDBMessage[] = [];\n        const targetResourceId = resourceId || sourceThread.resourceId;\n\n        for (const sourceMsg of sourceMessages) {\n          const newMessageId = crypto.randomUUID();\n          const contentStr = sourceMsg.content as string;\n          let parsedContent: MastraDBMessage['content'];\n          try {\n            parsedContent = JSON.parse(contentStr);\n          } catch {\n            // use content as is - wrap in format 2 structure if needed\n            parsedContent = { format: 2, parts: [{ type: 'text', text: contentStr }] };\n          }\n\n          await tx.execute({\n            sql: `INSERT INTO \"${TABLE_MESSAGES}\" (id, thread_id, content, role, type, \"createdAt\", \"resourceId\")\n                  VALUES (?, ?, ?, ?, ?, ?, ?)`,\n            args: [\n              newMessageId,\n              newThreadId,\n              contentStr,\n              sourceMsg.role as string,\n              (sourceMsg.type as string) || 'v2',\n              sourceMsg.createdAt as string,\n              targetResourceId,\n            ],\n          });\n\n          clonedMessages.push({\n            id: newMessageId,\n            threadId: newThreadId,\n            content: parsedContent,\n            role: sourceMsg.role as MastraDBMessage['role'],\n            type: (sourceMsg.type as string) || undefined,\n            createdAt: new Date(sourceMsg.createdAt as string),\n            resourceId: targetResourceId,\n          });\n        }\n\n        await tx.commit();\n\n        return {\n          thread: newThread,\n          clonedMessages,\n        };\n      } catch (error) {\n        await tx.rollback();\n        throw error;\n      }\n    } catch (error) {\n      if (error instanceof MastraError) {\n        throw error;\n      }\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { sourceThreadId, newThreadId },\n        },\n        error,\n      );\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  createStorageErrorId,\n  listTracesArgsSchema,\n  ObservabilityStorage,\n  SPAN_SCHEMA,\n  TABLE_SPANS,\n  TraceStatus,\n} from '@mastra/core/storage';\nimport type {\n  SpanRecord,\n  ListTracesArgs,\n  PaginationInfo,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  BatchCreateSpansArgs,\n  CreateSpanArgs,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n} from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { transformFromSqlRow } from '../../db/utils';\n\nexport class ObservabilityLibSQL extends ObservabilityStorage {\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_SPANS, schema: SPAN_SCHEMA });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_SPANS });\n  }\n\n  public override get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates',\n      supported: ['batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createSpan(args: CreateSpanArgs): Promise<void> {\n    const { span } = args;\n    try {\n      const startedAt = span.startedAt instanceof Date ? span.startedAt.toISOString() : span.startedAt;\n      const endedAt = span.endedAt instanceof Date ? span.endedAt.toISOString() : span.endedAt;\n      const now = new Date().toISOString();\n\n      const record = {\n        ...span,\n        startedAt,\n        endedAt,\n        createdAt: now,\n        updatedAt: now,\n      };\n      return this.#db.insert({ tableName: TABLE_SPANS, record });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId: span.spanId,\n            traceId: span.traceId,\n            spanType: span.spanType,\n            name: span.name,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async getSpan(args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    const { traceId, spanId } = args;\n    try {\n      const rows = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ? AND spanId = ?', args: [traceId, spanId] },\n        limit: 1,\n      });\n\n      if (!rows || rows.length === 0) {\n        return null;\n      }\n\n      return {\n        span: transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: rows[0]! }),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { traceId, spanId },\n        },\n        error,\n      );\n    }\n  }\n\n  async getRootSpan(args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    const { traceId } = args;\n    try {\n      const rows = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ? AND parentSpanId IS NULL', args: [traceId] },\n        limit: 1,\n      });\n\n      if (!rows || rows.length === 0) {\n        return null;\n      }\n\n      return {\n        span: transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: rows[0]! }),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_ROOT_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { traceId },\n        },\n        error,\n      );\n    }\n  }\n\n  async getTrace(args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    const { traceId } = args;\n    try {\n      const spans = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ?', args: [traceId] },\n        orderBy: 'startedAt ASC',\n      });\n\n      if (!spans || spans.length === 0) {\n        return null;\n      }\n\n      return {\n        traceId,\n        spans: spans.map(span => transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: span })),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_TRACE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateSpan(args: UpdateSpanArgs): Promise<void> {\n    const { traceId, spanId, updates } = args;\n    try {\n      const data: Record<string, any> = { ...updates };\n      if (data.endedAt instanceof Date) {\n        data.endedAt = data.endedAt.toISOString();\n      }\n      if (data.startedAt instanceof Date) {\n        data.startedAt = data.startedAt.toISOString();\n      }\n      data.updatedAt = new Date().toISOString();\n\n      await this.#db.update({\n        tableName: TABLE_SPANS,\n        keys: { spanId, traceId },\n        data,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId,\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async listTraces(args: ListTracesArgs): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    // Parse args through schema to apply defaults\n    const { filters, pagination, orderBy } = listTracesArgsSchema.parse(args);\n    const { page, perPage } = pagination;\n\n    const tableName = parseSqlIdentifier(TABLE_SPANS, 'table name');\n\n    try {\n      // Build WHERE clause for filters\n      const conditions: string[] = ['parentSpanId IS NULL']; // Only root spans\n      const queryArgs: any[] = [];\n\n      if (filters) {\n        // Date range filters\n        if (filters.startedAt?.start) {\n          conditions.push(`startedAt >= ?`);\n          queryArgs.push(filters.startedAt.start.toISOString());\n        }\n        if (filters.startedAt?.end) {\n          conditions.push(`startedAt <= ?`);\n          queryArgs.push(filters.startedAt.end.toISOString());\n        }\n        if (filters.endedAt?.start) {\n          conditions.push(`endedAt >= ?`);\n          queryArgs.push(filters.endedAt.start.toISOString());\n        }\n        if (filters.endedAt?.end) {\n          conditions.push(`endedAt <= ?`);\n          queryArgs.push(filters.endedAt.end.toISOString());\n        }\n\n        // Span type filter\n        if (filters.spanType !== undefined) {\n          conditions.push(`spanType = ?`);\n          queryArgs.push(filters.spanType);\n        }\n\n        // Entity filters\n        if (filters.entityType !== undefined) {\n          conditions.push(`entityType = ?`);\n          queryArgs.push(filters.entityType);\n        }\n        if (filters.entityId !== undefined) {\n          conditions.push(`entityId = ?`);\n          queryArgs.push(filters.entityId);\n        }\n        if (filters.entityName !== undefined) {\n          conditions.push(`entityName = ?`);\n          queryArgs.push(filters.entityName);\n        }\n\n        // Identity & Tenancy filters\n        if (filters.userId !== undefined) {\n          conditions.push(`userId = ?`);\n          queryArgs.push(filters.userId);\n        }\n        if (filters.organizationId !== undefined) {\n          conditions.push(`organizationId = ?`);\n          queryArgs.push(filters.organizationId);\n        }\n        if (filters.resourceId !== undefined) {\n          conditions.push(`resourceId = ?`);\n          queryArgs.push(filters.resourceId);\n        }\n\n        // Correlation ID filters\n        if (filters.runId !== undefined) {\n          conditions.push(`runId = ?`);\n          queryArgs.push(filters.runId);\n        }\n        if (filters.sessionId !== undefined) {\n          conditions.push(`sessionId = ?`);\n          queryArgs.push(filters.sessionId);\n        }\n        if (filters.threadId !== undefined) {\n          conditions.push(`threadId = ?`);\n          queryArgs.push(filters.threadId);\n        }\n        if (filters.requestId !== undefined) {\n          conditions.push(`requestId = ?`);\n          queryArgs.push(filters.requestId);\n        }\n\n        // Deployment context filters\n        if (filters.environment !== undefined) {\n          conditions.push(`environment = ?`);\n          queryArgs.push(filters.environment);\n        }\n        if (filters.source !== undefined) {\n          conditions.push(`source = ?`);\n          queryArgs.push(filters.source);\n        }\n        if (filters.serviceName !== undefined) {\n          conditions.push(`serviceName = ?`);\n          queryArgs.push(filters.serviceName);\n        }\n\n        // Scope filter (JSON containment - SQLite uses json_extract)\n        if (filters.scope != null) {\n          // For SQLite/libsql, we need to check each key in the scope object\n          for (const [key, value] of Object.entries(filters.scope)) {\n            // Validate key to prevent SQL injection in JSON path\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {\n              throw new MastraError({\n                id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'INVALID_FILTER_KEY'),\n                domain: ErrorDomain.STORAGE,\n                category: ErrorCategory.USER,\n                details: { key },\n              });\n            }\n            conditions.push(`json_extract(scope, '$.${key}') = ?`);\n            queryArgs.push(typeof value === 'string' ? value : JSON.stringify(value));\n          }\n        }\n\n        // Metadata filter (JSON containment)\n        if (filters.metadata != null) {\n          for (const [key, value] of Object.entries(filters.metadata)) {\n            // Validate key to prevent SQL injection in JSON path\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {\n              throw new MastraError({\n                id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'INVALID_FILTER_KEY'),\n                domain: ErrorDomain.STORAGE,\n                category: ErrorCategory.USER,\n                details: { key },\n              });\n            }\n            conditions.push(`json_extract(metadata, '$.${key}') = ?`);\n            queryArgs.push(typeof value === 'string' ? value : JSON.stringify(value));\n          }\n        }\n\n        // Tags filter (all tags must be present)\n        if (filters.tags != null && filters.tags.length > 0) {\n          // Use json_each for exact tag matching (LIKE can match substrings)\n          for (const tag of filters.tags) {\n            conditions.push(`EXISTS (SELECT 1 FROM json_each(${tableName}.tags) WHERE value = ?)`);\n            queryArgs.push(tag);\n          }\n        }\n\n        // Status filter (derived from error and endedAt)\n        if (filters.status !== undefined) {\n          switch (filters.status) {\n            case TraceStatus.ERROR:\n              conditions.push(`error IS NOT NULL`);\n              break;\n            case TraceStatus.RUNNING:\n              conditions.push(`endedAt IS NULL AND error IS NULL`);\n              break;\n            case TraceStatus.SUCCESS:\n              conditions.push(`endedAt IS NOT NULL AND error IS NULL`);\n              break;\n          }\n        }\n\n        // hasChildError filter (requires subquery)\n        if (filters.hasChildError !== undefined) {\n          if (filters.hasChildError) {\n            conditions.push(`EXISTS (\n              SELECT 1 FROM ${tableName} c\n              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL\n            )`);\n          } else {\n            conditions.push(`NOT EXISTS (\n              SELECT 1 FROM ${tableName} c\n              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL\n            )`);\n          }\n        }\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Order by clause with proper NULL handling for endedAt\n      // For endedAt DESC: NULLs FIRST (running spans on top when viewing newest)\n      // For endedAt ASC: NULLs LAST (running spans at end when viewing oldest)\n      // startedAt is never null (required field), so no special handling needed\n      // SQLite's natural behavior: NULLs are \"smaller\" than any value\n      //   - ASC: NULLs first (natural)\n      //   - DESC: NULLs last (natural)\n      // So we need CASE WHEN workarounds to invert the natural behavior for endedAt\n      const sortField = orderBy.field;\n      const sortDirection = orderBy.direction;\n      let orderByClause: string;\n      if (sortField === 'endedAt') {\n        // endedAt DESC: want NULLs first (running spans on top) - need CASE WHEN\n        // endedAt ASC: want NULLs last (oldest completed first) - need CASE WHEN\n        orderByClause =\n          sortDirection === 'DESC'\n            ? `CASE WHEN ${sortField} IS NULL THEN 0 ELSE 1 END, ${sortField} DESC`\n            : `CASE WHEN ${sortField} IS NULL THEN 1 ELSE 0 END, ${sortField} ASC`;\n      } else {\n        orderByClause = `${sortField} ${sortDirection}`;\n      }\n\n      // Get total count\n      const count = await this.#db.selectTotalCount({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: whereClause, args: queryArgs },\n      });\n\n      if (count === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage,\n            hasMore: false,\n          },\n          spans: [],\n        };\n      }\n\n      // Get paginated spans\n      const spans = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: whereClause, args: queryArgs },\n        orderBy: orderByClause,\n        offset: page * perPage,\n        limit: perPage,\n      });\n\n      return {\n        pagination: {\n          total: count,\n          page,\n          perPage,\n          hasMore: (page + 1) * perPage < count,\n        },\n        spans: spans.map(span => transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: span })),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchCreateSpans(args: BatchCreateSpansArgs): Promise<void> {\n    try {\n      const now = new Date().toISOString();\n      const records = args.records.map(record => {\n        const startedAt = record.startedAt instanceof Date ? record.startedAt.toISOString() : record.startedAt;\n        const endedAt = record.endedAt instanceof Date ? record.endedAt.toISOString() : record.endedAt;\n\n        return {\n          ...record,\n          startedAt,\n          endedAt,\n          createdAt: now,\n          updatedAt: now,\n        };\n      });\n\n      return this.#db.batchInsert({\n        tableName: TABLE_SPANS,\n        records,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_CREATE_SPANS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchUpdateSpans(args: BatchUpdateSpansArgs): Promise<void> {\n    const now = new Date().toISOString();\n\n    try {\n      return this.#db.batchUpdate({\n        tableName: TABLE_SPANS,\n        updates: args.records.map(record => {\n          const data: Record<string, any> = { ...record.updates };\n          if (data.endedAt instanceof Date) {\n            data.endedAt = data.endedAt.toISOString();\n          }\n          if (data.startedAt instanceof Date) {\n            data.startedAt = data.startedAt.toISOString();\n          }\n          data.updatedAt = now;\n\n          return {\n            keys: { spanId: record.spanId, traceId: record.traceId },\n            data,\n          };\n        }),\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_UPDATE_SPANS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchDeleteTraces(args: BatchDeleteTracesArgs): Promise<void> {\n    try {\n      const keys = args.traceIds.map(traceId => ({ traceId }));\n      return this.#db.batchDelete({\n        tableName: TABLE_SPANS,\n        keys,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_DELETE_TRACES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { saveScorePayloadSchema } from '@mastra/core/evals';\nimport type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '@mastra/core/evals';\nimport {\n  createStorageErrorId,\n  TABLE_SCORERS,\n  SCORERS_SCHEMA,\n  ScoresStorage,\n  calculatePagination,\n  normalizePerPage,\n  transformScoreRow as coreTransformScoreRow,\n} from '@mastra/core/storage';\nimport type { StoragePagination } from '@mastra/core/storage';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { buildSelectColumns } from '../../db/utils';\n\nexport class ScoresLibSQL extends ScoresStorage {\n  #db: LibSQLDB;\n  #client: Client;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_SCORERS, schema: SCORERS_SCHEMA });\n    // Add columns for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_SCORERS,\n      schema: SCORERS_SCHEMA,\n      ifNotExists: ['spanId', 'requestContext'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_SCORERS });\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE runId = ?`,\n        args: [runId],\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE runId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [runId, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_RUN_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    source,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      const conditions: string[] = [];\n      const queryParams: InValue[] = [];\n\n      if (scorerId) {\n        conditions.push(`scorerId = ?`);\n        queryParams.push(scorerId);\n      }\n\n      if (entityId) {\n        conditions.push(`entityId = ?`);\n        queryParams.push(entityId);\n      }\n\n      if (entityType) {\n        conditions.push(`entityType = ?`);\n        queryParams.push(entityType);\n      }\n\n      if (source) {\n        conditions.push(`source = ?`);\n        queryParams.push(source);\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} ${whereClause} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_SCORER_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * LibSQL-specific score row transformation.\n   */\n  private transformScoreRow(row: Record<string, any>): ScoreRowData {\n    return coreTransformScoreRow(row);\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    const result = await this.#client.execute({\n      sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE id = ?`,\n      args: [id],\n    });\n    return result.rows?.[0] ? this.transformScoreRow(result.rows[0]) : null;\n  }\n\n  async saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }> {\n    let parsedScore: SaveScorePayload;\n    try {\n      parsedScore = saveScorePayloadSchema.parse(score);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_SCORE', 'VALIDATION_FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            scorer: typeof score.scorer?.id === 'string' ? score.scorer.id : String(score.scorer?.id ?? 'unknown'),\n            entityId: score.entityId ?? 'unknown',\n            entityType: score.entityType ?? 'unknown',\n            traceId: score.traceId ?? '',\n            spanId: score.spanId ?? '',\n          },\n        },\n        error,\n      );\n    }\n\n    try {\n      const id = crypto.randomUUID();\n      const now = new Date();\n\n      await this.#db.insert({\n        tableName: TABLE_SCORERS,\n        record: {\n          ...parsedScore,\n          id,\n          createdAt: now.toISOString(),\n          updatedAt: now.toISOString(),\n        },\n      });\n\n      return { score: { ...parsedScore, id, createdAt: now, updatedAt: now } as ScoreRowData };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_SCORE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE entityId = ? AND entityType = ?`,\n        args: [entityId, entityType],\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE entityId = ? AND entityType = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [entityId, entityType, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_ENTITY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n      const countSQLResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE traceId = ? AND spanId = ?`,\n        args: [traceId, spanId],\n      });\n\n      const total = Number(countSQLResult.rows?.[0]?.count ?? 0);\n\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE traceId = ? AND spanId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [traceId, spanId, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type {\n  WorkflowRun,\n  WorkflowRuns,\n  StorageListWorkflowRunsInput,\n  UpdateWorkflowStateOptions,\n} from '@mastra/core/storage';\nimport {\n  createStorageErrorId,\n  normalizePerPage,\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_SCHEMAS,\n  WorkflowsStorage,\n} from '@mastra/core/storage';\nimport type { WorkflowRunState, StepResult } from '@mastra/core/workflows';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { createExecuteWriteOperationWithRetry } from '../../db/utils';\n\nexport class WorkflowsLibSQL extends WorkflowsStorage {\n  #db: LibSQLDB;\n  #client: Client;\n  private readonly executeWithRetry: <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    const maxRetries = config.maxRetries ?? 5;\n    const initialBackoffMs = config.initialBackoffMs ?? 500;\n\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries, initialBackoffMs });\n    this.executeWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries,\n      initialBackoffMs,\n    });\n\n    // Set PRAGMA settings to help with database locks\n    // Note: This is async but we can't await in constructor, so we'll handle it as a fire-and-forget\n    this.setupPragmaSettings().catch(err =>\n      this.logger.warn('LibSQL Workflows: Failed to setup PRAGMA settings.', err),\n    );\n  }\n\n  private parseWorkflowRun(row: Record<string, any>): WorkflowRun {\n    let parsedSnapshot: WorkflowRunState | string = row.snapshot as string;\n    if (typeof parsedSnapshot === 'string') {\n      try {\n        parsedSnapshot = JSON.parse(row.snapshot as string) as WorkflowRunState;\n      } catch (e) {\n        this.logger.warn(`Failed to parse snapshot for workflow ${row.workflow_name}: ${e}`);\n      }\n    }\n    return {\n      workflowName: row.workflow_name as string,\n      runId: row.run_id as string,\n      snapshot: parsedSnapshot,\n      resourceId: row.resourceId as string,\n      createdAt: new Date(row.createdAt as string),\n      updatedAt: new Date(row.updatedAt as string),\n    };\n  }\n\n  async init(): Promise<void> {\n    const schema = TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT];\n    await this.#db.createTable({ tableName: TABLE_WORKFLOW_SNAPSHOT, schema });\n    // Add resourceId column for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      schema,\n      ifNotExists: ['resourceId'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_WORKFLOW_SNAPSHOT });\n  }\n\n  private async setupPragmaSettings() {\n    try {\n      // Set busy timeout to wait longer before returning busy errors\n      await this.#client.execute('PRAGMA busy_timeout = 10000;');\n      this.logger.debug('LibSQL Workflows: PRAGMA busy_timeout=10000 set.');\n\n      // Enable WAL mode for better concurrency (if supported)\n      try {\n        await this.#client.execute('PRAGMA journal_mode = WAL;');\n        this.logger.debug('LibSQL Workflows: PRAGMA journal_mode=WAL set.');\n      } catch {\n        this.logger.debug('LibSQL Workflows: WAL mode not supported, using default journal mode.');\n      }\n\n      // Set synchronous mode for better durability vs performance trade-off\n      try {\n        await this.#client.execute('PRAGMA synchronous = NORMAL;');\n        this.logger.debug('LibSQL Workflows: PRAGMA synchronous=NORMAL set.');\n      } catch {\n        this.logger.debug('LibSQL Workflows: Failed to set synchronous mode.');\n      }\n    } catch (err) {\n      this.logger.warn('LibSQL Workflows: Failed to set PRAGMA settings.', err);\n    }\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    return this.executeWithRetry(async () => {\n      // Use a transaction to ensure atomicity\n      const tx = await this.#client.transaction('write');\n      try {\n        // Load existing snapshot within transaction\n        const existingSnapshotResult = await tx.execute({\n          sql: `SELECT json(snapshot) as snapshot FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n\n        let snapshot: WorkflowRunState;\n        if (!existingSnapshotResult.rows?.[0]) {\n          // Create new snapshot if none exists\n          snapshot = {\n            context: {},\n            activePaths: [],\n            timestamp: Date.now(),\n            suspendedPaths: {},\n            activeStepsPath: {},\n            resumeLabels: {},\n            serializedStepGraph: [],\n            status: 'pending',\n            value: {},\n            waitingPaths: {},\n            runId: runId,\n            requestContext: {},\n          } as WorkflowRunState;\n        } else {\n          // Parse existing snapshot\n          const existingSnapshot = existingSnapshotResult.rows[0].snapshot;\n          snapshot = typeof existingSnapshot === 'string' ? JSON.parse(existingSnapshot) : existingSnapshot;\n        }\n\n        // Merge the new step result and request context\n        snapshot.context[stepId] = result;\n        snapshot.requestContext = { ...snapshot.requestContext, ...requestContext };\n\n        // Upsert the snapshot within the same transaction\n        const now = new Date().toISOString();\n        await tx.execute({\n          sql: `INSERT INTO ${TABLE_WORKFLOW_SNAPSHOT} (workflow_name, run_id, snapshot, createdAt, updatedAt)\n                VALUES (?, ?, jsonb(?), ?, ?)\n                ON CONFLICT(workflow_name, run_id)\n                DO UPDATE SET snapshot = excluded.snapshot, updatedAt = excluded.updatedAt`,\n          args: [workflowName, runId, JSON.stringify(snapshot), now, now],\n        });\n\n        await tx.commit();\n        return snapshot.context;\n      } catch (error) {\n        if (!tx.closed) {\n          await tx.rollback();\n        }\n        throw error;\n      }\n    }, 'updateWorkflowResults');\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined> {\n    return this.executeWithRetry(async () => {\n      // Use a transaction to ensure atomicity\n      const tx = await this.#client.transaction('write');\n      try {\n        // Load existing snapshot within transaction\n        const existingSnapshotResult = await tx.execute({\n          sql: `SELECT json(snapshot) as snapshot FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n\n        if (!existingSnapshotResult.rows?.[0]) {\n          await tx.rollback();\n          return undefined;\n        }\n\n        // Parse existing snapshot\n        const existingSnapshot = existingSnapshotResult.rows[0].snapshot;\n        const snapshot = typeof existingSnapshot === 'string' ? JSON.parse(existingSnapshot) : existingSnapshot;\n\n        if (!snapshot || !snapshot?.context) {\n          await tx.rollback();\n          throw new Error(`Snapshot not found for runId ${runId}`);\n        }\n\n        // Merge the new options with the existing snapshot\n        const updatedSnapshot = { ...snapshot, ...opts };\n\n        // Update the snapshot within the same transaction\n        await tx.execute({\n          sql: `UPDATE ${TABLE_WORKFLOW_SNAPSHOT} SET snapshot = jsonb(?) WHERE workflow_name = ? AND run_id = ?`,\n          args: [JSON.stringify(updatedSnapshot), workflowName, runId],\n        });\n\n        await tx.commit();\n        return updatedSnapshot;\n      } catch (error) {\n        if (!tx.closed) {\n          await tx.rollback();\n        }\n        throw error;\n      }\n    }, 'updateWorkflowState');\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n    createdAt,\n    updatedAt,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }) {\n    const now = new Date();\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: createdAt ?? now,\n      updatedAt: updatedAt ?? now,\n    };\n\n    this.logger.debug('Persisting workflow snapshot', { workflowName, runId, data });\n    await this.#db.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.#db.select<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    return d ? d.snapshot : null;\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const conditions: string[] = [];\n    const args: (string | number)[] = [];\n\n    if (runId) {\n      conditions.push('run_id = ?');\n      args.push(runId);\n    }\n\n    if (workflowName) {\n      conditions.push('workflow_name = ?');\n      args.push(workflowName);\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const result = await this.#client.execute({\n        sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause} ORDER BY createdAt DESC LIMIT 1`,\n        args,\n      });\n\n      if (!result.rows?.[0]) {\n        return null;\n      }\n\n      return this.parseWorkflowRun(result.rows[0]);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_WORKFLOW_RUN_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteWorkflowRunById({ runId, workflowName }: { runId: string; workflowName: string }): Promise<void> {\n    return this.executeWithRetry(async () => {\n      try {\n        await this.#client.execute({\n          sql: `DELETE FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n      } catch (error) {\n        throw new MastraError(\n          {\n            id: createStorageErrorId('LIBSQL', 'DELETE_WORKFLOW_RUN_BY_ID', 'FAILED'),\n            domain: ErrorDomain.STORAGE,\n            category: ErrorCategory.THIRD_PARTY,\n            details: { runId, workflowName },\n          },\n          error,\n        );\n      }\n    }, 'deleteWorkflowRunById');\n  }\n\n  async listWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    page,\n    perPage,\n    resourceId,\n    status,\n  }: StorageListWorkflowRunsInput = {}): Promise<WorkflowRuns> {\n    try {\n      const conditions: string[] = [];\n      const args: InValue[] = [];\n\n      if (workflowName) {\n        conditions.push('workflow_name = ?');\n        args.push(workflowName);\n      }\n\n      if (status) {\n        conditions.push(\"json_extract(snapshot, '$.status') = ?\");\n        args.push(status);\n      }\n\n      if (fromDate) {\n        conditions.push('createdAt >= ?');\n        args.push(fromDate.toISOString());\n      }\n\n      if (toDate) {\n        conditions.push('createdAt <= ?');\n        args.push(toDate.toISOString());\n      }\n\n      if (resourceId) {\n        const hasResourceId = await this.#db.hasColumn(TABLE_WORKFLOW_SNAPSHOT, 'resourceId');\n        if (hasResourceId) {\n          conditions.push('resourceId = ?');\n          args.push(resourceId);\n        } else {\n          this.logger.warn(`[${TABLE_WORKFLOW_SNAPSHOT}] resourceId column not found. Skipping resourceId filter.`);\n        }\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      let total = 0;\n      // Only get total count when using pagination\n      const usePagination = typeof perPage === 'number' && typeof page === 'number';\n      if (usePagination) {\n        const countResult = await this.#client.execute({\n          sql: `SELECT COUNT(*) as count FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause}`,\n          args,\n        });\n        total = Number(countResult.rows?.[0]?.count ?? 0);\n      }\n\n      // Get results\n      const normalizedPerPage = usePagination ? normalizePerPage(perPage, Number.MAX_SAFE_INTEGER) : 0;\n      const offset = usePagination ? page! * normalizedPerPage : 0;\n      const result = await this.#client.execute({\n        sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause} ORDER BY createdAt DESC${usePagination ? ` LIMIT ? OFFSET ?` : ''}`,\n        args: usePagination ? [...args, normalizedPerPage, offset] : args,\n      });\n\n      const runs = (result.rows || []).map(row => this.parseWorkflowRun(row));\n\n      // Use runs.length as total when not paginating\n      return { runs, total: total || runs.length };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_WORKFLOW_RUNS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import { createClient } from '@libsql/client';\nimport type { Client } from '@libsql/client';\nimport type { StorageDomains } from '@mastra/core/storage';\nimport { MastraStorage } from '@mastra/core/storage';\n\nimport { AgentsLibSQL } from './domains/agents';\nimport { MemoryLibSQL } from './domains/memory';\nimport { ObservabilityLibSQL } from './domains/observability';\nimport { ScoresLibSQL } from './domains/scores';\nimport { WorkflowsLibSQL } from './domains/workflows';\n\n// Export domain classes for direct use with MastraStorage composition\nexport { AgentsLibSQL, MemoryLibSQL, ObservabilityLibSQL, ScoresLibSQL, WorkflowsLibSQL };\nexport type { LibSQLDomainConfig } from './db';\n\n/**\n * Base configuration options shared across LibSQL configurations\n */\nexport type LibSQLBaseConfig = {\n  id: string;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   * This is useful for CI/CD pipelines where you want to:\n   * 1. Run migrations explicitly during deployment (not at runtime)\n   * 2. Use different credentials for schema changes vs runtime operations\n   *\n   * When disableInit is true:\n   * - The storage will not automatically create/alter tables on first use\n   * - You must call `storage.init()` explicitly in your CI/CD scripts\n   *\n   * @example\n   * // In CI/CD script:\n   * const storage = new LibSQLStore({ ...config, disableInit: false });\n   * await storage.init(); // Explicitly run migrations\n   *\n   * // In runtime application:\n   * const storage = new LibSQLStore({ ...config, disableInit: true });\n   * // No auto-init, tables must already exist\n   */\n  disableInit?: boolean;\n};\n\nexport type LibSQLConfig =\n  | (LibSQLBaseConfig & {\n      url: string;\n      authToken?: string;\n    })\n  | (LibSQLBaseConfig & {\n      client: Client;\n    });\n\n/**\n * LibSQL/Turso storage adapter for Mastra.\n *\n * Access domain-specific storage via `getStore()`:\n *\n * @example\n * ```typescript\n * const storage = new LibSQLStore({ id: 'my-store', url: 'file:./dev.db' });\n *\n * // Access memory domain\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n *\n * // Access workflows domain\n * const workflows = await storage.getStore('workflows');\n * await workflows?.persistWorkflowSnapshot({ workflowName, runId, snapshot });\n * ```\n */\nexport class LibSQLStore extends MastraStorage {\n  private client: Client;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  stores: StorageDomains;\n\n  constructor(config: LibSQLConfig) {\n    if (!config.id || typeof config.id !== 'string' || config.id.trim() === '') {\n      throw new Error('LibSQLStore: id must be provided and cannot be empty.');\n    }\n    super({ id: config.id, name: `LibSQLStore`, disableInit: config.disableInit });\n\n    this.maxRetries = config.maxRetries ?? 5;\n    this.initialBackoffMs = config.initialBackoffMs ?? 100;\n\n    if ('url' in config) {\n      // need to re-init every time for in memory dbs or the tables might not exist\n      if (config.url.endsWith(':memory:')) {\n        this.shouldCacheInit = false;\n      }\n\n      this.client = createClient({\n        url: config.url,\n        ...(config.authToken ? { authToken: config.authToken } : {}),\n      });\n\n      // Set PRAGMAs for better concurrency, especially for file-based databases\n      if (config.url.startsWith('file:') || config.url.includes(':memory:')) {\n        this.client\n          .execute('PRAGMA journal_mode=WAL;')\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n        this.client\n          .execute('PRAGMA busy_timeout = 5000;') // 5 seconds\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout.', err));\n      }\n    } else {\n      this.client = config.client;\n    }\n\n    const domainConfig = {\n      client: this.client,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    };\n\n    const scores = new ScoresLibSQL(domainConfig);\n    const workflows = new WorkflowsLibSQL(domainConfig);\n    const memory = new MemoryLibSQL(domainConfig);\n    const observability = new ObservabilityLibSQL(domainConfig);\n    const agents = new AgentsLibSQL(domainConfig);\n\n    this.stores = {\n      scores,\n      workflows,\n      memory,\n      observability,\n      agents,\n    };\n  }\n}\n\nexport { LibSQLStore as DefaultStorage };\n","/**\n * Vector store specific prompt that details supported operators and examples.\n * This prompt helps users construct valid filters for LibSQL Vector.\n */\nexport const LIBSQL_PROMPT = `When querying LibSQL Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Direct RegExp patterns will throw an error\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Basic operators handle array values as JSON strings\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$contains\": \"value\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 50 }, \"inStock\": true } } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n"],"names":["result","conditions","operator","operatorValue","parseSqlIdentifier","buildCondition","createClient","MastraError","ErrorDomain","ErrorCategory","TABLE_SCHEMAS","createStorageErrorId","normalizePerPage","calculatePagination","TABLE_SPANS","coreTransformScoreRow","TABLE_WORKFLOW_SNAPSHOT"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BO,IAAM,sBAAA,GAAN,cAAqC,uLAAA,CAAyC;IAChE,qBAAA,GAAyC;QAC1D,OAAO;YACL,GAAG,uLAAA,CAAqB,iBAAA;YACxB,OAAO,EAAC;YACR,MAAA,EAAQ;gBAAC,WAAA;gBAAa,OAAO;aAAA;QAAA,CAC/B;IACF;IAEA,UAAU,MAAA,EAAiD;QACzD,IAAI,IAAA,CAAK,OAAA,CAAQ,MAAM,CAAA,EAAG;YACxB,OAAO,MAAA;QACT;QACA,IAAA,CAAK,cAAA,CAAe,MAAM,CAAA;QAC1B,OAAO,IAAA,CAAK,aAAA,CAAc,MAAM,CAAA;IAClC;IAEQ,aAAA,CAAc,IAAA,EAA0B,WAAA,GAAsB,EAAA,EAAS;QAC7E,IAAI,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA,EAAG;YACtB,MAAM,IAAI,MAAM,wDAAwD,CAAA;QAC1E;QAEA,MAAM,QAAA,GAAW,CAACA,OAAAA,GAAiB,WAAA,GAAc;gBAAE,CAAC,WAAW,CAAA,EAAGA,OAAAA;YAAAA,CAAO,GAAIA,OAAAA;QAG7E,IAAI,IAAA,CAAK,WAAA,CAAY,IAAI,CAAA,EAAG;YAC1B,OAAO,SAAS;gBAAE,GAAA,EAAK,IAAA,CAAK,wBAAA,CAAyB,IAAI;YAAA,CAAG,CAAA;QAC9D;QAGA,IAAI,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA,EAAG;YACvB,OAAO,SAAS;gBAAE,GAAA,EAAK,IAAA,CAAK,oBAAA,CAAqB,IAAI;YAAA,CAAG,CAAA;QAC1D;QAQA,MAAM,OAAA,GAAU,MAAA,CAAO,OAAA,CAAQ,IAA2B,CAAA;QAC1D,MAAM,SAA8B,CAAA,CAAC;QAcrC,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,CAAA,IAAK,OAAA,CAAS;YAIlC,MAAM,UAAU,WAAA,GAAc,CAAA,EAAG,WAAW,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,GAAK,GAAA;YAExD,IAAI,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAA,EAAG;gBAC/B,MAAA,CAAO,GAAG,CAAA,GAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,IAC7B,KAAA,CAAM,GAAA,CAAI,CAAC,MAAA,GAA+B,IAAA,CAAK,aAAA,CAAc,MAAM,CAAC,CAAA,GACpE,IAAA,CAAK,aAAA,CAAc,KAAK,CAAA;YAC9B,CAAA,MAAA,IAAW,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;gBAC/B,IAAI,IAAA,CAAK,eAAA,CAAgB,GAAG,CAAA,IAAK,CAAC,MAAM,OAAA,CAAQ,KAAK,CAAA,IAAK,GAAA,KAAQ,YAAA,EAAc;oBAC9E,MAAA,CAAO,GAAG,CAAA,GAAI;wBAAC,KAAK;qBAAA;gBACtB,CAAA,MAAA,IAAW,IAAA,CAAK,eAAA,CAAgB,GAAG,KAAK,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;oBAC5D,MAAA,CAAO,GAAG,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA;gBACpC,CAAA,MAAO;oBACL,MAAA,CAAO,GAAG,CAAA,GAAI,KAAA;gBAChB;YACF,CAAA,MAAA,IAAW,OAAO,KAAA,KAAU,QAAA,IAAY,UAAU,IAAA,EAAM;gBAEtD,MAAM,YAAA,GAAe,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,CAAE,IAAA,CAAK,CAAA,CAAA,GAAK,IAAA,CAAK,UAAA,CAAW,CAAC,CAAC,CAAA;gBACpE,IAAI,YAAA,EAAc;oBAChB,MAAA,CAAO,OAAO,CAAA,GAAI,IAAA,CAAK,aAAA,CAAc,KAAK,CAAA;gBAC5C,CAAA,MAAO;oBACL,MAAA,CAAO,MAAA,CAAO,MAAA,EAAQ,IAAA,CAAK,aAAA,CAAc,KAAA,EAAO,OAAO,CAAC,CAAA;gBAC1D;YACF,CAAA,MAAO;gBACL,MAAA,CAAO,OAAO,CAAA,GAAI,IAAA,CAAK,aAAA,CAAc,KAAK,CAAA;YAC5C;QACF;QAEA,OAAO,MAAA;IACT;AAgBF,CAAA;ACrGA,IAAM,mBAAA,GAAsB,CAAC,MAAA,KAAmB;IAC9C,OAAO,CAAC,KAAa,KAAA,KAA+B;QAClD,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,OAAO;YACL,GAAA,EAAK,CAAA;mDAAA,EAC0C,QAAQ,CAAA,KAAA,EAAQ,MAAA,KAAW,GAAA,GAAM,KAAK,KAAK,CAAA;oCAAA,EAC1D,QAAQ,CAAA,EAAA,EAAK,MAAM,CAAA;SAAA,CAAA;YAEnD,UAAA,EAAY,IAAA;YACZ,gBAAgB,MAAM;gBAEpB,OAAO;oBAAC;oBAAO,KAAK;iBAAA;YACtB;QAAA,CACF;IACF,CAAA;AACF,CAAA;AACA,IAAM,qBAAA,GAAwB,CAAC,MAAA,KAAmB;IAChD,OAAO,CAAC,KAAa,KAAA,KAA+B;QAClD,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAGhC,MAAM,SAAA,GACJ,OAAO,KAAA,KAAU,QAAA,IAAa,OAAO,KAAA,KAAU,QAAA,IAAY,CAAC,KAAA,CAAM,OAAO,KAAK,CAAC,CAAA,IAAK,KAAA,CAAM,IAAA,EAAK,KAAM,EAAA;QAEvG,IAAI,SAAA,EAAW;YAEb,OAAO;gBACL,GAAA,EAAK,CAAA,4BAAA,EAA+B,QAAQ,CAAA,cAAA,EAAiB,MAAM,CAAA,EAAA,CAAA;gBACnE,UAAA,EAAY;YAAA,CACd;QACF,CAAA,MAAO;YAEL,OAAO;gBACL,GAAA,EAAK,CAAA,4BAAA,EAA+B,QAAQ,CAAA,WAAA,EAAc,MAAM,CAAA,EAAA,CAAA;gBAChE,UAAA,EAAY;YAAA,CACd;QACF;IACF,CAAA;AACF,CAAA;AAEA,IAAM,iBAAA,GAAoB,CAAC,GAAA,KAAgB;IACzC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;IAChC,OAAO,CAAA,kCAAA,EAAqC,QAAQ,CAAA;wCAAA,EACZ,QAAQ,CAAA,YAAA,CAAA;AAClD,CAAA;AAEA,IAAM,OAAA,GAAU,kEAAA;AAEhB,SAAS,yBAAyB,KAAA,EAAY;IAC5C,MAAM,UAAA,GAAa,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA,CAAE,GAAA,CAAI,CAAC,CAAC,KAAA,EAAO,UAAU,CAAA,KAAM;QACpE,IAAI,KAAA,CAAM,UAAA,CAAW,GAAG,CAAA,EAAG;YAEzB,MAAM,EAAE,GAAA,EAAK,MAAA,EAAO,GAAI,cAAA,CAAe,YAAA,EAAc;gBAAE,CAAC,KAAK,CAAA,EAAG,UAAA;YAAA,CAAgB,CAAA;YAEhF,MAAM,OAAA,GAAU,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS,YAAY,CAAA;YACjD,OAAO;gBAAE,GAAA,EAAK,OAAA;gBAAS,MAAA;YAAA,CAAO;QAChC,CAAA,MAAA,IAAW,OAAO,UAAA,KAAe,QAAA,IAAY,CAAC,KAAA,CAAM,OAAA,CAAQ,UAAU,CAAA,EAAG;YAEvE,MAAM,EAAE,GAAA,EAAK,MAAA,EAAA,GAAW,cAAA,CAAe,KAAA,EAAO,UAAc,CAAA;YAE5D,MAAM,QAAA,GAAW,iBAAiB,KAAK,CAAA;YACvC,MAAM,UAAU,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS,CAAA,4BAAA,EAA+B,QAAQ,CAAA,EAAA,CAAI,CAAA;YAChF,OAAO;gBAAE,GAAA,EAAK,OAAA;gBAAS,MAAA;YAAA,CAAO;QAChC,CAAA,MAAO;YACL,MAAM,QAAA,GAAW,iBAAiB,KAAK,CAAA;YAEvC,OAAO;gBACL,GAAA,EAAK,CAAA,4BAAA,EAA+B,QAAQ,CAAA,MAAA,CAAA;gBAC5C,MAAA,EAAQ;oBAAC,UAAU;iBAAA;YAAA,CACrB;QACF;IACF,CAAC,CAAA;IAED,OAAO,UAAA;AACT;AAGA,IAAM,gBAAA,GAAqD;IACzD,GAAA,EAAK,oBAAoB,GAAG,CAAA;IAC5B,GAAA,EAAK,oBAAoB,IAAI,CAAA;IAC7B,GAAA,EAAK,sBAAsB,GAAG,CAAA;IAC9B,IAAA,EAAM,sBAAsB,IAAI,CAAA;IAChC,GAAA,EAAK,sBAAsB,GAAG,CAAA;IAC9B,IAAA,EAAM,sBAAsB,IAAI,CAAA;IAAA,kBAAA;IAGhC,GAAA,EAAK,CAAC,GAAA,EAAa,KAAA,KAAe;QAChC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,MAAM,MAAM,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,KAAA,GAAQ;YAAC,KAAK;SAAA;QACjD,IAAI,GAAA,CAAI,MAAA,KAAW,CAAA,EAAG;YACpB,OAAO;gBAAE,KAAK,OAAA;gBAAS,UAAA,EAAY;gBAAM,cAAA,EAAgB,IAAM,EAAC;YAAA,CAAE;QACpE;QACA,MAAM,oBAAoB,GAAA,CAAI,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;QACrD,OAAO;YACL,GAAA,EAAK,CAAA;;aAAA,EAEI,iBAAA,CAAkB,GAAG,CAAC,CAAA;;2DAAA,EAEwB,QAAQ,CAAA;;;oCAAA,EAG/B,QAAQ,CAAA,MAAA,EAAS,iBAAiB,CAAA;;KAAA,CAAA;YAGlE,UAAA,EAAY,IAAA;YACZ,cAAA,EAAgB,IAAM;oBAAC,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,EAAG;uBAAG,GAAG;iBAAA;QAAA,CACpD;IACF,CAAA;IAEA,IAAA,EAAM,CAAC,GAAA,EAAa,KAAA,KAAe;QACjC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,MAAM,MAAM,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,KAAA,GAAQ;YAAC,KAAK;SAAA;QACjD,IAAI,GAAA,CAAI,MAAA,KAAW,CAAA,EAAG;YACpB,OAAO;gBAAE,KAAK,OAAA;gBAAS,UAAA,EAAY;gBAAM,cAAA,EAAgB,IAAM,EAAC;YAAA,CAAE;QACpE;QACA,MAAM,oBAAoB,GAAA,CAAI,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;QACrD,OAAO;YACL,GAAA,EAAK,CAAA;;aAAA,EAEI,iBAAA,CAAkB,GAAG,CAAC,CAAA;;2DAAA,EAEwB,QAAQ,CAAA;;;oCAAA,EAG/B,QAAQ,CAAA,UAAA,EAAa,iBAAiB,CAAA;;KAAA,CAAA;YAGtE,UAAA,EAAY,IAAA;YACZ,cAAA,EAAgB,IAAM;oBAAC,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,EAAG;uBAAG,GAAG;iBAAA;QAAA,CACpD;IACF,CAAA;IACA,IAAA,EAAM,CAAC,GAAA,EAAa,KAAA,KAAe;QACjC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,IAAI,GAAA;QACJ,MAAM,aAAa,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,KAAA,GAAQ;YAAC,KAAK;SAAA;QAExD,IAAI,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;YAE3B,GAAA,GAAM,OAAA;QACR,CAAA,MAAO;YACL,GAAA,GAAM,CAAA;;aAAA,EAEG,iBAAA,CAAkB,GAAG,CAAC,CAAA;;;;;;oDAAA,EAMiB,QAAQ,CAAA;;;;;KAAA,CAAA;QAM1D;QAEA,OAAO;YACL,GAAA;YACA,UAAA,EAAY,IAAA;YACZ,gBAAgB,MAAM;gBACpB,IAAI,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;oBAC3B,OAAO,EAAC;gBACV;gBACA,OAAO;oBAAC,IAAA,CAAK,SAAA,CAAU,UAAU,CAAC;iBAAA;YACpC;QAAA,CACF;IACF,CAAA;IACA,UAAA,EAAY,CAAC,GAAA,EAAa,KAAA,KAAe;QACvC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;YACrD,MAAM,IAAI,MAAM,+CAA+C,CAAA;QACjE;QAGA,MAAM,UAAA,GAAa,yBAAyB,KAAK,CAAA;QAEjD,OAAO;YACL,GAAA,EAAK,CAAA;;eAAA,EAEM,iBAAA,CAAkB,GAAG,CAAC,CAAA;;;oDAAA,EAGe,QAAQ,CAAA;oBAAA,EACxC,UAAA,CAAW,GAAA,CAAI,CAAA,CAAA,GAAK,CAAA,CAAE,GAAG,CAAA,CAAE,IAAA,CAAK,OAAO,CAAC,CAAA;;;;OAAA,CAAA;YAKxD,UAAA,EAAY,IAAA;YACZ,gBAAgB,IAAM,UAAA,CAAW,OAAA,CAAQ,CAAA,CAAA,GAAK,EAAE,MAAM;QAAA,CACxD;IACF,CAAA;IAAA,oBAAA;IAGA,OAAA,EAAS,CAAC,GAAA,KAAgB;QACxB,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,OAAO;YACL,GAAA,EAAK,CAAA,uBAAA,EAA0B,QAAQ,CAAA,aAAA,CAAA;YACvC,UAAA,EAAY;QAAA,CACd;IACF,CAAA;IAAA,oBAAA;IAGA,IAAA,EAAM,CAAC,GAAA,GAAA,CAAiB;YACtB,GAAA,EAAK,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,CAAA;YACZ,UAAA,EAAY;QAAA,CACd,CAAA;IACA,GAAA,EAAK,CAAC,GAAA,GAAA,CAAiB;YACrB,GAAA,EAAK,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,CAAA;YACZ,UAAA,EAAY;QAAA,CACd,CAAA;IACA,IAAA,EAAM,CAAA,MAAA,CAAQ;YAAE,GAAA,EAAK,CAAA,KAAA,EAAQ,GAAG,CAAA,CAAA,CAAA;YAAK,YAAY,KAAA;QAAA,CAAM,CAAA;IACvD,IAAA,EAAM,CAAC,GAAA,GAAA,CAAiB;YACtB,GAAA,EAAK,CAAA,KAAA,EAAQ,GAAG,CAAA,CAAA,CAAA;YAChB,UAAA,EAAY;QAAA,CACd,CAAA;IACA,KAAA,EAAO,CAAC,GAAA,EAAa,UAAA,KAAuB;QAC1C,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,OAAO;YACL,GAAA,EAAK,CAAA;;4CAAA,EAEmC,QAAQ,CAAA;iDAAA,EACH,QAAQ,CAAA,MAAA,EAAS,UAAU,CAAA;;;GAAA,CAAA;YAIxE,UAAA,EAAY;QAAA,CACd;IACF,CAAA;IAAA,QAAA;IAAA,uBAAA;IAAA,+CAAA;IAAA,QAAA;IAAA,gDAAA;IAAA,sEAAA;IAAA,wBAAA;IAAA,wCAAA;IAAA,0EAAA;IAAA,+EAAA;IAAA,yEAAA;IAAA,4BAAA;IAAA,0CAAA;IAAA,wDAAA;IAAA,eAAA;IAAA,6CAAA;IAAA,0BAAA;IAAA,yDAAA;IAAA,aAAA;IAAA,0CAAA;IAAA,0CAAA;IAAA,sDAAA;IAAA,sBAAA;IAAA,wCAAA;IAAA,eAAA;IAAA,qCAAA;IAAA,0BAAA;IAAA,mBAAA;IAAA,0BAAA;IAAA,wBAAA;IAAA,sBAAA;IAAA,kDAAA;IAAA,cAAA;IAAA,qBAAA;IAAA,qCAAA;IAAA,YAAA;IAAA,iBAAA;IAAA,mCAAA;IAAA,UAAA;IAAA,qCAAA;IAAA,qCAAA;IAAA,4DAAA;IAAA,oEAAA;IAAA,UAAA;IAAA,uEAAA;IAAA,qCAAA;IAAA,yDAAA;IAAA,kEAAA;IAAA,mBAAA;IAAA,iBAAA;IAAA,oCAAA;IAAA,aAAA;IAAA,UAAA;IAAA,iBAAA;IAAA,eAAA;IAAA,6BAAA;IAAA,WAAA;IAAA,SAAA;IAAA,QAAA;IAmEA,SAAA,EAAW,CAAC,GAAA,EAAa,KAAA,KAAe;QACtC,MAAM,WAAA,GAAc,iBAAiB,GAAG,CAAA;QACxC,IAAI,GAAA;QACJ,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;YACxB,GAAA,GAAM,CAAA;eAAA,EACK,iBAAA,CAAkB,WAAW,CAAC,CAAA;;;oDAAA,EAGO,WAAW,CAAA;;;OAAA,CAAA;QAI7D,CAAA,MAAA,IAAW,OAAO,KAAA,KAAU,QAAA,EAAU;YACpC,GAAA,GAAM,CAAA,iCAAA,EAAoC,WAAW,CAAA,4CAAA,CAAA;QACvD,CAAA,MAAO;YACL,GAAA,GAAM,CAAA,2BAAA,EAA8B,WAAW,CAAA,OAAA,CAAA;QACjD;QACA,OAAO;YACL,GAAA;YACA,UAAA,EAAY,IAAA;YACZ,gBAAgB,MAAM;gBACpB,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;oBACxB,OAAO;wBAAC,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC;qBAAA;gBAC/B;gBACA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,IAAA,EAAM;oBAC/C,OAAO;wBAAC,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC;qBAAA;gBAC/B;gBACA,IAAI,OAAO,UAAU,QAAA,EAAU;oBAC7B,OAAO;wBAAC,iBAAA,CAAkB,KAAK,CAAC;qBAAA;gBAClC;gBACA,OAAO;oBAAC,KAAK;iBAAA;YACf;QAAA,CACF;IACF;AAcF,CAAA;AAOA,SAAS,eAAe,GAAA,EAA+B;IACrD,OAAO,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAA,IAAY,OAAO,GAAA,CAAI,GAAA,KAAQ,QAAA,IAAY,KAAA,CAAM,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA;AAClG;AAEA,IAAM,gBAAA,GAAmB,CAAC,GAAA,KAAgB;IACxC,MAAM,SAAA,OAAY,gLAAA,EAAc,GAAG,CAAA;IAEnC,IAAI,SAAA,CAAU,QAAA,CAAS,GAAG,CAAA,EAAG;QAC3B,OAAO,SAAA,CACJ,KAAA,CAAM,GAAG,CAAA,CACT,GAAA,CAAI,CAAA,OAAA,GAAW,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAG,CAAA,CAC7B,IAAA,CAAK,GAAG,CAAA;IACb;IACA,OAAO,SAAA;AACT,CAAA;AAGA,IAAM,WAAA,GAAc,CAAC,GAAA,KAAgB;IACnC,MAAM,WAAA,GAAc,iBAAiB,GAAG,CAAA;IAExC,OAAO,CAAA,GAAA,EAAM,WAAW,CAAA,CAAA,CAAA;AAC1B,CAAA;AAEA,SAAS,kBAAkB,GAAA,EAAqB;IAC9C,OAAO,GAAA,CAAI,OAAA,CAAQ,WAAA,EAAa,MAAM,CAAA;AACxC;AAEO,SAAS,iBAAiB,MAAA,EAA0C;IACzE,IAAI,CAAC,MAAA,EAAQ;QACX,OAAO;YAAE,GAAA,EAAK,EAAA;YAAI,MAAA,EAAQ,EAAC;QAAA,CAAE;IAC/B;IAEA,MAAM,SAAoB,EAAC;IAC3B,MAAM,UAAA,GAAa,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,CACrC,GAAA,CAAI,CAAC,CAAC,GAAA,EAAK,KAAK,CAAA,KAAM;QACrB,MAAM,SAAA,GAAY,cAAA,CAAe,GAAA,EAAK,KAAS,CAAA;QAC/C,MAAA,CAAO,IAAA,CAAK,GAAG,SAAA,CAAU,MAAM,CAAA;QAC/B,OAAO,SAAA,CAAU,GAAA;IACnB,CAAC,CAAA,CACA,IAAA,CAAK,OAAO,CAAA;IAEf,OAAO;QACL,GAAA,EAAK,UAAA,GAAa,CAAA,MAAA,EAAS,UAAU,CAAA,CAAA,GAAK,EAAA;QAC1C;IAAA,CACF;AACF;AAEA,SAAS,cAAA,CAAe,GAAA,EAAa,KAAA,EAAY,UAAA,EAAkC;IAEjF,IAAI;QAAC;QAAQ,KAAA;QAAO,MAAA;QAAQ,MAAM;KAAA,CAAE,QAAA,CAAS,GAAG,CAAA,EAAG;QACjD,OAAO,qBAAA,CAAsB,GAAA,EAAyC,KAAiB,CAAA;IACzF;IAGA,IAAI,CAAC,KAAA,IAAS,OAAO,KAAA,KAAU,QAAA,EAAU;QACvC,MAAM,QAAA,GAAW,YAAY,GAAG,CAAA;QAChC,OAAO;YACL,GAAA,EAAK,CAAA,uBAAA,EAA0B,QAAQ,CAAA,KAAA,CAAA;YACvC,MAAA,EAAQ;gBAAC,KAAK;aAAA;QAAA,CAChB;IACF;IAQA,OAAO,cAAA,CAAe,KAAK,KAAK,CAAA;AAClC;AAaA,SAAS,qBAAA,CACP,GAAA,EACA,KAAA,EACA,UAAA,EACc;IAEd,IAAI,CAAC,SAAU,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,IAAK,KAAA,CAAM,MAAA,KAAW,CAAA,EAAI;QAC1D,OAAQ,GAAA;YACN,KAAK,MAAA;YACL,KAAK,MAAA;gBACH,OAAO;oBAAE,GAAA,EAAK,MAAA;oBAAQ,MAAA,EAAQ,EAAC;gBAAA,CAAE;YACnC,KAAK,KAAA;gBACH,OAAO;oBAAE,GAAA,EAAK,OAAA;oBAAS,MAAA,EAAQ,EAAC;gBAAA,CAAE;YACpC,KAAK,MAAA;gBACH,MAAM,IAAI,MAAM,+BAA+B,CAAA;YACjD;gBACE,OAAO;oBAAE,GAAA,EAAK,MAAA;oBAAQ,MAAA,EAAQ,EAAC;gBAAA,CAAE;QAAA;IAEvC;IAEA,IAAI,QAAQ,MAAA,EAAQ;QAElB,MAAM,OAAA,GAAU,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA;QACpC,MAAMC,WAAAA,GAAa,OAAA,CAAQ,GAAA,CAAI,CAAC,CAAC,QAAA,EAAU,UAAU,CAAA,GAAM,cAAA,CAAe,QAAA,EAAU,UAAe,CAAC,CAAA;QACpG,OAAO;YACL,GAAA,EAAK,CAAA,KAAA,EAAQA,WAAAA,CAAW,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,GAAG,CAAA,CAAE,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,CAAA;YACrD,MAAA,EAAQA,WAAAA,CAAW,OAAA,CAAQ,CAAA,CAAA,GAAK,EAAE,MAAM;QAAA,CAC1C;IACF;IAEA,MAAM,SAAoB,EAAC;IAC3B,MAAM,YAAA,GAAe,GAAA,KAAQ,KAAA,IAAS,GAAA,KAAQ,SAAS,IAAA,GAAO,KAAA;IAC9D,MAAM,aAAa,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAClC,KAAA,CAAM,GAAA,CAAI,CAAA,CAAA,KAAK;QACb,MAAM,OAAA,GAAU,CAAC,CAAC,CAAA,GAAI,OAAO,OAAA,CAAQ,CAAC,IAAI,EAAC;QAC3C,OAAO,OAAA,CAAQ,GAAA,CAAI,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,GAAM,cAAA,CAAe,CAAA,EAAG,CAAM,CAAC,CAAA;IAC1D,CAAC,CAAA,GACD;QAAC,eAAe,GAAA,EAAK,KAAiB,CAAC;KAAA;IAE3C,MAAM,MAAA,GAAS,UAAA,CACZ,IAAA,EAAK,CACL,GAAA,CAAI,CAAA,CAAA,KAAK;QACR,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA,CAAE,MAAM,CAAA;QACvB,OAAO,CAAA,CAAE,GAAA;IACX,CAAC,CAAA,CACA,IAAA,CAAK,CAAA,CAAA,EAAI,YAAY,CAAA,CAAA,CAAG,CAAA;IAE3B,OAAO;QACL,KAAK,GAAA,KAAQ,MAAA,GAAS,CAAA,KAAA,EAAQ,MAAM,CAAA,CAAA,CAAA,GAAM,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,CAAA;QACpD;IAAA,CACF;AACF;AAEA,SAAS,cAAA,CAAe,GAAA,EAAa,KAAA,EAA0B;IAC7D,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,CAAC,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;QACtD,MAAM,OAAA,GAAU,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA;QACpC,MAAM,UAAU,OAAA,CAAQ,GAAA,CAAI,CAAC,CAACC,SAAAA,EAAUC,cAAa,CAAA,GACnDD,cAAa,MAAA,GACT;gBACE,GAAA,EAAK,CAAA,KAAA,EAAQ,MAAA,CAAO,OAAA,CAAQC,cAAoC,CAAA,CAC7D,GAAA,CAAI,CAAC,CAAC,EAAA,EAAI,GAAG,CAAA,GAAM,eAAA,CAAgB,KAAK,EAAA,EAAoB,GAAG,EAAE,GAAG,CAAA,CACpE,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,CAAA;gBAChB,MAAA,EAAQ,MAAA,CAAO,OAAA,CAAQA,cAAoC,CAAA,CAAE,OAAA,CAC3D,CAAC,CAAC,EAAA,EAAI,GAAG,CAAA,GAAM,eAAA,CAAgB,GAAA,EAAK,EAAA,EAAoB,GAAG,CAAA,CAAE,MAAA;YAC/D,CACF,GACA,eAAA,CAAgB,GAAA,EAAKD,SAAAA,EAA0BC,cAAa;QAGlE,OAAO;YACL,GAAA,EAAK,CAAA,CAAA,EAAI,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,GAAG,CAAA,CAAE,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,CAAA;YAC9C,MAAA,EAAQ,OAAA,CAAQ,OAAA,CAAQ,CAAA,CAAA,GAAK,EAAE,MAAM;QAAA,CACvC;IACF;IAGA,MAAM,CAAC,CAAC,QAAA,EAAU,aAAa,CAAA,GAAI,EAAE,CAAA,GAAI,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA;IAC7D,OAAO,eAAA,CAAgB,GAAA,EAAK,QAAA,EAA0B,aAAa,CAAA;AACrE;AAEA,IAAM,eAAA,GAAkB,CAAC,GAAA,EAAa,QAAA,EAAwB,aAAA,KAAqC;IACjG,IAAI,CAAC,SAAS,UAAA,CAAW,GAAG,KAAK,CAAC,gBAAA,CAAiB,QAAQ,CAAA,EAAG;QAC5D,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqB,QAAQ,CAAA,CAAE,CAAA;IACjD;IACA,MAAM,UAAA,GAAa,gBAAA,CAAiB,QAAQ,CAAA;IAC5C,MAAM,cAAA,GAAiB,UAAA,CAAW,GAAA,EAAK,aAAa,CAAA;IAEpD,IAAI,CAAC,eAAe,UAAA,EAAY;QAC9B,OAAO;YAAE,GAAA,EAAK,cAAA,CAAe,GAAA;YAAK,MAAA,EAAQ,EAAC;QAAA,CAAE;IAC/C;IAEA,MAAM,WAAA,GAAc,cAAA,CAAe,cAAA,GAAiB,cAAA,CAAe,cAAA,EAAe,GAAI,aAAA;IAEtF,IAAI,cAAA,CAAe,WAAW,CAAA,EAAG;QAC/B,OAAO,WAAA;IACT;IAEA,OAAO;QACL,KAAK,cAAA,CAAe,GAAA;QACpB,QAAQ,KAAA,CAAM,OAAA,CAAQ,WAAW,CAAA,GAAI,WAAA,GAAc;YAAC,WAAW;SAAA;IAAA,CACjE;AACF,CAAA;;AChgBO,IAAM,YAAA,GAAN,cAA2B,6LAAA,CAAiC;IACzD,KAAA,CAAA;IACS,UAAA,CAAA;IACA,gBAAA,CAAA;IAEjB,WAAA,CAAY,EACV,GAAA,EACA,SAAA,EACA,OAAA,EACA,YAAA,EACA,UAAA,GAAa,CAAA,EACb,gBAAA,GAAmB,GAAA,EACnB,EAAA,EACF,CAAwC;QACtC,KAAA,CAAM;YAAE;QAAA,CAAI,CAAA;QAEZ,IAAA,CAAK,KAAA,OAAQ,6MAAA,EAAa;YACxB,GAAA;YACA,OAAA;YACA,SAAA;YACA;QAAA,CACD,CAAA;QACD,IAAA,CAAK,UAAA,GAAa,UAAA;QAClB,IAAA,CAAK,gBAAA,GAAmB,gBAAA;QAExB,IAAI,IAAI,QAAA,CAAS,CAAA,KAAA,CAAO,KAAK,GAAA,CAAI,QAAA,CAAS,CAAA,QAAA,CAAU,CAAA,EAAG;YACrD,IAAA,CAAK,KAAA,CACF,OAAA,CAAQ,0BAA0B,EAClC,IAAA,CAAK,IAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,2CAA2C,CAAC,CAAA,CACzE,KAAA,CAAM,CAAA,GAAA,GAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,qDAAA,EAAuD,GAAG,CAAC,CAAA;YAC5F,IAAA,CAAK,KAAA,CACF,OAAA,CAAQ,6BAA6B,EACrC,IAAA,CAAK,IAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,4CAA4C,CAAC,CAAA,CAC1E,KAAA,CAAM,CAAA,GAAA,GAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,sDAAA,EAAwD,GAAG,CAAC,CAAA;QAC/F;IACF;IAEA,MAAc,8BAAA,CAAkC,SAAA,EAA6B,aAAA,GAAgB,KAAA,EAAmB;QAC9G,IAAI,QAAA,GAAW,CAAA;QACf,IAAI,UAAU,IAAA,CAAK,gBAAA;QACnB,MAAO,QAAA,GAAW,IAAA,CAAK,UAAA,CAAY;YACjC,IAAI;gBACF,OAAO,MAAM,SAAA,EAAU;YACzB,EAAA,OAAS,KAAA,EAAY;gBACnB,IACE,KAAA,CAAM,IAAA,KAAS,aAAA,IACd,KAAA,CAAM,OAAA,IAAW,KAAA,CAAM,OAAA,CAAQ,WAAA,EAAY,CAAE,QAAA,CAAS,oBAAoB,CAAA,EAC3E;oBACA,QAAA,EAAA;oBACA,IAAI,QAAA,IAAY,IAAA,CAAK,UAAA,EAAY;wBAC/B,IAAA,CAAK,MAAA,CAAO,KAAA,CACV,CAAA,qCAAA,EAAwC,IAAA,CAAK,UAAU,CAAA,kBAAA,EAAqB,MAAM,OAAO,CAAA,CAAA,EACzF;wBAEF,MAAM,KAAA;oBACR;oBACA,IAAA,CAAK,MAAA,CAAO,IAAA,CACV,CAAA,sBAAA,EAAyB,QAAQ,CAAA,eAAA,EAAkB,gBAAgB,cAAA,GAAiB,EAAE,CAAA,2BAAA,EAA8B,OAAO,CAAA,KAAA,CAAA;oBAE7H,MAAM,IAAI,OAAA,CAAQ,CAAA,OAAA,GAAW,UAAA,CAAW,OAAA,EAAS,OAAO,CAAC,CAAA;oBACzD,OAAA,IAAW,CAAA;gBACb,CAAA,MAAO;oBACL,MAAM,KAAA;gBACR;YACF;QACF;QACA,MAAM,IAAI,MAAM,8EAA8E,CAAA;IAChG;IAEA,gBAAgB,MAAA,EAA6B;QAC3C,MAAM,UAAA,GAAa,IAAI,sBAAA,EAAuB;QAC9C,OAAO,UAAA,CAAW,SAAA,CAAU,MAAM,CAAA;IACpC;IAEA,MAAM,KAAA,CAAM,EACV,SAAA,EACA,WAAA,EACA,IAAA,GAAO,EAAA,EACP,MAAA,EACA,aAAA,GAAgB,KAAA,EAChB,QAAA,GAAW,CAAA,CAAA,EACb,EAAoD;QAClD,IAAI;YACF,IAAI,CAAC,MAAA,CAAO,SAAA,CAAU,IAAI,CAAA,IAAK,QAAQ,CAAA,EAAG;gBACxC,MAAM,IAAI,MAAM,iCAAiC,CAAA;YACnD;YACA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,WAAW,CAAA,IAAK,CAAC,WAAA,CAAY,KAAA,CAAM,CAAA,CAAA,GAAK,OAAO,MAAM,QAAA,IAAY,MAAA,CAAO,QAAA,CAAS,CAAC,CAAC,CAAA,EAAG;gBACvG,MAAM,IAAI,MAAM,gDAAgD,CAAA;YAClE;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,OAAA,EAAS,cAAc,CAAA;gBACzD,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;YAAA,CAC1B,EACA;QAEJ;QAEA,IAAI;YACF,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;YAElE,MAAM,SAAA,GAAY,CAAA,CAAA,EAAI,WAAA,CAAY,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA;YAE3C,MAAM,gBAAA,GAAmB,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAA;YACpD,MAAM,EAAE,GAAA,EAAK,WAAA,EAAa,QAAQ,YAAA,EAAa,GAAI,iBAAiB,gBAAgB,CAAA;YACpF,YAAA,CAAa,IAAA,CAAK,QAAQ,CAAA;YAC1B,YAAA,CAAa,IAAA,CAAK,IAAI,CAAA;YAEtB,MAAM,KAAA,GAAQ,CAAA;;;;6CAAA,EAI2B,SAAS,CAAA;;UAAA,EAE5C,aAAA,GAAgB,6CAA6C,EAAE,CAAA;aAAA,EAC5D,eAAe,CAAA;QAAA,EACpB,WAAW,CAAA;;;;;;aAAA,CAAA;YAQf,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBACtC,GAAA,EAAK,KAAA;gBACL,IAAA,EAAM;YAAA,CACP,CAAA;YAED,OAAO,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,CAAC,EAAE,EAAA,EAAI,KAAA,EAAO,QAAA,EAAU,SAAA,EAAU,GAAA,CAAO;oBAC9D,EAAA;oBACA,KAAA;oBACA,QAAA,EAAU,IAAA,CAAK,KAAA,CAAO,QAAA,IAAuB,IAAI,CAAA;oBACjD,GAAI,iBAAiB,SAAA,IAAa;wBAAE,QAAQ,IAAA,CAAK,KAAA,CAAM,SAAmB,CAAA;oBAAA,CAAA;gBAAE,CAC9E,CAAE,CAAA;QACJ,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,OAAA,EAAS,QAAQ,CAAA;gBACnD,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEO,OAAO,IAAA,EAA6C;QACzD,IAAI;YACF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,QAAA,CAAS,IAAI,GAAG,IAAI,CAAA;QAC5E,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,QAAA,EAAU,QAAQ,CAAA;gBACpD,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAc,QAAA,CAAS,EAAE,SAAA,EAAW,OAAA,EAAS,QAAA,EAAU,GAAA,EAAI,EAA0C;QACnG,MAAM,EAAA,GAAK,MAAM,IAAA,CAAK,KAAA,CAAM,WAAA,CAAY,OAAO,CAAA;QAC/C,IAAI;YACF,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;YAClE,MAAM,YAAY,GAAA,IAAO,OAAA,CAAQ,GAAA,CAAI,IAAM,MAAA,CAAO,UAAA,EAAY,CAAA;YAE9D,IAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,EAAA,CAAK;gBACvC,MAAM,KAAA,GAAQ,CAAA;wBAAA,EACI,eAAe,CAAA;;;;;UAAA,CAAA;gBAMjC,MAAM,GAAG,OAAA,CAAQ;oBACf,GAAA,EAAK,KAAA;oBACL,IAAA,EAAM;wBACJ,SAAA,CAAU,CAAC,CAAA;wBACX,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,CAAC,CAAC,CAAA;wBACzB,KAAK,SAAA,CAAU,QAAA,EAAA,CAAW,CAAC,CAAA,IAAK,CAAA,CAAE,CAAA;wBAClC,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,CAAC,CAAC,CAAA;wBACzB,KAAK,SAAA,CAAU,QAAA,EAAA,CAAW,CAAC,CAAA,IAAK,CAAA,CAAE;qBAAA;gBACpC,CACD,CAAA;YACH;YACA,MAAM,GAAG,MAAA,EAAO;YAChB,OAAO,SAAA;QACT,EAAA,OAAS,KAAA,EAAO;YACd,CAAC,EAAA,CAAG,MAAA,IAAW,MAAM,EAAA,CAAG,QAAA,EAAS;YACjC,IAAI,iBAAiB,KAAA,IAAS,KAAA,CAAM,OAAA,EAAS,QAAA,CAAS,0BAA0B,CAAA,EAAG;gBACjF,MAAM,KAAA,GAAQ,KAAA,CAAM,OAAA,CAAQ,KAAA,CAAM,0CAA0C,CAAA;gBAC5E,IAAI,KAAA,EAAO;oBACT,MAAM,GAAG,MAAA,EAAQ,QAAQ,CAAA,GAAI,KAAA;oBAC7B,MAAM,IAAI,KAAA,CACR,CAAA,kCAAA,EAAqC,SAAS,CAAA,UAAA,EAAa,QAAQ,CAAA,oBAAA,EAAuB,MAAM,CAAA,2GAAA,CAAA;gBAGpG;YACF;YACA,MAAM,KAAA;QACR;IACF;IAEO,YAAY,IAAA,EAAwC;QACzD,IAAI;YACF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,aAAA,CAAc,IAAI,CAAC,CAAA;QAC3E,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC1D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,SAAS;oBAAE,SAAA,EAAW,KAAK,SAAA;oBAAW,SAAA,EAAW,KAAK,SAAA;gBAAA;YAAU,CAClE,EACA;QAEJ;IACF;IAEA,MAAc,aAAA,CAAc,EAAE,SAAA,EAAW,SAAA,EAAU,EAAqC;QACtF,IAAI,CAAC,MAAA,CAAO,SAAA,CAAU,SAAS,CAAA,IAAK,aAAa,CAAA,EAAG;YAClD,MAAM,IAAI,MAAM,sCAAsC,CAAA;QACxD;QACA,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;YACvB,GAAA,EAAK,CAAA;qCAAA,EAC4B,eAAe,CAAA;;;+BAAA,EAGrB,SAAS,CAAA;;;QAAA,CAAA;YAIpC,MAAM,EAAA;QAAC,CACR,CAAA;QACD,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;YACvB,GAAA,EAAK,CAAA;qCAAA,EAC4B,eAAe,CAAA;aAAA,EACvC,eAAe,CAAA;QAAA,CAAA;YAExB,MAAM,EAAA;QAAC,CACR,CAAA;IACH;IAEO,YAAY,IAAA,EAAwC;QACzD,IAAI;YACF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,aAAA,CAAc,IAAI,CAAC,CAAA;QAC3E,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC1D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA,EAAW,IAAA,CAAK,SAAA;gBAAA;YAAU,CACvC,EACA;QAEJ;IACF;IAEA,MAAc,aAAA,CAAc,EAAE,SAAA,EAAU,EAAqC;QAC3E,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;YACvB,GAAA,EAAK,CAAA,qBAAA,EAAwB,eAAe,CAAA,CAAA;YAC5C,MAAM,EAAA;QAAC,CACR,CAAA;IACH;IAEA,MAAM,WAAA,GAAiC;QACrC,IAAI;YACF,MAAM,iBAAA,GAAoB,CAAA;;;;MAAA,CAAA;YAK1B,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBACtC,GAAA,EAAK,iBAAA;gBACL,MAAM,EAAA;YAAC,CACR,CAAA;YACD,OAAO,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,CAAA,GAAA,GAAO,IAAI,IAAc,CAAA;QAClD,EAAA,OAAS,KAAA,EAAY;YACnB,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC1D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAAA;;;;;GAAA,GAQA,MAAM,aAAA,CAAc,EAAE,SAAA,EAAU,EAA6C;QAC3E,IAAI;YACF,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;YAElE,MAAM,cAAA,GAAiB,CAAA;;;;;MAAA,CAAA;YAMvB,MAAM,SAAA,GAAY,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBACzC,GAAA,EAAK,cAAA;gBACL,IAAA,EAAM;oBAAC,eAAe;iBAAA;YAAA,CACvB,CAAA;YAED,IAAI,CAAC,SAAA,CAAU,IAAA,CAAK,CAAC,CAAA,EAAG,GAAA,EAAK;gBAC3B,MAAM,IAAI,KAAA,CAAM,CAAA,MAAA,EAAS,eAAe,CAAA,UAAA,CAAY,CAAA;YACtD;YAGA,MAAM,SAAA,GAAY,QAAA,CAAU,SAAA,CAAU,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAe,KAAA,CAAM,mBAAmB,CAAA,EAAA,CAAI,CAAC,CAAA,IAAK,GAAG,CAAA;YAGnG,MAAM,UAAA,GAAa,CAAA;;aAAA,EAEV,eAAe,CAAA;MAAA,CAAA;YAExB,MAAM,WAAA,GAAc,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBAC3C,GAAA,EAAK,UAAA;gBACL,MAAM,EAAA;YAAC,CACR,CAAA;YAGD,MAAM,MAAA,GAAgD,QAAA;YAEtD,OAAO;gBACL,SAAA;gBACA,KAAA,EAAQ,WAAA,EAAa,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,KAAA,IAAoB,CAAA;gBACpD;YAAA,CACF;QACF,EAAA,OAAS,CAAA,EAAQ;YACf,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,QAAQ,CAAA;gBAC5D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA;YAAU,CACvB,EACA;QAEJ;IACF;IAAA;;;;;;;;;;GAAA,GAaO,aAAa,IAAA,EAA6D;QAC/E,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,cAAA,CAAe,IAAI,CAAC,CAAA;IAC5E;IAEA,MAAc,eAAe,MAAA,EAA+D;QAC1F,MAAM,EAAE,SAAA,EAAW,MAAA,EAAO,GAAI,MAAA;QAC9B,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAGlE,IAAI,QAAQ,MAAA,IAAU,MAAA,CAAO,EAAA,IAAM,QAAA,IAAY,MAAA,IAAU,OAAO,MAAA,EAAQ;YACtE,MAAM,IAAI,8KAAA,CAAY;gBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,oBAAoB,CAAA;gBACvE,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA,CAAU;gBACrB,IAAA,EAAM;YAAA,CACP,CAAA;QACH;QAEA,IAAI,CAAC,MAAA,CAAO,MAAA,IAAU,CAAC,OAAO,QAAA,EAAU;YACtC,MAAM,IAAI,8KAAA,CAAY;gBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,YAAY,CAAA;gBAC/D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA,CAAU;gBACrB,IAAA,EAAM;YAAA,CACP,CAAA;QACH;QAEA,MAAM,UAAoB,EAAC;QAC3B,MAAM,OAAkB,EAAC;QAEzB,IAAI,OAAO,MAAA,EAAQ;YACjB,OAAA,CAAQ,IAAA,CAAK,yBAAyB,CAAA;YACtC,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,MAAM,CAAC,CAAA;QACzC;QAEA,IAAI,OAAO,QAAA,EAAU;YACnB,OAAA,CAAQ,IAAA,CAAK,cAAc,CAAA;YAC3B,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,QAAQ,CAAC,CAAA;QAC3C;QAEA,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;YACxB;QACF;QAEA,IAAI,WAAA;QACJ,IAAI,WAAA;QAGJ,IAAI,IAAA,IAAQ,MAAA,IAAU,MAAA,CAAO,EAAA,EAAI;YAE/B,WAAA,GAAc,eAAA;YACd,WAAA,GAAc;gBAAC,OAAO,EAAE;aAAA;QAC1B,CAAA,MAAA,IAAW,QAAA,IAAY,MAAA,IAAU,MAAA,CAAO,MAAA,EAAQ;YAE9C,MAAM,SAAS,MAAA,CAAO,MAAA;YAEtB,IAAI,CAAC,MAAA,IAAU,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CAAE,MAAA,KAAW,CAAA,EAAG;gBAC/C,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,cAAc,CAAA;oBACjE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;oBAAA,CAAU;oBACrB,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAEA,MAAM,gBAAA,GAAmB,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAA;YACpD,MAAM,EAAE,GAAA,EAAK,SAAA,EAAW,QAAQ,YAAA,EAAa,GAAI,iBAAiB,gBAAgB,CAAA;YAElF,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,IAAA,OAAW,EAAA,EAAI;gBACzC,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,gBAAgB,CAAA;oBACnE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;oBAAA,CAAU;oBACrB,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAIA,MAAM,mBAAA,GAAsB,UACzB,OAAA,CAAQ,eAAA,EAAiB,EAAE,CAAA,CAC3B,IAAA,GACA,WAAA,EAAY;YACf,MAAM,gBAAA,GAAmB;gBAAC,MAAA;gBAAQ,OAAA;gBAAS,KAAK;aAAA;YAEhD,IAAI,gBAAA,CAAiB,QAAA,CAAS,mBAAmB,CAAA,EAAG;gBAClD,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,kBAAkB,CAAA;oBACrE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;wBAAW,SAAA,EAAW,mBAAA;oBAAA,CAAoB;oBACrD,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAGA,WAAA,GAAc,SAAA,CAAU,OAAA,CAAQ,YAAA,EAAc,EAAE,CAAA;YAChD,WAAA,GAAc,YAAA;QAChB,CAAA,MAAO;YACL,MAAM,IAAI,8KAAA,CAAY;gBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,WAAW,CAAA;gBAC9D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA,CAAU;gBACrB,IAAA,EAAM;YAAA,CACP,CAAA;QACH;QAEA,MAAM,KAAA,GAAQ,CAAA;aAAA,EACH,eAAe,CAAA;UAAA,EAClB,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAC,CAAA;YAAA,EAChB,WAAW,CAAA;IAAA,CAAA;QAGrB,IAAI;YACF,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBACvB,GAAA,EAAK,KAAA;gBACL,IAAA,EAAM,CAAC;uBAAG,IAAA,EAAM;uBAAG,WAAW;iBAAA;YAAA,CAC/B,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,YAAA,GAAoC;gBAAE,SAAA;YAAA,CAAU;YAEtD,IAAI,IAAA,IAAQ,MAAA,IAAU,MAAA,CAAO,EAAA,EAAI;gBAC/B,YAAA,CAAa,EAAA,GAAK,MAAA,CAAO,EAAA;YAC3B;YAEA,IAAI,QAAA,IAAY,MAAA,IAAU,MAAA,CAAO,MAAA,EAAQ;gBACvC,YAAA,CAAa,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,MAAM,CAAA;YACpD;YAEA,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC3D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;YAAA,CACX,EACA;QAEJ;IACF;IAAA;;;;;;GAAA,GASO,aAAa,IAAA,EAAyC;QAC3D,IAAI;YACF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,cAAA,CAAe,IAAI,CAAC,CAAA;QAC5E,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC3D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,WAAW,IAAA,CAAK,SAAA;oBAChB,GAAI,IAAA,CAAK,EAAA,IAAM;wBAAE,EAAA,EAAI,KAAK,EAAA;oBAAA,CAAA;gBAAG;YAC/B,CACF,EACA;QAEJ;IACF;IAEA,MAAc,cAAA,CAAe,EAAE,SAAA,EAAW,EAAA,EAAG,EAAsC;QACjF,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;YACvB,GAAA,EAAK,CAAA,YAAA,EAAe,eAAe,CAAA,oBAAA,CAAA;YACnC,IAAA,EAAM;gBAAC,EAAE;aAAA;QAAA,CACV,CAAA;IACH;IAEO,cAAc,IAAA,EAA8D;QACjF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,eAAA,CAAgB,IAAI,CAAC,CAAA;IAC7E;IAEA,MAAc,eAAA,CAAgB,EAAE,SAAA,EAAW,MAAA,EAAQ,GAAA,EAAI,EAA2D;QAChH,MAAM,eAAA,OAAkB,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAGlE,IAAI,CAAC,MAAA,IAAU,CAAC,GAAA,EAAK;YACnB,MAAM,IAAI,8KAAA,CAAY;gBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,WAAW,CAAA;gBAC/D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA,CAAU;gBACrB,IAAA,EAAM;YAAA,CACP,CAAA;QACH;QAEA,IAAI,UAAU,GAAA,EAAK;YACjB,MAAM,IAAI,8KAAA,CAAY;gBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,oBAAoB,CAAA;gBACxE,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA,CAAU;gBACrB,IAAA,EAAM;YAAA,CACP,CAAA;QACH;QAEA,IAAI,KAAA;QACJ,IAAI,MAAA;QAEJ,IAAI,GAAA,EAAK;YAEP,IAAI,GAAA,CAAI,MAAA,KAAW,CAAA,EAAG;gBACpB,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,WAAW,CAAA;oBAC/D,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;oBAAA,CAAU;oBACrB,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAEA,MAAM,eAAe,GAAA,CAAI,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA;YACjD,KAAA,GAAQ,CAAA,YAAA,EAAe,eAAe,CAAA,qBAAA,EAAwB,YAAY,CAAA,CAAA,CAAA;YAC1E,MAAA,GAAS,GAAA;QACX,CAAA,MAAO;YAGL,IAAI,CAAC,MAAA,IAAU,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CAAE,MAAA,KAAW,CAAA,EAAG;gBAC/C,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,cAAc,CAAA;oBAClE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;oBAAA,CAAU;oBACrB,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAEA,MAAM,gBAAA,GAAmB,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAA;YACpD,MAAM,EAAE,GAAA,EAAK,SAAA,EAAW,QAAQ,YAAA,EAAa,GAAI,iBAAiB,gBAAgB,CAAA;YAElF,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,IAAA,OAAW,EAAA,EAAI;gBACzC,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,gBAAgB,CAAA;oBACpE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;oBAAA,CAAU;oBACrB,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAIA,MAAM,mBAAA,GAAsB,UACzB,OAAA,CAAQ,eAAA,EAAiB,EAAE,CAAA,CAC3B,IAAA,GACA,WAAA,EAAY;YACf,MAAM,gBAAA,GAAmB;gBAAC,MAAA;gBAAQ,OAAA;gBAAS,KAAK;aAAA;YAEhD,IAAI,gBAAA,CAAiB,QAAA,CAAS,mBAAmB,CAAA,EAAG;gBAClD,MAAM,IAAI,8KAAA,CAAY;oBACpB,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,kBAAkB,CAAA;oBACtE,QAAQ,8KAAA,CAAY,OAAA;oBACpB,UAAU,gLAAA,CAAc,IAAA;oBACxB,OAAA,EAAS;wBAAE,SAAA;wBAAW,SAAA,EAAW,mBAAA;oBAAA,CAAoB;oBACrD,IAAA,EAAM;gBAAA,CACP,CAAA;YACH;YAGA,KAAA,GAAQ,CAAA,YAAA,EAAe,eAAe,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA;YACnD,MAAA,GAAS,YAAA;QACX;QAEA,IAAI;YACF,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;gBACvB,GAAA,EAAK,KAAA;gBACL,IAAA,EAAM;YAAA,CACP,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,QAAQ,CAAA;gBAC5D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,SAAA;oBACA,GAAI,MAAA,IAAU;wBAAE,QAAQ,IAAA,CAAK,SAAA,CAAU,MAAM,CAAA;oBAAA,CAAE;oBAC/C,GAAI,GAAA,IAAO;wBAAE,QAAA,EAAU,IAAI,MAAA;oBAAA,CAAA;gBAAO;YACpC,CACF,EACA;QAEJ;IACF;IAEO,cAAc,IAAA,EAAwC;QAC3D,IAAI;YACF,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,gBAAA,CAAiB,IAAI,CAAC,CAAA;QAC9E,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAI,8KAAA,CACR;gBACE,EAAA,MAAI,sLAAA,EAAoB,QAAA,EAAU,gBAAA,EAAkB,QAAQ,CAAA;gBAC5D,QAAQ,8KAAA,CAAY,OAAA;gBACpB,UAAU,gLAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA,EAAW,IAAA,CAAK,SAAA;gBAAA;YAAU,CACvC,EACA;QAEJ;IACF;IAEA,MAAc,gBAAA,CAAiB,EAAE,SAAA,EAAU,EAAqC;QAC9E,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ;YACvB,GAAA,EAAK,CAAA,YAAA,MAAe,qLAAA,EAAmB,SAAA,EAAW,YAAY,CAAC,CAAA,CAAA;YAC/D,MAAM,EAAA;QAAC,CACR,CAAA;IACH;AACF;AC1sBO,SAAS,mBAAmB,SAAA,EAAgC;IACjE,MAAM,MAAA,GAAS,gLAAA,CAAc,SAAS,CAAA;IACtC,OAAO,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CACtB,GAAA,CAAI,CAAA,GAAA,KAAO;QACV,MAAM,MAAA,GAAS,MAAA,CAAO,GAAG,CAAA;QACzB,MAAM,SAAA,OAAYC,qLAAAA,EAAmB,GAAA,EAAK,aAAa,CAAA;QACvD,OAAO,QAAQ,IAAA,KAAS,OAAA,GAAU,CAAA,KAAA,EAAQ,SAAS,CAAA,KAAA,EAAQ,SAAS,CAAA,CAAA,GAAK,SAAA;IAC3E,CAAC,CAAA,CACA,IAAA,CAAK,IAAI,CAAA;AACd;AAKO,SAAS,YAAY,KAAA,EAAqB;IAC/C,OACE,MAAM,IAAA,KAAS,aAAA,IACf,KAAA,CAAM,IAAA,KAAS,mBACf,KAAA,CAAM,OAAA,EAAS,WAAA,EAAY,CAAE,SAAS,oBAAoB,CAAA,IAC1D,KAAA,CAAM,OAAA,EAAS,aAAY,CAAE,QAAA,CAAS,0BAA0B,CAAA,IAChE,MAAM,OAAA,EAAS,WAAA,EAAY,CAAE,QAAA,CAAS,iBAAiB,CAAA,IACtD,KAAA,CAAM,WAAA,CAAY,IAAA,KAAS,iBAAiB,KAAA,CAAM,OAAA,EAAS,WAAA,EAAY,CAAE,SAAS,QAAQ,CAAA;AAE/F;AAEO,SAAS,oCAAA,CAAqC,EACnD,MAAA,EACA,UAAA,EACA,gBAAA,EACF,EAIG;IACD,OAAO,eAAe,8BAAA,CACpB,WAAA,EACA,oBAAA,EACY;QACZ,IAAI,QAAA,GAAW,CAAA;QACf,IAAI,OAAA,GAAU,gBAAA;QAEd,MAAO,WAAW,UAAA,CAAY;YAC5B,IAAI;gBACF,OAAO,MAAM,WAAA,EAAY;YAC3B,EAAA,OAAS,KAAA,EAAY;gBACnB,MAAA,CAAO,KAAA,CAAM,CAAA,4CAAA,EAA+C,oBAAoB,CAAA,CAAA,EAAI;oBAClF,SAAA,EAAW,MAAM,WAAA,CAAY,IAAA;oBAC7B,WAAW,KAAA,CAAM,IAAA;oBACjB,cAAc,KAAA,CAAM,OAAA;oBACpB,QAAA;oBACA;gBAAA,CACD,CAAA;gBAED,IAAI,WAAA,CAAY,KAAK,CAAA,EAAG;oBACtB,QAAA,EAAA;oBACA,IAAI,YAAY,UAAA,EAAY;wBAC1B,MAAA,CAAO,KAAA,CACL,CAAA,oCAAA,EAAuC,UAAU,CAAA,gCAAA,EAAmC,KAAA,CAAM,OAAO,CAAA,CAAA,EACjG;4BAAE,KAAA;4BAAO,QAAA;4BAAU,UAAA;wBAAA;wBAErB,MAAM,KAAA;oBACR;oBACA,MAAA,CAAO,IAAA,CACL,CAAA,qBAAA,EAAwB,QAAQ,CAAA,oCAAA,EAAuC,oBAAoB,CAAA,cAAA,EAAiB,OAAO,CAAA,KAAA,CAAA,EACnH;wBAAE,YAAA,EAAc,KAAA,CAAM,OAAA;wBAAS,QAAA;wBAAU;wBAAS,UAAA;oBAAA;oBAEpD,MAAM,IAAI,OAAA,CAAQ,CAAA,OAAA,GAAW,UAAA,CAAW,OAAA,EAAS,OAAO,CAAC,CAAA;oBACzD,OAAA,IAAW,CAAA;gBACb,CAAA,MAAO;oBACL,MAAA,CAAO,KAAA,CAAM,CAAA,mCAAA,EAAsC,oBAAoB,CAAA,cAAA,CAAA,EAAkB;wBAAE;oBAAA,CAAO,CAAA;oBAClG,MAAM,KAAA;gBACR;YACF;QACF;QAGA,MAAM,IAAI,KAAA,CAAM,CAAA,iDAAA,EAAoD,oBAAoB,CAAA,CAAE,CAAA;IAC5F,CAAA;AACF;AAEO,SAAS,gBAAA,CAAiB,EAAE,SAAA,EAAW,MAAA,EAAO,EAGnD;IACA,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;IAClE,MAAM,MAAA,GAAS,gLAAA,CAAc,SAAS,CAAA;IACtC,MAAM,WAAA,GAAc,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA;IACtC,MAAM,UAAU,WAAA,CAAY,GAAA,CAAI,CAAA,UAAOA,qLAAAA,EAAmB,GAAA,EAAK,aAAa,CAAC,CAAA;IAC7E,MAAM,MAAA,GAAS,WAAA,CAAY,GAAA,CAAI,CAAA,GAAA,KAAO;QACpC,MAAM,CAAA,GAAI,MAAA,CAAO,GAAG,CAAA;QACpB,IAAI,OAAO,CAAA,KAAM,CAAA,SAAA,CAAA,IAAe,CAAA,KAAM,IAAA,EAAM;YAE1C,OAAO,IAAA;QACT;QAGA,MAAM,MAAA,GAAS,MAAA,CAAO,GAAG,CAAA;QACzB,IAAI,MAAA,EAAQ,SAAS,OAAA,EAAS;YAC5B,OAAO,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;QACzB;QACA,IAAI,aAAa,IAAA,EAAM;YACrB,OAAO,EAAE,WAAA,EAAY;QACvB;QACA,OAAO,OAAO,CAAA,KAAM,QAAA,GAAW,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA,GAAI,CAAA;IACrD,CAAC,CAAA;IACD,MAAM,YAAA,GAAe,WAAA,CAClB,GAAA,CAAI,CAAA,GAAA,KAAO;QACV,MAAM,MAAA,GAAS,MAAA,CAAO,GAAG,CAAA;QACzB,OAAO,MAAA,EAAQ,IAAA,KAAS,OAAA,GAAU,UAAA,GAAa,GAAA;IACjD,CAAC,CAAA,CACA,IAAA,CAAK,IAAI,CAAA;IAEZ,OAAO;QACL,GAAA,EAAK,CAAA,uBAAA,EAA0B,eAAe,CAAA,EAAA,EAAK,QAAQ,IAAA,CAAK,IAAI,CAAC,CAAA,UAAA,EAAa,YAAY,CAAA,CAAA,CAAA;QAC9F,IAAA,EAAM;IAAA,CACR;AACF;AAEO,SAAS,sBAAA,CAAuB,EACrC,SAAA,EACA,OAAA,EACA,IAAA,EACF,EAOE;IACA,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;IAClE,MAAM,MAAA,GAAS,gLAAA,CAAc,SAAS,CAAA;IAGtC,MAAM,iBAAA,GAAoB,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA;IAC7C,MAAM,gBAAgB,iBAAA,CAAkB,GAAA,CAAI,CAAA,UAAOA,qLAAAA,EAAmB,GAAA,EAAK,aAAa,CAAC,CAAA;IACzF,MAAM,YAAA,GAAe,iBAAA,CAAkB,GAAA,CAAI,CAAA,GAAA,KAAO;QAChD,MAAM,MAAA,GAAS,MAAA,CAAO,GAAG,CAAA;QACzB,MAAM,CAAA,GAAI,OAAA,CAAQ,GAAG,CAAA;QAErB,IAAI,MAAA,EAAQ,SAAS,OAAA,EAAS;YAC5B,OAAO,mBAAA,CAAoB,GAAG,IAAI,CAAA;QACpC;QACA,OAAO,mBAAA,CAAoB,GAAG,KAAK,CAAA;IACrC,CAAC,CAAA;IACD,MAAM,SAAA,GAAY,aAAA,CACf,GAAA,CAAI,CAAC,KAAK,CAAA,KAAM;QACf,MAAM,MAAA,GAAS,MAAA,CAAO,iBAAA,CAAkB,CAAC,CAAE,CAAA;QAC3C,OAAO,QAAQ,IAAA,KAAS,OAAA,GAAU,GAAG,GAAG,CAAA,WAAA,CAAA,GAAgB,GAAG,GAAG,CAAA,IAAA,CAAA;IAChE,CAAC,CAAA,CACA,IAAA,CAAK,IAAI,CAAA;IAEZ,MAAM,WAAA,GAAc,kBAAA,CAAmB,IAAA,EAAM,MAAM,CAAA;IAEnD,OAAO;QACL,KAAK,CAAA,OAAA,EAAU,eAAe,CAAA,KAAA,EAAQ,SAAS,CAAA,EAAG,YAAY,GAAG,CAAA,CAAA;QACjE,MAAM,CAAC;eAAG,YAAA,EAAc;eAAG,YAAY,IAAI;SAAA;IAAA,CAC7C;AACF;AAEO,SAAS,mBAAA,CAAoB,KAAA,EAAY,kBAAA,GAA8B,KAAA,EAAgB;IAC5F,IAAI,OAAO,KAAA,KAAU,WAAA,IAAe,KAAA,KAAU,IAAA,EAAM;QAClD,OAAO,IAAA;IACT;IAGA,IAAI,kBAAA,EAAoB;QACtB,OAAO,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA;IAC7B;IACA,IAAI,iBAAiB,IAAA,EAAM;QACzB,OAAO,MAAM,WAAA,EAAY;IAC3B;IACA,OAAO,OAAO,KAAA,KAAU,QAAA,GAAW,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA,GAAI,KAAA;AAC7D;AAEO,SAAS,sBAAA,CAAuB,EAAE,SAAA,EAAW,IAAA,EAAK,EAGvD;IACA,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;IAClE,MAAM,WAAA,GAAc,kBAAA,CAAmB,IAAA,EAAM,gLAAA,CAAc,SAAS,CAAC,CAAA;IAErE,OAAO;QACL,GAAA,EAAK,CAAA,YAAA,EAAe,eAAe,CAAA,EAAG,YAAY,GAAG,CAAA,CAAA;QACrD,MAAM,WAAA,CAAY,IAAA;IAAA,CACpB;AACF;AAIO,SAAS,kBAAA,CACd,OAAA,EACA,MAAA,EAIA;IACA,MAAM,aAAuB,EAAC;IAC9B,MAAM,OAAkB,EAAC;IAEzB,KAAA,MAAW,CAAC,UAAA,EAAY,WAAW,CAAA,IAAK,MAAA,CAAO,OAAA,CAAQ,OAAO,CAAA,CAAG;QAC/D,MAAM,MAAA,GAAS,MAAA,CAAO,UAAU,CAAA;QAChC,IAAI,CAAC,MAAA,EAAQ;YACX,MAAM,IAAI,KAAA,CAAM,CAAA,gBAAA,EAAmB,UAAU,CAAA,CAAE,CAAA;QACjD;QAEA,MAAM,YAAA,OAAeA,qLAAAA,EAAmB,UAAA,EAAY,aAAa,CAAA;QACjE,MAAM,MAAA,GAASC,eAAAA,CAAe,YAAA,EAAc,WAAW,CAAA;QAEvD,UAAA,CAAW,IAAA,CAAK,OAAO,SAAS,CAAA;QAChC,IAAA,CAAK,IAAA,CAAK,GAAG,MAAA,CAAO,IAAI,CAAA;IAC1B;IAEA,OAAO;QACL,GAAA,EAAK,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,OAAA,EAAU,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;QACpE;IAAA,CACF;AACF;AAEA,SAASA,eAAAA,CAAe,UAAA,EAAoB,WAAA,EAAiE;IAE3G,IAAI,gBAAgB,IAAA,EAAM;QACxB,OAAO;YAAE,SAAA,EAAW,CAAA,EAAG,UAAU,CAAA,QAAA,CAAA;YAAY,IAAA,EAAM,EAAC;QAAA,CAAE;IACxD;IAGA,IAAI,OAAO,gBAAgB,QAAA,IAAY,WAAA,KAAgB,QAAA,CAAS,SAAA,IAAa,WAAA,IAAe,WAAW,WAAA,CAAA,EAAc;QACnH,OAAO,uBAAA,CAAwB,YAAY,WAAW,CAAA;IACxD;IAGA,OAAO;QACL,SAAA,EAAW,GAAG,UAAU,CAAA,IAAA,CAAA;QACxB,IAAA,EAAM;YAAC,mBAAA,CAAoB,WAAW,CAAC;SAAA;IAAA,CACzC;AACF;AAEA,SAAS,uBAAA,CACP,UAAA,EACA,KAAA,EACwC;IACxC,MAAM,aAAuB,EAAC;IAC9B,MAAM,OAAkB,EAAC;IAEzB,IAAI,KAAA,CAAM,OAAA,KAAY,KAAA,CAAA,EAAW;QAC/B,UAAA,CAAW,IAAA,CAAK,CAAA,EAAG,UAAU,CAAA,KAAA,CAAO,CAAA;QACpC,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAoB,KAAA,CAAM,OAAO,CAAC,CAAA;IAC9C;IAEA,IAAI,KAAA,CAAM,KAAA,KAAU,KAAA,CAAA,EAAW;QAC7B,UAAA,CAAW,IAAA,CAAK,CAAA,EAAG,UAAU,CAAA,KAAA,CAAO,CAAA;QACpC,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAoB,KAAA,CAAM,KAAK,CAAC,CAAA;IAC5C;IAEA,IAAI,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;QAC3B,MAAM,IAAI,MAAM,mDAAmD,CAAA;IACrE;IAEA,OAAO;QACL,SAAA,EAAW,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;QAClC;IAAA,CACF;AACF;AAMO,SAAS,mBAAA,CAAuB,EACrC,SAAA,EACA,MAAA,EACF,EAGM;IACJ,MAAM,SAA8B,CAAA,CAAC;IACrC,MAAM,cAAc,IAAI,GAAA,CACtB,OAAO,IAAA,CAAK,gLAAA,CAAc,SAAS,CAAC,CAAA,CACjC,MAAA,CAAO,CAAA,GAAA,GAAO,gLAAA,CAAc,SAAS,CAAA,CAAE,GAAG,CAAA,CAAG,IAAA,KAAS,OAAO,CAAA,CAC7D,GAAA,CAAI,CAAA,MAAO,GAAG;IAEnB,MAAM,cAAc,IAAI,GAAA,CACtB,OAAO,IAAA,CAAK,gLAAA,CAAc,SAAS,CAAC,CAAA,CACjC,MAAA,CAAO,CAAA,GAAA,GAAO,gLAAA,CAAc,SAAS,CAAA,CAAE,GAAG,CAAA,CAAG,IAAA,KAAS,WAAW,CAAA,CACjE,GAAA,CAAI,CAAA,MAAO,GAAG;IAGnB,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,CAAA,IAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,CAAG;QACjD,IAAI,KAAA,KAAU,IAAA,IAAQ,KAAA,KAAU,KAAA,CAAA,EAAW;YACzC,MAAA,CAAO,GAAG,CAAA,GAAI,KAAA;YACd;QACF;QAEA,IAAI,YAAY,GAAA,CAAI,GAAG,CAAA,IAAK,OAAO,UAAU,QAAA,EAAU;YACrD,MAAA,CAAO,GAAG,CAAA,GAAI,IAAI,IAAA,CAAK,KAAK,CAAA;YAC5B;QACF;QAEA,IAAI,YAAY,GAAA,CAAI,GAAG,CAAA,IAAK,OAAO,UAAU,QAAA,EAAU;YACrD,MAAA,CAAO,GAAG,CAAA,OAAI,kLAAA,EAAgB,KAAK,CAAA;YACnC;QACF;QAEA,MAAA,CAAO,GAAG,CAAA,GAAI,KAAA;IAChB;IAEA,OAAO,MAAA;AACT;;AC3QO,SAAS,cAAc,MAAA,EAAoC;IAChE,IAAI,YAAY,MAAA,EAAQ;QACtB,OAAO,MAAA,CAAO,MAAA;IAChB;IACA,WAAOC,6MAAAA,EAAa;QAClB,KAAK,MAAA,CAAO,GAAA;QACZ,GAAI,OAAO,SAAA,GAAY;YAAE,WAAW,MAAA,CAAO,SAAA;QAAA,IAAc,CAAA,CAAA;IAAC,CAC3D,CAAA;AACH;AAEO,IAAM,QAAA,GAAN,cAAuB,6KAAA,CAAW;IAC/B,MAAA,CAAA;IACR,UAAA,CAAA;IACA,gBAAA,CAAA;IACA,8BAAA,CAAA;IAEA,WAAA,CAAY,EACV,MAAA,EACA,UAAA,EACA,gBAAA,EACF,CAIG;QACD,KAAA,CAAM;YACJ,SAAA,EAAW,SAAA;YACX,IAAA,EAAM;QAAA,CACP,CAAA;QAED,IAAA,CAAK,MAAA,GAAS,MAAA;QACd,IAAA,CAAK,UAAA,GAAa,UAAA,IAAc,CAAA;QAChC,IAAA,CAAK,gBAAA,GAAmB,gBAAA,IAAoB,GAAA;QAE5C,IAAA,CAAK,8BAAA,GAAiC,oCAAA,CAAqC;YACzE,QAAQ,IAAA,CAAK,MAAA;YACb,YAAY,IAAA,CAAK,UAAA;YACjB,kBAAkB,IAAA,CAAK,gBAAA;QAAA,CACxB,CAAA;IACH;IAAA;;;;;;GAAA,GASA,MAAM,SAAA,CAAU,KAAA,EAAe,MAAA,EAAkC;QAC/D,MAAM,cAAA,OAAiBF,qLAAAA,EAAmB,KAAA,EAAO,YAAY,CAAA;QAC7D,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ;YACvC,GAAA,EAAK,CAAA,mBAAA,EAAsB,cAAc,CAAA,EAAA,CAAA;QAAA,CAC1C,CAAA;QACD,OAAO,OAAO,IAAA,EAAM,IAAA,CAAK,CAAC,GAAA,GAAa,GAAA,CAAI,IAAA,KAAS,MAAM,CAAA;IAC5D;IAAA;;GAAA,GAKA,MAAc,QAAA,CAAS,EACrB,SAAA,EACA,MAAA,EACF,EAGkB;QAChB,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAChB,gBAAA,CAAiB;YACf,SAAA;YACA;QAAA,CACD;IAEL;IAAA;;;;;;GAAA,GASO,OAAO,IAAA,EAA8E;QAC1F,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG,CAAA,kBAAA,EAAqB,IAAA,CAAK,SAAS,CAAA,CAAE,CAAA;IAC7G;IAAA;;GAAA,GAKA,MAAc,QAAA,CAAS,EACrB,SAAA,EACA,IAAA,EACA,IAAA,EACF,EAIkB;QAChB,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,sBAAA,CAAuB;YAAE;YAAW,OAAA,EAAS,IAAA;YAAM,IAAA;QAAA,CAAM,CAAC,CAAA;IACtF;IAAA;;;;;;;GAAA,GAUO,OAAO,IAAA,EAAuG;QACnH,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG,CAAA,aAAA,EAAgB,IAAA,CAAK,SAAS,CAAA,CAAE,CAAA;IACxG;IAAA;;GAAA,GAKA,MAAc,aAAA,CAAc,EAC1B,SAAA,EACA,OAAA,EACF,EAGkB;QAChB,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;QAC1B,MAAM,eAAA,GAAkB,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,GAAK,gBAAA,CAAiB;gBAAE,SAAA;gBAAW,MAAA,EAAQ,CAAA;YAAA,CAAG,CAAC,CAAA;QACnF,MAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,EAAiB,OAAO,CAAA;IAClD;IAAA;;;;;;;GAAA,GAUA,MAAa,YAAY,IAAA,EAAiF;QACxG,OAAO,IAAA,CAAK,8BAAA,CACV,IAAM,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,EAC7B,CAAA,wBAAA,EAA2B,KAAK,SAAS,CAAA,CAAA,EACzC,KAAA,CAAM,CAAA,KAAA,KAAS;YACf,MAAM,IAAIG,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,WAAW,IAAA,CAAK,SAAA;gBAAA;YAClB,CACF,EACA;QAEJ,CAAC,CAAA;IACH;IAAA;;;GAAA,GAMA,MAAc,aAAA,CAAc,EAC1B,SAAA,EACA,OAAA,EACF,EAMkB;QAChB,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;QAE1B,MAAM,kBAAkB,OAAA,CAAQ,GAAA,CAAI,CAAC,EAAE,IAAA,EAAM,IAAA,EAAA,GAC3C,sBAAA,CAAuB;gBACrB,SAAA;gBACA,OAAA,EAAS,IAAA;gBACT;YAAA,CACD;QAGH,MAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,EAAiB,OAAO,CAAA;IAClD;IAAA;;;;;;;;GAAA,GAWA,MAAa,YAAY,IAAA,EAMP;QAChB,OAAO,IAAA,CAAK,8BAAA,CACV,IAAM,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,EAC7B,CAAA,sBAAA,EAAyB,KAAK,SAAS,CAAA,CAAA,EACvC,KAAA,CAAM,CAAA,KAAA,KAAS;YACf,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,WAAW,IAAA,CAAK,SAAA;gBAAA;YAClB,CACF,EACA;QAEJ,CAAC,CAAA;IACH;IAAA;;;GAAA,GAMA,MAAc,aAAA,CAAc,EAC1B,SAAA,EACA,IAAA,EACF,EAGkB;QAChB,IAAI,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;QAEvB,MAAM,kBAAkB,IAAA,CAAK,GAAA,CAAI,CAAA,SAC/B,sBAAA,CAAuB;gBACrB,SAAA;gBACA,IAAA,EAAM;YAAA,CACP;QAGH,MAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,EAAiB,OAAO,CAAA;IAClD;IAAA;;;;;;;;GAAA,GAWA,MAAa,WAAA,CAAY,EACvB,SAAA,EACA,IAAA,EACF,EAGkB;QAChB,OAAO,IAAA,CAAK,8BAAA,CACV,IAAM,IAAA,CAAK,aAAA,CAAc;gBAAE,SAAA;gBAAW;YAAA,CAAM,CAAA,EAC5C,CAAA,wBAAA,EAA2B,SAAS,CAAA,CAAA,EACpC,KAAA,CAAM,CAAA,KAAA,KAAS;YACf,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP;gBAAA;YACF,CACF,EACA;QAEJ,CAAC,CAAA;IACH;IAAA;;GAAA,GAKA,MAAc,QAAA,CAAS,EAAE,SAAA,EAAW,IAAA,EAAK,EAAyE;QAChH,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,sBAAA,CAAuB;YAAE,SAAA;YAAW,IAAA;QAAA,CAAM,CAAC,CAAA;IACvE;IAAA;;;;;;;GAAA,GAUA,MAAa,OAAO,IAAA,EAA4E;QAC9F,OAAO,IAAA,CAAK,8BAAA,CAA+B,IAAM,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG,CAAA,kBAAA,EAAqB,IAAA,CAAK,SAAS,CAAA,CAAE,CAAA,CAAE,KAAA,CAC3G,CAAA,KAAA,KAAS;YACP,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,QAAA,EAAU,QAAQ,CAAA;gBACrD,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,WAAW,IAAA,CAAK,SAAA;gBAAA;YAClB,CACF,EACA;QAEJ;IAEJ;IAAA;;;;;;;;;;GAAA,GAaA,MAAM,MAAA,CAAU,EAAE,SAAA,EAAW,IAAA,EAAK,EAAgF;QAChH,MAAM,eAAA,OAAkBL,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,MAAM,OAAA,GAAU,mBAAmB,SAAS,CAAA;QAE5C,MAAM,UAAA,GAAa,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,CAAE,GAAA,CAAI,CAAA,GAAA,OAAOA,qLAAAA,EAAmB,GAAA,EAAK,aAAa,CAAC,CAAA;QAEtF,MAAM,UAAA,GAAa,WAAW,GAAA,CAAI,CAAA,GAAA,GAAO,GAAG,GAAG,CAAA,IAAA,CAAM,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;QACnE,MAAM,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;QAEjC,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ;YACvC,KAAK,CAAA,OAAA,EAAU,OAAO,CAAA,MAAA,EAAS,eAAe,CAAA,OAAA,EAAU,UAAU,CAAA,gCAAA,CAAA;YAClE,IAAA,EAAM;QAAA,CACP,CAAA;QAED,IAAI,CAAC,MAAA,CAAO,IAAA,IAAQ,MAAA,CAAO,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;YAC5C,OAAO,IAAA;QACT;QAEA,MAAM,GAAA,GAAM,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA;QAIzB,MAAM,SAAS,MAAA,CAAO,WAAA,CACpB,MAAA,CAAO,OAAA,CAAQ,GAAA,IAAO,CAAA,CAAE,CAAA,CAAE,GAAA,CAAI,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,KAAM;YACxC,IAAI;gBACF,OAAO;oBAAC,CAAA;oBAAG,OAAO,MAAM,QAAA,GAAY,CAAA,CAAE,UAAA,CAAW,GAAG,CAAA,IAAK,CAAA,CAAE,UAAA,CAAW,GAAG,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,GAAI,IAAK,CAAC;iBAAA;YACrG,CAAA,CAAA,OAAQ;gBACN,OAAO;oBAAC;oBAAG,CAAC;iBAAA;YACd;QACF,CAAC;QAGH,OAAO,MAAA;IACT;IAAA;;;;;;;;;;;;GAAA,GAeA,MAAM,UAAA,CAAc,EAClB,SAAA,EACA,WAAA,EACA,OAAA,EACA,MAAA,EACA,KAAA,EACA,IAAA,EACF,EAOiB;QACf,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,MAAM,OAAA,GAAU,mBAAmB,SAAS,CAAA;QAE5C,IAAI,SAAA,GAAY,CAAA,OAAA,EAAU,OAAO,CAAA,MAAA,EAAS,eAAe,CAAA,CAAA;QAEzD,IAAI,aAAa,GAAA,EAAK;YACpB,SAAA,IAAa,CAAA,CAAA,EAAI,YAAY,GAAG,CAAA,CAAA;QAClC;QAEA,IAAI,OAAA,EAAS;YACX,SAAA,IAAa,CAAA,UAAA,EAAa,OAAO,CAAA,CAAA;QACnC;QAEA,IAAI,KAAA,EAAO;YACT,SAAA,IAAa,CAAA,OAAA,EAAU,KAAK,CAAA,CAAA;QAC9B;QAEA,IAAI,MAAA,EAAQ;YACV,SAAA,IAAa,CAAA,QAAA,EAAW,MAAM,CAAA,CAAA;QAChC;QAEA,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ;YACvC,GAAA,EAAK,SAAA;YACL,IAAA,EAAM,CAAC;mBAAI,WAAA,EAAa,IAAA,IAAQ,EAAC,EAAI;mBAAI,IAAA,IAAQ,EAAG;aAAA;QAAA,CACrD,CAAA;QAGD,OAAA,CAAQ,MAAA,CAAO,IAAA,IAAQ,EAAC,EAAG,GAAA,CAAI,CAAA,GAAA,KAAO;YACpC,OAAO,MAAA,CAAO,WAAA,CACZ,MAAA,CAAO,OAAA,CAAQ,GAAA,IAAO,CAAA,CAAE,CAAA,CAAE,GAAA,CAAI,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,KAAM;gBACxC,IAAI;oBACF,OAAO;wBAAC,CAAA;wBAAG,OAAO,MAAM,QAAA,GAAY,CAAA,CAAE,UAAA,CAAW,GAAG,CAAA,IAAK,CAAA,CAAE,UAAA,CAAW,GAAG,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,GAAI,IAAK,CAAC;qBAAA;gBACrG,CAAA,CAAA,OAAQ;oBACN,OAAO;wBAAC;wBAAG,CAAC;qBAAA;gBACd;YACF,CAAC;QAEL,CAAC,CAAA;IACH;IAAA;;;;;;;GAAA,GAUA,MAAM,gBAAA,CAAiB,EACrB,SAAA,EACA,WAAA,EACF,EAGoB;QAClB,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAElE,MAAM,SAAA,GAAY,CAAA,8BAAA,EAAiC,eAAe,CAAA,CAAA,EAAI,cAAc,CAAA,EAAG,WAAA,CAAY,GAAG,CAAA,CAAA,GAAK,EAAE,CAAA,CAAA;QAE7G,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ;YACvC,GAAA,EAAK,SAAA;YACL,IAAA,EAAM,WAAA,EAAa,IAAA,IAAQ,EAAA;QAAC,CAC7B,CAAA;QAED,IAAI,CAAC,MAAA,CAAO,IAAA,IAAQ,MAAA,CAAO,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;YAC5C,OAAO,CAAA;QACT;QAEA,OAAQ,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,EAAG,KAAA,IAAoB,CAAA;IAC9C;IAAA;;GAAA,GAMU,WAAW,IAAA,EAAqC;QACxD,OAAQ,IAAA;YACN,KAAK,QAAA;gBACH,OAAO,SAAA;YAAA,4CAAA;YACT,KAAK,WAAA;gBACH,OAAO,MAAA;YAAA,4CAAA;YACT,KAAK,OAAA;gBACH,OAAO,MAAA;YAAA,+BAAA;YACT,KAAK,SAAA;gBACH,OAAO,SAAA;YAAA,+BAAA;YACT,KAAK,OAAA;gBACH,OAAO,MAAA;YAAA,sFAAA;YACT;gBACE,WAAO,6KAAA,EAAW,IAAI,CAAA;QAAA;IAE5B;IAAA;;;;;;GAAA,GASA,MAAM,WAAA,CAAY,EAChB,SAAA,EACA,MAAA,EACF,EAGkB;QAChB,IAAI;YACF,MAAM,eAAA,OAAkBA,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;YAGlE,MAAM,iBAAA,GAAoB,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,CAAE,GAAA,CAAI,CAAC,CAAC,OAAA,EAAS,MAAM,CAAA,KAAM;gBAC1E,MAAM,IAAA,GAAO,IAAA,CAAK,UAAA,CAAW,MAAA,CAAO,IAAI,CAAA;gBACxC,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA,KAAa,KAAA,GAAQ,UAAA,GAAa,EAAA;gBAC1D,MAAM,UAAA,GAAa,MAAA,CAAO,UAAA,GAAa,aAAA,GAAgB,EAAA;gBACvD,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,EAAA,EAAK,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAG,IAAA,EAAK;YAC/D,CAAC,CAAA;YAGD,MAAM,mBAA6B,EAAC;YACpC,IAAI,cAAc,0LAAA,EAAyB;gBACzC,gBAAA,CAAiB,IAAA,CAAK,gCAAgC,CAAA;YACxD;YAEA,MAAM,cAAA,GAAiB,CAAC;mBAAG,iBAAA,EAAmB;mBAAG,gBAAgB;aAAA,CAAE,IAAA,CAAK,OAAO,CAAA;YAE/E,MAAM,GAAA,GAAM,CAAA,2BAAA,EAA8B,eAAe,CAAA;EAAA,EAAS,cAAc,CAAA;CAAA,CAAA;YAEhF,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,GAAG,CAAA;YAC7B,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,CAAA,wBAAA,EAA2B,SAAS,CAAA,CAAE,CAAA;YAGxD,IAAI,cAAc,8KAAA,EAAa;gBAC7B,MAAM,IAAA,CAAK,iBAAA,EAAkB;YAC/B;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIG,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA;YAAU,CACvB,EACA;QAEJ;IACF;IAAA;;;GAAA,GAMA,MAAc,iBAAA,GAAmC;QAC/C,MAAM,MAAA,GAASC,gLAAAA,CAAc,8KAAW,CAAA;QAExC,IAAI;YAEF,KAAA,MAAW,CAAC,UAAA,EAAY,SAAS,CAAA,IAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,CAAG;gBAC5D,MAAM,YAAA,GAAe,MAAM,IAAA,CAAK,SAAA,CAAU,8KAAA,EAAa,UAAU,CAAA;gBACjE,IAAI,CAAC,YAAA,EAAc;oBACjB,MAAM,OAAA,GAAU,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,IAAI,CAAA;oBAE9C,MAAM,WAAW,CAAA,aAAA,EAAgB,8KAAW,CAAA,cAAA,EAAiB,UAAU,CAAA,EAAA,EAAK,OAAO,CAAA,CAAA;oBACnF,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,QAAQ,CAAA;oBAClC,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,CAAA,wBAAA,EAA2B,UAAU,CAAA,KAAA,EAAQ,8KAAW,CAAA,CAAE,CAAA;gBAC9E;YACF;YAEA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,kCAAA,EAAqC,8KAAW,CAAA,CAAE,CAAA;QACrE,EAAA,OAAS,KAAA,EAAO;YAEd,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,wCAAA,EAA2C,8KAAW,CAAA,CAAA,CAAA,EAAK,KAAK,CAAA;QACnF;IACF;IAAA;;GAAA,GAKQ,gBAAgB,IAAA,EAAqC;QAC3D,OAAQ,IAAA;YACN,KAAK,MAAA;YACL,KAAK,MAAA;gBACH,OAAO,YAAA;YACT,KAAK,SAAA;YACL,KAAK,QAAA;YACL,KAAK,OAAA;gBACH,OAAO,WAAA;YACT,KAAK,SAAA;gBACH,OAAO,WAAA;YACT,KAAK,OAAA;gBACH,OAAO,cAAA;YACT,KAAK,WAAA;gBACH,OAAO,2BAAA;YACT;gBACE,OAAO,YAAA;QAAA;IAEb;IAAA;;;;;;;;GAAA,GAWA,MAAM,UAAA,CAAW,EACf,SAAA,EACA,MAAA,EACA,WAAA,EACF,EAIkB;QAChB,MAAM,eAAA,OAAkBN,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAElE,IAAI;YAEF,MAAM,SAAA,GAAY,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ;gBAC1C,GAAA,EAAK,CAAA,mBAAA,EAAsB,eAAe,CAAA,EAAA,CAAA;YAAA,CAC3C,CAAA;YACD,MAAM,eAAA,GAAkB,IAAI,GAAA,CAAA,CAAK,SAAA,CAAU,IAAA,IAAQ,EAAC,EAAG,GAAA,CAAI,CAAC,GAAA,GAAa,GAAA,CAAI,IAAA,EAAM,WAAA,EAAa,CAAC,CAAA;YAGjG,KAAA,MAAW,cAAc,WAAA,CAAa;gBACpC,IAAI,CAAC,gBAAgB,GAAA,CAAI,UAAA,CAAW,WAAA,EAAa,CAAA,IAAK,MAAA,CAAO,UAAU,CAAA,EAAG;oBACxE,MAAM,SAAA,GAAY,MAAA,CAAO,UAAU,CAAA;oBACnC,MAAM,OAAA,GAAU,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,IAAI,CAAA;oBAC9C,MAAM,YAAA,GAAe,IAAA,CAAK,eAAA,CAAgB,SAAA,CAAU,IAAI,CAAA;oBAGxD,MAAM,QAAA,GAAW,CAAA,YAAA,EAAe,eAAe,CAAA,aAAA,EAAgB,UAAU,CAAA,EAAA,EAAK,OAAO,CAAA,CAAA,EAAI,YAAY,CAAA,CAAA;oBACrG,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,QAAQ,CAAA;oBAClC,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,CAAA,uBAAA,EAA0B,UAAU,CAAA,UAAA,EAAa,SAAS,CAAA,CAAE,CAAA;gBAChF;YACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIG,8KAAAA,CACR;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,SAAA;gBAAA;YAAU,CACvB,EACA;QAEJ;IACF;IAAA;;;;;;GAAA,GASA,MAAM,UAAA,CAAW,EAAE,SAAA,EAAU,EAA8C;QACzE,MAAM,eAAA,OAAkBL,qLAAAA,EAAmB,SAAA,EAAW,YAAY,CAAA;QAClE,IAAI;YACF,MAAM,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,CAAA,YAAA,EAAe,eAAe,CAAA,CAAE,CAAA;QAC5D,EAAA,OAAS,CAAA,EAAG;YACV,MAAM,cAAc,IAAIG,8KAAAA,CACtB;gBACE,EAAA,MAAI,uLAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQC,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP;gBAAA;YACF,CACF,EACA;YAEF,IAAA,CAAK,MAAA,EAAQ,iBAAiB,WAAW,CAAA;YACzC,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,WAAA,CAAY,QAAA,EAAU,CAAA;QAC7C;IACF;AACF,CAAA;;ACzrBO,IAAM,YAAA,GAAN,cAA2B,gLAAA,CAAc;KAC9C,EAAA,CAAA;IAEA,YAAY,MAAA,CAA4B;QACtC,KAAA,EAAM;QACN,MAAM,MAAA,GAAS,cAAc,MAAM,CAAA;QACnC,IAAA,EAAK,EAAA,GAAM,IAAI,QAAA,CAAS;YAAE,MAAA;YAAQ,UAAA,EAAY,MAAA,CAAO,UAAA;YAAY,gBAAA,EAAkB,MAAA,CAAO,gBAAA;QAAA,CAAkB,CAAA;IAC9G;IAEA,MAAM,IAAA,GAAsB;QAC1B,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,WAAW,+KAAA;YAAc,MAAA,EAAQ,gLAAA;QAAA,CAAe,CAAA;IAC/E;IAEA,MAAM,mBAAA,GAAqC;QACzC,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAW,+KAAA;QAAA,CAAc,CAAA;IACvD;IAEQ,SAAA,CAAU,KAAA,EAAY,SAAA,EAAyB;QACrD,IAAI,CAAC,OAAO,OAAO,KAAA,CAAA;QACnB,IAAI,OAAO,KAAA,KAAU,QAAA,EAAU,OAAO,KAAA;QAEtC,IAAI;YACF,OAAO,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;QACzB,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,OAAA,GAAkC;gBACtC,KAAA,EAAO,MAAM,MAAA,GAAS,GAAA,GAAM,MAAM,SAAA,CAAU,CAAA,EAAG,GAAG,CAAA,GAAI,KAAA,GAAQ;YAAA,CAChE;YACA,IAAI,SAAA,EAAW;gBACb,OAAA,CAAQ,KAAA,GAAQ,SAAA;YAClB;YAEA,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,YAAA,EAAc,cAAc,CAAA;gBAC/D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,MAAA;gBACxB,IAAA,EAAM,CAAA,oBAAA,EAAuB,SAAA,GAAY,CAAA,YAAA,EAAe,SAAS,CAAA,CAAA,CAAA,GAAM,EAAE,CAAA,EAAA,EAAK,KAAA,YAAiB,KAAA,GAAQ,KAAA,CAAM,OAAA,GAAU,eAAe,CAAA,CAAA;gBACtI;YAAA,CACF,EACA;QAEJ;IACF;IAEQ,SAAS,GAAA,EAA4B;QAC3C,OAAO;YACL,IAAI,GAAA,CAAI,EAAA;YACR,MAAM,GAAA,CAAI,IAAA;YACV,aAAa,GAAA,CAAI,WAAA;YACjB,cAAc,GAAA,CAAI,YAAA;YAClB,KAAA,EAAO,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,KAAA,EAAO,OAAO,CAAA;YACxC,KAAA,EAAO,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,KAAA,EAAO,OAAO,CAAA;YACxC,cAAA,EAAgB,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,cAAA,EAAgB,gBAAgB,CAAA;YACnE,SAAA,EAAW,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,SAAA,EAAW,WAAW,CAAA;YACpD,MAAA,EAAQ,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,MAAA,EAAQ,QAAQ,CAAA;YAC3C,eAAA,EAAiB,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,eAAA,EAAiB,iBAAiB,CAAA;YACtE,gBAAA,EAAkB,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,gBAAA,EAAkB,kBAAkB,CAAA;YACzE,MAAA,EAAQ,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,MAAA,EAAQ,QAAQ,CAAA;YAC3C,OAAA,EAAS,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,OAAA,EAAS,SAAS,CAAA;YAC9C,QAAA,EAAU,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,QAAA,EAAU,UAAU,CAAA;YACjD,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB,CAAA;YAC3C,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB;QAAA,CAC7C;IACF;IAEA,MAAM,YAAA,CAAa,EAAE,EAAA,EAAG,EAAqD;QAC3E,IAAI;YACF,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAA4B;gBACxD,SAAA,EAAW,+KAAA;gBACX,IAAA,EAAM;oBAAE,EAAA;gBAAA;YAAG,CACZ,CAAA;YAED,OAAO,MAAA,GAAS,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA,GAAI,IAAA;QAC1C,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,iBAAA,EAAmB,QAAQ,CAAA;gBAC9D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA,EAAS,EAAA;gBAAA;YAAG,CACzB,EACA;QAEJ;IACF;IAEA,MAAM,WAAA,CAAY,EAAE,KAAA,EAAM,EAAkE;QAC1F,IAAI;YACF,MAAM,GAAA,GAAA,aAAA,GAAA,IAAU,IAAA,EAAK;YAErB,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBACpB,SAAA,EAAW,+KAAA;gBACX,MAAA,EAAQ;oBACN,IAAI,KAAA,CAAM,EAAA;oBACV,MAAM,KAAA,CAAM,IAAA;oBACZ,WAAA,EAAa,MAAM,WAAA,IAAe,IAAA;oBAClC,cAAc,KAAA,CAAM,YAAA;oBACpB,OAAO,KAAA,CAAM,KAAA;oBACb,KAAA,EAAO,MAAM,KAAA,IAAS,IAAA;oBACtB,cAAA,EAAgB,MAAM,cAAA,IAAkB,IAAA;oBACxC,SAAA,EAAW,MAAM,SAAA,IAAa,IAAA;oBAC9B,MAAA,EAAQ,MAAM,MAAA,IAAU,IAAA;oBACxB,eAAA,EAAiB,MAAM,eAAA,IAAmB,IAAA;oBAC1C,gBAAA,EAAkB,MAAM,gBAAA,IAAoB,IAAA;oBAC5C,MAAA,EAAQ,MAAM,MAAA,IAAU,IAAA;oBACxB,OAAA,EAAS,MAAM,OAAA,IAAW,IAAA;oBAC1B,QAAA,EAAU,MAAM,QAAA,IAAY,IAAA;oBAC5B,SAAA,EAAW,GAAA;oBACX,SAAA,EAAW;gBAAA;YACb,CACD,CAAA;YAED,OAAO;gBACL,GAAG,KAAA;gBACH,SAAA,EAAW,GAAA;gBACX,SAAA,EAAW;YAAA,CACb;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA,EAAS,KAAA,CAAM,EAAA;gBAAA;YAAG,CAC/B,EACA;QAEJ;IACF;IAEA,MAAM,WAAA,CAAY,EAAE,EAAA,EAAI,GAAG,SAAQ,EAAuD;QACxF,IAAI;YAEF,MAAM,gBAAgB,MAAM,IAAA,CAAK,YAAA,CAAa;gBAAE;YAAA,CAAI,CAAA;YACpD,IAAI,CAAC,aAAA,EAAe;gBAClB,MAAM,IAAIF,8KAAAA,CAAY;oBACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,WAAW,CAAA;oBAC9D,QAAQH,8KAAAA,CAAY,OAAA;oBACpB,UAAUC,gLAAAA,CAAc,IAAA;oBACxB,IAAA,EAAM,CAAA,MAAA,EAAS,EAAE,CAAA,UAAA,CAAA;oBACjB,OAAA,EAAS;wBAAE,OAAA,EAAS,EAAA;oBAAA;gBAAG,CACxB,CAAA;YACH;YAGA,MAAM,IAAA,GAA4B;gBAChC,SAAA,EAAA,aAAA,GAAA,IAAe,IAAA;YAAK,CACtB;YAEA,IAAI,OAAA,CAAQ,IAAA,KAAS,KAAA,CAAA,EAAW,IAAA,CAAK,IAAA,GAAO,OAAA,CAAQ,IAAA;YACpD,IAAI,OAAA,CAAQ,WAAA,KAAgB,KAAA,CAAA,EAAW,IAAA,CAAK,WAAA,GAAc,OAAA,CAAQ,WAAA;YAClE,IAAI,OAAA,CAAQ,YAAA,KAAiB,KAAA,CAAA,EAAW,IAAA,CAAK,YAAA,GAAe,OAAA,CAAQ,YAAA;YACpE,IAAI,OAAA,CAAQ,KAAA,KAAU,KAAA,CAAA,EAAW,IAAA,CAAK,KAAA,GAAQ,OAAA,CAAQ,KAAA;YACtD,IAAI,OAAA,CAAQ,KAAA,KAAU,KAAA,CAAA,EAAW,IAAA,CAAK,KAAA,GAAQ,OAAA,CAAQ,KAAA;YACtD,IAAI,OAAA,CAAQ,cAAA,KAAmB,KAAA,CAAA,EAAW,IAAA,CAAK,cAAA,GAAiB,OAAA,CAAQ,cAAA;YACxE,IAAI,OAAA,CAAQ,SAAA,KAAc,KAAA,CAAA,EAAW,IAAA,CAAK,SAAA,GAAY,OAAA,CAAQ,SAAA;YAC9D,IAAI,OAAA,CAAQ,MAAA,KAAW,KAAA,CAAA,EAAW,IAAA,CAAK,MAAA,GAAS,OAAA,CAAQ,MAAA;YACxD,IAAI,OAAA,CAAQ,eAAA,KAAoB,KAAA,CAAA,EAAW,IAAA,CAAK,eAAA,GAAkB,OAAA,CAAQ,eAAA;YAC1E,IAAI,OAAA,CAAQ,gBAAA,KAAqB,KAAA,CAAA,EAAW,IAAA,CAAK,gBAAA,GAAmB,OAAA,CAAQ,gBAAA;YAC5E,IAAI,OAAA,CAAQ,MAAA,KAAW,KAAA,CAAA,EAAW,IAAA,CAAK,MAAA,GAAS,OAAA,CAAQ,MAAA;YACxD,IAAI,OAAA,CAAQ,OAAA,KAAY,KAAA,CAAA,EAAW,IAAA,CAAK,OAAA,GAAU,OAAA,CAAQ,OAAA;YAC1D,IAAI,OAAA,CAAQ,QAAA,KAAa,KAAA,CAAA,EAAW;gBAElC,IAAA,CAAK,QAAA,GAAW;oBAAE,GAAG,cAAc,QAAA;oBAAU,GAAG,QAAQ,QAAA;gBAAA,CAAS;YACnE;YAGA,IAAI,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,CAAE,MAAA,GAAS,CAAA,EAAG;gBAChC,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;oBACpB,SAAA,EAAW,+KAAA;oBACX,IAAA,EAAM;wBAAE,EAAA;oBAAA,CAAG;oBACX;gBAAA,CACD,CAAA;YACH;YAGA,MAAM,eAAe,MAAM,IAAA,CAAK,YAAA,CAAa;gBAAE;YAAA,CAAI,CAAA;YACnD,IAAI,CAAC,YAAA,EAAc;gBACjB,MAAM,IAAIF,8KAAAA,CAAY;oBACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,wBAAwB,CAAA;oBAC3E,QAAQH,8KAAAA,CAAY,OAAA;oBACpB,UAAUC,gLAAAA,CAAc,MAAA;oBACxB,IAAA,EAAM,CAAA,MAAA,EAAS,EAAE,CAAA,uBAAA,CAAA;oBACjB,OAAA,EAAS;wBAAE,OAAA,EAAS,EAAA;oBAAA;gBAAG,CACxB,CAAA;YACH;YAEA,OAAO,YAAA;QACT,EAAA,OAAS,KAAA,EAAO;YACd,IAAI,iBAAiBF,8KAAAA,EAAa;gBAChC,MAAM,KAAA;YACR;YACA,MAAM,IAAIA,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA,EAAS,EAAA;gBAAA;YAAG,CACzB,EACA;QAEJ;IACF;IAEA,MAAM,WAAA,CAAY,EAAE,EAAA,EAAG,EAAkC;QACvD,IAAI;YACF,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBACpB,SAAA,EAAW,+KAAA;gBACX,IAAA,EAAM;oBAAE,EAAA;gBAAA;YAAG,CACZ,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA,EAAS,EAAA;gBAAA;YAAG,CACzB,EACA;QAEJ;IACF;IAEA,MAAM,WAAW,IAAA,EAAiE;QAChF,MAAM,EAAE,OAAO,CAAA,EAAG,OAAA,EAAS,YAAA,EAAc,OAAA,EAAQ,GAAI,QAAQ,CAAA,CAAC;QAC9D,MAAM,EAAE,KAAA,EAAO,SAAA,EAAU,GAAI,IAAA,CAAK,YAAA,CAAa,OAAO,CAAA;QAEtD,IAAI,OAAO,CAAA,EAAG;YACZ,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,cAAc,CAAA;gBAChE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,IAAA;gBAAA;YAAK,CAClB,EACA,IAAI,MAAM,mBAAmB;QAEjC;QAEA,MAAM,OAAA,OAAU,mLAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;QAClD,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,kBAAA,EAAA,OAAuB,sLAAA,EAAoB,IAAA,EAAM,cAAc,OAAO,CAAA;QAE/F,IAAI;YAEF,MAAM,KAAA,GAAQ,MAAM,IAAA,EAAK,EAAA,CAAI,gBAAA,CAAiB;gBAAE,SAAA,EAAW,+KAAA;YAAA,CAAc,CAAA;YAEzE,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,QAAQ,EAAC;oBACT,KAAA,EAAO,CAAA;oBACP,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,OAAA,EAAS;gBAAA,CACX;YACF;YAGA,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,IAAA,GAAO,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAgC;gBAC1D,SAAA,EAAW,+KAAA;gBACX,OAAA,EAAS,CAAA,CAAA,EAAI,KAAK,CAAA,EAAA,EAAK,SAAS,CAAA,CAAA;gBAChC,KAAA,EAAO,UAAA;gBACP;YAAA,CACD,CAAA;YAED,MAAM,SAAS,IAAA,CAAK,GAAA,CAAI,CAAA,MAAO,IAAA,CAAK,QAAA,CAAS,GAAG,CAAC,CAAA;YAEjD,OAAO;gBACL,MAAA;gBACA,KAAA;gBACA,IAAA;gBACA,OAAA,EAAS,kBAAA;gBACT,OAAA,EAAS,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,SAAS,OAAA,GAAU;YAAA,CAC/D;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;AACF;AClRO,IAAM,YAAA,GAAN,cAA2B,gLAAA,CAAc;KAC9C,MAAA,CAAA;KACA,EAAA,CAAA;IAEA,YAAY,MAAA,CAA4B;QACtC,KAAA,EAAM;QACN,MAAM,MAAA,GAAS,cAAc,MAAM,CAAA;QACnC,IAAA,EAAK,MAAA,GAAU,MAAA;QACf,IAAA,EAAK,EAAA,GAAM,IAAI,QAAA,CAAS;YAAE,MAAA;YAAQ,UAAA,EAAY,MAAA,CAAO,UAAA;YAAY,gBAAA,EAAkB,MAAA,CAAO,gBAAA;QAAA,CAAkB,CAAA;IAC9G;IAEA,MAAM,IAAA,GAAsB;QAC1B,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,SAAA,EAAW,gLAAA;YAAe,MAAA,EAAQC,gLAAAA,CAAc,gLAAa,CAAA;QAAA,CAAG,CAAA;QAC7F,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,SAAA,EAAW,iLAAA;YAAgB,MAAA,EAAQA,gLAAAA,CAAc,iLAAc,CAAA;QAAA,CAAG,CAAA;QAC/F,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,SAAA,EAAW,kLAAA;YAAiB,MAAA,EAAQA,gLAAAA,CAAc,kLAAe,CAAA;QAAA,CAAG,CAAA;QAEjG,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YACxB,SAAA,EAAW,iLAAA;YACX,MAAA,EAAQA,gLAAAA,CAAc,iLAAc,CAAA;YACpC,WAAA,EAAa;gBAAC,YAAY;aAAA;QAAA,CAC3B,CAAA;IACH;IAEA,MAAM,mBAAA,GAAqC;QACzC,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAW,iLAAA;QAAA,CAAgB,CAAA;QACvD,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAW,gLAAA;QAAA,CAAe,CAAA;QACtD,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAW,kLAAA;QAAA,CAAiB,CAAA;IAC1D;IAEQ,SAAS,GAAA,EAA2B;QAC1C,IAAI,UAAU,GAAA,CAAI,OAAA;QAClB,IAAI;YACF,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,OAAO,CAAA;QAClC,CAAA,CAAA,OAAQ,CAER;QACA,MAAM,MAAA,GAAS;YACb,IAAI,GAAA,CAAI,EAAA;YACR,OAAA;YACA,MAAM,GAAA,CAAI,IAAA;YACV,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB,CAAA;YAC3C,UAAU,GAAA,CAAI,SAAA;YACd,YAAY,GAAA,CAAI,UAAA;QAAA,CAClB;QACA,IAAI,IAAI,IAAA,IAAQ,GAAA,CAAI,IAAA,KAAS,CAAA,EAAA,CAAA,EAAM,MAAA,CAAO,IAAA,GAAO,GAAA,CAAI,IAAA;QACrD,OAAO,MAAA;IACT;IAEA,MAAc,oBAAA,CAAqB,EAAE,OAAA,EAAQ,EAAqD;QAChG,IAAI,CAAC,OAAA,IAAW,OAAA,CAAQ,MAAA,KAAW,GAAG,OAAO,IAAA;QAE7C,MAAM,eAAyB,EAAC;QAChC,MAAM,SAAgB,EAAC;QAEvB,KAAA,MAAW,OAAO,OAAA,CAAS;YACzB,MAAM,EAAE,EAAA,EAAI,oBAAA,GAAuB,CAAA,EAAG,gBAAA,GAAmB,CAAA,EAAE,GAAI,GAAA;YAE/D,YAAA,CAAa,IAAA,CACX,CAAA;;;2CAAA,EAGqC,iLAAc,CAAA;;;;;;0BAAA,EAM/B,iLAAc,CAAA;;;;;;;;;;;;;gBAAA,CAAA;YAepC,MAAA,CAAO,IAAA,CAAK,EAAA,EAAI,EAAA,EAAI,oBAAA,EAAsB,gBAAgB,CAAA;QAC5D;QACA,MAAM,UAAA,GAAa,YAAA,CAAa,IAAA,CAAK,aAAa,CAAA,GAAI,2BAAA;QACtD,MAAM,cAAA,GAAiB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;YAAE,GAAA,EAAK,UAAA;YAAY,IAAA,EAAM,MAAA;QAAA,CAAQ,CAAA;QACnF,MAAM,YAAA,GAAe,eAAe,IAAA,EAAM,GAAA,CAAI,CAAA,MAAO,IAAA,CAAK,QAAA,CAAS,GAAG,CAAC,CAAA;QACvE,MAAM,IAAA,GAAA,aAAA,GAAA,IAAW,GAAA,EAAY;QAC7B,MAAM,WAAA,GAAc,YAAA,CAAa,MAAA,CAAO,CAAA,GAAA,KAAO;YAC7C,IAAI,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,EAAE,GAAG,OAAO,KAAA;YAC7B,IAAA,CAAK,GAAA,CAAI,IAAI,EAAE,CAAA;YACf,OAAO,IAAA;QACT,CAAC,CAAA;QACD,OAAO,WAAA;IACT;IAEA,MAAa,gBAAA,CAAiB,EAAE,UAAA,EAAW,EAAuE;QAChH,IAAI,WAAW,MAAA,KAAW,CAAA,EAAA,OAAU;YAAE,QAAA,EAAU,EAAC;QAAA,CAAE;QAEnD,IAAI;YACF,MAAM,GAAA,GAAM,CAAA;;;;;;;;;cAAA,EASF,iLAAc,CAAA;qBAAA,EACP,WAAW,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;;MAAA,CAAA;YAGrD,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAAE,GAAA;gBAAK,IAAA,EAAM,UAAA;YAAA,CAAY,CAAA;YACnE,IAAI,CAAC,MAAA,CAAO,IAAA,EAAA,OAAa;gBAAE,QAAA,EAAU,EAAC;YAAA,CAAE;YAExC,MAAM,IAAA,GAAO,IAAI,8KAAA,EAAY,CAAE,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,QAAQ,CAAA,EAAG,QAAQ,CAAA;YAC3E,OAAO;gBAAE,QAAA,EAAU,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,EAAA,EAAG;YAAA,CAAE;QACvC,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIH,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,qBAAA,EAAuB,QAAQ,CAAA;gBAClE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,SAAS;oBAAE,UAAA,EAAY,IAAA,CAAK,SAAA,CAAU,UAAU,CAAA;gBAAA;YAAE,CACpD,EACA;QAEJ;IACF;IAEA,MAAa,aAAa,IAAA,EAAoE;QAC5F,MAAM,EAAE,QAAA,EAAU,UAAA,EAAY,OAAA,EAAS,MAAA,EAAQ,SAAS,YAAA,EAAc,IAAA,GAAO,CAAA,EAAG,OAAA,EAAQ,GAAI,IAAA;QAG5F,MAAM,YAAY,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,GAAI,QAAA,GAAW;YAAC,QAAQ;SAAA;QAEhE,IAAI,SAAA,CAAU,MAAA,KAAW,CAAA,IAAK,SAAA,CAAU,IAAA,CAAK,CAAA,KAAM,CAAC,EAAA,CAAG,IAAA,EAAM,CAAA,EAAG;YAC9D,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,mBAAmB,CAAA;gBACvE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,QAAA,EAAU,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,GAAI,QAAA,CAAS,IAAA,CAAK,GAAG,CAAA,GAAI,QAAA;gBAAA;YAAS,CAC/E,EACA,IAAI,MAAM,mEAAmE;QAEjF;QAEA,IAAI,OAAO,CAAA,EAAG;YACZ,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,cAAc,CAAA;gBAClE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,IAAA;gBAAA;YAAK,CAClB,EACA,IAAI,MAAM,mBAAmB;QAEjC;QAEA,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,EAAE,CAAA;QACjD,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,kBAAA,EAAA,OAAuBC,sLAAAA,EAAoB,IAAA,EAAM,cAAc,OAAO,CAAA;QAE/F,IAAI;YAEF,MAAM,EAAE,KAAA,EAAO,SAAA,EAAA,GAAc,IAAA,CAAK,YAAA,CAAa,SAAS,KAAK,CAAA;YAC7D,MAAM,gBAAA,GAAmB,CAAA,UAAA,EAAa,KAAK,CAAA,EAAA,EAAK,SAAS,CAAA,CAAA;YAGzD,MAAM,qBAAqB,SAAA,CAAU,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA;YAC7D,MAAM,UAAA,GAAuB;gBAAC,CAAA,cAAA,EAAiB,kBAAkB,CAAA,CAAA,CAAG;aAAA;YACpE,MAAM,WAAA,GAAyB,CAAC;mBAAG,SAAS;aAAA;YAE5C,IAAI,UAAA,EAAY;gBACd,UAAA,CAAW,IAAA,CAAK,CAAA,gBAAA,CAAkB,CAAA;gBAClC,WAAA,CAAY,IAAA,CAAK,UAAU,CAAA;YAC7B;YAEA,IAAI,MAAA,EAAQ,WAAW,KAAA,EAAO;gBAC5B,MAAM,OAAA,GAAU,MAAA,CAAO,SAAA,CAAU,cAAA,GAAiB,GAAA,GAAM,IAAA;gBACxD,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,EAAe,OAAO,CAAA,EAAA,CAAI,CAAA;gBAC1C,WAAA,CAAY,IAAA,CACV,MAAA,CAAO,SAAA,CAAU,KAAA,YAAiB,IAAA,GAAO,MAAA,CAAO,SAAA,CAAU,KAAA,CAAM,WAAA,EAAY,GAAI,MAAA,CAAO,SAAA,CAAU,KAAA;YAErG;YAEA,IAAI,MAAA,EAAQ,WAAW,GAAA,EAAK;gBAC1B,MAAM,KAAA,GAAQ,MAAA,CAAO,SAAA,CAAU,YAAA,GAAe,GAAA,GAAM,IAAA;gBACpD,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,EAAe,KAAK,CAAA,EAAA,CAAI,CAAA;gBACxC,WAAA,CAAY,IAAA,CACV,MAAA,CAAO,SAAA,CAAU,GAAA,YAAe,IAAA,GAAO,MAAA,CAAO,SAAA,CAAU,GAAA,CAAI,WAAA,EAAY,GAAI,MAAA,CAAO,SAAA,CAAU,GAAA;YAEjG;YAEA,MAAM,WAAA,GAAc,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,MAAA,EAAS,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;YAGlF,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC7C,GAAA,EAAK,CAAA,8BAAA,EAAiC,iLAAc,CAAA,CAAA,EAAI,WAAW,CAAA,CAAA;gBACnE,IAAA,EAAM;YAAA,CACP,CAAA;YACD,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAGtD,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,UAAA,GAAa,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC5C,KAAK,CAAA,4EAAA,EAA+E,iLAAc,CAAA,CAAA,EAAI,WAAW,CAAA,CAAA,EAAI,gBAAgB,CAAA,iBAAA,CAAA;gBACrI,IAAA,EAAM,CAAC;uBAAG,WAAA;oBAAa;oBAAY,MAAM;iBAAA;YAAA,CAC1C,CAAA;YACD,MAAM,QAAA,GAAA,CAA+B,UAAA,CAAW,IAAA,IAAQ,EAAC,EAAG,GAAA,CAAI,CAAC,GAAA,GAAa,IAAA,CAAK,QAAA,CAAS,GAAG,CAAC,CAAA;YAGhG,IAAI,KAAA,KAAU,KAAK,QAAA,CAAS,MAAA,KAAW,KAAA,CAAM,CAAC,OAAA,IAAW,OAAA,CAAQ,MAAA,KAAW,CAAA,CAAA,EAAI;gBAC9E,OAAO;oBACL,UAAU,EAAC;oBACX,KAAA,EAAO,CAAA;oBACP,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,OAAA,EAAS;gBAAA,CACX;YACF;YAGA,MAAM,UAAA,GAAa,IAAI,GAAA,CAAI,QAAA,CAAS,GAAA,CAAI,CAAA,CAAA,GAAK,CAAA,CAAE,EAAE,CAAC,CAAA;YAClD,IAAI,OAAA,IAAW,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;gBACjC,MAAM,kBAAkB,MAAM,IAAA,CAAK,oBAAA,CAAqB;oBAAE;gBAAA,CAAS,CAAA;gBACnE,IAAI,eAAA,EAAiB;oBAEnB,KAAA,MAAW,cAAc,eAAA,CAAiB;wBACxC,IAAI,CAAC,UAAA,CAAW,GAAA,CAAI,UAAA,CAAW,EAAE,CAAA,EAAG;4BAClC,QAAA,CAAS,IAAA,CAAK,UAAU,CAAA;4BACxB,UAAA,CAAW,GAAA,CAAI,WAAW,EAAE,CAAA;wBAC9B;oBACF;gBACF;YACF;YAGA,MAAM,OAAO,IAAI,8KAAA,EAAY,CAAE,GAAA,CAAI,UAAU,QAAQ,CAAA;YACrD,IAAI,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,EAAA,EAAG;YAGpC,aAAA,GAAgB,aAAA,CAAc,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM;gBAC3C,MAAM,WAAA,GAAc,KAAA,KAAU,WAAA,IAAe,KAAA,KAAU,WAAA;gBACvD,MAAM,MAAA,GAAS,WAAA,GAAc,IAAI,IAAA,CAAM,CAAA,CAAU,KAAK,CAAC,CAAA,CAAE,OAAA,EAAQ,GAAK,CAAA,CAAU,KAAK,CAAA;gBACrF,MAAM,MAAA,GAAS,WAAA,GAAc,IAAI,IAAA,CAAM,CAAA,CAAU,KAAK,CAAC,CAAA,CAAE,OAAA,EAAQ,GAAK,CAAA,CAAU,KAAK,CAAA;gBAErF,IAAI,OAAO,MAAA,KAAW,QAAA,IAAY,OAAO,WAAW,QAAA,EAAU;oBAC5D,OAAO,SAAA,KAAc,KAAA,GAAQ,MAAA,GAAS,MAAA,GAAS,MAAA,GAAS,MAAA;gBAC1D;gBACA,OAAO,cAAc,KAAA,GACjB,MAAA,CAAO,MAAM,CAAA,CAAE,aAAA,CAAc,MAAA,CAAO,MAAM,CAAC,CAAA,GAC3C,OAAO,MAAM,CAAA,CAAE,aAAA,CAAc,MAAA,CAAO,MAAM,CAAC,CAAA;YACjD,CAAC,CAAA;YAKD,MAAM,WAAA,GAAc,IAAI,GAAA,CAAI,SAAS,CAAA;YACrC,MAAM,2BAA2B,IAAI,GAAA,CACnC,aAAA,CAAc,MAAA,CAAO,CAAA,CAAA,GAAK,CAAA,CAAE,QAAA,IAAY,WAAA,CAAY,GAAA,CAAI,CAAA,CAAE,QAAQ,CAAC,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,EAAE;YAEpF,MAAM,yBAAA,GAA4B,yBAAyB,IAAA,IAAQ,KAAA;YACnE,MAAM,UAAU,YAAA,KAAiB,KAAA,IAAS,CAAC,yBAAA,IAA6B,SAAS,OAAA,GAAU,KAAA;YAE3F,OAAO;gBACL,QAAA,EAAU,aAAA;gBACV,KAAA;gBACA,IAAA;gBACA,OAAA,EAAS,kBAAA;gBACT;YAAA,CACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,cAAc,IAAIN,8KAAAA,CACtB;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC5D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBACP,QAAA,EAAU,MAAM,OAAA,CAAQ,QAAQ,IAAI,QAAA,CAAS,IAAA,CAAK,GAAG,CAAA,GAAI,QAAA;oBACzD,YAAY,UAAA,IAAc;gBAAA;YAC5B,CACF,EACA;YAEF,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,WAAA,CAAY,QAAA,EAAU,CAAA;YAC3C,IAAA,CAAK,MAAA,EAAQ,iBAAiB,WAAW,CAAA;YACzC,OAAO;gBACL,UAAU,EAAC;gBACX,KAAA,EAAO,CAAA;gBACP,IAAA;gBACA,OAAA,EAAS,kBAAA;gBACT,OAAA,EAAS;YAAA,CACX;QACF;IACF;IAEA,MAAM,YAAA,CAAa,EAAE,QAAA,EAAS,EAA8E;QAC1G,IAAI,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG,OAAO;YAAE,QAAA;QAAA,CAAS;QAE7C,IAAI;YACF,MAAM,QAAA,GAAW,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA;YAC9B,IAAI,CAAC,QAAA,EAAU;gBACb,MAAM,IAAI,MAAM,uBAAuB,CAAA;YACzC;YAGA,MAAM,eAAA,GAAkB,QAAA,CAAS,GAAA,CAAI,CAAA,OAAA,KAAW;gBAC9C,MAAM,IAAA,GAAO,OAAA,CAAQ,SAAA,IAAA,aAAA,GAAa,IAAI,IAAA,EAAK;gBAC3C,IAAI,CAAC,QAAQ,QAAA,EAAU;oBACrB,MAAM,IAAI,KAAA,CACR,CAAA,iGAAA,CAAA;gBAEJ;gBACA,IAAI,CAAC,QAAQ,UAAA,EAAY;oBACvB,MAAM,IAAI,KAAA,CACR,CAAA,mGAAA,CAAA;gBAEJ;gBACA,OAAO;oBACL,GAAA,EAAK,CAAA,aAAA,EAAgB,iLAAc,CAAA;;;;;;;;gBAAA,CAAA;oBASnC,IAAA,EAAM;wBACJ,OAAA,CAAQ,EAAA;wBACR,OAAA,CAAQ,QAAA;wBACR,OAAO,QAAQ,OAAA,KAAY,QAAA,GAAW,KAAK,SAAA,CAAU,OAAA,CAAQ,OAAO,CAAA,GAAI,OAAA,CAAQ,OAAA;wBAChF,OAAA,CAAQ,IAAA;wBACR,QAAQ,IAAA,IAAQ,IAAA;wBAChB,IAAA,YAAgB,IAAA,GAAO,IAAA,CAAK,WAAA,EAAY,GAAI,IAAA;wBAC5C,OAAA,CAAQ,UAAA;qBAAA;gBACV,CACF;YACF,CAAC,CAAA;YAED,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;YACnC,eAAA,CAAgB,IAAA,CAAK;gBACnB,GAAA,EAAK,CAAA,QAAA,EAAW,gLAAa,CAAA,kCAAA,CAAA;gBAC7B,IAAA,EAAM;oBAAC,GAAA;oBAAK,QAAQ;iBAAA;YAAA,CACrB,CAAA;YAGD,MAAM,UAAA,GAAa,EAAA;YAGnB,MAAM,iBAAA,GAAoB,eAAA,CAAgB,KAAA,CAAM,CAAA,EAAG,CAAA,CAAE,CAAA;YACrD,MAAM,qBAAA,GAAwB,eAAA,CAAgB,eAAA,CAAgB,MAAA,GAAS,CAAC,CAAA;YAGxE,IAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,iBAAA,CAAkB,MAAA,EAAQ,KAAK,UAAA,CAAY;gBAC7D,MAAM,KAAA,GAAQ,iBAAA,CAAkB,KAAA,CAAM,CAAA,EAAG,IAAI,UAAU,CAAA;gBACvD,IAAI,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;oBACpB,MAAM,IAAA,EAAK,MAAA,CAAQ,KAAA,CAAM,KAAA,EAAO,OAAO,CAAA;gBACzC;YACF;YAGA,IAAI,qBAAA,EAAuB;gBACzB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ,qBAAqB,CAAA;YAClD;YAEA,MAAM,OAAO,IAAI,8KAAA,EAAY,CAAE,GAAA,CAAI,UAAiB,QAAQ,CAAA;YAC5D,OAAO;gBAAE,QAAA,EAAU,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,EAAA,EAAG;YAAA,CAAE;QACvC,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC5D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,cAAA,CAAe,EACnB,QAAA,EACF,EAK+B;QAC7B,IAAI,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;YACzB,OAAO,EAAC;QACV;QAEA,MAAM,UAAA,GAAa,QAAA,CAAS,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,EAAE,CAAA;QACzC,MAAM,eAAe,UAAA,CAAW,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;QAEvD,MAAM,SAAA,GAAY,CAAA,cAAA,EAAiB,iLAAc,CAAA,cAAA,EAAiB,YAAY,CAAA,CAAA,CAAA;QAC9E,MAAM,cAAA,GAAiB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;YAAE,GAAA,EAAK,SAAA;YAAW,IAAA,EAAM,UAAA;QAAA,CAAY,CAAA;QACtF,MAAM,gBAAA,GAAsC,eAAe,IAAA,CAAK,GAAA,CAAI,CAAA,MAAO,IAAA,CAAK,QAAA,CAAS,GAAG,CAAC,CAAA;QAE7F,IAAI,gBAAA,CAAiB,MAAA,KAAW,CAAA,EAAG;YACjC,OAAO,EAAC;QACV;QAEA,MAAM,kBAAkB,EAAC;QACzB,MAAM,iBAAA,GAAA,aAAA,GAAA,IAAwB,GAAA,EAAY;QAC1C,MAAM,aAAA,GAAwC;YAC5C,QAAA,EAAU;QAAA,CACZ;QAEA,KAAA,MAAW,mBAAmB,gBAAA,CAAkB;YAC9C,MAAM,gBAAgB,QAAA,CAAS,IAAA,CAAK,CAAA,IAAK,CAAA,CAAE,EAAA,KAAO,gBAAgB,EAAE,CAAA;YACpE,IAAI,CAAC,aAAA,EAAe;YAEpB,MAAM,EAAE,EAAA,EAAI,GAAG,cAAA,EAAe,GAAI,aAAA;YAClC,IAAI,MAAA,CAAO,IAAA,CAAK,cAAc,CAAA,CAAE,MAAA,KAAW,CAAA,EAAG;YAE9C,iBAAA,CAAkB,GAAA,CAAI,gBAAgB,QAAS,CAAA;YAC/C,IAAI,aAAA,CAAc,QAAA,IAAY,aAAA,CAAc,QAAA,KAAa,gBAAgB,QAAA,EAAU;gBACjF,iBAAA,CAAkB,GAAA,CAAI,cAAc,QAAQ,CAAA;YAC9C;YAEA,MAAM,aAAa,EAAC;YACpB,MAAM,OAAkB,EAAC;YACzB,MAAM,eAAA,GAAkB;gBAAE,GAAG,cAAA;YAAA,CAAe;YAG5C,IAAI,gBAAgB,OAAA,EAAS;gBAC3B,MAAM,UAAA,GAAa;oBACjB,GAAG,eAAA,CAAgB,OAAA;oBACnB,GAAG,eAAA,CAAgB,OAAA;oBAAA,2CAAA;oBAEnB,GAAI,eAAA,CAAgB,OAAA,EAAS,QAAA,IAAY,eAAA,CAAgB,OAAA,CAAQ,QAAA,GAC7D;wBACE,QAAA,EAAU;4BACR,GAAG,gBAAgB,OAAA,CAAQ,QAAA;4BAC3B,GAAG,gBAAgB,OAAA,CAAQ,QAAA;wBAAA;oBAC7B,IAEF,CAAA,CAAA;gBAAC,CACP;gBACA,UAAA,CAAW,IAAA,CAAK,CAAA,MAAGL,qLAAAA,EAAmB,SAAA,EAAW,aAAa,CAAC,CAAA,IAAA,CAAM,CAAA;gBACrE,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,UAAU,CAAC,CAAA;gBACpC,OAAO,eAAA,CAAgB,OAAA;YACzB;YAEA,IAAA,MAAW,OAAO,eAAA,CAAiB;gBACjC,IAAI,OAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,eAAA,EAAiB,GAAG,CAAA,EAAG;oBAC9D,MAAM,KAAA,GAAQ,aAAA,CAAc,GAAG,CAAA,IAAK,GAAA;oBACpC,UAAA,CAAW,IAAA,CAAK,CAAA,MAAGA,qLAAAA,EAAmB,KAAA,EAAO,aAAa,CAAC,CAAA,IAAA,CAAM,CAAA;oBACjE,IAAI,KAAA,GAAQ,eAAA,CAAgB,GAAmC,CAAA;oBAE/D,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,IAAA,EAAM;wBAC/C,KAAA,GAAQ,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA;oBAC9B;oBACA,IAAA,CAAK,IAAA,CAAK,KAAgB,CAAA;gBAC5B;YACF;YAEA,IAAI,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;YAE7B,IAAA,CAAK,IAAA,CAAK,EAAE,CAAA;YAEZ,MAAM,MAAM,CAAA,OAAA,EAAU,iLAAc,CAAA,KAAA,EAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA,aAAA,CAAA;YACjE,eAAA,CAAgB,IAAA,CAAK;gBAAE,GAAA;gBAAK,IAAA;YAAA,CAAM,CAAA;QACpC;QAEA,IAAI,eAAA,CAAgB,MAAA,KAAW,CAAA,EAAG;YAChC,OAAO,gBAAA;QACT;QAEA,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;QACnC,KAAA,MAAW,YAAY,iBAAA,CAAmB;YACxC,IAAI,QAAA,EAAU;gBACZ,eAAA,CAAgB,IAAA,CAAK;oBACnB,GAAA,EAAK,CAAA,OAAA,EAAU,gLAAa,CAAA,+BAAA,CAAA;oBAC5B,IAAA,EAAM;wBAAC,GAAA;wBAAK,QAAQ;qBAAA;gBAAA,CACrB,CAAA;YACH;QACF;QAEA,MAAM,IAAA,EAAK,MAAA,CAAQ,KAAA,CAAM,eAAA,EAAiB,OAAO,CAAA;QAEjD,MAAM,aAAA,GAAgB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;YAAE,GAAA,EAAK,SAAA;YAAW,IAAA,EAAM,UAAA;QAAA,CAAY,CAAA;QACrF,OAAO,cAAc,IAAA,CAAK,GAAA,CAAI,CAAA,MAAO,IAAA,CAAK,QAAA,CAAS,GAAG,CAAC,CAAA;IACzD;IAEA,MAAM,eAAe,UAAA,EAAqC;QACxD,IAAI,CAAC,UAAA,IAAc,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;YAC1C;QACF;QAEA,IAAI;YAEF,MAAM,UAAA,GAAa,GAAA;YACnB,MAAM,SAAA,GAAA,aAAA,GAAA,IAAgB,GAAA,EAAY;YAGlC,MAAM,EAAA,GAAK,MAAM,IAAA,EAAK,MAAA,CAAQ,WAAA,CAAY,OAAO,CAAA;YAEjD,IAAI;gBACF,IAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,MAAA,EAAQ,KAAK,UAAA,CAAY;oBACtD,MAAM,KAAA,GAAQ,UAAA,CAAW,KAAA,CAAM,CAAA,EAAG,IAAI,UAAU,CAAA;oBAChD,MAAM,eAAe,KAAA,CAAM,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;oBAGlD,MAAM,MAAA,GAAS,MAAM,EAAA,CAAG,OAAA,CAAQ;wBAC9B,GAAA,EAAK,CAAA,gCAAA,EAAmC,iLAAc,CAAA,eAAA,EAAkB,YAAY,CAAA,CAAA,CAAA;wBACpF,IAAA,EAAM;oBAAA,CACP,CAAA;oBAED,MAAA,CAAO,IAAA,EAAM,QAAQ,CAAA,GAAA,KAAO;wBAC1B,IAAI,GAAA,CAAI,SAAA,EAAW,SAAA,CAAU,GAAA,CAAI,IAAI,SAAmB,CAAA;oBAC1D,CAAC,CAAA;oBAGD,MAAM,GAAG,OAAA,CAAQ;wBACf,GAAA,EAAK,CAAA,aAAA,EAAgB,iLAAc,CAAA,eAAA,EAAkB,YAAY,CAAA,CAAA,CAAA;wBACjE,IAAA,EAAM;oBAAA,CACP,CAAA;gBACH;gBAGA,IAAI,SAAA,CAAU,IAAA,GAAO,CAAA,EAAG;oBACtB,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;oBACnC,KAAA,MAAW,YAAY,SAAA,CAAW;wBAChC,MAAM,GAAG,OAAA,CAAQ;4BACf,GAAA,EAAK,CAAA,QAAA,EAAW,gLAAa,CAAA,kCAAA,CAAA;4BAC7B,IAAA,EAAM;gCAAC,GAAA;gCAAK,QAAQ;6BAAA;wBAAA,CACrB,CAAA;oBACH;gBACF;gBAGA,MAAM,GAAG,MAAA,EAAO;YAClB,EAAA,OAAS,KAAA,EAAO;gBAEd,MAAM,GAAG,QAAA,EAAS;gBAClB,MAAM,KAAA;YACR;QAGF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIG,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,iBAAA,EAAmB,QAAQ,CAAA;gBAC9D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,SAAS;oBAAE,UAAA,EAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAAA;YAAE,CAC/C,EACA;QAEJ;IACF;IAEA,MAAM,eAAA,CAAgB,EAAE,UAAA,EAAW,EAAgE;QACjG,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAA4B;YACxD,SAAA,EAAW,kLAAA;YACX,IAAA,EAAM;gBAAE,EAAA,EAAI,UAAA;YAAA;QAAW,CACxB,CAAA;QAED,IAAI,CAAC,MAAA,EAAQ;YACX,OAAO,IAAA;QACT;QAEA,OAAO;YACL,GAAG,MAAA;YAAA,mFAAA;YAEH,aAAA,EACE,MAAA,CAAO,aAAA,IAAiB,OAAO,MAAA,CAAO,aAAA,KAAkB,QAAA,GACpD,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,aAAa,CAAA,GACnC,MAAA,CAAO,aAAA;YACb,QAAA,EAAU,OAAO,MAAA,CAAO,QAAA,KAAa,QAAA,GAAW,KAAK,KAAA,CAAM,MAAA,CAAO,QAAQ,CAAA,GAAI,MAAA,CAAO,QAAA;YACrF,SAAA,EAAW,IAAI,IAAA,CAAK,MAAA,CAAO,SAAS,CAAA;YACpC,SAAA,EAAW,IAAI,IAAA,CAAK,MAAA,CAAO,SAAS;QAAA,CACtC;IACF;IAEA,MAAM,YAAA,CAAa,EAAE,QAAA,EAAS,EAAoE;QAChG,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;YACpB,SAAA,EAAW,kLAAA;YACX,MAAA,EAAQ;gBACN,GAAG,QAAA;YAAA;QAEL,CACD,CAAA;QAED,OAAO,QAAA;IACT;IAEA,MAAM,cAAA,CAAe,EACnB,UAAA,EACA,aAAA,EACA,QAAA,EACF,EAIiC;QAC/B,MAAM,mBAAmB,MAAM,IAAA,CAAK,eAAA,CAAgB;YAAE;QAAA,CAAY,CAAA;QAElE,IAAI,CAAC,gBAAA,EAAkB;YAErB,MAAM,WAAA,GAAmC;gBACvC,EAAA,EAAI,UAAA;gBACJ,aAAA;gBACA,QAAA,EAAU,YAAY,CAAA,CAAC;gBACvB,SAAA,EAAA,aAAA,GAAA,IAAe,IAAA,EAAK;gBACpB,SAAA,EAAA,aAAA,GAAA,IAAe,IAAA;YAAK,CACtB;YACA,OAAO,IAAA,CAAK,YAAA,CAAa;gBAAE,QAAA,EAAU;YAAA,CAAa,CAAA;QACpD;QAEA,MAAM,eAAA,GAAkB;YACtB,GAAG,gBAAA;YACH,aAAA,EAAe,aAAA,KAAkB,KAAA,CAAA,GAAY,aAAA,GAAgB,gBAAA,CAAiB,aAAA;YAC9E,QAAA,EAAU;gBACR,GAAG,gBAAA,CAAiB,QAAA;gBACpB,GAAG,QAAA;YAAA,CACL;YACA,SAAA,EAAA,aAAA,GAAA,IAAe,IAAA;QAAK,CACtB;QAEA,MAAM,UAAoB,EAAC;QAC3B,MAAM,SAAoB,EAAC;QAE3B,IAAI,kBAAkB,KAAA,CAAA,EAAW;YAC/B,OAAA,CAAQ,IAAA,CAAK,mBAAmB,CAAA;YAChC,MAAA,CAAO,IAAA,CAAK,aAAa,CAAA;QAC3B;QAEA,IAAI,QAAA,EAAU;YACZ,OAAA,CAAQ,IAAA,CAAK,qBAAqB,CAAA;YAClC,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,eAAA,CAAgB,QAAQ,CAAC,CAAA;QACtD;QAEA,OAAA,CAAQ,IAAA,CAAK,eAAe,CAAA;QAC5B,MAAA,CAAO,IAAA,CAAK,eAAA,CAAgB,SAAA,CAAU,WAAA,EAAa,CAAA;QAEnD,MAAA,CAAO,IAAA,CAAK,UAAU,CAAA;QAEtB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;YACzB,KAAK,CAAA,OAAA,EAAU,kLAAe,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAC,CAAA,aAAA,CAAA;YACxD,IAAA,EAAM;QAAA,CACP,CAAA;QAED,OAAO,eAAA;IACT;IAEA,MAAM,aAAA,CAAc,EAAE,QAAA,EAAS,EAA4D;QACzF,IAAI;YACF,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAE5B;gBACA,SAAA,EAAW,gLAAA;gBACX,IAAA,EAAM;oBAAE,EAAA,EAAI,QAAA;gBAAA;YAAS,CACtB,CAAA;YAED,IAAI,CAAC,MAAA,EAAQ;gBACX,OAAO,IAAA;YACT;YAEA,OAAO;gBACL,GAAG,MAAA;gBACH,QAAA,EAAU,OAAO,MAAA,CAAO,QAAA,KAAa,QAAA,GAAW,KAAK,KAAA,CAAM,MAAA,CAAO,QAAQ,CAAA,GAAI,MAAA,CAAO,QAAA;gBACrF,SAAA,EAAW,IAAI,IAAA,CAAK,MAAA,CAAO,SAAS,CAAA;gBACpC,SAAA,EAAW,IAAI,IAAA,CAAK,MAAA,CAAO,SAAS;YAAA,CACtC;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,kBAAA,EAAoB,QAAQ,CAAA;gBAC/D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,QAAA;gBAAA;YAAS,CACtB,EACA;QAEJ;IACF;IAEA,MAAa,wBACX,IAAA,EAC+C;QAC/C,MAAM,EAAE,UAAA,EAAY,IAAA,GAAO,CAAA,EAAG,OAAA,EAAS,YAAA,EAAc,OAAA,EAAQ,GAAI,IAAA;QAEjE,IAAI,OAAO,CAAA,EAAG;YACZ,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,6BAAA,EAA+B,cAAc,CAAA;gBAChF,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,IAAA;gBAAA;YAAK,CAClB,EACA,IAAI,MAAM,mBAAmB;QAEjC;QAEA,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;QAClD,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,kBAAA,EAAA,OAAuBC,sLAAAA,EAAoB,IAAA,EAAM,cAAc,OAAO,CAAA;QAC/F,MAAM,EAAE,KAAA,EAAO,SAAA,EAAU,GAAI,IAAA,CAAK,YAAA,CAAa,OAAO,CAAA;QAEtD,IAAI;YACF,MAAM,SAAA,GAAY,CAAA,KAAA,EAAQ,gLAAa,CAAA,qBAAA,CAAA;YACvC,MAAM,WAAA,GAAyB;gBAAC,UAAU;aAAA;YAE1C,MAAM,yBAAA,GAA4B,CAAC,GAAA,GAAA,CAAiC;oBAClE,IAAI,GAAA,CAAI,EAAA;oBACR,YAAY,GAAA,CAAI,UAAA;oBAChB,OAAO,GAAA,CAAI,KAAA;oBACX,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB,CAAA;oBAAA,yBAAA;oBAC3C,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB,CAAA;oBAAA,yBAAA;oBAC3C,QAAA,EAAU,OAAO,GAAA,CAAI,QAAA,KAAa,QAAA,GAAW,KAAK,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAA,GAAI,GAAA,CAAI,QAAA;gBAAA,CAC9E,CAAA;YAEA,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC7C,GAAA,EAAK,CAAA,yBAAA,EAA4B,SAAS,CAAA,CAAA;gBAC1C,IAAA,EAAM;YAAA,CACP,CAAA;YACD,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAEtD,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,SAAS,EAAC;oBACV,KAAA,EAAO,CAAA;oBACP,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,OAAA,EAAS;gBAAA,CACX;YACF;YAEA,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,UAAA,GAAa,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC5C,GAAA,EAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,CAAA,EAAI,SAAS,CAAA,WAAA,EAAc,KAAK,CAAA,EAAA,EAAK,SAAS,CAAA,iBAAA,CAAA;gBAC9F,IAAA,EAAM,CAAC;uBAAG,WAAA;oBAAa;oBAAY,MAAM;iBAAA;YAAA,CAC1C,CAAA;YAED,MAAM,UAAA,CAAW,UAAA,CAAW,IAAA,IAAQ,EAAC,EAAG,GAAA,CAAI,yBAAyB,CAAA;YAErE,OAAO;gBACL,OAAA;gBACA,KAAA;gBACA,IAAA;gBACA,OAAA,EAAS,kBAAA;gBACT,OAAA,EAAS,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,SAAS,OAAA,GAAU;YAAA,CAC/D;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,cAAc,IAAIN,8KAAAA,CACtB;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,6BAAA,EAA+B,QAAQ,CAAA;gBAC1E,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,UAAA;gBAAA;YAAW,CACxB,EACA;YAEF,IAAA,CAAK,MAAA,EAAQ,iBAAiB,WAAW,CAAA;YACzC,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,WAAA,CAAY,QAAA,EAAU,CAAA;YAC3C,OAAO;gBACL,SAAS,EAAC;gBACV,KAAA,EAAO,CAAA;gBACP,IAAA;gBACA,OAAA,EAAS,kBAAA;gBACT,OAAA,EAAS;YAAA,CACX;QACF;IACF;IAEA,MAAM,UAAA,CAAW,EAAE,MAAA,EAAO,EAA8D;QACtF,IAAI;YACF,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBACpB,SAAA,EAAW,gLAAA;gBACX,MAAA,EAAQ;oBACN,GAAG,MAAA;gBAAA;YAEL,CACD,CAAA;YAED,OAAO,MAAA;QACT,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,cAAc,IAAIF,8KAAAA,CACtB;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,QAAA,EAAU,MAAA,CAAO,EAAA;gBAAA;YAAG,CACjC,EACA;YAEF,IAAA,CAAK,MAAA,EAAQ,iBAAiB,WAAW,CAAA;YACzC,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,WAAA,CAAY,QAAA,EAAU,CAAA;YAC3C,MAAM,WAAA;QACR;IACF;IAEA,MAAM,YAAA,CAAa,EACjB,EAAA,EACA,KAAA,EACA,QAAA,EACF,EAI+B;QAC7B,MAAM,SAAS,MAAM,IAAA,CAAK,aAAA,CAAc;YAAE,QAAA,EAAU;QAAA,CAAI,CAAA;QACxD,IAAI,CAAC,MAAA,EAAQ;YACX,MAAM,IAAIF,8KAAAA,CAAY;gBACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,WAAW,CAAA;gBAC/D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,IAAA,EAAM,CAAA,OAAA,EAAU,EAAE,CAAA,UAAA,CAAA;gBAClB,OAAA,EAAS;oBACP,MAAA,EAAQ,GAAA;oBACR,QAAA,EAAU;gBAAA;YACZ,CACD,CAAA;QACH;QAEA,MAAM,aAAA,GAAgB;YACpB,GAAG,MAAA;YACH,KAAA;YACA,QAAA,EAAU;gBACR,GAAG,MAAA,CAAO,QAAA;gBACV,GAAG,QAAA;YAAA;QACL,CACF;QAEA,IAAI;YACF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACzB,GAAA,EAAK,CAAA,OAAA,EAAU,gLAAa,CAAA,gDAAA,CAAA;gBAC5B,IAAA,EAAM;oBAAC,KAAA;oBAAO,IAAA,CAAK,SAAA,CAAU,aAAA,CAAc,QAAQ;oBAAG,EAAE;iBAAA;YAAA,CACzD,CAAA;YAED,OAAO,aAAA;QACT,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC5D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,IAAA,EAAM,CAAA,wBAAA,EAA2B,EAAE,CAAA,CAAA;gBACnC,OAAA,EAAS;oBAAE,QAAA,EAAU,EAAA;gBAAA;YAAG,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,YAAA,CAAa,EAAE,QAAA,EAAS,EAAwC;QACpE,IAAI;YAKF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACzB,GAAA,EAAK,CAAA,YAAA,EAAe,iLAAc,CAAA,oBAAA,CAAA;gBAClC,IAAA,EAAM;oBAAC,QAAQ;iBAAA;YAAA,CAChB,CAAA;YACD,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACzB,GAAA,EAAK,CAAA,YAAA,EAAe,gLAAa,CAAA,aAAA,CAAA;gBACjC,IAAA,EAAM;oBAAC,QAAQ;iBAAA;YAAA,CAChB,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC5D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,QAAA;gBAAA;YAAS,CACtB,EACA;QAEJ;IACF;IAEA,MAAM,YAAY,IAAA,EAAkE;QAClF,MAAM,EAAE,cAAA,EAAgB,WAAA,EAAa,gBAAA,EAAkB,UAAA,EAAY,KAAA,EAAO,QAAA,EAAU,OAAA,EAAQ,GAAI,IAAA;QAGhG,MAAM,eAAe,MAAM,IAAA,CAAK,aAAA,CAAc;YAAE,QAAA,EAAU;QAAA,CAAgB,CAAA;QAC1E,IAAI,CAAC,YAAA,EAAc;YACjB,MAAM,IAAIF,8KAAAA,CAAY;gBACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,kBAAkB,CAAA;gBACrE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,IAAA,EAAM,CAAA,sBAAA,EAAyB,cAAc,CAAA,UAAA,CAAA;gBAC7C,OAAA,EAAS;oBAAE,cAAA;gBAAA;YAAe,CAC3B,CAAA;QACH;QAGA,MAAM,WAAA,GAAc,gBAAA,IAAoB,MAAA,CAAO,UAAA,EAAW;QAG1D,MAAM,iBAAiB,MAAM,IAAA,CAAK,aAAA,CAAc;YAAE,QAAA,EAAU;QAAA,CAAa,CAAA;QACzE,IAAI,cAAA,EAAgB;YAClB,MAAM,IAAIF,8KAAAA,CAAY;gBACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,eAAe,CAAA;gBAClE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,IAAA,EAAM,CAAA,eAAA,EAAkB,WAAW,CAAA,eAAA,CAAA;gBACnC,OAAA,EAAS;oBAAE,WAAA;gBAAA;YAAY,CACxB,CAAA;QACH;QAEA,IAAI;YAEF,IAAI,YAAA,GAAe,CAAA;gCAAA,EACS,iLAAc,CAAA,qBAAA,CAAA;YAC1C,MAAM,aAAA,GAA2B;gBAAC,cAAc;aAAA;YAGhD,IAAI,OAAA,EAAS,eAAe,SAAA,EAAW;gBACrC,YAAA,IAAgB,CAAA,qBAAA,CAAA;gBAChB,aAAA,CAAc,IAAA,CACZ,OAAA,CAAQ,aAAA,CAAc,SAAA,YAAqB,IAAA,GACvC,OAAA,CAAQ,aAAA,CAAc,SAAA,CAAU,WAAA,EAAY,GAC5C,OAAA,CAAQ,aAAA,CAAc,SAAA;YAE9B;YACA,IAAI,OAAA,EAAS,eAAe,OAAA,EAAS;gBACnC,YAAA,IAAgB,CAAA,qBAAA,CAAA;gBAChB,aAAA,CAAc,IAAA,CACZ,OAAA,CAAQ,aAAA,CAAc,OAAA,YAAmB,IAAA,GACrC,OAAA,CAAQ,aAAA,CAAc,OAAA,CAAQ,WAAA,EAAY,GAC1C,OAAA,CAAQ,aAAA,CAAc,OAAA;YAE9B;YAGA,IAAI,SAAS,aAAA,EAAe,UAAA,IAAc,QAAQ,aAAA,CAAc,UAAA,CAAW,MAAA,GAAS,CAAA,EAAG;gBACrF,YAAA,IAAgB,CAAA,YAAA,EAAe,OAAA,CAAQ,aAAA,CAAc,UAAA,CAAW,GAAA,CAAI,IAAM,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAA;gBACzF,aAAA,CAAc,IAAA,CAAK,GAAG,OAAA,CAAQ,aAAA,CAAc,UAAU,CAAA;YACxD;YAEA,YAAA,IAAgB,CAAA,yBAAA,CAAA;YAGhB,IAAI,OAAA,EAAS,YAAA,IAAgB,OAAA,CAAQ,YAAA,GAAe,CAAA,EAAG;gBACrD,MAAM,aAAa,CAAA,eAAA,EAAkB,YAAA,CAAa,OAAA,CAAQ,0BAAA,EAA4B,2BAA2B,CAAC,CAAA,kCAAA,CAAA;gBAClH,aAAA,CAAc,IAAA,CAAK,QAAQ,YAAY,CAAA;gBACvC,YAAA,GAAe,UAAA;YACjB;YAEA,MAAM,oBAAA,GAAuB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAAE,GAAA,EAAK,YAAA;gBAAc,IAAA,EAAM,aAAA;YAAA,CAAe,CAAA;YAClG,MAAM,cAAA,GAAiB,oBAAA,CAAqB,IAAA,IAAQ,EAAC;YAErD,MAAM,GAAA,GAAA,aAAA,GAAA,IAAU,IAAA,EAAK;YACrB,MAAM,MAAA,GAAS,IAAI,WAAA,EAAY;YAG/B,MAAM,aAAA,GACJ,eAAe,MAAA,GAAS,CAAA,GAAK,cAAA,CAAe,cAAA,CAAe,MAAA,GAAS,CAAC,CAAA,CAAG,EAAA,GAAgB,KAAA,CAAA;YAG1F,MAAM,aAAA,GAAqC;gBACzC,cAAA;gBACA,QAAA,EAAU,GAAA;gBACV,GAAI,aAAA,IAAiB;oBAAE,aAAA;gBAAA,CAAA;YAAc,CACvC;YAGA,MAAM,SAAA,GAA+B;gBACnC,EAAA,EAAI,WAAA;gBACJ,UAAA,EAAY,cAAc,YAAA,CAAa,UAAA;gBACvC,OAAO,KAAA,IAAA,CAAU,YAAA,CAAa,KAAA,GAAQ,CAAA,SAAA,EAAY,YAAA,CAAa,KAAK,CAAA,CAAA,GAAK,KAAA,CAAA,CAAA;gBACzE,QAAA,EAAU;oBACR,GAAG,QAAA;oBACH,KAAA,EAAO;gBAAA,CACT;gBACA,SAAA,EAAW,GAAA;gBACX,SAAA,EAAW;YAAA,CACb;YAGA,MAAM,EAAA,GAAK,MAAM,IAAA,EAAK,MAAA,CAAQ,WAAA,CAAY,OAAO,CAAA;YAEjD,IAAI;gBAEF,MAAM,GAAG,OAAA,CAAQ;oBACf,GAAA,EAAK,CAAA,aAAA,EAAgB,gLAAa,CAAA;gDAAA,CAAA;oBAElC,IAAA,EAAM;wBACJ,SAAA,CAAU,EAAA;wBACV,SAAA,CAAU,UAAA;wBACV,UAAU,KAAA,IAAS,IAAA;wBACnB,IAAA,CAAK,SAAA,CAAU,SAAA,CAAU,QAAQ,CAAA;wBACjC,MAAA;wBACA;qBAAA;gBACF,CACD,CAAA;gBAGD,MAAM,iBAAoC,EAAC;gBAC3C,MAAM,gBAAA,GAAmB,cAAc,YAAA,CAAa,UAAA;gBAEpD,KAAA,MAAW,aAAa,cAAA,CAAgB;oBACtC,MAAM,YAAA,GAAe,OAAO,UAAA,EAAW;oBACvC,MAAM,aAAa,SAAA,CAAU,OAAA;oBAC7B,IAAI,aAAA;oBACJ,IAAI;wBACF,aAAA,GAAgB,IAAA,CAAK,KAAA,CAAM,UAAU,CAAA;oBACvC,CAAA,CAAA,OAAQ;wBAEN,aAAA,GAAgB;4BAAE,MAAA,EAAQ,CAAA;4BAAG,KAAA,EAAO;gCAAC;oCAAE,IAAA,EAAM,MAAA;oCAAQ,IAAA,EAAM,UAAA;gCAAA,CAAY;6BAAA;wBAAA,CAAE;oBAC3E;oBAEA,MAAM,GAAG,OAAA,CAAQ;wBACf,GAAA,EAAK,CAAA,aAAA,EAAgB,iLAAc,CAAA;8CAAA,CAAA;wBAEnC,IAAA,EAAM;4BACJ,YAAA;4BACA,WAAA;4BACA,UAAA;4BACA,SAAA,CAAU,IAAA;4BACT,UAAU,IAAA,IAAmB,IAAA;4BAC9B,SAAA,CAAU,SAAA;4BACV;yBAAA;oBACF,CACD,CAAA;oBAED,cAAA,CAAe,IAAA,CAAK;wBAClB,EAAA,EAAI,YAAA;wBACJ,QAAA,EAAU,WAAA;wBACV,OAAA,EAAS,aAAA;wBACT,MAAM,SAAA,CAAU,IAAA;wBAChB,IAAA,EAAO,UAAU,IAAA,IAAmB,KAAA,CAAA;wBACpC,SAAA,EAAW,IAAI,IAAA,CAAK,SAAA,CAAU,SAAmB,CAAA;wBACjD,UAAA,EAAY;oBAAA,CACb,CAAA;gBACH;gBAEA,MAAM,GAAG,MAAA,EAAO;gBAEhB,OAAO;oBACL,MAAA,EAAQ,SAAA;oBACR;gBAAA,CACF;YACF,EAAA,OAAS,KAAA,EAAO;gBACd,MAAM,GAAG,QAAA,EAAS;gBAClB,MAAM,KAAA;YACR;QACF,EAAA,OAAS,KAAA,EAAO;YACd,IAAI,iBAAiBF,8KAAAA,EAAa;gBAChC,MAAM,KAAA;YACR;YACA,MAAM,IAAIA,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,cAAA,EAAgB,QAAQ,CAAA;gBAC3D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;gBACxB,OAAA,EAAS;oBAAE,cAAA;oBAAgB,WAAA;gBAAA;YAAY,CACzC,EACA;QAEJ;IACF;AACF;ACjiCO,IAAM,mBAAA,GAAN,cAAkC,uLAAA,CAAqB;KAC5D,EAAA,CAAA;IAEA,YAAY,MAAA,CAA4B;QACtC,KAAA,EAAM;QACN,MAAM,MAAA,GAAS,cAAc,MAAM,CAAA;QACnC,IAAA,EAAK,EAAA,GAAM,IAAI,QAAA,CAAS;YAAE,MAAA;YAAQ,UAAA,EAAY,MAAA,CAAO,UAAA;YAAY,gBAAA,EAAkB,MAAA,CAAO,gBAAA;QAAA,CAAkB,CAAA;IAC9G;IAEA,MAAM,IAAA,GAAsB;QAC1B,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,WAAWK,8KAAAA;YAAa,MAAA,EAAQ,8KAAA;QAAA,CAAa,CAAA;IAC5E;IAEA,MAAM,mBAAA,GAAqC;QACzC,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAWA,8KAAAA;QAAAA,CAAa,CAAA;IACtD;IAEA,IAAoB,eAAA,GAGlB;QACA,OAAO;YACL,SAAA,EAAW,oBAAA;YACX,SAAA,EAAW;gBAAC,oBAAA;gBAAsB,aAAa;aAAA;QAAA,CACjD;IACF;IAEA,MAAM,WAAW,IAAA,EAAqC;QACpD,MAAM,EAAE,IAAA,EAAK,GAAI,IAAA;QACjB,IAAI;YACF,MAAM,SAAA,GAAY,KAAK,SAAA,YAAqB,IAAA,GAAO,KAAK,SAAA,CAAU,WAAA,KAAgB,IAAA,CAAK,SAAA;YACvF,MAAM,OAAA,GAAU,KAAK,OAAA,YAAmB,IAAA,GAAO,KAAK,OAAA,CAAQ,WAAA,KAAgB,IAAA,CAAK,OAAA;YACjF,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;YAEnC,MAAM,MAAA,GAAS;gBACb,GAAG,IAAA;gBACH,SAAA;gBACA,OAAA;gBACA,SAAA,EAAW,GAAA;gBACX,SAAA,EAAW;YAAA,CACb;YACA,OAAO,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBAAE,SAAA,EAAWA,8KAAAA;gBAAa;YAAA,CAAQ,CAAA;QAC3D,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBACP,QAAQ,IAAA,CAAK,MAAA;oBACb,SAAS,IAAA,CAAK,OAAA;oBACd,UAAU,IAAA,CAAK,QAAA;oBACf,MAAM,IAAA,CAAK,IAAA;gBAAA;YACb,CACF,EACA;QAEJ;IACF;IAEA,MAAM,QAAQ,IAAA,EAAoD;QAChE,MAAM,EAAE,OAAA,EAAS,MAAA,EAAO,GAAI,IAAA;QAC5B,IAAI;YACF,MAAM,IAAA,GAAO,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAuB;gBACjD,SAAA,EAAWK,8KAAAA;gBACX,WAAA,EAAa;oBAAE,GAAA,EAAK,mCAAA;oBAAqC,MAAM;wBAAC,OAAA;wBAAS,MAAM;qBAAA;gBAAA,CAAE;gBACjF,KAAA,EAAO;YAAA,CACR,CAAA;YAED,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;gBAC9B,OAAO,IAAA;YACT;YAEA,OAAO;gBACL,IAAA,EAAM,oBAAgC;oBAAE,SAAA,EAAWA,8KAAAA;oBAAa,MAAA,EAAQ,IAAA,CAAK,CAAC,CAAA;gBAAA,CAAI;YAAA,CACpF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,UAAA,EAAY,QAAQ,CAAA;gBACvD,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA;oBAAS,MAAA;gBAAA;YAAO,CAC7B,EACA;QAEJ;IACF;IAEA,MAAM,YAAY,IAAA,EAA4D;QAC5E,MAAM,EAAE,OAAA,EAAQ,GAAI,IAAA;QACpB,IAAI;YACF,MAAM,IAAA,GAAO,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAuB;gBACjD,SAAA,EAAWK,8KAAAA;gBACX,aAAa;oBAAE,GAAA,EAAK;oBAA+C,IAAA,EAAM;wBAAC,OAAO;qBAAA;gBAAA,CAAE;gBACnF,KAAA,EAAO;YAAA,CACR,CAAA;YAED,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;gBAC9B,OAAO,IAAA;YACT;YAEA,OAAO;gBACL,IAAA,EAAM,oBAAgC;oBAAE,SAAA,EAAWA,8KAAAA;oBAAa,MAAA,EAAQ,IAAA,CAAK,CAAC,CAAA;gBAAA,CAAI;YAAA,CACpF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,eAAA,EAAiB,QAAQ,CAAA;gBAC5D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBAAE,OAAA;gBAAA;YAAQ,CACrB,EACA;QAEJ;IACF;IAEA,MAAM,SAAS,IAAA,EAAsD;QACnE,MAAM,EAAE,OAAA,EAAQ,GAAI,IAAA;QACpB,IAAI;YACF,MAAM,KAAA,GAAQ,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAuB;gBAClD,SAAA,EAAWK,8KAAAA;gBACX,aAAa;oBAAE,GAAA,EAAK;oBAAsB,IAAA,EAAM;wBAAC,OAAO;qBAAA;gBAAA,CAAE;gBAC1D,OAAA,EAAS;YAAA,CACV,CAAA;YAED,IAAI,CAAC,KAAA,IAAS,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;gBAChC,OAAO,IAAA;YACT;YAEA,OAAO;gBACL,OAAA;gBACA,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,CAAA,IAAA,GAAQ,mBAAA,CAAgC;wBAAE,SAAA,EAAWA,8KAAAA;wBAAa,MAAA,EAAQ,IAAA;oBAAA,CAAM,CAAC;YAAA,CACpG;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,WAAA,EAAa,QAAQ,CAAA;gBACxD,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBACP;gBAAA;YACF,CACF,EACA;QAEJ;IACF;IAEA,MAAM,WAAW,IAAA,EAAqC;QACpD,MAAM,EAAE,OAAA,EAAS,MAAA,EAAQ,OAAA,EAAQ,GAAI,IAAA;QACrC,IAAI;YACF,MAAM,IAAA,GAA4B;gBAAE,GAAG,OAAA;YAAA,CAAQ;YAC/C,IAAI,IAAA,CAAK,OAAA,YAAmB,IAAA,EAAM;gBAChC,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,WAAA,EAAY;YAC1C;YACA,IAAI,IAAA,CAAK,SAAA,YAAqB,IAAA,EAAM;gBAClC,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,WAAA,EAAY;YAC9C;YACA,IAAA,CAAK,SAAA,GAAA,aAAA,GAAY,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;YAExC,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBACpB,SAAA,EAAWK,8KAAAA;gBACX,IAAA,EAAM;oBAAE,MAAA;oBAAQ,OAAA;gBAAA,CAAQ;gBACxB;YAAA,CACD,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBACP,MAAA;oBACA;gBAAA;YACF,CACF,EACA;QAEJ;IACF;IAEA,MAAM,WAAW,IAAA,EAAoF;QAEnG,MAAM,EAAE,OAAA,EAAS,UAAA,EAAY,OAAA,EAAQ,GAAI,uLAAA,CAAqB,KAAA,CAAM,IAAI,CAAA;QACxE,MAAM,EAAE,IAAA,EAAM,OAAA,EAAQ,GAAI,UAAA;QAE1B,MAAM,SAAA,OAAYL,qLAAAA,EAAmBU,8KAAAA,EAAa,YAAY,CAAA;QAE9D,IAAI;YAEF,MAAM,UAAA,GAAuB;gBAAC,sBAAsB;aAAA;YACpD,MAAM,YAAmB,EAAC;YAE1B,IAAI,OAAA,EAAS;gBAEX,IAAI,OAAA,CAAQ,SAAA,EAAW,KAAA,EAAO;oBAC5B,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;oBAChC,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,KAAA,CAAM,WAAA,EAAa,CAAA;gBACtD;gBACA,IAAI,OAAA,CAAQ,SAAA,EAAW,GAAA,EAAK;oBAC1B,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;oBAChC,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,GAAA,CAAI,WAAA,EAAa,CAAA;gBACpD;gBACA,IAAI,OAAA,CAAQ,OAAA,EAAS,KAAA,EAAO;oBAC1B,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;oBAC9B,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,WAAA,EAAa,CAAA;gBACpD;gBACA,IAAI,OAAA,CAAQ,OAAA,EAAS,GAAA,EAAK;oBACxB,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;oBAC9B,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,GAAA,CAAI,WAAA,EAAa,CAAA;gBAClD;gBAGA,IAAI,OAAA,CAAQ,QAAA,KAAa,KAAA,CAAA,EAAW;oBAClC,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;oBAC9B,SAAA,CAAU,IAAA,CAAK,QAAQ,QAAQ,CAAA;gBACjC;gBAGA,IAAI,OAAA,CAAQ,UAAA,KAAe,KAAA,CAAA,EAAW;oBACpC,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;oBAChC,SAAA,CAAU,IAAA,CAAK,QAAQ,UAAU,CAAA;gBACnC;gBACA,IAAI,OAAA,CAAQ,QAAA,KAAa,KAAA,CAAA,EAAW;oBAClC,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;oBAC9B,SAAA,CAAU,IAAA,CAAK,QAAQ,QAAQ,CAAA;gBACjC;gBACA,IAAI,OAAA,CAAQ,UAAA,KAAe,KAAA,CAAA,EAAW;oBACpC,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;oBAChC,SAAA,CAAU,IAAA,CAAK,QAAQ,UAAU,CAAA;gBACnC;gBAGA,IAAI,OAAA,CAAQ,MAAA,KAAW,KAAA,CAAA,EAAW;oBAChC,UAAA,CAAW,IAAA,CAAK,CAAA,UAAA,CAAY,CAAA;oBAC5B,SAAA,CAAU,IAAA,CAAK,QAAQ,MAAM,CAAA;gBAC/B;gBACA,IAAI,OAAA,CAAQ,cAAA,KAAmB,KAAA,CAAA,EAAW;oBACxC,UAAA,CAAW,IAAA,CAAK,CAAA,kBAAA,CAAoB,CAAA;oBACpC,SAAA,CAAU,IAAA,CAAK,QAAQ,cAAc,CAAA;gBACvC;gBACA,IAAI,OAAA,CAAQ,UAAA,KAAe,KAAA,CAAA,EAAW;oBACpC,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;oBAChC,SAAA,CAAU,IAAA,CAAK,QAAQ,UAAU,CAAA;gBACnC;gBAGA,IAAI,OAAA,CAAQ,KAAA,KAAU,KAAA,CAAA,EAAW;oBAC/B,UAAA,CAAW,IAAA,CAAK,CAAA,SAAA,CAAW,CAAA;oBAC3B,SAAA,CAAU,IAAA,CAAK,QAAQ,KAAK,CAAA;gBAC9B;gBACA,IAAI,OAAA,CAAQ,SAAA,KAAc,KAAA,CAAA,EAAW;oBACnC,UAAA,CAAW,IAAA,CAAK,CAAA,aAAA,CAAe,CAAA;oBAC/B,SAAA,CAAU,IAAA,CAAK,QAAQ,SAAS,CAAA;gBAClC;gBACA,IAAI,OAAA,CAAQ,QAAA,KAAa,KAAA,CAAA,EAAW;oBAClC,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;oBAC9B,SAAA,CAAU,IAAA,CAAK,QAAQ,QAAQ,CAAA;gBACjC;gBACA,IAAI,OAAA,CAAQ,SAAA,KAAc,KAAA,CAAA,EAAW;oBACnC,UAAA,CAAW,IAAA,CAAK,CAAA,aAAA,CAAe,CAAA;oBAC/B,SAAA,CAAU,IAAA,CAAK,QAAQ,SAAS,CAAA;gBAClC;gBAGA,IAAI,OAAA,CAAQ,WAAA,KAAgB,KAAA,CAAA,EAAW;oBACrC,UAAA,CAAW,IAAA,CAAK,CAAA,eAAA,CAAiB,CAAA;oBACjC,SAAA,CAAU,IAAA,CAAK,QAAQ,WAAW,CAAA;gBACpC;gBACA,IAAI,OAAA,CAAQ,MAAA,KAAW,KAAA,CAAA,EAAW;oBAChC,UAAA,CAAW,IAAA,CAAK,CAAA,UAAA,CAAY,CAAA;oBAC5B,SAAA,CAAU,IAAA,CAAK,QAAQ,MAAM,CAAA;gBAC/B;gBACA,IAAI,OAAA,CAAQ,WAAA,KAAgB,KAAA,CAAA,EAAW;oBACrC,UAAA,CAAW,IAAA,CAAK,CAAA,eAAA,CAAiB,CAAA;oBACjC,SAAA,CAAU,IAAA,CAAK,QAAQ,WAAW,CAAA;gBACpC;gBAGA,IAAI,OAAA,CAAQ,KAAA,IAAS,IAAA,EAAM;oBAEzB,KAAA,MAAW,CAAC,KAAK,KAAK,CAAA,IAAK,OAAO,OAAA,CAAQ,OAAA,CAAQ,KAAK,CAAA,CAAG;wBAExD,IAAI,CAAC,0BAAA,CAA2B,IAAA,CAAK,GAAG,CAAA,EAAG;4BACzC,MAAM,IAAIP,8KAAAA,CAAY;gCACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,oBAAoB,CAAA;gCACtE,QAAQH,8KAAAA,CAAY,OAAA;gCACpB,UAAUC,gLAAAA,CAAc,IAAA;gCACxB,OAAA,EAAS;oCAAE,GAAA;gCAAA;4BAAI,CAChB,CAAA;wBACH;wBACA,UAAA,CAAW,IAAA,CAAK,CAAA,uBAAA,EAA0B,GAAG,CAAA,MAAA,CAAQ,CAAA;wBACrD,SAAA,CAAU,IAAA,CAAK,OAAO,KAAA,KAAU,QAAA,GAAW,QAAQ,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA;oBAC1E;gBACF;gBAGA,IAAI,OAAA,CAAQ,QAAA,IAAY,IAAA,EAAM;oBAC5B,KAAA,MAAW,CAAC,KAAK,KAAK,CAAA,IAAK,OAAO,OAAA,CAAQ,OAAA,CAAQ,QAAQ,CAAA,CAAG;wBAE3D,IAAI,CAAC,0BAAA,CAA2B,IAAA,CAAK,GAAG,CAAA,EAAG;4BACzC,MAAM,IAAIF,8KAAAA,CAAY;gCACpB,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,oBAAoB,CAAA;gCACtE,QAAQH,8KAAAA,CAAY,OAAA;gCACpB,UAAUC,gLAAAA,CAAc,IAAA;gCACxB,OAAA,EAAS;oCAAE,GAAA;gCAAA;4BAAI,CAChB,CAAA;wBACH;wBACA,UAAA,CAAW,IAAA,CAAK,CAAA,0BAAA,EAA6B,GAAG,CAAA,MAAA,CAAQ,CAAA;wBACxD,SAAA,CAAU,IAAA,CAAK,OAAO,KAAA,KAAU,QAAA,GAAW,QAAQ,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA;oBAC1E;gBACF;gBAGA,IAAI,QAAQ,IAAA,IAAQ,IAAA,IAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG;oBAEnD,KAAA,MAAW,GAAA,IAAO,QAAQ,IAAA,CAAM;wBAC9B,UAAA,CAAW,IAAA,CAAK,CAAA,gCAAA,EAAmC,SAAS,CAAA,uBAAA,CAAyB,CAAA;wBACrF,SAAA,CAAU,IAAA,CAAK,GAAG,CAAA;oBACpB;gBACF;gBAGA,IAAI,OAAA,CAAQ,MAAA,KAAW,KAAA,CAAA,EAAW;oBAChC,OAAQ,QAAQ,MAAA;wBACd,KAAK,8KAAA,CAAY,KAAA;4BACf,UAAA,CAAW,IAAA,CAAK,CAAA,iBAAA,CAAmB,CAAA;4BACnC;wBACF,KAAK,8KAAA,CAAY,OAAA;4BACf,UAAA,CAAW,IAAA,CAAK,CAAA,iCAAA,CAAmC,CAAA;4BACnD;wBACF,KAAK,8KAAA,CAAY,OAAA;4BACf,UAAA,CAAW,IAAA,CAAK,CAAA,qCAAA,CAAuC,CAAA;4BACvD;oBAAA;gBAEN;gBAGA,IAAI,OAAA,CAAQ,aAAA,KAAkB,KAAA,CAAA,EAAW;oBACvC,IAAI,QAAQ,aAAA,EAAe;wBACzB,UAAA,CAAW,IAAA,CAAK,CAAA;4BAAA,EACE,SAAS,CAAA;gCAAA,EACL,SAAS,CAAA;aAAA,CAC7B,CAAA;oBACJ,CAAA,MAAO;wBACL,UAAA,CAAW,IAAA,CAAK,CAAA;4BAAA,EACE,SAAS,CAAA;gCAAA,EACL,SAAS,CAAA;aAAA,CAC7B,CAAA;oBACJ;gBACF;YACF;YAEA,MAAM,WAAA,GAAc,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,MAAA,EAAS,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;YAUlF,MAAM,YAAY,OAAA,CAAQ,KAAA;YAC1B,MAAM,gBAAgB,OAAA,CAAQ,SAAA;YAC9B,IAAI,aAAA;YACJ,IAAI,cAAc,SAAA,EAAW;gBAG3B,aAAA,GACE,aAAA,KAAkB,MAAA,GACd,CAAA,UAAA,EAAa,SAAS,CAAA,4BAAA,EAA+B,SAAS,CAAA,KAAA,CAAA,GAC9D,CAAA,UAAA,EAAa,SAAS,CAAA,4BAAA,EAA+B,SAAS,CAAA,IAAA,CAAA;YACtE,CAAA,MAAO;gBACL,aAAA,GAAgB,CAAA,EAAG,SAAS,CAAA,CAAA,EAAI,aAAa,CAAA,CAAA;YAC/C;YAGA,MAAM,KAAA,GAAQ,MAAM,IAAA,EAAK,EAAA,CAAI,gBAAA,CAAiB;gBAC5C,SAAA,EAAWK,8KAAAA;gBACX,WAAA,EAAa;oBAAE,GAAA,EAAK,WAAA;oBAAa,MAAM,SAAA;gBAAA;YAAU,CAClD,CAAA;YAED,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,UAAA,EAAY;wBACV,KAAA,EAAO,CAAA;wBACP,IAAA;wBACA,OAAA;wBACA,OAAA,EAAS;oBAAA,CACX;oBACA,OAAO,EAAA;gBAAC,CACV;YACF;YAGA,MAAM,KAAA,GAAQ,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAuB;gBAClD,SAAA,EAAWA,8KAAAA;gBACX,WAAA,EAAa;oBAAE,GAAA,EAAK,WAAA;oBAAa,MAAM,SAAA;gBAAA,CAAU;gBACjD,OAAA,EAAS,aAAA;gBACT,QAAQ,IAAA,GAAO,OAAA;gBACf,KAAA,EAAO;YAAA,CACR,CAAA;YAED,OAAO;gBACL,UAAA,EAAY;oBACV,KAAA,EAAO,KAAA;oBACP,IAAA;oBACA,OAAA;oBACA,OAAA,EAAA,CAAU,IAAA,GAAO,CAAA,IAAK,OAAA,GAAU;gBAAA,CAClC;gBACA,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,CAAA,IAAA,GAAQ,mBAAA,CAAgC;wBAAE,SAAA,EAAWA,8KAAAA;wBAAa,MAAA,EAAQ,IAAA;oBAAA,CAAM,CAAC;YAAA,CACpG;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,aAAA,EAAe,QAAQ,CAAA;gBAC1D,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,iBAAiB,IAAA,EAA2C;QAChE,IAAI;YACF,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;YACnC,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,CAAA,MAAA,KAAU;gBACzC,MAAM,SAAA,GAAY,OAAO,SAAA,YAAqB,IAAA,GAAO,OAAO,SAAA,CAAU,WAAA,KAAgB,MAAA,CAAO,SAAA;gBAC7F,MAAM,OAAA,GAAU,OAAO,OAAA,YAAmB,IAAA,GAAO,OAAO,OAAA,CAAQ,WAAA,KAAgB,MAAA,CAAO,OAAA;gBAEvF,OAAO;oBACL,GAAG,MAAA;oBACH,SAAA;oBACA,OAAA;oBACA,SAAA,EAAW,GAAA;oBACX,SAAA,EAAW;gBAAA,CACb;YACF,CAAC,CAAA;YAED,OAAO,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;gBAC1B,SAAA,EAAWK,8KAAAA;gBACX;YAAA,CACD,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,oBAAA,EAAsB,QAAQ,CAAA;gBACjE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,iBAAiB,IAAA,EAA2C;QAChE,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;QAEnC,IAAI;YACF,OAAO,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;gBAC1B,SAAA,EAAWK,8KAAAA;gBACX,OAAA,EAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,CAAA,MAAA,KAAU;oBAClC,MAAM,IAAA,GAA4B;wBAAE,GAAG,MAAA,CAAO,OAAA;oBAAA,CAAQ;oBACtD,IAAI,IAAA,CAAK,OAAA,YAAmB,IAAA,EAAM;wBAChC,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,WAAA,EAAY;oBAC1C;oBACA,IAAI,IAAA,CAAK,SAAA,YAAqB,IAAA,EAAM;wBAClC,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,WAAA,EAAY;oBAC9C;oBACA,IAAA,CAAK,SAAA,GAAY,GAAA;oBAEjB,OAAO;wBACL,MAAM;4BAAE,MAAA,EAAQ,OAAO,MAAA;4BAAQ,OAAA,EAAS,OAAO,OAAA;wBAAA,CAAQ;wBACvD;oBAAA,CACF;gBACF,CAAC;YAAA,CACF,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,oBAAA,EAAsB,QAAQ,CAAA;gBACjE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,kBAAkB,IAAA,EAA4C;QAClE,IAAI;YACF,MAAM,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,CAAA,OAAA,GAAA,CAAY;oBAAE;gBAAA,CAAQ,CAAE,CAAA;YACvD,OAAO,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;gBAC1B,SAAA,EAAWK,8KAAAA;gBACX;YAAA,CACD,CAAA;QACH,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIP,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,qBAAA,EAAuB,QAAQ,CAAA;gBAClE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;YAAA,CAC1B,EACA;QAEJ;IACF;AACF;AC5gBO,IAAM,YAAA,GAAN,cAA2B,gLAAA,CAAc;KAC9C,EAAA,CAAA;KACA,MAAA,CAAA;IAEA,YAAY,MAAA,CAA4B;QACtC,KAAA,EAAM;QACN,MAAM,MAAA,GAAS,cAAc,MAAM,CAAA;QACnC,IAAA,EAAK,MAAA,GAAU,MAAA;QACf,IAAA,EAAK,EAAA,GAAM,IAAI,QAAA,CAAS;YAAE,MAAA;YAAQ,UAAA,EAAY,MAAA,CAAO,UAAA;YAAY,gBAAA,EAAkB,MAAA,CAAO,gBAAA;QAAA,CAAkB,CAAA;IAC9G;IAEA,MAAM,IAAA,GAAsB;QAC1B,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,WAAW,gLAAA;YAAe,MAAA,EAAQ,iLAAA;QAAA,CAAgB,CAAA;QAE/E,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YACxB,SAAA,EAAW,gLAAA;YACX,MAAA,EAAQ,iLAAA;YACR,WAAA,EAAa;gBAAC,QAAA;gBAAU,gBAAgB;aAAA;QAAA,CACzC,CAAA;IACH;IAEA,MAAM,mBAAA,GAAqC;QACzC,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAW,gLAAA;QAAA,CAAe,CAAA;IACxD;IAEA,MAAM,iBAAA,CAAkB,EACtB,KAAA,EACA,UAAA,EACF,EAGgC;QAC9B,IAAI;YACF,MAAM,EAAE,IAAA,EAAM,OAAA,EAAS,YAAA,EAAa,GAAI,UAAA;YAGxC,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC7C,GAAA,EAAK,CAAA,8BAAA,EAAiC,gLAAa,CAAA,gBAAA,CAAA;gBACnD,IAAA,EAAM;oBAAC,KAAK;iBAAA;YAAA,CACb,CAAA;YACD,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAEtD,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,UAAA,EAAY;wBACV,KAAA,EAAO,CAAA;wBACP,IAAA;wBACA,OAAA,EAAS,YAAA;wBACT,OAAA,EAAS;oBAAA,CACX;oBACA,QAAQ,EAAA;gBAAC,CACX;YACF;YAEA,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;YAClD,MAAM,EAAE,QAAQ,KAAA,EAAO,OAAA,EAAS,kBAAA,EAAmB,OAAIC,sLAAAA,EAAoB,IAAA,EAAM,YAAA,EAAc,OAAO,CAAA;YACtG,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,GAAA,GAAM,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,KAAA,GAAQ,OAAA;YAErD,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,KAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,MAAA,EAAS,gLAAa,CAAA,yDAAA,CAAA;gBACtE,IAAA,EAAM;oBAAC,KAAA;oBAAO,UAAA;oBAAY,KAAK;iBAAA;YAAA,CAChC,CAAA;YAED,MAAM,MAAA,GAAS,MAAA,CAAO,IAAA,EAAM,GAAA,CAAI,CAAA,GAAA,GAAO,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAC,CAAA,IAAK,EAAC;YAExE,OAAO;gBACL,MAAA;gBACA,UAAA,EAAY;oBACV,KAAA;oBACA,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,SAAS,GAAA,GAAM;gBAAA;YACjB,CACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIN,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,uBAAA,EAAyB,QAAQ,CAAA;gBACpE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,oBAAA,CAAqB,EACzB,QAAA,EACA,QAAA,EACA,UAAA,EACA,MAAA,EACA,UAAA,EACF,EAMgC;QAC9B,IAAI;YACF,MAAM,EAAE,IAAA,EAAM,OAAA,EAAS,YAAA,EAAa,GAAI,UAAA;YAExC,MAAM,aAAuB,EAAC;YAC9B,MAAM,cAAyB,EAAC;YAEhC,IAAI,QAAA,EAAU;gBACZ,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;gBAC9B,WAAA,CAAY,IAAA,CAAK,QAAQ,CAAA;YAC3B;YAEA,IAAI,QAAA,EAAU;gBACZ,UAAA,CAAW,IAAA,CAAK,CAAA,YAAA,CAAc,CAAA;gBAC9B,WAAA,CAAY,IAAA,CAAK,QAAQ,CAAA;YAC3B;YAEA,IAAI,UAAA,EAAY;gBACd,UAAA,CAAW,IAAA,CAAK,CAAA,cAAA,CAAgB,CAAA;gBAChC,WAAA,CAAY,IAAA,CAAK,UAAU,CAAA;YAC7B;YAEA,IAAI,MAAA,EAAQ;gBACV,UAAA,CAAW,IAAA,CAAK,CAAA,UAAA,CAAY,CAAA;gBAC5B,WAAA,CAAY,IAAA,CAAK,MAAM,CAAA;YACzB;YAEA,MAAM,WAAA,GAAc,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,MAAA,EAAS,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;YAGlF,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC7C,GAAA,EAAK,CAAA,8BAAA,EAAiC,gLAAa,CAAA,CAAA,EAAI,WAAW,CAAA,CAAA;gBAClE,IAAA,EAAM;YAAA,CACP,CAAA;YACD,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAEtD,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,UAAA,EAAY;wBACV,KAAA,EAAO,CAAA;wBACP,IAAA;wBACA,OAAA,EAAS,YAAA;wBACT,OAAA,EAAS;oBAAA,CACX;oBACA,QAAQ,EAAA;gBAAC,CACX;YACF;YAEA,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;YAClD,MAAM,EAAE,QAAQ,KAAA,EAAO,OAAA,EAAS,kBAAA,EAAmB,OAAIC,sLAAAA,EAAoB,IAAA,EAAM,YAAA,EAAc,OAAO,CAAA;YACtG,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,GAAA,GAAM,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,KAAA,GAAQ,OAAA;YAErD,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,GAAA,EAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,MAAA,EAAS,gLAAa,CAAA,CAAA,EAAI,WAAW,CAAA,yCAAA,CAAA;gBACrF,IAAA,EAAM,CAAC;uBAAG,WAAA;oBAAa;oBAAY,KAAK;iBAAA;YAAA,CACzC,CAAA;YAED,MAAM,MAAA,GAAS,MAAA,CAAO,IAAA,EAAM,GAAA,CAAI,CAAA,GAAA,GAAO,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAC,CAAA,IAAK,EAAC;YAExE,OAAO;gBACL,MAAA;gBACA,UAAA,EAAY;oBACV,KAAA;oBACA,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,SAAS,GAAA,GAAM;gBAAA;YACjB,CACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIN,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,0BAAA,EAA4B,QAAQ,CAAA;gBACvE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAAA;;GAAA,GAKQ,kBAAkB,GAAA,EAAwC;QAChE,WAAOM,oLAAAA,EAAsB,GAAG,CAAA;IAClC;IAEA,MAAM,YAAA,CAAa,EAAE,EAAA,EAAG,EAAiD;QACvE,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;YACxC,KAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,MAAA,EAAS,gLAAa,CAAA,aAAA,CAAA;YACtE,IAAA,EAAM;gBAAC,EAAE;aAAA;QAAA,CACV,CAAA;QACD,OAAO,MAAA,CAAO,IAAA,EAAA,CAAO,CAAC,CAAA,GAAI,IAAA,CAAK,iBAAA,CAAkB,MAAA,CAAO,IAAA,CAAK,CAAC,CAAC,CAAA,GAAI,IAAA;IACrE;IAEA,MAAM,UAAU,KAAA,EAA2D;QACzE,IAAI,WAAA;QACJ,IAAI;YACF,WAAA,GAAc,yLAAA,CAAuB,KAAA,CAAM,KAAK,CAAA;QAClD,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIR,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,YAAA,EAAc,mBAAmB,CAAA;gBACpE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,IAAA;gBACxB,OAAA,EAAS;oBACP,MAAA,EAAQ,OAAO,KAAA,CAAM,MAAA,EAAQ,EAAA,KAAO,QAAA,GAAW,KAAA,CAAM,MAAA,CAAO,EAAA,GAAK,MAAA,CAAO,KAAA,CAAM,MAAA,EAAQ,MAAM,SAAS,CAAA;oBACrG,QAAA,EAAU,MAAM,QAAA,IAAY,SAAA;oBAC5B,UAAA,EAAY,MAAM,UAAA,IAAc,SAAA;oBAChC,OAAA,EAAS,MAAM,OAAA,IAAW,EAAA;oBAC1B,MAAA,EAAQ,MAAM,MAAA,IAAU;gBAAA;YAC1B,CACF,EACA;QAEJ;QAEA,IAAI;YACF,MAAM,EAAA,GAAK,OAAO,UAAA,EAAW;YAC7B,MAAM,GAAA,GAAA,aAAA,GAAA,IAAU,IAAA,EAAK;YAErB,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;gBACpB,SAAA,EAAW,gLAAA;gBACX,MAAA,EAAQ;oBACN,GAAG,WAAA;oBACH,EAAA;oBACA,SAAA,EAAW,IAAI,WAAA,EAAY;oBAC3B,SAAA,EAAW,IAAI,WAAA;gBAAY;YAC7B,CACD,CAAA;YAED,OAAO;gBAAE,KAAA,EAAO;oBAAE,GAAG,WAAA;oBAAa;oBAAI,SAAA,EAAW,GAAA;oBAAK,SAAA,EAAW,GAAA;gBAAA,CAAI;YAAA,CAAkB;QACzF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIF,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,YAAA,EAAc,QAAQ,CAAA;gBACzD,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,oBAAA,CAAqB,EACzB,QAAA,EACA,UAAA,EACA,UAAA,EACF,EAIgC;QAC9B,IAAI;YACF,MAAM,EAAE,IAAA,EAAM,OAAA,EAAS,YAAA,EAAa,GAAI,UAAA;YAGxC,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAC7C,GAAA,EAAK,CAAA,8BAAA,EAAiC,gLAAa,CAAA,sCAAA,CAAA;gBACnD,IAAA,EAAM;oBAAC,QAAA;oBAAU,UAAU;iBAAA;YAAA,CAC5B,CAAA;YACD,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAEtD,IAAI,UAAU,CAAA,EAAG;gBACf,OAAO;oBACL,UAAA,EAAY;wBACV,KAAA,EAAO,CAAA;wBACP,IAAA;wBACA,OAAA,EAAS,YAAA;wBACT,OAAA,EAAS;oBAAA,CACX;oBACA,QAAQ,EAAA;gBAAC,CACX;YACF;YAEA,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;YAClD,MAAM,EAAE,QAAQ,KAAA,EAAO,OAAA,EAAS,kBAAA,EAAmB,OAAIC,sLAAAA,EAAoB,IAAA,EAAM,YAAA,EAAc,OAAO,CAAA;YACtG,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,GAAA,GAAM,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,KAAA,GAAQ,OAAA;YAErD,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,KAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,MAAA,EAAS,gLAAa,CAAA,+EAAA,CAAA;gBACtE,IAAA,EAAM;oBAAC,QAAA;oBAAU,UAAA;oBAAY;oBAAY,KAAK;iBAAA;YAAA,CAC/C,CAAA;YAED,MAAM,MAAA,GAAS,MAAA,CAAO,IAAA,EAAM,GAAA,CAAI,CAAA,GAAA,GAAO,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAC,CAAA,IAAK,EAAC;YAExE,OAAO;gBACL,MAAA;gBACA,UAAA,EAAY;oBACV,KAAA;oBACA,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,SAAS,GAAA,GAAM;gBAAA;YACjB,CACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIN,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,0BAAA,EAA4B,QAAQ,CAAA;gBACvE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,gBAAA,CAAiB,EACrB,OAAA,EACA,MAAA,EACA,UAAA,EACF,EAIgC;QAC9B,IAAI;YACF,MAAM,EAAE,IAAA,EAAM,OAAA,EAAS,YAAA,EAAa,GAAI,UAAA;YACxC,MAAM,OAAA,OAAUG,mLAAAA,EAAiB,YAAA,EAAc,GAAG,CAAA;YAClD,MAAM,EAAE,QAAQ,KAAA,EAAO,OAAA,EAAS,kBAAA,EAAmB,OAAIC,sLAAAA,EAAoB,IAAA,EAAM,YAAA,EAAc,OAAO,CAAA;YAEtG,MAAM,cAAA,GAAiB,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBAChD,GAAA,EAAK,CAAA,8BAAA,EAAiC,gLAAa,CAAA,iCAAA,CAAA;gBACnD,IAAA,EAAM;oBAAC,OAAA;oBAAS,MAAM;iBAAA;YAAA,CACvB,CAAA;YAED,MAAM,QAAQ,MAAA,CAAO,cAAA,CAAe,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAEzD,MAAM,UAAA,GAAa,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,OAAA;YACpD,MAAM,GAAA,GAAM,YAAA,KAAiB,KAAA,GAAQ,KAAA,GAAQ,KAAA,GAAQ,OAAA;YAErD,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,KAAK,CAAA,OAAA,EAAU,kBAAA,CAAmB,gLAAa,CAAC,CAAA,MAAA,EAAS,gLAAa,CAAA,0EAAA,CAAA;gBACtE,IAAA,EAAM;oBAAC,OAAA;oBAAS,MAAA;oBAAQ;oBAAY,KAAK;iBAAA;YAAA,CAC1C,CAAA;YAED,MAAM,MAAA,GAAS,MAAA,CAAO,IAAA,EAAM,GAAA,CAAI,CAAA,GAAA,GAAO,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAC,CAAA,IAAK,EAAC;YAExE,OAAO;gBACL,MAAA;gBACA,UAAA,EAAY;oBACV,KAAA;oBACA,IAAA;oBACA,OAAA,EAAS,kBAAA;oBACT,SAAS,GAAA,GAAM;gBAAA;YACjB,CACF;QACF,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIN,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,qBAAA,EAAuB,QAAQ,CAAA;gBAClE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;AACF;ACrWO,IAAM,eAAA,GAAN,cAA8B,mLAAA,CAAiB;KACpD,EAAA,CAAA;KACA,MAAA,CAAA;IACiB,gBAAA,CAAA;IAEjB,YAAY,MAAA,CAA4B;QACtC,KAAA,EAAM;QACN,MAAM,MAAA,GAAS,cAAc,MAAM,CAAA;QACnC,MAAM,UAAA,GAAa,OAAO,UAAA,IAAc,CAAA;QACxC,MAAM,gBAAA,GAAmB,OAAO,gBAAA,IAAoB,GAAA;QAEpD,IAAA,EAAK,MAAA,GAAU,MAAA;QACf,IAAA,EAAK,EAAA,GAAM,IAAI,QAAA,CAAS;YAAE,MAAA;YAAQ,UAAA;YAAY;QAAA,CAAkB,CAAA;QAChE,IAAA,CAAK,gBAAA,GAAmB,oCAAA,CAAqC;YAC3D,QAAQ,IAAA,CAAK,MAAA;YACb,UAAA;YACA;QAAA,CACD,CAAA;QAID,IAAA,CAAK,mBAAA,EAAoB,CAAE,KAAA,CAAM,CAAA,GAAA,GAC/B,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,sDAAsD,GAAG;IAE9E;IAEQ,iBAAiB,GAAA,EAAuC;QAC9D,IAAI,iBAA4C,GAAA,CAAI,QAAA;QACpD,IAAI,OAAO,mBAAmB,QAAA,EAAU;YACtC,IAAI;gBACF,cAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAkB,CAAA;YACpD,EAAA,OAAS,CAAA,EAAG;gBACV,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,sCAAA,EAAyC,IAAI,aAAa,CAAA,EAAA,EAAK,CAAC,CAAA,CAAE,CAAA;YACrF;QACF;QACA,OAAO;YACL,cAAc,GAAA,CAAI,aAAA;YAClB,OAAO,GAAA,CAAI,MAAA;YACX,QAAA,EAAU,cAAA;YACV,YAAY,GAAA,CAAI,UAAA;YAChB,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB,CAAA;YAC3C,SAAA,EAAW,IAAI,IAAA,CAAK,GAAA,CAAI,SAAmB;QAAA,CAC7C;IACF;IAEA,MAAM,IAAA,GAAsB;QAC1B,MAAM,MAAA,GAASC,gLAAAA,CAAcM,0LAAuB,CAAA;QACpD,MAAM,IAAA,EAAK,EAAA,CAAI,WAAA,CAAY;YAAE,SAAA,EAAWA,0LAAAA;YAAyB;QAAA,CAAQ,CAAA;QAEzE,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YACxB,SAAA,EAAWA,0LAAAA;YACX,MAAA;YACA,WAAA,EAAa;gBAAC,YAAY;aAAA;QAAA,CAC3B,CAAA;IACH;IAEA,MAAM,mBAAA,GAAqC;QACzC,MAAM,IAAA,EAAK,EAAA,CAAI,UAAA,CAAW;YAAE,SAAA,EAAWA,0LAAAA;QAAAA,CAAyB,CAAA;IAClE;IAEA,MAAc,mBAAA,GAAsB;QAClC,IAAI;YAEF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ,8BAA8B,CAAA;YACzD,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,kDAAkD,CAAA;YAGpE,IAAI;gBACF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ,4BAA4B,CAAA;gBACvD,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,gDAAgD,CAAA;YACpE,CAAA,CAAA,OAAQ;gBACN,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,uEAAuE,CAAA;YAC3F;YAGA,IAAI;gBACF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ,8BAA8B,CAAA;gBACzD,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,kDAAkD,CAAA;YACtE,CAAA,CAAA,OAAQ;gBACN,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,mDAAmD,CAAA;YACvE;QACF,EAAA,OAAS,GAAA,EAAK;YACZ,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,kDAAA,EAAoD,GAAG,CAAA;QAC1E;IACF;IAEA,MAAM,qBAAA,CAAsB,EAC1B,YAAA,EACA,KAAA,EACA,MAAA,EACA,MAAA,EACA,cAAA,EACF,EAM4D;QAC1D,OAAO,IAAA,CAAK,gBAAA,CAAiB,YAAY;YAEvC,MAAM,EAAA,GAAK,MAAM,IAAA,EAAK,MAAA,CAAQ,WAAA,CAAY,OAAO,CAAA;YACjD,IAAI;gBAEF,MAAM,sBAAA,GAAyB,MAAM,EAAA,CAAG,OAAA,CAAQ;oBAC9C,GAAA,EAAK,CAAA,uCAAA,EAA0CA,0LAAuB,CAAA,uCAAA,CAAA;oBACtE,IAAA,EAAM;wBAAC,YAAA;wBAAc,KAAK;qBAAA;gBAAA,CAC3B,CAAA;gBAED,IAAI,QAAA;gBACJ,IAAI,CAAC,sBAAA,CAAuB,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG;oBAErC,QAAA,GAAW;wBACT,SAAS,CAAA,CAAC;wBACV,aAAa,EAAC;wBACd,SAAA,EAAW,KAAK,GAAA,EAAI;wBACpB,gBAAgB,CAAA,CAAC;wBACjB,iBAAiB,CAAA,CAAC;wBAClB,cAAc,CAAA,CAAC;wBACf,qBAAqB,EAAC;wBACtB,MAAA,EAAQ,SAAA;wBACR,OAAO,CAAA,CAAC;wBACR,cAAc,CAAA,CAAC;wBACf,KAAA;wBACA,gBAAgB,CAAA;oBAAC,CACnB;gBACF,CAAA,MAAO;oBAEL,MAAM,gBAAA,GAAmB,sBAAA,CAAuB,IAAA,CAAK,CAAC,CAAA,CAAE,QAAA;oBACxD,QAAA,GAAW,OAAO,gBAAA,KAAqB,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,gBAAgB,CAAA,GAAI,gBAAA;gBACnF;gBAGA,QAAA,CAAS,OAAA,CAAQ,MAAM,CAAA,GAAI,MAAA;gBAC3B,QAAA,CAAS,cAAA,GAAiB;oBAAE,GAAG,QAAA,CAAS,cAAA;oBAAgB,GAAG,cAAA;gBAAA,CAAe;gBAG1E,MAAM,GAAA,GAAA,aAAA,GAAM,IAAI,IAAA,EAAK,CAAE,WAAA,EAAY;gBACnC,MAAM,GAAG,OAAA,CAAQ;oBACf,GAAA,EAAK,CAAA,YAAA,EAAeA,0LAAuB,CAAA;;;0FAAA,CAAA;oBAI3C,IAAA,EAAM;wBAAC,YAAA;wBAAc,KAAA;wBAAO,KAAK,SAAA,CAAU,QAAQ,CAAA;wBAAG,GAAA;wBAAK,GAAG;qBAAA;gBAAA,CAC/D,CAAA;gBAED,MAAM,GAAG,MAAA,EAAO;gBAChB,OAAO,QAAA,CAAS,OAAA;YAClB,EAAA,OAAS,KAAA,EAAO;gBACd,IAAI,CAAC,GAAG,MAAA,EAAQ;oBACd,MAAM,GAAG,QAAA,EAAS;gBACpB;gBACA,MAAM,KAAA;YACR;QACF,GAAG,uBAAuB,CAAA;IAC5B;IAEA,MAAM,mBAAA,CAAoB,EACxB,YAAA,EACA,KAAA,EACA,IAAA,EACF,EAI0C;QACxC,OAAO,IAAA,CAAK,gBAAA,CAAiB,YAAY;YAEvC,MAAM,EAAA,GAAK,MAAM,IAAA,EAAK,MAAA,CAAQ,WAAA,CAAY,OAAO,CAAA;YACjD,IAAI;gBAEF,MAAM,sBAAA,GAAyB,MAAM,EAAA,CAAG,OAAA,CAAQ;oBAC9C,GAAA,EAAK,CAAA,uCAAA,EAA0CA,0LAAuB,CAAA,uCAAA,CAAA;oBACtE,IAAA,EAAM;wBAAC,YAAA;wBAAc,KAAK;qBAAA;gBAAA,CAC3B,CAAA;gBAED,IAAI,CAAC,sBAAA,CAAuB,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG;oBACrC,MAAM,GAAG,QAAA,EAAS;oBAClB,OAAO,KAAA,CAAA;gBACT;gBAGA,MAAM,gBAAA,GAAmB,sBAAA,CAAuB,IAAA,CAAK,CAAC,CAAA,CAAE,QAAA;gBACxD,MAAM,WAAW,OAAO,gBAAA,KAAqB,WAAW,IAAA,CAAK,KAAA,CAAM,gBAAgB,CAAA,GAAI,gBAAA;gBAEvF,IAAI,CAAC,QAAA,IAAY,CAAC,QAAA,EAAU,OAAA,EAAS;oBACnC,MAAM,GAAG,QAAA,EAAS;oBAClB,MAAM,IAAI,KAAA,CAAM,CAAA,6BAAA,EAAgC,KAAK,CAAA,CAAE,CAAA;gBACzD;gBAGA,MAAM,eAAA,GAAkB;oBAAE,GAAG,QAAA;oBAAU,GAAG,IAAA;gBAAA,CAAK;gBAG/C,MAAM,GAAG,OAAA,CAAQ;oBACf,GAAA,EAAK,CAAA,OAAA,EAAUA,0LAAuB,CAAA,+DAAA,CAAA;oBACtC,MAAM;wBAAC,IAAA,CAAK,SAAA,CAAU,eAAe,CAAA;wBAAG;wBAAc,KAAK;qBAAA;gBAAA,CAC5D,CAAA;gBAED,MAAM,GAAG,MAAA,EAAO;gBAChB,OAAO,eAAA;YACT,EAAA,OAAS,KAAA,EAAO;gBACd,IAAI,CAAC,GAAG,MAAA,EAAQ;oBACd,MAAM,GAAG,QAAA,EAAS;gBACpB;gBACA,MAAM,KAAA;YACR;QACF,GAAG,qBAAqB,CAAA;IAC1B;IAEA,MAAM,uBAAA,CAAwB,EAC5B,YAAA,EACA,KAAA,EACA,UAAA,EACA,QAAA,EACA,SAAA,EACA,SAAA,EACF,EAOG;QACD,MAAM,GAAA,GAAA,aAAA,GAAA,IAAU,IAAA,EAAK;QACrB,MAAM,IAAA,GAAO;YACX,aAAA,EAAe,YAAA;YACf,MAAA,EAAQ,KAAA;YACR,UAAA;YACA,QAAA;YACA,WAAW,SAAA,IAAa,GAAA;YACxB,WAAW,SAAA,IAAa;QAAA,CAC1B;QAEA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,8BAAA,EAAgC;YAAE,YAAA;YAAc,KAAA;YAAO;QAAA,CAAM,CAAA;QAC/E,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAO;YACpB,SAAA,EAAWA,0LAAAA;YACX,MAAA,EAAQ;QAAA,CACT,CAAA;IACH;IAEA,MAAM,oBAAA,CAAqB,EACzB,YAAA,EACA,KAAA,EACF,EAGqC;QACnC,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,2BAAA,EAA6B;YAAE,YAAA;YAAc;QAAA,CAAO,CAAA;QACtE,MAAM,CAAA,GAAI,MAAM,IAAA,EAAK,EAAA,CAAI,MAAA,CAAuC;YAC9D,SAAA,EAAWA,0LAAAA;YACX,IAAA,EAAM;gBAAE,aAAA,EAAe,YAAA;gBAAc,QAAQ,KAAA;YAAA;QAAM,CACpD,CAAA;QAED,OAAO,CAAA,GAAI,EAAE,QAAA,GAAW,IAAA;IAC1B;IAEA,MAAM,kBAAA,CAAmB,EACvB,KAAA,EACA,YAAA,EACF,EAGgC;QAC9B,MAAM,aAAuB,EAAC;QAC9B,MAAM,OAA4B,EAAC;QAEnC,IAAI,KAAA,EAAO;YACT,UAAA,CAAW,IAAA,CAAK,YAAY,CAAA;YAC5B,IAAA,CAAK,IAAA,CAAK,KAAK,CAAA;QACjB;QAEA,IAAI,YAAA,EAAc;YAChB,UAAA,CAAW,IAAA,CAAK,mBAAmB,CAAA;YACnC,IAAA,CAAK,IAAA,CAAK,YAAY,CAAA;QACxB;QAEA,MAAM,WAAA,GAAc,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,MAAA,EAAS,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;QAElF,IAAI;YACF,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,GAAA,EAAK,CAAA,gGAAA,EAAmGA,0LAAuB,CAAA,CAAA,EAAI,WAAW,CAAA,gCAAA,CAAA;gBAC9I;YAAA,CACD,CAAA;YAED,IAAI,CAAC,MAAA,CAAO,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG;gBACrB,OAAO,IAAA;YACT;YAEA,OAAO,IAAA,CAAK,gBAAA,CAAiB,MAAA,CAAO,IAAA,CAAK,CAAC,CAAC,CAAA;QAC7C,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIT,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,wBAAA,EAA0B,QAAQ,CAAA;gBACrE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;IAEA,MAAM,qBAAA,CAAsB,EAAE,KAAA,EAAO,YAAA,EAAa,EAA2D;QAC3G,OAAO,IAAA,CAAK,gBAAA,CAAiB,YAAY;YACvC,IAAI;gBACF,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;oBACzB,GAAA,EAAK,CAAA,YAAA,EAAeO,0LAAuB,CAAA,uCAAA,CAAA;oBAC3C,IAAA,EAAM;wBAAC,YAAA;wBAAc,KAAK;qBAAA;gBAAA,CAC3B,CAAA;YACH,EAAA,OAAS,KAAA,EAAO;gBACd,MAAM,IAAIT,8KAAAA,CACR;oBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,2BAAA,EAA6B,QAAQ,CAAA;oBACxE,QAAQH,8KAAAA,CAAY,OAAA;oBACpB,UAAUC,gLAAAA,CAAc,WAAA;oBACxB,OAAA,EAAS;wBAAE,KAAA;wBAAO,YAAA;oBAAA;gBAAa,CACjC,EACA;YAEJ;QACF,GAAG,uBAAuB,CAAA;IAC5B;IAEA,MAAM,gBAAA,CAAiB,EACrB,YAAA,EACA,QAAA,EACA,MAAA,EACA,IAAA,EACA,OAAA,EACA,UAAA,EACA,MAAA,EACF,GAAkC,CAAA,CAAC,EAA0B;QAC3D,IAAI;YACF,MAAM,aAAuB,EAAC;YAC9B,MAAM,OAAkB,EAAC;YAEzB,IAAI,YAAA,EAAc;gBAChB,UAAA,CAAW,IAAA,CAAK,mBAAmB,CAAA;gBACnC,IAAA,CAAK,IAAA,CAAK,YAAY,CAAA;YACxB;YAEA,IAAI,MAAA,EAAQ;gBACV,UAAA,CAAW,IAAA,CAAK,wCAAwC,CAAA;gBACxD,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;YAClB;YAEA,IAAI,QAAA,EAAU;gBACZ,UAAA,CAAW,IAAA,CAAK,gBAAgB,CAAA;gBAChC,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,WAAA,EAAa,CAAA;YAClC;YAEA,IAAI,MAAA,EAAQ;gBACV,UAAA,CAAW,IAAA,CAAK,gBAAgB,CAAA;gBAChC,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,WAAA,EAAa,CAAA;YAChC;YAEA,IAAI,UAAA,EAAY;gBACd,MAAM,gBAAgB,MAAM,IAAA,EAAK,EAAA,CAAI,SAAA,CAAUO,0LAAAA,EAAyB,YAAY,CAAA;gBACpF,IAAI,aAAA,EAAe;oBACjB,UAAA,CAAW,IAAA,CAAK,gBAAgB,CAAA;oBAChC,IAAA,CAAK,IAAA,CAAK,UAAU,CAAA;gBACtB,CAAA,MAAO;oBACL,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,CAAA,EAAIA,0LAAuB,CAAA,0DAAA,CAA4D,CAAA;gBAC1G;YACF;YAEA,MAAM,WAAA,GAAc,WAAW,MAAA,GAAS,CAAA,GAAI,CAAA,MAAA,EAAS,UAAA,CAAW,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA,GAAK,EAAA;YAElF,IAAI,KAAA,GAAQ,CAAA;YAEZ,MAAM,aAAA,GAAgB,OAAO,OAAA,KAAY,QAAA,IAAY,OAAO,IAAA,KAAS,QAAA;YACrE,IAAI,aAAA,EAAe;gBACjB,MAAM,WAAA,GAAc,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;oBAC7C,GAAA,EAAK,CAAA,8BAAA,EAAiCA,0LAAuB,CAAA,CAAA,EAAI,WAAW,CAAA,CAAA;oBAC5E;gBAAA,CACD,CAAA;gBACD,KAAA,GAAQ,OAAO,WAAA,CAAY,IAAA,EAAA,CAAO,CAAC,CAAA,EAAG,SAAS,CAAC,CAAA;YAClD;YAGA,MAAM,oBAAoB,aAAA,OAAgBJ,mLAAAA,EAAiB,OAAA,EAAS,MAAA,CAAO,gBAAgB,CAAA,GAAI,CAAA;YAC/F,MAAM,MAAA,GAAS,aAAA,GAAgB,IAAA,GAAQ,iBAAA,GAAoB,CAAA;YAC3D,MAAM,MAAA,GAAS,MAAM,IAAA,EAAK,MAAA,CAAQ,OAAA,CAAQ;gBACxC,GAAA,EAAK,CAAA,gGAAA,EAAmGI,0LAAuB,CAAA,CAAA,EAAI,WAAW,CAAA,wBAAA,EAA2B,aAAA,GAAgB,CAAA,iBAAA,CAAA,GAAsB,EAAE,CAAA,CAAA;gBACjN,MAAM,aAAA,GAAgB,CAAC;uBAAG,IAAA;oBAAM,iBAAA;oBAAmB,MAAM;iBAAA,GAAI;YAAA,CAC9D,CAAA;YAED,MAAM,IAAA,GAAA,CAAQ,MAAA,CAAO,IAAA,IAAQ,EAAC,EAAG,GAAA,CAAI,CAAA,GAAA,GAAO,IAAA,CAAK,gBAAA,CAAiB,GAAG,CAAC,CAAA;YAGtE,OAAO;gBAAE,IAAA;gBAAM,KAAA,EAAO,KAAA,IAAS,KAAK,MAAA;YAAA,CAAO;QAC7C,EAAA,OAAS,KAAA,EAAO;YACd,MAAM,IAAIT,8KAAAA,CACR;gBACE,EAAA,MAAII,uLAAAA,EAAqB,QAAA,EAAU,oBAAA,EAAsB,QAAQ,CAAA;gBACjE,QAAQH,8KAAAA,CAAY,OAAA;gBACpB,UAAUC,gLAAAA,CAAc,WAAA;YAAA,CAC1B,EACA;QAEJ;IACF;AACF;;ACvVO,IAAM,WAAA,GAAN,cAA0B,gLAAA,CAAc;IACrC,MAAA,CAAA;IACS,UAAA,CAAA;IACA,gBAAA,CAAA;IAEjB,MAAA,CAAA;IAEA,YAAY,MAAA,CAAsB;QAChC,IAAI,CAAC,MAAA,CAAO,EAAA,IAAM,OAAO,MAAA,CAAO,EAAA,KAAO,QAAA,IAAY,MAAA,CAAO,EAAA,CAAG,IAAA,EAAK,KAAM,EAAA,EAAI;YAC1E,MAAM,IAAI,MAAM,uDAAuD,CAAA;QACzE;QACA,KAAA,CAAM;YAAE,IAAI,MAAA,CAAO,EAAA;YAAI,MAAM,CAAA,WAAA,CAAA;YAAe,WAAA,EAAa,MAAA,CAAO,WAAA;QAAA,CAAa,CAAA;QAE7E,IAAA,CAAK,UAAA,GAAa,OAAO,UAAA,IAAc,CAAA;QACvC,IAAA,CAAK,gBAAA,GAAmB,OAAO,gBAAA,IAAoB,GAAA;QAEnD,IAAI,SAAS,MAAA,EAAQ;YAEnB,IAAI,MAAA,CAAO,GAAA,CAAI,QAAA,CAAS,UAAU,CAAA,EAAG;gBACnC,IAAA,CAAK,eAAA,GAAkB,KAAA;YACzB;YAEA,IAAA,CAAK,MAAA,OAASH,6MAAAA,EAAa;gBACzB,KAAK,MAAA,CAAO,GAAA;gBACZ,GAAI,OAAO,SAAA,GAAY;oBAAE,WAAW,MAAA,CAAO,SAAA;gBAAA,IAAc,CAAA,CAAA;YAAC,CAC3D,CAAA;YAGD,IAAI,MAAA,CAAO,GAAA,CAAI,UAAA,CAAW,OAAO,KAAK,MAAA,CAAO,GAAA,CAAI,QAAA,CAAS,UAAU,CAAA,EAAG;gBACrE,IAAA,CAAK,MAAA,CACF,OAAA,CAAQ,0BAA0B,EAClC,IAAA,CAAK,IAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,2CAA2C,CAAC,CAAA,CACzE,KAAA,CAAM,CAAA,GAAA,GAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,qDAAA,EAAuD,GAAG,CAAC,CAAA;gBAC5F,IAAA,CAAK,MAAA,CACF,OAAA,CAAQ,6BAA6B,EACrC,IAAA,CAAK,IAAM,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,4CAA4C,CAAC,CAAA,CAC1E,KAAA,CAAM,CAAA,GAAA,GAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,iDAAA,EAAmD,GAAG,CAAC,CAAA;YAC1F;QACF,CAAA,MAAO;YACL,IAAA,CAAK,MAAA,GAAS,MAAA,CAAO,MAAA;QACvB;QAEA,MAAM,YAAA,GAAe;YACnB,QAAQ,IAAA,CAAK,MAAA;YACb,YAAY,IAAA,CAAK,UAAA;YACjB,kBAAkB,IAAA,CAAK,gBAAA;QAAA,CACzB;QAEA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,YAAY,CAAA;QAC5C,MAAM,SAAA,GAAY,IAAI,eAAA,CAAgB,YAAY,CAAA;QAClD,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,YAAY,CAAA;QAC5C,MAAM,aAAA,GAAgB,IAAI,mBAAA,CAAoB,YAAY,CAAA;QAC1D,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,YAAY,CAAA;QAE5C,IAAA,CAAK,MAAA,GAAS;YACZ,MAAA;YACA,SAAA;YACA,MAAA;YACA,aAAA;YACA;QAAA,CACF;IACF;AACF;;AC1IO,IAAM,aAAA,GAAgB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,CAAA"}}]
}