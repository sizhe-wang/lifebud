module.exports = [
"[project]/node_modules/@mastra/memory/dist/chunk-DGUM43GV.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__require",
    ()=>__require
]);
var __require = /* @__PURE__ */ ((x)=>("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.z : "TURBOPACK unreachable")(function(x) {
    if ("TURBOPACK compile-time truthy", 1) return /*TURBOPACK member replacement*/ __turbopack_context__.z.apply(this, arguments);
    //TURBOPACK unreachable
    ;
});
;
 //# sourceMappingURL=chunk-DGUM43GV.js.map
 //# sourceMappingURL=chunk-DGUM43GV.js.map
}),
"[project]/node_modules/@mastra/memory/dist/chunk-KMQS2YEC.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commonJS",
    ()=>__commonJS,
    "__require",
    ()=>__require2,
    "__toESM",
    ()=>__toESM,
    "require_token_error",
    ()=>require_token_error
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/memory/dist/chunk-DGUM43GV.js [app-route] (ecmascript)");
;
// ../_vendored/ai_v5/dist/chunk-7D4SUZUM.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x)=>typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : typeof Proxy !== "undefined" ? new Proxy(x, {
        get: (a, b)=>(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : a)[b]
    }) : x)(function(x) {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"].apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod)=>function __require22() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// ../_vendored/ai_v5/dist/chunk-TLQKI65U.js
var require_token_error = __commonJS({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export = (target, all)=>{
            for(var name in all)__defProp2(target, name, {
                get: all[name],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var token_error_exports = {};
        __export(token_error_exports, {
            VercelOidcTokenError: ()=>VercelOidcTokenError
        });
        module.exports = __toCommonJS(token_error_exports);
        var VercelOidcTokenError = class extends Error {
            constructor(message, cause){
                super(message);
                this.name = "VercelOidcTokenError";
                this.cause = cause;
            }
            toString() {
                if (this.cause) {
                    return `${this.name}: ${this.message}: ${this.cause}`;
                }
                return `${this.name}: ${this.message}`;
            }
        };
    }
});
;
 //# sourceMappingURL=chunk-KMQS2YEC.js.map
 //# sourceMappingURL=chunk-KMQS2YEC.js.map
}),
"[project]/node_modules/@mastra/memory/dist/chunk-MMUHFOCG.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__commonJS",
    ()=>__commonJS,
    "__require",
    ()=>__require2,
    "__toESM",
    ()=>__toESM,
    "require_token_error",
    ()=>require_token_error
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/memory/dist/chunk-DGUM43GV.js [app-route] (ecmascript)");
;
// ../_vendored/ai_v6/dist/chunk-7D4SUZUM.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x)=>typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : typeof Proxy !== "undefined" ? new Proxy(x, {
        get: (a, b)=>(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] : a)[b]
    }) : x)(function(x) {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"] !== "undefined") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$DGUM43GV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"].apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod)=>function __require22() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
// ../_vendored/ai_v6/dist/chunk-TLQKI65U.js
var require_token_error = __commonJS({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/token-error.js" (exports, module) {
        var __defProp2 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export = (target, all)=>{
            for(var name in all)__defProp2(target, name, {
                get: all[name],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp2({}, "__esModule", {
                value: true
            }), mod);
        var token_error_exports = {};
        __export(token_error_exports, {
            VercelOidcTokenError: ()=>VercelOidcTokenError
        });
        module.exports = __toCommonJS(token_error_exports);
        var VercelOidcTokenError = class extends Error {
            constructor(message, cause){
                super(message);
                this.name = "VercelOidcTokenError";
                this.cause = cause;
            }
            toString() {
                if (this.cause) {
                    return `${this.name}: ${this.message}: ${this.cause}`;
                }
                return `${this.name}: ${this.message}`;
            }
        };
    }
});
;
 //# sourceMappingURL=chunk-MMUHFOCG.js.map
 //# sourceMappingURL=chunk-MMUHFOCG.js.map
}),
"[project]/node_modules/@mastra/memory/dist/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Memory",
    ()=>Memory,
    "deepMergeWorkingMemory",
    ()=>deepMergeWorkingMemory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/memory/dist/chunk-KMQS2YEC.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/memory/dist/chunk-MMUHFOCG.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/parse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/core/to-json-schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-PSIJ6OSV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-5A5RM7PH.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-MCVLH3QV.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$zod$2d$to$2d$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/zod-to-json.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/chunk-3RG3ZAXL.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$mutex$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-mutex/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xxhash$2d$wasm$2f$esm$2f$xxhash$2d$wasm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xxhash-wasm/esm/xxhash-wasm.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/core/dist/chunk-N3PAHTKU.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mastra/schema-compat/dist/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
// ../_vendored/ai_v4/dist/chunk-OPIPXJLE.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS3 = (cb, mod)=>function __require2() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM3 = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    __defProp(target, "default", {
        value: mod,
        enumerable: true
    }), mod));
var require_secure_json_parse = __commonJS3({
    "../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js" (exports, module) {
        var hasBuffer = typeof Buffer !== "undefined";
        var suspectProtoRx3 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
        var suspectConstructorRx3 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
        function _parse3(text4, reviver, options) {
            if (options == null) {
                if (reviver !== null && typeof reviver === "object") {
                    options = reviver;
                    reviver = void 0;
                }
            }
            if (hasBuffer && Buffer.isBuffer(text4)) {
                text4 = text4.toString();
            }
            if (text4 && text4.charCodeAt(0) === 65279) {
                text4 = text4.slice(1);
            }
            const obj = JSON.parse(text4, reviver);
            if (obj === null || typeof obj !== "object") {
                return obj;
            }
            const protoAction = options && options.protoAction || "error";
            const constructorAction = options && options.constructorAction || "error";
            if (protoAction === "ignore" && constructorAction === "ignore") {
                return obj;
            }
            if (protoAction !== "ignore" && constructorAction !== "ignore") {
                if (suspectProtoRx3.test(text4) === false && suspectConstructorRx3.test(text4) === false) {
                    return obj;
                }
            } else if (protoAction !== "ignore" && constructorAction === "ignore") {
                if (suspectProtoRx3.test(text4) === false) {
                    return obj;
                }
            } else {
                if (suspectConstructorRx3.test(text4) === false) {
                    return obj;
                }
            }
            return filter3(obj, {
                protoAction,
                constructorAction,
                safe: options && options.safe
            });
        }
        function filter3(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
            let next = [
                obj
            ];
            while(next.length){
                const nodes = next;
                next = [];
                for (const node of nodes){
                    if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                        if (safe === true) {
                            return null;
                        } else if (protoAction === "error") {
                            throw new SyntaxError("Object contains forbidden prototype property");
                        }
                        delete node.__proto__;
                    }
                    if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                        if (safe === true) {
                            return null;
                        } else if (constructorAction === "error") {
                            throw new SyntaxError("Object contains forbidden prototype property");
                        }
                        delete node.constructor;
                    }
                    for(const key in node){
                        const value = node[key];
                        if (value && typeof value === "object") {
                            next.push(value);
                        }
                    }
                }
            }
            return obj;
        }
        function parse(text4, reviver, options) {
            const stackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            try {
                return _parse3(text4, reviver, options);
            } finally{
                Error.stackTraceLimit = stackTraceLimit;
            }
        }
        function safeParse(text4, reviver) {
            const stackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            try {
                return _parse3(text4, reviver, {
                    safe: true
                });
            } catch (_e) {
                return null;
            } finally{
                Error.stackTraceLimit = stackTraceLimit;
            }
        }
        module.exports = parse;
        module.exports.default = parse;
        module.exports.parse = parse;
        module.exports.safeParse = safeParse;
        module.exports.scan = filter3;
    }
});
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name144, message, cause }){
        super(message);
        this[_a] = true;
        this.name = name144;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError2.hasMarker(error, marker);
    }
    static hasMarker(error, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name,
            message,
            cause
        });
        this[_a2] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker2);
    }
};
_a2 = symbol2;
function getErrorMessage(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
    constructor({ message, cause, argument }){
        super({
            name: name3,
            message,
            cause
        });
        this[_a4] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker4);
    }
};
_a4 = symbol4;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
    constructor({ text: text4, cause }){
        super({
            name: name6,
            message: `JSON parsing failed: Text: ${text4}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a7] = true;
        this.text = text4;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker7);
    }
};
_a7 = symbol7;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
    constructor({ value, cause }){
        super({
            name: name12,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
            cause
        });
        this[_a13] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker13);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({
            value,
            cause
        });
    }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = "";
        let i = size | 0;
        while(i--){
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
var import_secure_json_parse = __toESM3(require_secure_json_parse());
function convertAsyncIteratorToReadableStream(iterator) {
    return new ReadableStream({
        /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */ async pull (controller) {
            try {
                const { value, done } = await iterator.next();
                if (done) {
                    controller.close();
                } else {
                    controller.enqueue(value);
                }
            } catch (error) {
                controller.error(error);
            }
        },
        /**
     * Called when the consumer cancels the stream.
     */ cancel () {}
    });
}
async function delay(delayInMs) {
    return delayInMs == null ? Promise.resolve() : new Promise((resolve22)=>setTimeout(resolve22, delayInMs));
}
var createIdGenerator = ({ prefix, size: defaultSize = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = customAlphabet(alphabet, defaultSize);
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new InvalidArgumentError({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return (size)=>`${prefix}${separator}${generator(size)}`;
};
createIdGenerator();
function getErrorMessage2(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
function isAbortError(error) {
    return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
    return {
        [validatorSymbol]: true,
        validate
    };
}
function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
    return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema4) {
    return validator((value)=>{
        const result = zodSchema4.safeParse(value);
        return result.success ? {
            success: true,
            value: result.data
        } : {
            success: false,
            error: result.error
        };
    });
}
function safeValidateTypes({ value, schema }) {
    const validator22 = asValidator(schema);
    try {
        if (validator22.validate == null) {
            return {
                success: true,
                value
            };
        }
        const result = validator22.validate(value);
        if (result.success) {
            return result;
        }
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: result.error
            })
        };
    } catch (error) {
        return {
            success: false,
            error: TypeValidationError.wrap({
                value,
                cause: error
            })
        };
    }
}
function safeParseJSON({ text: text4, schema }) {
    try {
        const value = import_secure_json_parse.default.parse(text4);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const validationResult = safeValidateTypes({
            value,
            schema
        });
        return validationResult.success ? {
            ...validationResult,
            rawValue: value
        } : validationResult;
    } catch (error) {
        return {
            success: false,
            error: JSONParseError.isInstance(error) ? error : new JSONParseError({
                text: text4,
                cause: error
            })
        };
    }
}
var ignoreOverride = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
    openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options)=>typeof options === "string" ? {
        ...defaultOptions,
        name: options
    } : {
        ...defaultOptions,
        ...options
    };
var getRefs = (options)=>{
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return {
        ..._options,
        flags: {
            hasReferencedOpenAiAnyType: false
        },
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name172, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name172
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    };
};
function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages) return;
    if (errorMessage) {
        res.errorMessage = {
            ...res.errorMessage,
            [key]: errorMessage
        };
    }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}
var getRelativePath = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
function parseAnyDef(refs) {
    if (refs.target !== "openAi") {
        return {};
    }
    const anyDefinitionPath = [
        ...refs.basePath,
        refs.definitionPath,
        refs.openAiAnyTypeName
    ];
    refs.flags.hasReferencedOpenAiAnyType = true;
    return {
        $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
    };
}
function parseArrayDef(def, refs) {
    const res = {
        type: "array"
    };
    if (def.type?._def && def.type?._def?.typeName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        });
    }
    if (def.minLength) {
        setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
        setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}
function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    } else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                } else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    } else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                } else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}
function parseBooleanDef() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
var integerDateParser = (def, refs)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    if (refs.target === "openApi3") {
        return res;
    }
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                setResponseValueAndErrors(res, "minimum", check.value, // This is in milliseconds
                check.message, refs);
                break;
            case "max":
                setResponseValueAndErrors(res, "maximum", check.value, // This is in milliseconds
                check.message, refs);
                break;
        }
    }
    return res;
};
function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? {
        unevaluatedProperties: false
    } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (schema.unevaluatedProperties === void 0) {
                unevaluatedProperties = void 0;
            }
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            } else {
                unevaluatedProperties = void 0;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf,
        ...unevaluatedProperties
    } : void 0;
}
function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    if (refs.target === "openApi3") {
        return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            enum: [
                def.value
            ]
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex = void 0;
var zodPatterns = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex === void 0) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
                    break;
                case "includes":
                    {
                        addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern(res, zodPatterns.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern(res, zodPatterns.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern(res, zodPatterns.nanoid, check.message, refs);
                    }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x)=>x.format)) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...schema.errorMessage && refs.errorMessages && {
                    errorMessage: {
                        format: schema.errorMessage.format
                    }
                }
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
    }
}
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x)=>x.pattern)) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...schema.errorMessage && refs.errorMessages && {
                    errorMessage: {
                        pattern: schema.errorMessage.pattern
                    }
                }
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else {
        setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
}
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}
function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" && def.keyType?._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            type: "object",
            required: def.keyType._def.values,
            properties: def.keyType._def.values.reduce((acc, key)=>({
                    ...acc,
                    [key]: parseDef(def.valueType._def, {
                        ...refs,
                        currentPath: [
                            ...refs.currentPath,
                            "properties",
                            key
                        ]
                    }) ?? parseAnyDef(refs)
                }), {}),
            additionalProperties: refs.rejectedAdditionalProperties
        };
    }
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        }) ?? refs.allowedAdditionalProperties
    };
    if (refs.target === "openApi3") {
        return schema;
    }
    if (def.keyType?._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    } else if (def.keyType?._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values
            }
        };
    } else if (def.keyType?._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded && def.keyType._def.type._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || parseAnyDef(refs);
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || parseAnyDef(refs);
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef(def) {
    const object22 = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object22[object22[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object22[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef(refs) {
    return refs.target === "openAi" ? void 0 : {
        not: parseAnyDef({
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "not"
            ]
        })
    };
}
function parseNullDef(refs) {
    return refs.target === "openApi3" ? {
        enum: [
            "null"
        ],
        nullable: true
    } : {
        type: "null"
    };
}
var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef(def, refs) {
    if (refs.target === "openApi3") return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf(def, refs);
}
var asAnyOf = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
            return {
                type: primitiveMappings[def.innerType._def.typeName],
                nullable: true
            };
        }
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    if (refs.target === "openApi3") {
        const base2 = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath
            ]
        });
        if (base2 && "$ref" in base2) return {
            allOf: [
                base2
            ],
            nullable: true
        };
        return base2 && {
            ...base2,
            nullable: true
        };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef(def, refs) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                addErrorMessage(res, "type", check.message, refs);
                break;
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    } else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                } else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    } else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                } else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}
function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
            if (propDef._def.typeName === "ZodOptional") {
                propDef = propDef._def.innerType;
            }
            if (!propDef.isNullable()) {
                propDef = propDef.nullable();
            }
            propOptional = false;
        }
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        });
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        });
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    } catch  {
        return true;
    }
}
var parseOptionalDef = (def, refs)=>{
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef(refs)
            },
            innerSchema
        ]
    } : parseAnyDef(refs);
};
var parsePipelineDef = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
        setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
}
function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            })
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef(refs) {
    return {
        not: parseAnyDef(refs)
    };
}
function parseUnknownDef(refs) {
    return parseAnyDef(refs);
}
var parseReadonlyDef = (def, refs)=>{
    return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs)=>{
    switch(typeName){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString:
            return parseStringDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNumber:
            return parseNumberDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodObject:
            return parseObjectDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBigInt:
            return parseBigintDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBoolean:
            return parseBooleanDef();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDate:
            return parseDateDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUndefined:
            return parseUndefinedDef(refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNull:
            return parseNullDef(refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodArray:
            return parseArrayDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnion:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodIntersection:
            return parseIntersectionDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodTuple:
            return parseTupleDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodRecord:
            return parseRecordDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLiteral:
            return parseLiteralDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum:
            return parseEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNativeEnum:
            return parseNativeEnumDef(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNullable:
            return parseNullableDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodOptional:
            return parseOptionalDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodMap:
            return parseMapDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSet:
            return parseSetDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLazy:
            return ()=>def.getter()._def;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPromise:
            return parsePromiseDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNaN:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNever:
            return parseNeverDef(refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEffects:
            return parseEffectsDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny:
            return parseAnyDef(refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnknown:
            return parseUnknownDef(refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDefault:
            return parseDefaultDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded:
            return parseBrandedDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodReadonly:
            return parseReadonlyDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodCatch:
            return parseCatchDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPipeline:
            return parsePipelineDef(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodFunction:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodVoid:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)();
    }
};
function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema22) {
        addMeta(def, refs, jsonSchema22);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
        newItem.jsonSchema = jsonSchema22;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema22;
    return jsonSchema22;
}
var get$ref = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef(refs);
                }
                return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
            }
    }
};
var addMeta = (def, refs, jsonSchema22)=>{
    if (def.description) {
        jsonSchema22.description = def.description;
        if (refs.markdownDescription) {
            jsonSchema22.markdownDescription = def.description;
        }
    }
    return jsonSchema22;
};
var zodToJsonSchema = (schema, options)=>{
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name182, schema2])=>({
            ...acc,
            [name182]: parseDef(schema2._def, {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name182
                ]
            }, true) ?? parseAnyDef(refs)
        }), {}) : void 0;
    const name172 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
    const main = parseDef(schema._def, name172 === void 0 ? refs : {
        ...refs,
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name172
        ]
    }, false) ?? parseAnyDef(refs);
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    if (refs.flags.hasReferencedOpenAiAnyType) {
        if (!definitions) {
            definitions = {};
        }
        if (!definitions[refs.openAiAnyTypeName]) {
            definitions[refs.openAiAnyTypeName] = {
                // Skipping "object" as no properties can be defined and additionalProperties must be "false"
                type: [
                    "string",
                    "number",
                    "integer",
                    "boolean",
                    "array",
                    "null"
                ],
                items: {
                    $ref: refs.$refStrategy === "relative" ? "1" : [
                        ...refs.basePath,
                        refs.definitionPath,
                        refs.openAiAnyTypeName
                    ].join("/")
                }
            };
        }
    }
    const combined = name172 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
    } : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name172
        ].join("/"),
        [refs.definitionPath]: {
            ...definitions,
            [name172]: main
        }
    };
    if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
};
var esm_default = zodToJsonSchema;
function fixJson(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = safeParseJSON({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = safeParseJSON({
        text: fixJson(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
var textStreamPart2 = {
    code: "0",
    name: "text",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"text" parts expect a string value.');
        }
        return {
            type: "text",
            value
        };
    }
};
var dataStreamPart = {
    code: "2",
    name: "data",
    parse: (value)=>{
        if (!Array.isArray(value)) {
            throw new Error('"data" parts expect an array value.');
        }
        return {
            type: "data",
            value
        };
    }
};
var errorStreamPart2 = {
    code: "3",
    name: "error",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"error" parts expect a string value.');
        }
        return {
            type: "error",
            value
        };
    }
};
var messageAnnotationsStreamPart = {
    code: "8",
    name: "message_annotations",
    parse: (value)=>{
        if (!Array.isArray(value)) {
            throw new Error('"message_annotations" parts expect an array value.');
        }
        return {
            type: "message_annotations",
            value
        };
    }
};
var toolCallStreamPart = {
    code: "9",
    name: "tool_call",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
            throw new Error('"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.');
        }
        return {
            type: "tool_call",
            value
        };
    }
};
var toolResultStreamPart = {
    code: "a",
    name: "tool_result",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
            throw new Error('"tool_result" parts expect an object with a "toolCallId" and a "result" property.');
        }
        return {
            type: "tool_result",
            value
        };
    }
};
var toolCallStreamingStartStreamPart = {
    code: "b",
    name: "tool_call_streaming_start",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
            throw new Error('"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.');
        }
        return {
            type: "tool_call_streaming_start",
            value
        };
    }
};
var toolCallDeltaStreamPart = {
    code: "c",
    name: "tool_call_delta",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
            throw new Error('"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.');
        }
        return {
            type: "tool_call_delta",
            value
        };
    }
};
var finishMessageStreamPart = {
    code: "d",
    name: "finish_message",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
            throw new Error('"finish_message" parts expect an object with a "finishReason" property.');
        }
        const result = {
            finishReason: value.finishReason
        };
        if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
            result.usage = {
                promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
                completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
            };
        }
        return {
            type: "finish_message",
            value: result
        };
    }
};
var finishStepStreamPart = {
    code: "e",
    name: "finish_step",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
            throw new Error('"finish_step" parts expect an object with a "finishReason" property.');
        }
        const result = {
            finishReason: value.finishReason,
            isContinued: false
        };
        if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
            result.usage = {
                promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
                completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
            };
        }
        if ("isContinued" in value && typeof value.isContinued === "boolean") {
            result.isContinued = value.isContinued;
        }
        return {
            type: "finish_step",
            value: result
        };
    }
};
var startStepStreamPart = {
    code: "f",
    name: "start_step",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
            throw new Error('"start_step" parts expect an object with an "id" property.');
        }
        return {
            type: "start_step",
            value: {
                messageId: value.messageId
            }
        };
    }
};
var reasoningStreamPart = {
    code: "g",
    name: "reasoning",
    parse: (value)=>{
        if (typeof value !== "string") {
            throw new Error('"reasoning" parts expect a string value.');
        }
        return {
            type: "reasoning",
            value
        };
    }
};
var sourcePart = {
    code: "h",
    name: "source",
    parse: (value)=>{
        if (value == null || typeof value !== "object") {
            throw new Error('"source" parts expect a Source object.');
        }
        return {
            type: "source",
            value
        };
    }
};
var redactedReasoningStreamPart = {
    code: "i",
    name: "redacted_reasoning",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
            throw new Error('"redacted_reasoning" parts expect an object with a "data" property.');
        }
        return {
            type: "redacted_reasoning",
            value: {
                data: value.data
            }
        };
    }
};
var reasoningSignatureStreamPart = {
    code: "j",
    name: "reasoning_signature",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
            throw new Error('"reasoning_signature" parts expect an object with a "signature" property.');
        }
        return {
            type: "reasoning_signature",
            value: {
                signature: value.signature
            }
        };
    }
};
var fileStreamPart = {
    code: "k",
    name: "file",
    parse: (value)=>{
        if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
            throw new Error('"file" parts expect an object with a "data" and "mimeType" property.');
        }
        return {
            type: "file",
            value
        };
    }
};
var dataStreamParts = [
    textStreamPart2,
    dataStreamPart,
    errorStreamPart2,
    messageAnnotationsStreamPart,
    toolCallStreamPart,
    toolResultStreamPart,
    toolCallStreamingStartStreamPart,
    toolCallDeltaStreamPart,
    finishMessageStreamPart,
    finishStepStreamPart,
    startStepStreamPart,
    reasoningStreamPart,
    sourcePart,
    redactedReasoningStreamPart,
    reasoningSignatureStreamPart,
    fileStreamPart
];
Object.fromEntries(dataStreamParts.map((part)=>[
        part.code,
        part
    ]));
Object.fromEntries(dataStreamParts.map((part)=>[
        part.name,
        part.code
    ]));
function formatDataStreamPart(type, value) {
    const streamPart = dataStreamParts.find((part)=>part.name === type);
    if (!streamPart) {
        throw new Error(`Invalid stream part type: ${type}`);
    }
    return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema(zodSchema22, options) {
    var _a172;
    const useReferences = (_a172 = void 0) != null ? _a172 : false;
    return jsonSchema(esm_default(zodSchema22, {
        $refStrategy: useReferences ? "root" : "none",
        target: "jsonSchema7"
    }), {
        validate: (value)=>{
            const result = zodSchema22.safeParse(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
var schemaSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema22, { validate } = {}) {
    return {
        [schemaSymbol]: true,
        _type: void 0,
        // should never be used directly
        [validatorSymbol]: true,
        jsonSchema: jsonSchema22,
        validate
    };
}
function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
    return isSchema(schema) ? schema : zodSchema(schema);
}
var _globalThis = typeof globalThis === "object" ? globalThis : /*TURBOPACK member replacement*/ __turbopack_context__.g;
var VERSION = "1.9.0";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([
        ownVersion
    ]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        return function() {
            return false;
        };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible22(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
var isCompatible = _makeCompatibilityCheck(VERSION);
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a172;
    if (allowOverride === void 0) {
        allowOverride = false;
    }
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a172 !== void 0 ? _a172 : {
        version: VERSION
    };
    if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION) {
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
    return true;
}
function getGlobal(type) {
    var _a172, _b17;
    var globalVersion = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a172 === void 0 ? void 0 : _a172.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b17 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b17 === void 0 ? void 0 : _b17[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}
var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = /** @class */ function() {
    function DiagComponentLogger22(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger22.prototype.debug = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger22.prototype.error = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger22.prototype.info = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger22.prototype.warn = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger22.prototype.verbose = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger22;
}();
function logProxy(funcName, namespace, args) {
    var logger = getGlobal("diag");
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel22) {
    DiagLogLevel22[DiagLogLevel22["NONE"] = 0] = "NONE";
    DiagLogLevel22[DiagLogLevel22["ERROR"] = 30] = "ERROR";
    DiagLogLevel22[DiagLogLevel22["WARN"] = 50] = "WARN";
    DiagLogLevel22[DiagLogLevel22["INFO"] = 60] = "INFO";
    DiagLogLevel22[DiagLogLevel22["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel22[DiagLogLevel22["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel22[DiagLogLevel22["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function() {};
    }
    return {
        error: _filterFunc("error", DiagLogLevel.ERROR),
        warn: _filterFunc("warn", DiagLogLevel.WARN),
        info: _filterFunc("info", DiagLogLevel.INFO),
        debug: _filterFunc("debug", DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
    };
}
var __read2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray2 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = /** @class */ function() {
    function DiagAPI22() {
        function _logProxy(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal("diag");
                if (!logger) return;
                return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
            };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
            var _a172, _b17, _c;
            if (optionsOrLogLevel === void 0) {
                optionsOrLogLevel = {
                    logLevel: DiagLogLevel.INFO
                };
            }
            if (logger === self) {
                var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                self.error((_a172 = err.stack) !== null && _a172 !== void 0 ? _a172 : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === "number") {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel
                };
            }
            var oldLogger = getGlobal("diag");
            var newLogger = createLogLevelDiagLogger((_b17 = optionsOrLogLevel.logLevel) !== null && _b17 !== void 0 ? _b17 : DiagLogLevel.INFO, logger);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
            unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
    }
    DiagAPI22.instance = function() {
        if (!this._instance) {
            this._instance = new DiagAPI22();
        }
        return this._instance;
    };
    return DiagAPI22;
}();
function createContextKey(description) {
    return Symbol.for(description);
}
var BaseContext = /** @class */ /* @__PURE__ */ function() {
    function BaseContext22(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext22;
}();
var ROOT_CONTEXT = new BaseContext();
var __read3 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray3 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ function() {
    function NoopContextManager22() {}
    NoopContextManager22.prototype.active = function() {
        return ROOT_CONTEXT;
    };
    NoopContextManager22.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([
            thisArg
        ], __read3(args), false));
    };
    NoopContextManager22.prototype.bind = function(_context, target) {
        return target;
    };
    NoopContextManager22.prototype.enable = function() {
        return this;
    };
    NoopContextManager22.prototype.disable = function() {
        return this;
    };
    return NoopContextManager22;
}();
var __read4 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray4 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = /** @class */ function() {
    function ContextAPI22() {}
    ContextAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new ContextAPI22();
        }
        return this._instance;
    };
    ContextAPI22.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI22.prototype.active = function() {
        return this._getContextManager().active();
    };
    ContextAPI22.prototype.with = function(context, fn, thisArg) {
        var _a172;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return (_a172 = this._getContextManager()).with.apply(_a172, __spreadArray4([
            context,
            fn,
            thisArg
        ], __read4(args), false));
    };
    ContextAPI22.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI22.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI22.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI22;
}();
var TraceFlags;
(function(TraceFlags22) {
    TraceFlags22[TraceFlags22["NONE"] = 0] = "NONE";
    TraceFlags22[TraceFlags22["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = /** @class */ function() {
    function NonRecordingSpan22(_spanContext) {
        if (_spanContext === void 0) {
            _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
    }
    NonRecordingSpan22.prototype.spanContext = function() {
        return this._spanContext;
    };
    NonRecordingSpan22.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    NonRecordingSpan22.prototype.setAttributes = function(_attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addLink = function(_link) {
        return this;
    };
    NonRecordingSpan22.prototype.addLinks = function(_links) {
        return this;
    };
    NonRecordingSpan22.prototype.setStatus = function(_status) {
        return this;
    };
    NonRecordingSpan22.prototype.updateName = function(_name) {
        return this;
    };
    NonRecordingSpan22.prototype.end = function(_endTime) {};
    NonRecordingSpan22.prototype.isRecording = function() {
        return false;
    };
    NonRecordingSpan22.prototype.recordException = function(_exception, _time) {};
    return NonRecordingSpan22;
}();
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
    return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
    var _a172;
    return (_a172 = getSpan(context)) === null || _a172 === void 0 ? void 0 : _a172.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = /** @class */ function() {
    function NoopTracer22() {}
    NoopTracer22.prototype.startSpan = function(name172, options, context) {
        if (context === void 0) {
            context = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        } else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer22.prototype.startActiveSpan = function(name172, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        } else if (arguments.length === 2) {
            fn = arg2;
        } else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name172, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer22;
}();
function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = /** @class */ function() {
    function ProxyTracer22(_provider, name172, version, options) {
        this._provider = _provider;
        this.name = name172;
        this.version = version;
        this.options = options;
    }
    ProxyTracer22.prototype.startSpan = function(name172, options, context) {
        return this._getTracer().startSpan(name172, options, context);
    };
    ProxyTracer22.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer22.prototype._getTracer = function() {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer22;
}();
var NoopTracerProvider = /** @class */ function() {
    function NoopTracerProvider22() {}
    NoopTracerProvider22.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider22;
}();
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = /** @class */ function() {
    function ProxyTracerProvider22() {}
    ProxyTracerProvider22.prototype.getTracer = function(name172, version, options) {
        var _a172;
        return (_a172 = this.getDelegateTracer(name172, version, options)) !== null && _a172 !== void 0 ? _a172 : new ProxyTracer(this, name172, version, options);
    };
    ProxyTracerProvider22.prototype.getDelegate = function() {
        var _a172;
        return (_a172 = this._delegate) !== null && _a172 !== void 0 ? _a172 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider22.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider22.prototype.getDelegateTracer = function(name172, version, options) {
        var _a172;
        return (_a172 = this._delegate) === null || _a172 === void 0 ? void 0 : _a172.getTracer(name172, version, options);
    };
    return ProxyTracerProvider22;
}();
var SpanStatusCode;
(function(SpanStatusCode22) {
    SpanStatusCode22[SpanStatusCode22["UNSET"] = 0] = "UNSET";
    SpanStatusCode22[SpanStatusCode22["OK"] = 1] = "OK";
    SpanStatusCode22[SpanStatusCode22["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
var API_NAME3 = "trace";
var TraceAPI = /** @class */ function() {
    function TraceAPI22() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    TraceAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new TraceAPI22();
        }
        return this._instance;
    };
    TraceAPI22.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    TraceAPI22.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI22.prototype.getTracer = function(name172, version) {
        return this.getTracerProvider().getTracer(name172, version);
    };
    TraceAPI22.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI22;
}();
var trace = TraceAPI.getInstance();
var __defProp2 = Object.defineProperty;
var __export = (target, all)=>{
    for(var name172 in all)__defProp2(target, name172, {
        get: all[name172],
        enumerable: true
    });
};
function prepareResponseHeaders(headers, { contentType, dataStreamVersion }) {
    const responseHeaders = new Headers(headers != null ? headers : {});
    if (!responseHeaders.has("Content-Type")) {
        responseHeaders.set("Content-Type", contentType);
    }
    {
        responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
    }
    return responseHeaders;
}
var UnsupportedModelVersionError = class extends AISDKError {
    constructor(){
        super({
            name: "AI_UnsupportedModelVersionError",
            message: `Unsupported model version. AI SDK 4 only supports models that implement specification version "v1". Please upgrade to AI SDK 5 to use this model.`
        });
    }
};
var name8 = "AI_InvalidArgumentError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var InvalidArgumentError2 = class extends AISDKError {
    constructor({ parameter, value, message }){
        super({
            name: name8,
            message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a9] = true;
        this.parameter = parameter;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker9);
    }
};
_a9 = symbol9;
var name22 = "AI_RetryError";
var marker22 = `vercel.ai.error.${name22}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var RetryError = class extends AISDKError {
    constructor({ message, reason, errors }){
        super({
            name: name22,
            message
        });
        this[_a22] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker22);
    }
};
_a22 = symbol22;
var retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {
            maxRetries,
            delayInMs: initialDelayInMs,
            backoffFactor
        });
async function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {
    try {
        return await f();
    } catch (error) {
        if (isAbortError(error)) {
            throw error;
        }
        if (maxRetries === 0) {
            throw error;
        }
        const errorMessage = getErrorMessage2(error);
        const newErrors = [
            ...errors,
            error
        ];
        const tryNumber = newErrors.length;
        if (tryNumber > maxRetries) {
            throw new RetryError({
                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
                reason: "maxRetriesExceeded",
                errors: newErrors
            });
        }
        if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
            await delay(delayInMs);
            return _retryWithExponentialBackoff(f, {
                maxRetries,
                delayInMs: backoffFactor * delayInMs,
                backoffFactor
            }, newErrors);
        }
        if (tryNumber === 1) {
            throw error;
        }
        throw new RetryError({
            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
            reason: "errorNotRetryable",
            errors: newErrors
        });
    }
}
function prepareRetries({ maxRetries }) {
    if (maxRetries != null) {
        if (!Number.isInteger(maxRetries)) {
            throw new InvalidArgumentError2({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be an integer"
            });
        }
        if (maxRetries < 0) {
            throw new InvalidArgumentError2({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be >= 0"
            });
        }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
        maxRetries: maxRetriesResult,
        retry: retryWithExponentialBackoff({
            maxRetries: maxRetriesResult
        })
    };
}
function assembleOperationName({ operationId, telemetry }) {
    return {
        // standardized operation and resource name:
        "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
        "resource.name": telemetry == null ? void 0 : telemetry.functionId,
        // detailed, AI SDK specific data:
        "ai.operationId": operationId,
        "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
}
function getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {
    var _a172;
    return {
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // settings:
        ...Object.entries(settings).reduce((attributes, [key, value])=>{
            attributes[`ai.settings.${key}`] = value;
            return attributes;
        }, {}),
        // add metadata as attributes:
        ...Object.entries((_a172 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a172 : {}).reduce((attributes, [key, value])=>{
            attributes[`ai.telemetry.metadata.${key}`] = value;
            return attributes;
        }, {}),
        // request headers
        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{
            if (value !== void 0) {
                attributes[`ai.request.headers.${key}`] = value;
            }
            return attributes;
        }, {})
    };
}
var noopTracer = {
    startSpan () {
        return noopSpan;
    },
    startActiveSpan (name172, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
            return arg1(noopSpan);
        }
        if (typeof arg2 === "function") {
            return arg2(noopSpan);
        }
        if (typeof arg3 === "function") {
            return arg3(noopSpan);
        }
    }
};
var noopSpan = {
    spanContext () {
        return noopSpanContext;
    },
    setAttribute () {
        return this;
    },
    setAttributes () {
        return this;
    },
    addEvent () {
        return this;
    },
    addLink () {
        return this;
    },
    addLinks () {
        return this;
    },
    setStatus () {
        return this;
    },
    updateName () {
        return this;
    },
    end () {
        return this;
    },
    isRecording () {
        return false;
    },
    recordException () {
        return this;
    }
};
var noopSpanContext = {
    traceId: "",
    spanId: "",
    traceFlags: 0
};
function getTracer({ isEnabled = false, tracer } = {}) {
    if (!isEnabled) {
        return noopTracer;
    }
    if (tracer) {
        return tracer;
    }
    return trace.getTracer("ai");
}
function recordSpan({ name: name172, tracer, attributes, fn, endWhenDone = true }) {
    return tracer.startActiveSpan(name172, {
        attributes
    }, async (span)=>{
        try {
            const result = await fn(span);
            if (endWhenDone) {
                span.end();
            }
            return result;
        } catch (error) {
            try {
                recordErrorOnSpan(span, error);
            } finally{
                span.end();
            }
            throw error;
        }
    });
}
function recordErrorOnSpan(span, error) {
    if (error instanceof Error) {
        span.recordException({
            name: error.name,
            message: error.message,
            stack: error.stack
        });
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message
        });
    } else {
        span.setStatus({
            code: SpanStatusCode.ERROR
        });
    }
}
function selectTelemetryAttributes({ telemetry, attributes }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
        return {};
    }
    return Object.entries(attributes).reduce((attributes2, [key, value])=>{
        if (value === void 0) {
            return attributes2;
        }
        if (typeof value === "object" && "input" in value && typeof value.input === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
                return attributes2;
            }
            const result = value.input();
            return result === void 0 ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        if (typeof value === "object" && "output" in value && typeof value.output === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
                return attributes2;
            }
            const result = value.output();
            return result === void 0 ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        return {
            ...attributes2,
            [key]: value
        };
    }, {});
}
function splitArray(array2, chunkSize) {
    if (chunkSize <= 0) {
        throw new Error("chunkSize must be greater than 0");
    }
    const result = [];
    for(let i = 0; i < array2.length; i += chunkSize){
        result.push(array2.slice(i, i + chunkSize));
    }
    return result;
}
async function embedMany({ model, values, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {
    if (typeof model === "string" || model.specificationVersion !== "v1") {
        throw new UnsupportedModelVersionError();
    }
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer(telemetry);
    return recordSpan({
        name: "ai.embedMany",
        attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
                ...assembleOperationName({
                    operationId: "ai.embedMany",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                    input: ()=>values.map((value)=>JSON.stringify(value))
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;
            if (maxEmbeddingsPerCall == null) {
                const { embeddings: embeddings2, usage } = await retry(()=>{
                    return recordSpan({
                        name: "ai.embedMany.doEmbed",
                        attributes: selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                ...assembleOperationName({
                                    operationId: "ai.embedMany.doEmbed",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                // specific settings that only make sense on the outer level:
                                "ai.values": {
                                    input: ()=>values.map((value)=>JSON.stringify(value))
                                }
                            }
                        }),
                        tracer,
                        fn: async (doEmbedSpan)=>{
                            var _a172;
                            const modelResponse = await model.doEmbed({
                                values,
                                abortSignal,
                                headers
                            });
                            const embeddings3 = modelResponse.embeddings;
                            const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : {
                                tokens: NaN
                            };
                            doEmbedSpan.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.embeddings": {
                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))
                                    },
                                    "ai.usage.tokens": usage2.tokens
                                }
                            }));
                            return {
                                embeddings: embeddings3,
                                usage: usage2
                            };
                        }
                    });
                });
                span.setAttributes(selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.embeddings": {
                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                        },
                        "ai.usage.tokens": usage.tokens
                    }
                }));
                return new DefaultEmbedManyResult({
                    values,
                    embeddings: embeddings2,
                    usage
                });
            }
            const valueChunks = splitArray(values, maxEmbeddingsPerCall);
            const embeddings = [];
            let tokens = 0;
            for (const chunk of valueChunks){
                const { embeddings: responseEmbeddings, usage } = await retry(()=>{
                    return recordSpan({
                        name: "ai.embedMany.doEmbed",
                        attributes: selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                ...assembleOperationName({
                                    operationId: "ai.embedMany.doEmbed",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                // specific settings that only make sense on the outer level:
                                "ai.values": {
                                    input: ()=>chunk.map((value)=>JSON.stringify(value))
                                }
                            }
                        }),
                        tracer,
                        fn: async (doEmbedSpan)=>{
                            var _a172;
                            const modelResponse = await model.doEmbed({
                                values: chunk,
                                abortSignal,
                                headers
                            });
                            const embeddings2 = modelResponse.embeddings;
                            const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : {
                                tokens: NaN
                            };
                            doEmbedSpan.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.embeddings": {
                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                                    },
                                    "ai.usage.tokens": usage2.tokens
                                }
                            }));
                            return {
                                embeddings: embeddings2,
                                usage: usage2
                            };
                        }
                    });
                });
                embeddings.push(...responseEmbeddings);
                tokens += usage.tokens;
            }
            span.setAttributes(selectTelemetryAttributes({
                telemetry,
                attributes: {
                    "ai.embeddings": {
                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": tokens
                }
            }));
            return new DefaultEmbedManyResult({
                values,
                embeddings,
                usage: {
                    tokens
                }
            });
        }
    });
}
var DefaultEmbedManyResult = class {
    constructor(options){
        this.values = options.values;
        this.embeddings = options.embeddings;
        this.usage = options.usage;
    }
};
var name42 = "AI_NoObjectGeneratedError";
var marker42 = `vercel.ai.error.${name42}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var NoObjectGeneratedError = class extends AISDKError {
    constructor({ message = "No object generated.", cause, text: text22, response, usage, finishReason }){
        super({
            name: name42,
            message,
            cause
        });
        this[_a42] = true;
        this.text = text22;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
    }
    static isInstance(error) {
        return AISDKError.hasMarker(error, marker42);
    }
};
_a42 = symbol42;
var dataContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>{
        var _a172, _b17;
        return (_b17 = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b17 : false;
    }, {
        message: "Must be a Buffer"
    })
]);
var jsonValueSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(jsonValueSchema)
    ]));
var providerMetadataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema));
var toolResultContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    })
]));
var textPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var imagePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var filePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var reasoningPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var redactedReasoningPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("redacted-reasoning"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolCallPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    args: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolResultPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    content: toolResultContentSchema.optional(),
    isError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreSystemMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("system"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreUserMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("user"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            imagePartSchema,
            filePartSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("assistant"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            filePartSchema,
            reasoningPartSchema,
            redactedReasoningPartSchema,
            toolCallPartSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreToolMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(toolResultPartSchema),
    providerOptions: providerMetadataSchema.optional(),
    experimental_providerMetadata: providerMetadataSchema.optional()
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    coreSystemMessageSchema,
    coreUserMessageSchema,
    coreAssistantMessageSchema,
    coreToolMessageSchema
]);
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {
    return [
        prompt != null && prompt.length > 0 ? prompt : void 0,
        prompt != null && prompt.length > 0 ? "" : void 0,
        // add a newline if prompt is not null
        schemaPrefix,
        schema != null ? JSON.stringify(schema) : void 0,
        schemaSuffix
    ].filter((line)=>line != null).join("\n");
}
createIdGenerator({
    prefix: "aiobj",
    size: 24
});
createIdGenerator({
    prefix: "aiobj",
    size: 24
});
createIdGenerator({
    prefix: "aitxt",
    size: 24
});
createIdGenerator({
    prefix: "msg",
    size: 24
});
var output_exports = {};
__export(output_exports, {
    object: ()=>object,
    text: ()=>text
});
var text = ()=>({
        type: "text",
        responseFormat: ()=>({
                type: "text"
            }),
        injectIntoSystemPrompt ({ system }) {
            return system;
        },
        parsePartial ({ text: text22 }) {
            return {
                partial: text22
            };
        },
        parseOutput ({ text: text22 }) {
            return text22;
        }
    });
var object = ({ schema: inputSchema })=>{
    const schema = asSchema(inputSchema);
    return {
        type: "object",
        responseFormat: ({ model })=>({
                type: "json",
                schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
            }),
        injectIntoSystemPrompt ({ system, model }) {
            return model.supportsStructuredOutputs ? system : injectJsonInstruction({
                prompt: system,
                schema: schema.jsonSchema
            });
        },
        parsePartial ({ text: text22 }) {
            const result = parsePartialJson(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    return void 0;
                case "repaired-parse":
                case "successful-parse":
                    return {
                        // Note: currently no validation of partial results:
                        partial: result.value
                    };
                default:
                    {
                        const _exhaustiveCheck = result.state;
                        throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
                    }
            }
        },
        parseOutput ({ text: text22 }, context) {
            const parseResult = safeParseJSON({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const validationResult = safeValidateTypes({
                value: parseResult.value,
                schema
            });
            if (!validationResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: response did not match schema.",
                    cause: validationResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return validationResult.value;
        }
    };
};
function mergeStreams(stream1, stream2) {
    const reader1 = stream1.getReader();
    const reader2 = stream2.getReader();
    let lastRead1 = void 0;
    let lastRead2 = void 0;
    let stream1Done = false;
    let stream2Done = false;
    async function readStream1(controller) {
        try {
            if (lastRead1 == null) {
                lastRead1 = reader1.read();
            }
            const result = await lastRead1;
            lastRead1 = void 0;
            if (!result.done) {
                controller.enqueue(result.value);
            } else {
                controller.close();
            }
        } catch (error) {
            controller.error(error);
        }
    }
    async function readStream2(controller) {
        try {
            if (lastRead2 == null) {
                lastRead2 = reader2.read();
            }
            const result = await lastRead2;
            lastRead2 = void 0;
            if (!result.done) {
                controller.enqueue(result.value);
            } else {
                controller.close();
            }
        } catch (error) {
            controller.error(error);
        }
    }
    return new ReadableStream({
        async pull (controller) {
            try {
                if (stream1Done) {
                    await readStream2(controller);
                    return;
                }
                if (stream2Done) {
                    await readStream1(controller);
                    return;
                }
                if (lastRead1 == null) {
                    lastRead1 = reader1.read();
                }
                if (lastRead2 == null) {
                    lastRead2 = reader2.read();
                }
                const { result, reader } = await Promise.race([
                    lastRead1.then((result2)=>({
                            result: result2,
                            reader: reader1
                        })),
                    lastRead2.then((result2)=>({
                            result: result2,
                            reader: reader2
                        }))
                ]);
                if (!result.done) {
                    controller.enqueue(result.value);
                }
                if (reader === reader1) {
                    lastRead1 = void 0;
                    if (result.done) {
                        await readStream2(controller);
                        stream1Done = true;
                    }
                } else {
                    lastRead2 = void 0;
                    if (result.done) {
                        stream2Done = true;
                        await readStream1(controller);
                    }
                }
            } catch (error) {
                controller.error(error);
            }
        },
        cancel () {
            reader1.cancel();
            reader2.cancel();
        }
    });
}
createIdGenerator({
    prefix: "aitxt",
    size: 24
});
createIdGenerator({
    prefix: "msg",
    size: 24
});
var ClientOrServerImplementationSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var BaseParamsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    _meta: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    params: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    experimental: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough()),
    logging: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough()),
    prompts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough()),
    resources: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        subscribe: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean()),
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough()),
    tools: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough())
}).passthrough();
ResultSchema.extend({
    protocolVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ClientOrServerImplementationSchema,
    instructions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
});
var PaginatedResultSchema = ResultSchema.extend({
    nextCursor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
});
var ToolSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
    inputSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("object"),
        properties: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough())
    }).passthrough()
}).passthrough();
PaginatedResultSchema.extend({
    tools: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(ToolSchema)
});
var TextContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var ImageContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().base64(),
    mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var ResourceContentsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    /**
   * The URI of this resource.
   */ uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    /**
   * The MIME type of this resource, if known.
   */ mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().base64()
});
var EmbeddedResourceSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("resource"),
    resource: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        TextResourceContentsSchema,
        BlobResourceContentsSchema
    ])
}).passthrough();
ResultSchema.extend({
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        TextContentSchema,
        ImageContentSchema,
        EmbeddedResourceSchema
    ])),
    isError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false).optional()
}).or(ResultSchema.extend({
    toolResult: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
}));
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ]),
    result: ResultSchema
}).strict();
var JSONRPCErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ]),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int(),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown())
    })
}).strict();
var JSONRPCNotificationSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION)
}).merge(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    params: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(BaseParamsSchema)
})).strict();
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
]);
var langchain_adapter_exports = {};
__export(langchain_adapter_exports, {
    mergeIntoDataStream: ()=>mergeIntoDataStream,
    toDataStream: ()=>toDataStream,
    toDataStreamResponse: ()=>toDataStreamResponse
});
function createCallbacksTransformer(callbacks = {}) {
    const textEncoder = new TextEncoder();
    let aggregatedResponse = "";
    return new TransformStream({
        async start () {
            if (callbacks.onStart) await callbacks.onStart();
        },
        async transform (message, controller) {
            controller.enqueue(textEncoder.encode(message));
            aggregatedResponse += message;
            if (callbacks.onToken) await callbacks.onToken(message);
            if (callbacks.onText && typeof message === "string") {
                await callbacks.onText(message);
            }
        },
        async flush () {
            if (callbacks.onCompletion) {
                await callbacks.onCompletion(aggregatedResponse);
            }
            if (callbacks.onFinal) {
                await callbacks.onFinal(aggregatedResponse);
            }
        }
    });
}
function toDataStreamInternal(stream, callbacks) {
    return stream.pipeThrough(new TransformStream({
        transform: async (value, controller)=>{
            var _a172;
            if (typeof value === "string") {
                controller.enqueue(value);
                return;
            }
            if ("event" in value) {
                if (value.event === "on_chat_model_stream") {
                    forwardAIMessageChunk((_a172 = value.data) == null ? void 0 : _a172.chunk, controller);
                }
                return;
            }
            forwardAIMessageChunk(value, controller);
        }
    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
        transform: async (chunk, controller)=>{
            controller.enqueue(formatDataStreamPart("text", chunk));
        }
    }));
}
function toDataStream(stream, callbacks) {
    return toDataStreamInternal(stream, callbacks).pipeThrough(new TextEncoderStream());
}
function toDataStreamResponse(stream, options) {
    var _a172;
    const dataStream = toDataStreamInternal(stream, options == null ? void 0 : options.callbacks).pipeThrough(new TextEncoderStream());
    const data = options == null ? void 0 : options.data;
    const init = options == null ? void 0 : options.init;
    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
    return new Response(responseStream, {
        status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
        statusText: init == null ? void 0 : init.statusText,
        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
            contentType: "text/plain; charset=utf-8",
            dataStreamVersion: "v1"
        })
    });
}
function mergeIntoDataStream(stream, options) {
    options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
function forwardAIMessageChunk(chunk, controller) {
    if (typeof chunk.content === "string") {
        controller.enqueue(chunk.content);
    } else {
        const content = chunk.content;
        for (const item of content){
            if (item.type === "text") {
                controller.enqueue(item.text);
            }
        }
    }
}
var llamaindex_adapter_exports = {};
__export(llamaindex_adapter_exports, {
    mergeIntoDataStream: ()=>mergeIntoDataStream2,
    toDataStream: ()=>toDataStream2,
    toDataStreamResponse: ()=>toDataStreamResponse2
});
function toDataStreamInternal2(stream, callbacks) {
    const trimStart = trimStartOfStream();
    return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]()).pipeThrough(new TransformStream({
        async transform (message, controller) {
            controller.enqueue(trimStart(message.delta));
        }
    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
        transform: async (chunk, controller)=>{
            controller.enqueue(formatDataStreamPart("text", chunk));
        }
    }));
}
function toDataStream2(stream, callbacks) {
    return toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());
}
function toDataStreamResponse2(stream, options = {}) {
    var _a172;
    const { init, data, callbacks } = options;
    const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());
    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
    return new Response(responseStream, {
        status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
        statusText: init == null ? void 0 : init.statusText,
        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
            contentType: "text/plain; charset=utf-8",
            dataStreamVersion: "v1"
        })
    });
}
function mergeIntoDataStream2(stream, options) {
    options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
function trimStartOfStream() {
    let isStreamStart = true;
    return (text22)=>{
        if (isStreamStart) {
            text22 = text22.trimStart();
            if (text22) isStreamStart = false;
        }
        return text22;
    };
}
var marker17 = "vercel.ai.error";
var symbol17 = Symbol.for(marker17);
var _a17;
var _AISDKError3 = class _AISDKError22 extends Error {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name144, message, cause }){
        super(message);
        this[_a17] = true;
        this.name = name144;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError22.hasMarker(error, marker17);
    }
    static hasMarker(error, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
_a17 = symbol17;
var AISDKError2 = _AISDKError3;
var name17 = "AI_APICallError";
var marker23 = `vercel.ai.error.${name17}`;
var symbol23 = Symbol.for(marker23);
var _a23;
var APICallError2 = class extends AISDKError2 {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name: name17,
            message,
            cause
        });
        this[_a23] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker23);
    }
};
_a23 = symbol23;
var name23 = "AI_EmptyResponseBodyError";
var marker33 = `vercel.ai.error.${name23}`;
var symbol33 = Symbol.for(marker33);
var _a33;
var EmptyResponseBodyError = class extends AISDKError2 {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}){
        super({
            name: name23,
            message
        });
        this[_a33] = true;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker33);
    }
};
_a33 = symbol33;
function getErrorMessage3(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
var name33 = "AI_InvalidArgumentError";
var marker43 = `vercel.ai.error.${name33}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidArgumentError3 = class extends AISDKError2 {
    constructor({ message, cause, argument }){
        super({
            name: name33,
            message,
            cause
        });
        this[_a43] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker43);
    }
};
_a43 = symbol43;
var name63 = "AI_JSONParseError";
var marker73 = `vercel.ai.error.${name63}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var JSONParseError2 = class extends AISDKError2 {
    constructor({ text: text4, cause }){
        super({
            name: name63,
            message: `JSON parsing failed: Text: ${text4}.
Error message: ${getErrorMessage3(cause)}`,
            cause
        });
        this[_a73] = true;
        this.text = text4;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker73);
    }
};
_a73 = symbol73;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError3 = class _TypeValidationError22 extends AISDKError2 {
    constructor({ value, cause }){
        super({
            name: name123,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
            cause
        });
        this[_a133] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker133);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError22.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError22({
            value,
            cause
        });
    }
};
_a133 = symbol133;
var TypeValidationError2 = _TypeValidationError3;
var ParseError = class extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
};
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = createParser({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
};
function combineHeaders(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>({
            ...combinedHeaders,
            ...currentHeaders != null ? currentHeaders : {}
        }), {});
}
async function delay2(delayInMs, options) {
    if (delayInMs == null) {
        return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve22, reject)=>{
        if (signal == null ? void 0 : signal.aborted) {
            reject(createAbortError());
            return;
        }
        const timeoutId = setTimeout(()=>{
            cleanup();
            resolve22();
        }, delayInMs);
        const cleanup = ()=>{
            clearTimeout(timeoutId);
            signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        };
        const onAbort = ()=>{
            cleanup();
            reject(createAbortError());
        };
        signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
}
function createAbortError() {
    return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
    return Object.fromEntries([
        ...response.headers
    ]);
}
var createIdGenerator2 = ({ prefix, size = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = ()=>{
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for(let i = 0; i < size; i++){
            chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
    };
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new InvalidArgumentError3({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return ()=>`${prefix}${separator}${generator()}`;
};
createIdGenerator2();
function getErrorMessage22(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
function isAbortError2(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = [
    "fetch failed",
    "failed to fetch"
];
function handleFetchError({ error, url, requestBodyValues }) {
    if (isAbortError2(error)) {
        return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
        const cause = error.cause;
        if (cause != null) {
            return new APICallError2({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
            });
        }
    }
    return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
    var _a154, _b17, _c;
    if (globalThisAny.window) {
        return `runtime/browser`;
    }
    if ((_a154 = globalThisAny.navigator) == null ? void 0 : _a154.userAgent) {
        return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b17 = globalThisAny.process) == null ? void 0 : _b17.versions) == null ? void 0 : _c.node) {
        return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
        return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
}
function normalizeHeaders(headers) {
    if (headers == null) {
        return {};
    }
    const normalized = {};
    if (headers instanceof Headers) {
        headers.forEach((value, key)=>{
            normalized[key.toLowerCase()] = value;
        });
    } else {
        if (!Array.isArray(headers)) {
            headers = Object.entries(headers);
        }
        for (const [key, value] of headers){
            if (value != null) {
                normalized[key.toLowerCase()] = value;
            }
        }
    }
    return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
    const normalizedHeaders = new Headers(normalizeHeaders(headers));
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set("user-agent", [
        currentUserAgentHeader,
        ...userAgentSuffixParts
    ].filter(Boolean).join(" "));
    return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION2 = "3.0.17";
var getOriginalFetch = ()=>globalThis.fetch;
var getFromApi = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch() })=>{
    try {
        const response = await fetch2(url, {
            method: "GET",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION2}`, getRuntimeEnvironmentUserAgent()),
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: {}
                });
            } catch (error) {
                if (isAbortError2(error) || APICallError2.isInstance(error)) {
                    throw error;
                }
                throw new APICallError2({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: {}
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: {}
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError2(error) || APICallError2.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError2({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: {}
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: {}
        });
    }
};
function loadOptionalSetting({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text4) {
    const obj = JSON.parse(text4);
    if (obj === null || typeof obj !== "object") {
        return obj;
    }
    if (suspectProtoRx.test(text4) === false && suspectConstructorRx.test(text4) === false) {
        return obj;
    }
    return filter(obj);
}
function filter(obj) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === "object") {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function secureJsonParse(text4) {
    const { stackTraceLimit } = Error;
    try {
        Error.stackTraceLimit = 0;
    } catch (e) {
        return _parse(text4);
    }
    try {
        return _parse(text4);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
var validatorSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator2(validate) {
    return {
        [validatorSymbol2]: true,
        validate
    };
}
function isValidator2(value) {
    return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
function lazyValidator(createValidator) {
    let validator22;
    return ()=>{
        if (validator22 == null) {
            validator22 = createValidator();
        }
        return validator22;
    };
}
function asValidator2(value) {
    return isValidator2(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema2) {
    return validator2(async (value)=>{
        const result = await standardSchema2["~standard"].validate(value);
        return result.issues == null ? {
            success: true,
            value: result.value
        } : {
            success: false,
            error: new TypeValidationError2({
                value,
                cause: result.issues
            })
        };
    });
}
async function validateTypes({ value, schema }) {
    const result = await safeValidateTypes2({
        value,
        schema
    });
    if (!result.success) {
        throw TypeValidationError2.wrap({
            value,
            cause: result.error
        });
    }
    return result.value;
}
async function safeValidateTypes2({ value, schema }) {
    const validator22 = asValidator2(schema);
    try {
        if (validator22.validate == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const result = await validator22.validate(value);
        if (result.success) {
            return {
                success: true,
                value: result.value,
                rawValue: value
            };
        }
        return {
            success: false,
            error: TypeValidationError2.wrap({
                value,
                cause: result.error
            }),
            rawValue: value
        };
    } catch (error) {
        return {
            success: false,
            error: TypeValidationError2.wrap({
                value,
                cause: error
            }),
            rawValue: value
        };
    }
}
async function parseJSON({ text: text4, schema }) {
    try {
        const value = secureJsonParse(text4);
        if (schema == null) {
            return value;
        }
        return validateTypes({
            value,
            schema
        });
    } catch (error) {
        if (JSONParseError2.isInstance(error) || TypeValidationError2.isInstance(error)) {
            throw error;
        }
        throw new JSONParseError2({
            text: text4,
            cause: error
        });
    }
}
async function safeParseJSON2({ text: text4, schema }) {
    try {
        const value = secureJsonParse(text4);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        return await safeValidateTypes2({
            value,
            schema
        });
    } catch (error) {
        return {
            success: false,
            error: JSONParseError2.isInstance(error) ? error : new JSONParseError2({
                text: text4,
                cause: error
            }),
            rawValue: void 0
        };
    }
}
function parseJsonEventStream({ stream, schema }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(new TransformStream({
        async transform ({ data }, controller) {
            if (data === "[DONE]") {
                return;
            }
            controller.enqueue(await safeParseJSON2({
                text: data,
                schema
            }));
        }
    }));
}
var getOriginalFetch2 = ()=>globalThis.fetch;
var postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch: fetch2 })=>postToApi({
        url,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        body: {
            content: JSON.stringify(body),
            values: body
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch: fetch2
    });
var postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch2() })=>{
    try {
        const response = await fetch2(url, {
            method: "POST",
            headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION2}`, getRuntimeEnvironmentUserAgent()),
            body: body.content,
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (isAbortError2(error) || APICallError2.isInstance(error)) {
                    throw error;
                }
                throw new APICallError2({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError2(error) || APICallError2.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError2({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
            });
        }
    } catch (error) {
        throw handleFetchError({
            error,
            url,
            requestBodyValues: body.values
        });
    }
};
async function resolve(value) {
    if (typeof value === "function") {
        value = value();
    }
    return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const responseHeaders = extractResponseHeaders(response);
        if (responseBody.trim() === "") {
            return {
                responseHeaders,
                value: new APICallError2({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
        try {
            const parsedError = await parseJSON({
                text: responseBody,
                schema: errorSchema
            });
            return {
                responseHeaders,
                value: new APICallError2({
                    message: errorToMessage(parsedError),
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    data: parsedError,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                })
            };
        } catch (parseError) {
            return {
                responseHeaders,
                value: new APICallError2({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
    };
var createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders(response);
        if (response.body == null) {
            throw new EmptyResponseBodyError({});
        }
        return {
            responseHeaders,
            value: parseJsonEventStream({
                stream: response.body,
                schema: chunkSchema
            })
        };
    };
var createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const parsedResult = await safeParseJSON2({
            text: responseBody,
            schema: responseSchema
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!parsedResult.success) {
            throw new APICallError2({
                message: "Invalid JSON response",
                cause: parsedResult.error,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                url,
                requestBodyValues
            });
        }
        return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
        };
    };
var getRelativePath2 = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
var ignoreOverride2 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
};
var getDefaultOptions2 = (options)=>typeof options === "string" ? {
        ...defaultOptions2,
        name: options
    } : {
        ...defaultOptions2,
        ...options
    };
function parseAnyDef2() {
    return {};
}
function parseArrayDef2(def, refs) {
    var _a154, _b17, _c;
    const res = {
        type: "array"
    };
    if (((_a154 = def.type) == null ? void 0 : _a154._def) && ((_c = (_b17 = def.type) == null ? void 0 : _b17._def) == null ? void 0 : _c.typeName) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny) {
        res.items = parseDef2(def.type._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        });
    }
    if (def.minLength) {
        res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
        res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
        res.minItems = def.exactLength.value;
        res.maxItems = def.exactLength.value;
    }
    return res;
}
function parseBigintDef2(def) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseBooleanDef2() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef2(_def, refs) {
    return parseDef2(_def.type._def, refs);
}
var parseCatchDef2 = (def, refs)=>{
    return parseDef2(def.innerType._def, refs);
};
function parseDateDef2(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef2(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser2(def);
    }
}
var integerDateParser2 = (def)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                res.minimum = check.value;
                break;
            case "max":
                res.maximum = check.value;
                break;
        }
    }
    return res;
};
function parseDefaultDef2(_def, refs) {
    return {
        ...parseDef2(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef2(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2();
}
function parseEnumDef2(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType2 = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef2(def, refs) {
    const allOf = [
        parseDef2(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef2(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType2(schema)) {
            mergedAllOf.push(...schema.allOf);
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf
    } : void 0;
}
function parseLiteralDef2(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex2 = void 0;
var zodPatterns2 = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex2 === void 0) {
            emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex2;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    break;
                case "max":
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat2(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat2(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern2(res, zodPatterns2.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat2(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat2(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern2(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern2(res, zodPatterns2.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern2(res, zodPatterns2.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat2(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat2(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat2(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat2(res, "duration", check.message, refs);
                    break;
                case "length":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "includes":
                    {
                        addPattern2(res, RegExp(escapeLiteralCheckValue2(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat2(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat2(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern2(res, zodPatterns2.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern2(res, zodPatterns2.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern2(res, zodPatterns2.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern2(res, zodPatterns2.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern2(res, zodPatterns2.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern2(res, zodPatterns2.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat2(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    res.contentEncoding = "base64";
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern2(res, zodPatterns2.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern2(res, zodPatterns2.nanoid, check.message, refs);
                    }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue2(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
}
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric2(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC2.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat2(schema, value, message, refs) {
    var _a154;
    if (schema.format || ((_a154 = schema.anyOf) == null ? void 0 : _a154.some((x)=>x.format))) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format
            });
            delete schema.format;
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else {
        schema.format = value;
    }
}
function addPattern2(schema, regex, message, refs) {
    var _a154;
    if (schema.pattern || ((_a154 = schema.allOf) == null ? void 0 : _a154.some((x)=>x.pattern))) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern
            });
            delete schema.pattern;
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags2(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else {
        schema.pattern = stringifyRegExpWithFlags2(regex, refs);
    }
}
function stringifyRegExpWithFlags2(regex, refs) {
    var _a154;
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        // Case-insensitive
        m: regex.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && ((_a154 = source[i + 2]) == null ? void 0 : _a154.match(/[a-z]/))) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}
function parseRecordDef2(def, refs) {
    var _a154, _b17, _c, _d, _e, _f;
    const schema = {
        type: "object",
        additionalProperties: (_a154 = parseDef2(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        })) != null ? _a154 : refs.allowedAdditionalProperties
    };
    if (((_b17 = def.keyType) == null ? void 0 : _b17._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
        const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values
            }
        };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded && def.keyType._def.type._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
        const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef2(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef2(def, refs);
    }
    const keys = parseDef2(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || parseAnyDef2();
    const values = parseDef2(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || parseAnyDef2();
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef2(def) {
    const object4 = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object4[object4[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object4[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef2() {
    return {
        not: parseAnyDef2()
    };
}
function parseNullDef2() {
    return {
        type: "null"
    };
}
var primitiveMappings2 = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef2(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings2[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef2(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef2(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        return {
            type: [
                primitiveMappings2[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    const base = parseDef2(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef2(def) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                break;
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseObjectDef2(def, refs) {
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        const propOptional = safeIsOptional2(propDef);
        const parsedDef = parseDef2(propDef._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        });
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties2(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties2(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef2(def.catchall._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        });
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional2(schema) {
    try {
        return schema.isOptional();
    } catch (e) {
        return true;
    }
}
var parseOptionalDef2 = (def, refs)=>{
    var _a154;
    if (refs.currentPath.toString() === ((_a154 = refs.propertyPath) == null ? void 0 : _a154.toString())) {
        return parseDef2(def.innerType._def, refs);
    }
    const innerSchema = parseDef2(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef2()
            },
            innerSchema
        ]
    } : parseAnyDef2();
};
var parsePipelineDef2 = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef2(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef2(def.out._def, refs);
    }
    const a = parseDef2(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef2(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef2(def, refs) {
    return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
    const items = parseDef2(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
        schema.maxItems = def.maxSize.value;
    }
    return schema;
}
function parseTupleDef2(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef2(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef2(def.rest._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            })
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef2(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef2() {
    return {
        not: parseAnyDef2()
    };
}
function parseUnknownDef2() {
    return parseAnyDef2();
}
var parseReadonlyDef2 = (def, refs)=>{
    return parseDef2(def.innerType._def, refs);
};
var selectParser2 = (def, typeName, refs)=>{
    switch(typeName){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString:
            return parseStringDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNumber:
            return parseNumberDef2(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodObject:
            return parseObjectDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBigInt:
            return parseBigintDef2(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBoolean:
            return parseBooleanDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDate:
            return parseDateDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUndefined:
            return parseUndefinedDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNull:
            return parseNullDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodArray:
            return parseArrayDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnion:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDiscriminatedUnion:
            return parseUnionDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodIntersection:
            return parseIntersectionDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodTuple:
            return parseTupleDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodRecord:
            return parseRecordDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLiteral:
            return parseLiteralDef2(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum:
            return parseEnumDef2(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNativeEnum:
            return parseNativeEnumDef2(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNullable:
            return parseNullableDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodOptional:
            return parseOptionalDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodMap:
            return parseMapDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSet:
            return parseSetDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLazy:
            return ()=>def.getter()._def;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPromise:
            return parsePromiseDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNaN:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNever:
            return parseNeverDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEffects:
            return parseEffectsDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny:
            return parseAnyDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnknown:
            return parseUnknownDef2();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDefault:
            return parseDefaultDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded:
            return parseBrandedDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodReadonly:
            return parseReadonlyDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodCatch:
            return parseCatchDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPipeline:
            return parsePipelineDef2(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodFunction:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodVoid:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)();
    }
};
function parseDef2(def, refs, forceResolution = false) {
    var _a154;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = (_a154 = refs.override) == null ? void 0 : _a154.call(refs, def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride2) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref2(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
    const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema22) {
        addMeta2(def, refs, jsonSchema22);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
        newItem.jsonSchema = jsonSchema22;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema22;
    return jsonSchema22;
}
var get$ref2 = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath2(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef2();
                }
                return refs.$refStrategy === "seen" ? parseAnyDef2() : void 0;
            }
    }
};
var addMeta2 = (def, refs, jsonSchema22)=>{
    if (def.description) {
        jsonSchema22.description = def.description;
    }
    return jsonSchema22;
};
var getRefs2 = (options)=>{
    const _options = getDefaultOptions2(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name144, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name144
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    };
};
var zodToJsonSchema2 = (schema, options)=>{
    var _a154;
    const refs = getRefs2(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name224, schema2])=>{
        var _a224;
        return {
            ...acc,
            [name224]: (_a224 = parseDef2(schema2._def, {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name224
                ]
            }, true)) != null ? _a224 : parseAnyDef2()
        };
    }, {}) : void 0;
    const name144 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a154 = parseDef2(schema._def, name144 === void 0 ? refs : {
        ...refs,
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name144
        ]
    }, false)) != null ? _a154 : parseAnyDef2();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    const combined = name144 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
    } : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name144
        ].join("/"),
        [refs.definitionPath]: {
            ...definitions,
            [name144]: main
        }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
};
var zod_to_json_schema_default = zodToJsonSchema2;
function zod3Schema(zodSchema22, options) {
    var _a154;
    const useReferences = (_a154 = void 0) != null ? _a154 : false;
    return jsonSchema2(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>zod_to_json_schema_default(zodSchema22, {
            $refStrategy: useReferences ? "root" : "none"
        }), {
        validate: async (value)=>{
            const result = await zodSchema22.safeParseAsync(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function zod4Schema(zodSchema22, options) {
    var _a154;
    const useReferences = (_a154 = void 0) != null ? _a154 : false;
    return jsonSchema2(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toJSONSchema"](zodSchema22, {
            target: "draft-7",
            io: "output",
            reused: useReferences ? "ref" : "inline"
        }), {
        validate: async (value)=>{
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseAsync"](zodSchema22, value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function isZod4Schema(zodSchema22) {
    return "_zod" in zodSchema22;
}
function zodSchema2(zodSchema22, options) {
    if (isZod4Schema(zodSchema22)) {
        return zod4Schema(zodSchema22);
    } else {
        return zod3Schema(zodSchema22);
    }
}
var schemaSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema2(jsonSchema22, { validate } = {}) {
    return {
        [schemaSymbol2]: true,
        _type: void 0,
        // should never be used directly
        [validatorSymbol2]: true,
        get jsonSchema () {
            if (typeof jsonSchema22 === "function") {
                jsonSchema22 = jsonSchema22();
            }
            return jsonSchema22;
        },
        validate
    };
}
function isSchema2(value) {
    return typeof value === "object" && value !== null && schemaSymbol2 in value && value[schemaSymbol2] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema2(schema) {
    return schema == null ? jsonSchema2({
        properties: {},
        additionalProperties: false
    }) : isSchema2(schema) ? schema : typeof schema === "function" ? schema() : zodSchema2(schema);
}
function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name162 in all)__defProp22(target, name162, {
                get: all[name162],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var get_context_exports = {};
        __export22(get_context_exports, {
            SYMBOL_FOR_REQ_CONTEXT: ()=>SYMBOL_FOR_REQ_CONTEXT,
            getContext: ()=>getContext3
        });
        module.exports = __toCommonJS(get_context_exports);
        var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
        function getContext3() {
            const fromSymbol = globalThis;
            return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
        }
    }
});
var require_get_vercel_oidc_token = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name162 in all)__defProp22(target, name162, {
                get: all[name162],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var get_vercel_oidc_token_exports = {};
        __export22(get_vercel_oidc_token_exports, {
            getVercelOidcToken: ()=>getVercelOidcToken3,
            getVercelOidcTokenSync: ()=>getVercelOidcTokenSync2
        });
        module.exports = __toCommonJS(get_vercel_oidc_token_exports);
        var import_get_context = require_get_context();
        var import_token_error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["require_token_error"])();
        async function getVercelOidcToken3() {
            let token = "";
            let err;
            try {
                token = getVercelOidcTokenSync2();
            } catch (error) {
                err = error;
            }
            try {
                const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
                    await __turbopack_context__.A("[project]/node_modules/@mastra/memory/dist/token-util-NEHG7TUY-TIJ3LMSH.js [app-route] (ecmascript, async loader)"),
                    await __turbopack_context__.A("[project]/node_modules/@mastra/memory/dist/token-6GSAFR2W-VLY2XUPA.js [app-route] (ecmascript, async loader)")
                ]);
                if (!token || isExpired(getTokenPayload(token))) {
                    await refreshToken();
                    token = getVercelOidcTokenSync2();
                }
            } catch (error) {
                if (err?.message && error instanceof Error) {
                    error.message = `${err.message}
${error.message}`;
                }
                throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
            }
            return token;
        }
        function getVercelOidcTokenSync2() {
            const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
            if (!token) {
                throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
            }
            return token;
        }
    }
});
var require_dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name162 in all)__defProp22(target, name162, {
                get: all[name162],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var src_exports = {};
        __export22(src_exports, {
            getContext: ()=>import_get_context.getContext,
            getVercelOidcToken: ()=>import_get_vercel_oidc_token.getVercelOidcToken,
            getVercelOidcTokenSync: ()=>import_get_vercel_oidc_token.getVercelOidcTokenSync
        });
        module.exports = __toCommonJS(src_exports);
        var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
        var import_get_context = require_get_context();
    }
});
var import_oidc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist(), 1);
var import_oidc2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$KMQS2YEC$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist(), 1);
var marker18 = "vercel.ai.gateway.error";
var symbol18 = Symbol.for(marker18);
var _a18;
var _b;
var GatewayError = class _GatewayError extends (_b = Error, _a18 = symbol18, _b) {
    constructor({ message, statusCode = 500, cause }){
        super(message);
        this[_a18] = true;
        this.statusCode = statusCode;
        this.cause = cause;
    }
    /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */ static isInstance(error) {
        return _GatewayError.hasMarker(error);
    }
    static hasMarker(error) {
        return typeof error === "object" && error !== null && symbol18 in error && error[symbol18] === true;
    }
};
var name18 = "GatewayAuthenticationError";
var marker24 = `vercel.ai.gateway.error.${name18}`;
var symbol24 = Symbol.for(marker24);
var _a24;
var _b2;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a24 = symbol24, _b2) {
    constructor({ message = "Authentication failed", statusCode = 401, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a24] = true;
        this.name = name18;
        this.type = "authentication_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol24 in error;
    }
    /**
   * Creates a contextual error message when authentication fails
   */ static createContextualError({ apiKeyProvided, oidcTokenProvided, message = "Authentication failed", statusCode = 401, cause }) {
        let contextualMessage;
        if (apiKeyProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
        } else if (oidcTokenProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
        } else {
            contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
        }
        return new _GatewayAuthenticationError({
            message: contextualMessage,
            statusCode,
            cause
        });
    }
};
var name24 = "GatewayInvalidRequestError";
var marker34 = `vercel.ai.gateway.error.${name24}`;
var symbol34 = Symbol.for(marker34);
var _a34;
var _b3;
var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a34 = symbol34, _b3) {
    constructor({ message = "Invalid request", statusCode = 400, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a34] = true;
        this.name = name24;
        this.type = "invalid_request_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol34 in error;
    }
};
var name34 = "GatewayRateLimitError";
var marker44 = `vercel.ai.gateway.error.${name34}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var _b4;
var GatewayRateLimitError = class extends (_b4 = GatewayError, _a44 = symbol44, _b4) {
    constructor({ message = "Rate limit exceeded", statusCode = 429, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a44] = true;
        this.name = name34;
        this.type = "rate_limit_exceeded";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol44 in error;
    }
};
var name44 = "GatewayModelNotFoundError";
var marker54 = `vercel.ai.gateway.error.${name44}`;
var symbol54 = Symbol.for(marker54);
var modelNotFoundParamSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })));
var _a54;
var _b5;
var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a54 = symbol54, _b5) {
    constructor({ message = "Model not found", statusCode = 404, modelId, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a54] = true;
        this.name = name44;
        this.type = "model_not_found";
        this.modelId = modelId;
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol54 in error;
    }
};
var name54 = "GatewayInternalServerError";
var marker64 = `vercel.ai.gateway.error.${name54}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var _b6;
var GatewayInternalServerError = class extends (_b6 = GatewayError, _a64 = symbol64, _b6) {
    constructor({ message = "Internal server error", statusCode = 500, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a64] = true;
        this.name = name54;
        this.type = "internal_server_error";
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol64 in error;
    }
};
var name64 = "GatewayResponseError";
var marker74 = `vercel.ai.gateway.error.${name64}`;
var symbol74 = Symbol.for(marker74);
var _a74;
var _b7;
var GatewayResponseError = class extends (_b7 = GatewayError, _a74 = symbol74, _b7) {
    constructor({ message = "Invalid response from Gateway", statusCode = 502, response, validationError, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a74] = true;
        this.name = name64;
        this.type = "response_error";
        this.response = response;
        this.validationError = validationError;
    }
    static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol74 in error;
    }
};
async function createGatewayErrorFromResponse({ response, statusCode, defaultMessage = "Gateway request failed", cause, authMethod }) {
    const parseResult = await safeValidateTypes2({
        value: response,
        schema: gatewayErrorResponseSchema
    });
    if (!parseResult.success) {
        return new GatewayResponseError({
            message: `Invalid error response format: ${defaultMessage}`,
            statusCode,
            response,
            validationError: parseResult.error,
            cause
        });
    }
    const validatedResponse = parseResult.value;
    const errorType = validatedResponse.error.type;
    const message = validatedResponse.error.message;
    switch(errorType){
        case "authentication_error":
            return GatewayAuthenticationError.createContextualError({
                apiKeyProvided: authMethod === "api-key",
                oidcTokenProvided: authMethod === "oidc",
                statusCode,
                cause
            });
        case "invalid_request_error":
            return new GatewayInvalidRequestError({
                message,
                statusCode,
                cause
            });
        case "rate_limit_exceeded":
            return new GatewayRateLimitError({
                message,
                statusCode,
                cause
            });
        case "model_not_found":
            {
                const modelResult = await safeValidateTypes2({
                    value: validatedResponse.error.param,
                    schema: modelNotFoundParamSchema
                });
                return new GatewayModelNotFoundError({
                    message,
                    statusCode,
                    modelId: modelResult.success ? modelResult.value.modelId : void 0,
                    cause
                });
            }
        case "internal_server_error":
            return new GatewayInternalServerError({
                message,
                statusCode,
                cause
            });
        default:
            return new GatewayInternalServerError({
                message,
                statusCode,
                cause
            });
    }
}
var gatewayErrorResponseSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            param: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().nullish(),
            code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
            ]).nullish()
        })
    })));
function asGatewayError(error, authMethod) {
    var _a832;
    if (GatewayError.isInstance(error)) {
        return error;
    }
    if (APICallError2.isInstance(error)) {
        return createGatewayErrorFromResponse({
            response: extractApiCallResponse(error),
            statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
            defaultMessage: "Gateway request failed",
            cause: error,
            authMethod
        });
    }
    return createGatewayErrorFromResponse({
        response: {},
        statusCode: 500,
        defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
        cause: error,
        authMethod
    });
}
function extractApiCallResponse(error) {
    if (error.data !== void 0) {
        return error.data;
    }
    if (error.responseBody != null) {
        try {
            return JSON.parse(error.responseBody);
        } catch (e) {
            return error.responseBody;
        }
    }
    return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
async function parseAuthMethod(headers) {
    const result = await safeValidateTypes2({
        value: headers[GATEWAY_AUTH_METHOD_HEADER],
        schema: gatewayAuthMethodSchema
    });
    return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("api-key"),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("oidc")
    ])));
var GatewayFetchMetadata = class {
    constructor(config){
        this.config = config;
    }
    async getAvailableModels() {
        try {
            const { value } = await getFromApi({
                url: `${this.config.baseURL}/config`,
                headers: await resolve(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler(gatewayAvailableModelsResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError(error);
        }
    }
    async getCredits() {
        try {
            const baseUrl = new URL(this.config.baseURL);
            const { value } = await getFromApi({
                url: `${baseUrl.origin}/v1/credits`,
                headers: await resolve(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler(gatewayCreditsResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError(error);
        }
    }
};
var gatewayAvailableModelsResponseSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        models: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            pricing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                input_cache_read: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
                input_cache_write: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish()
            }).transform(({ input, output, input_cache_read, input_cache_write })=>({
                    input,
                    output,
                    ...input_cache_read ? {
                        cachedInputTokens: input_cache_read
                    } : {},
                    ...input_cache_write ? {
                        cacheCreationInputTokens: input_cache_write
                    } : {}
                })).nullish(),
            specification: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                specificationVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("v2"),
                provider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            modelType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "language",
                "embedding",
                "image"
            ]).nullish()
        }))
    })));
var gatewayCreditsResponseSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        balance: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        total_used: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }).transform(({ balance, total_used })=>({
            balance,
            totalUsed: total_used
        }))));
var GatewayLanguageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
        this.supportedUrls = {
            "*/*": [
                /.*/
            ]
        };
    }
    get provider() {
        return this.config.provider;
    }
    async getArgs(options) {
        const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
        return {
            args: this.maybeEncodeFileParts(optionsWithoutSignal),
            warnings: []
        };
    }
    async doGenerate(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue: rawResponse } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, false), await resolve(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createJsonResponseHandler(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                ...responseBody,
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders,
                    body: rawResponse
                },
                warnings
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { value: response, responseHeaders } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, true), await resolve(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createEventSourceResponseHandler(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        if (warnings.length > 0) {
                            controller.enqueue({
                                type: "stream-start",
                                warnings
                            });
                        }
                    },
                    transform (chunk, controller) {
                        if (chunk.success) {
                            const streamPart = chunk.value;
                            if (streamPart.type === "raw" && !options.includeRawChunks) {
                                return;
                            }
                            if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                                streamPart.timestamp = new Date(streamPart.timestamp);
                            }
                            controller.enqueue(streamPart);
                        } else {
                            controller.error(chunk.error);
                        }
                    }
                })),
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    isFilePart(part) {
        return part && typeof part === "object" && "type" in part && part.type === "file";
    }
    /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */ maybeEncodeFileParts(options) {
        for (const message of options.prompt){
            for (const part of message.content){
                if (this.isFilePart(part)) {
                    const filePart = part;
                    if (filePart.data instanceof Uint8Array) {
                        const buffer = Uint8Array.from(filePart.data);
                        const base64Data = Buffer.from(buffer).toString("base64");
                        filePart.data = new URL(`data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`);
                    }
                }
            }
        }
        return options;
    }
    getUrl() {
        return `${this.config.baseURL}/language-model`;
    }
    getModelConfigHeaders(modelId, streaming) {
        return {
            "ai-language-model-specification-version": "2",
            "ai-language-model-id": modelId,
            "ai-language-model-streaming": String(streaming)
        };
    }
};
var GatewayEmbeddingModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
    }
    get provider() {
        return this.config.provider;
    }
    async doEmbed({ values, headers, abortSignal, providerOptions }) {
        var _a832;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
                body: {
                    input: values.length === 1 ? values[0] : values,
                    ...providerOptions ? {
                        providerOptions
                    } : {}
                },
                successfulResponseHandler: createJsonResponseHandler(gatewayEmbeddingResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                embeddings: responseBody.embeddings,
                usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
                providerMetadata: responseBody.providerMetadata,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                }
            };
        } catch (error) {
            throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/embedding-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-embedding-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var gatewayEmbeddingResponseSchema = lazyValidator(()=>zodSchema2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        embeddings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number())),
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            tokens: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
        }).nullish(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown())).optional()
    })));
var GatewayImageModel = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v2";
        this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
    }
    get provider() {
        return this.config.provider;
    }
    async doGenerate({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
        var _a832;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
            const { responseHeaders, value: responseBody } = await postJsonToApi({
                url: this.getUrl(),
                headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
                body: {
                    prompt,
                    n,
                    ...size && {
                        size
                    },
                    ...aspectRatio && {
                        aspectRatio
                    },
                    ...seed && {
                        seed
                    },
                    ...providerOptions && {
                        providerOptions
                    }
                },
                successfulResponseHandler: createJsonResponseHandler(gatewayImageResponseSchema),
                failedResponseHandler: createJsonErrorResponseHandler({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                images: responseBody.images,
                // Always base64 strings from server
                warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
                providerMetadata: responseBody.providerMetadata,
                response: {
                    timestamp: /* @__PURE__ */ new Date(),
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/image-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-image-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var providerMetadataEntrySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).optional()
}).catchall(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown());
var gatewayImageResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
    // Always base64 strings over the wire
    warnings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("other"),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })).optional(),
    providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), providerMetadataEntrySchema).optional()
});
async function getVercelRequestId() {
    var _a832;
    return (_a832 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION3 = "2.0.15";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
    var _a832, _b83;
    let pendingMetadata = null;
    let metadataCache = null;
    const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
    let lastFetchTime = 0;
    const baseURL = (_b83 = withoutTrailingSlash(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v1/ai";
    const getHeaders = async ()=>{
        const auth = await getGatewayAuthToken(options);
        if (auth) {
            return withUserAgentSuffix({
                Authorization: `Bearer ${auth.token}`,
                "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
                [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
                ...options.headers
            }, `ai-sdk/gateway/${VERSION3}`);
        }
        throw GatewayAuthenticationError.createContextualError({
            apiKeyProvided: false,
            oidcTokenProvided: false,
            statusCode: 401
        });
    };
    const createO11yHeaders = ()=>{
        const deploymentId = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_DEPLOYMENT_ID"
        });
        const environment = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_ENV"
        });
        const region = loadOptionalSetting({
            settingValue: void 0,
            environmentVariableName: "VERCEL_REGION"
        });
        return async ()=>{
            const requestId = await getVercelRequestId();
            return {
                ...deploymentId && {
                    "ai-o11y-deployment-id": deploymentId
                },
                ...environment && {
                    "ai-o11y-environment": environment
                },
                ...region && {
                    "ai-o11y-region": region
                },
                ...requestId && {
                    "ai-o11y-request-id": requestId
                }
            };
        };
    };
    const createLanguageModel = (modelId)=>{
        return new GatewayLanguageModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    const getAvailableModels = async ()=>{
        var _a922, _b92, _c;
        const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
        if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
            lastFetchTime = now2;
            pendingMetadata = new GatewayFetchMetadata({
                baseURL,
                headers: getHeaders,
                fetch: options.fetch
            }).getAvailableModels().then((metadata)=>{
                metadataCache = metadata;
                return metadata;
            }).catch(async (error)=>{
                throw await asGatewayError(error, await parseAuthMethod(await getHeaders()));
            });
        }
        return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
    };
    const getCredits = async ()=>{
        return new GatewayFetchMetadata({
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        }).getCredits().catch(async (error)=>{
            throw await asGatewayError(error, await parseAuthMethod(await getHeaders()));
        });
    };
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Gateway Provider model function cannot be called with the new keyword.");
        }
        return createLanguageModel(modelId);
    };
    provider.getAvailableModels = getAvailableModels;
    provider.getCredits = getCredits;
    provider.imageModel = (modelId)=>{
        return new GatewayImageModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    provider.languageModel = createLanguageModel;
    provider.textEmbeddingModel = (modelId)=>{
        return new GatewayEmbeddingModel(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
    const apiKey = loadOptionalSetting({
        settingValue: options.apiKey,
        environmentVariableName: "AI_GATEWAY_API_KEY"
    });
    if (apiKey) {
        return {
            token: apiKey,
            authMethod: "api-key"
        };
    }
    try {
        const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
        return {
            token: oidcToken,
            authMethod: "oidc"
        };
    } catch (e) {
        return null;
    }
}
var _globalThis2 = typeof globalThis === "object" ? globalThis : /*TURBOPACK member replacement*/ __turbopack_context__.g;
var VERSION22 = "1.9.0";
var re2 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck2(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([
        ownVersion
    ]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re2);
    if (!myVersionMatch) {
        return function() {
            return false;
        };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible22(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re2);
        if (!globalVersionMatch) {
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
var isCompatible2 = _makeCompatibilityCheck2(VERSION22);
var major2 = VERSION22.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY2 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major2);
var _global2 = _globalThis2;
function registerGlobal2(type, instance, diag, allowOverride) {
    var _a162;
    if (allowOverride === void 0) {
        allowOverride = false;
    }
    var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2] = (_a162 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) !== null && _a162 !== void 0 ? _a162 : {
        version: VERSION22
    };
    if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION22) {
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION22);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION22 + ".");
    return true;
}
function getGlobal2(type) {
    var _a162, _b83;
    var globalVersion = (_a162 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _a162 === void 0 ? void 0 : _a162.version;
    if (!globalVersion || !isCompatible2(globalVersion)) {
        return;
    }
    return (_b83 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal2(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION22 + ".");
    var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2];
    if (api) {
        delete api[type];
    }
}
var __read5 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray5 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger2 = /** @class */ function() {
    function DiagComponentLogger22(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger22.prototype.debug = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy2("debug", this._namespace, args);
    };
    DiagComponentLogger22.prototype.error = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy2("error", this._namespace, args);
    };
    DiagComponentLogger22.prototype.info = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy2("info", this._namespace, args);
    };
    DiagComponentLogger22.prototype.warn = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy2("warn", this._namespace, args);
    };
    DiagComponentLogger22.prototype.verbose = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy2("verbose", this._namespace, args);
    };
    return DiagComponentLogger22;
}();
function logProxy2(funcName, namespace, args) {
    var logger = getGlobal2("diag");
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray5([], __read5(args), false));
}
var DiagLogLevel2;
(function(DiagLogLevel22) {
    DiagLogLevel22[DiagLogLevel22["NONE"] = 0] = "NONE";
    DiagLogLevel22[DiagLogLevel22["ERROR"] = 30] = "ERROR";
    DiagLogLevel22[DiagLogLevel22["WARN"] = 50] = "WARN";
    DiagLogLevel22[DiagLogLevel22["INFO"] = 60] = "INFO";
    DiagLogLevel22[DiagLogLevel22["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel22[DiagLogLevel22["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel22[DiagLogLevel22["ALL"] = 9999] = "ALL";
})(DiagLogLevel2 || (DiagLogLevel2 = {}));
function createLogLevelDiagLogger2(maxLevel, logger) {
    if (maxLevel < DiagLogLevel2.NONE) {
        maxLevel = DiagLogLevel2.NONE;
    } else if (maxLevel > DiagLogLevel2.ALL) {
        maxLevel = DiagLogLevel2.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function() {};
    }
    return {
        error: _filterFunc("error", DiagLogLevel2.ERROR),
        warn: _filterFunc("warn", DiagLogLevel2.WARN),
        info: _filterFunc("info", DiagLogLevel2.INFO),
        debug: _filterFunc("debug", DiagLogLevel2.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel2.VERBOSE)
    };
}
var __read22 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray22 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME4 = "diag";
var DiagAPI2 = /** @class */ function() {
    function DiagAPI22() {
        function _logProxy(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal2("diag");
                if (!logger) return;
                return logger[funcName].apply(logger, __spreadArray22([], __read22(args), false));
            };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
            var _a162, _b83, _c;
            if (optionsOrLogLevel === void 0) {
                optionsOrLogLevel = {
                    logLevel: DiagLogLevel2.INFO
                };
            }
            if (logger === self) {
                var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                self.error((_a162 = err.stack) !== null && _a162 !== void 0 ? _a162 : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === "number") {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel
                };
            }
            var oldLogger = getGlobal2("diag");
            var newLogger = createLogLevelDiagLogger2((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel2.INFO, logger);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal2("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
            unregisterGlobal2(API_NAME4, self);
        };
        self.createComponentLogger = function(options) {
            return new DiagComponentLogger2(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
    }
    DiagAPI22.instance = function() {
        if (!this._instance) {
            this._instance = new DiagAPI22();
        }
        return this._instance;
    };
    return DiagAPI22;
}();
function createContextKey2(description) {
    return Symbol.for(description);
}
var BaseContext2 = /** @class */ /* @__PURE__ */ function() {
    function BaseContext22(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext22;
}();
var ROOT_CONTEXT2 = new BaseContext2();
var __read32 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray32 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager2 = /** @class */ function() {
    function NoopContextManager22() {}
    NoopContextManager22.prototype.active = function() {
        return ROOT_CONTEXT2;
    };
    NoopContextManager22.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray32([
            thisArg
        ], __read32(args), false));
    };
    NoopContextManager22.prototype.bind = function(_context, target) {
        return target;
    };
    NoopContextManager22.prototype.enable = function() {
        return this;
    };
    NoopContextManager22.prototype.disable = function() {
        return this;
    };
    return NoopContextManager22;
}();
var __read42 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray42 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME22 = "context";
var NOOP_CONTEXT_MANAGER2 = new NoopContextManager2();
var ContextAPI2 = /** @class */ function() {
    function ContextAPI22() {}
    ContextAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new ContextAPI22();
        }
        return this._instance;
    };
    ContextAPI22.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal2(API_NAME22, contextManager, DiagAPI2.instance());
    };
    ContextAPI22.prototype.active = function() {
        return this._getContextManager().active();
    };
    ContextAPI22.prototype.with = function(context, fn, thisArg) {
        var _a162;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return (_a162 = this._getContextManager()).with.apply(_a162, __spreadArray42([
            context,
            fn,
            thisArg
        ], __read42(args), false));
    };
    ContextAPI22.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI22.prototype._getContextManager = function() {
        return getGlobal2(API_NAME22) || NOOP_CONTEXT_MANAGER2;
    };
    ContextAPI22.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal2(API_NAME22, DiagAPI2.instance());
    };
    return ContextAPI22;
}();
var TraceFlags2;
(function(TraceFlags22) {
    TraceFlags22[TraceFlags22["NONE"] = 0] = "NONE";
    TraceFlags22[TraceFlags22["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags2 || (TraceFlags2 = {}));
var INVALID_SPANID2 = "0000000000000000";
var INVALID_TRACEID2 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT2 = {
    traceId: INVALID_TRACEID2,
    spanId: INVALID_SPANID2,
    traceFlags: TraceFlags2.NONE
};
var NonRecordingSpan2 = /** @class */ function() {
    function NonRecordingSpan22(_spanContext) {
        if (_spanContext === void 0) {
            _spanContext = INVALID_SPAN_CONTEXT2;
        }
        this._spanContext = _spanContext;
    }
    NonRecordingSpan22.prototype.spanContext = function() {
        return this._spanContext;
    };
    NonRecordingSpan22.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    NonRecordingSpan22.prototype.setAttributes = function(_attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addLink = function(_link) {
        return this;
    };
    NonRecordingSpan22.prototype.addLinks = function(_links) {
        return this;
    };
    NonRecordingSpan22.prototype.setStatus = function(_status) {
        return this;
    };
    NonRecordingSpan22.prototype.updateName = function(_name) {
        return this;
    };
    NonRecordingSpan22.prototype.end = function(_endTime) {};
    NonRecordingSpan22.prototype.isRecording = function() {
        return false;
    };
    NonRecordingSpan22.prototype.recordException = function(_exception, _time) {};
    return NonRecordingSpan22;
}();
var SPAN_KEY2 = createContextKey2("OpenTelemetry Context Key SPAN");
function getSpan2(context) {
    return context.getValue(SPAN_KEY2) || void 0;
}
function getActiveSpan2() {
    return getSpan2(ContextAPI2.getInstance().active());
}
function setSpan2(context, span) {
    return context.setValue(SPAN_KEY2, span);
}
function deleteSpan2(context) {
    return context.deleteValue(SPAN_KEY2);
}
function setSpanContext2(context, spanContext) {
    return setSpan2(context, new NonRecordingSpan2(spanContext));
}
function getSpanContext2(context) {
    var _a162;
    return (_a162 = getSpan2(context)) === null || _a162 === void 0 ? void 0 : _a162.spanContext();
}
var VALID_TRACEID_REGEX2 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX2 = /^[0-9a-f]{16}$/i;
function isValidTraceId2(traceId) {
    return VALID_TRACEID_REGEX2.test(traceId) && traceId !== INVALID_TRACEID2;
}
function isValidSpanId2(spanId) {
    return VALID_SPANID_REGEX2.test(spanId) && spanId !== INVALID_SPANID2;
}
function isSpanContextValid2(spanContext) {
    return isValidTraceId2(spanContext.traceId) && isValidSpanId2(spanContext.spanId);
}
function wrapSpanContext2(spanContext) {
    return new NonRecordingSpan2(spanContext);
}
var contextApi2 = ContextAPI2.getInstance();
var NoopTracer2 = /** @class */ function() {
    function NoopTracer22() {}
    NoopTracer22.prototype.startSpan = function(name162, options, context) {
        if (context === void 0) {
            context = contextApi2.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan2();
        }
        var parentFromContext = context && getSpanContext2(context);
        if (isSpanContext2(parentFromContext) && isSpanContextValid2(parentFromContext)) {
            return new NonRecordingSpan2(parentFromContext);
        } else {
            return new NonRecordingSpan2();
        }
    };
    NoopTracer22.prototype.startActiveSpan = function(name162, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        } else if (arguments.length === 2) {
            fn = arg2;
        } else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi2.active();
        var span = this.startSpan(name162, opts, parentContext);
        var contextWithSpanSet = setSpan2(parentContext, span);
        return contextApi2.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer22;
}();
function isSpanContext2(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER2 = new NoopTracer2();
var ProxyTracer2 = /** @class */ function() {
    function ProxyTracer22(_provider, name162, version, options) {
        this._provider = _provider;
        this.name = name162;
        this.version = version;
        this.options = options;
    }
    ProxyTracer22.prototype.startSpan = function(name162, options, context) {
        return this._getTracer().startSpan(name162, options, context);
    };
    ProxyTracer22.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer22.prototype._getTracer = function() {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER2;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer22;
}();
var NoopTracerProvider2 = /** @class */ function() {
    function NoopTracerProvider22() {}
    NoopTracerProvider22.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer2();
    };
    return NoopTracerProvider22;
}();
var NOOP_TRACER_PROVIDER2 = new NoopTracerProvider2();
var ProxyTracerProvider2 = /** @class */ function() {
    function ProxyTracerProvider22() {}
    ProxyTracerProvider22.prototype.getTracer = function(name162, version, options) {
        var _a162;
        return (_a162 = this.getDelegateTracer(name162, version, options)) !== null && _a162 !== void 0 ? _a162 : new ProxyTracer2(this, name162, version, options);
    };
    ProxyTracerProvider22.prototype.getDelegate = function() {
        var _a162;
        return (_a162 = this._delegate) !== null && _a162 !== void 0 ? _a162 : NOOP_TRACER_PROVIDER2;
    };
    ProxyTracerProvider22.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider22.prototype.getDelegateTracer = function(name162, version, options) {
        var _a162;
        return (_a162 = this._delegate) === null || _a162 === void 0 ? void 0 : _a162.getTracer(name162, version, options);
    };
    return ProxyTracerProvider22;
}();
var SpanStatusCode2;
(function(SpanStatusCode22) {
    SpanStatusCode22[SpanStatusCode22["UNSET"] = 0] = "UNSET";
    SpanStatusCode22[SpanStatusCode22["OK"] = 1] = "OK";
    SpanStatusCode22[SpanStatusCode22["ERROR"] = 2] = "ERROR";
})(SpanStatusCode2 || (SpanStatusCode2 = {}));
var API_NAME32 = "trace";
var TraceAPI2 = /** @class */ function() {
    function TraceAPI22() {
        this._proxyTracerProvider = new ProxyTracerProvider2();
        this.wrapSpanContext = wrapSpanContext2;
        this.isSpanContextValid = isSpanContextValid2;
        this.deleteSpan = deleteSpan2;
        this.getSpan = getSpan2;
        this.getActiveSpan = getActiveSpan2;
        this.getSpanContext = getSpanContext2;
        this.setSpan = setSpan2;
        this.setSpanContext = setSpanContext2;
    }
    TraceAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new TraceAPI22();
        }
        return this._instance;
    };
    TraceAPI22.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal2(API_NAME32, this._proxyTracerProvider, DiagAPI2.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    TraceAPI22.prototype.getTracerProvider = function() {
        return getGlobal2(API_NAME32) || this._proxyTracerProvider;
    };
    TraceAPI22.prototype.getTracer = function(name162, version) {
        return this.getTracerProvider().getTracer(name162, version);
    };
    TraceAPI22.prototype.disable = function() {
        unregisterGlobal2(API_NAME32, DiagAPI2.instance());
        this._proxyTracerProvider = new ProxyTracerProvider2();
    };
    return TraceAPI22;
}();
var trace2 = TraceAPI2.getInstance();
var __defProp3 = Object.defineProperty;
var __export2 = (target, all)=>{
    for(var name162 in all)__defProp3(target, name162, {
        get: all[name162],
        enumerable: true
    });
};
var name222 = "AI_InvalidArgumentError";
var marker222 = `vercel.ai.error.${name222}`;
var symbol222 = Symbol.for(marker222);
var _a222;
var InvalidArgumentError22 = class extends AISDKError2 {
    constructor({ parameter, value, message }){
        super({
            name: name222,
            message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a222] = true;
        this.parameter = parameter;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker222);
    }
};
_a222 = symbol222;
var name622 = "AI_NoObjectGeneratedError";
var marker622 = `vercel.ai.error.${name622}`;
var symbol622 = Symbol.for(marker622);
var _a622;
var NoObjectGeneratedError2 = class extends AISDKError2 {
    constructor({ message = "No object generated.", cause, text: text22, response, usage, finishReason }){
        super({
            name: name622,
            message,
            cause
        });
        this[_a622] = true;
        this.text = text22;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker622);
    }
};
_a622 = symbol622;
var UnsupportedModelVersionError2 = class extends AISDKError2 {
    constructor(options){
        super({
            name: "AI_UnsupportedModelVersionError",
            message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
        });
        this.version = options.version;
        this.provider = options.provider;
        this.modelId = options.modelId;
    }
};
var name142 = "AI_RetryError";
var marker144 = `vercel.ai.error.${name142}`;
var symbol144 = Symbol.for(marker144);
var _a144;
var RetryError2 = class extends AISDKError2 {
    constructor({ message, reason, errors }){
        super({
            name: name142,
            message
        });
        this[_a144] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
        return AISDKError2.hasMarker(error, marker144);
    }
};
_a144 = symbol144;
function resolveEmbeddingModel(model) {
    if (typeof model !== "string") {
        if (model.specificationVersion !== "v2") {
            throw new UnsupportedModelVersionError2({
                version: model.specificationVersion,
                provider: model.provider,
                modelId: model.modelId
            });
        }
        return model;
    }
    return getGlobalProvider().textEmbeddingModel(model);
}
function getGlobalProvider() {
    var _a162;
    return (_a162 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a162 : gateway;
}
var VERSION32 = "5.0.101";
var dataContentSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>{
        var _a162, _b83;
        return (_b83 = (_a162 = globalThis.Buffer) == null ? void 0 : _a162.isBuffer(value)) != null ? _b83 : false;
    }, {
        message: "Must be a Buffer"
    })
]);
var jsonValueSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema2),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(jsonValueSchema2)
    ]));
var providerMetadataSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema2));
var textPartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema2.optional()
});
var imagePartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema2,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    providerOptions: providerMetadataSchema2.optional()
});
var filePartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema2,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema2.optional()
});
var reasoningPartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema2.optional()
});
var toolCallPartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    providerOptions: providerMetadataSchema2.optional(),
    providerExecuted: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional()
});
var outputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].discriminatedUnion("type", [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("json"),
        value: jsonValueSchema2
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-json"),
        value: jsonValueSchema2
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("content"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
                text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("media"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            })
        ]))
    })
]);
var toolResultPartSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    output: outputSchema,
    providerOptions: providerMetadataSchema2.optional()
});
var systemModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("system"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema2.optional()
});
var userModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("user"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema2,
            imagePartSchema2,
            filePartSchema2
        ]))
    ]),
    providerOptions: providerMetadataSchema2.optional()
});
var assistantModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("assistant"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema2,
            filePartSchema2,
            reasoningPartSchema2,
            toolCallPartSchema2,
            toolResultPartSchema2
        ]))
    ]),
    providerOptions: providerMetadataSchema2.optional()
});
var toolModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(toolResultPartSchema2),
    providerOptions: providerMetadataSchema2.optional()
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
]);
function assembleOperationName2({ operationId, telemetry }) {
    return {
        // standardized operation and resource name:
        "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
        "resource.name": telemetry == null ? void 0 : telemetry.functionId,
        // detailed, AI SDK specific data:
        "ai.operationId": operationId,
        "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
}
function getBaseTelemetryAttributes2({ model, settings, telemetry, headers }) {
    var _a162;
    return {
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // settings:
        ...Object.entries(settings).reduce((attributes, [key, value])=>{
            attributes[`ai.settings.${key}`] = value;
            return attributes;
        }, {}),
        // add metadata as attributes:
        ...Object.entries((_a162 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a162 : {}).reduce((attributes, [key, value])=>{
            attributes[`ai.telemetry.metadata.${key}`] = value;
            return attributes;
        }, {}),
        // request headers
        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{
            if (value !== void 0) {
                attributes[`ai.request.headers.${key}`] = value;
            }
            return attributes;
        }, {})
    };
}
var noopTracer2 = {
    startSpan () {
        return noopSpan2;
    },
    startActiveSpan (name162, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
            return arg1(noopSpan2);
        }
        if (typeof arg2 === "function") {
            return arg2(noopSpan2);
        }
        if (typeof arg3 === "function") {
            return arg3(noopSpan2);
        }
    }
};
var noopSpan2 = {
    spanContext () {
        return noopSpanContext2;
    },
    setAttribute () {
        return this;
    },
    setAttributes () {
        return this;
    },
    addEvent () {
        return this;
    },
    addLink () {
        return this;
    },
    addLinks () {
        return this;
    },
    setStatus () {
        return this;
    },
    updateName () {
        return this;
    },
    end () {
        return this;
    },
    isRecording () {
        return false;
    },
    recordException () {
        return this;
    }
};
var noopSpanContext2 = {
    traceId: "",
    spanId: "",
    traceFlags: 0
};
function getTracer2({ isEnabled = false, tracer } = {}) {
    if (!isEnabled) {
        return noopTracer2;
    }
    if (tracer) {
        return tracer;
    }
    return trace2.getTracer("ai");
}
function recordSpan2({ name: name162, tracer, attributes, fn, endWhenDone = true }) {
    return tracer.startActiveSpan(name162, {
        attributes
    }, async (span)=>{
        try {
            const result = await fn(span);
            if (endWhenDone) {
                span.end();
            }
            return result;
        } catch (error) {
            try {
                recordErrorOnSpan2(span, error);
            } finally{
                span.end();
            }
            throw error;
        }
    });
}
function recordErrorOnSpan2(span, error) {
    if (error instanceof Error) {
        span.recordException({
            name: error.name,
            message: error.message,
            stack: error.stack
        });
        span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: error.message
        });
    } else {
        span.setStatus({
            code: SpanStatusCode2.ERROR
        });
    }
}
function selectTelemetryAttributes2({ telemetry, attributes }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
        return {};
    }
    return Object.entries(attributes).reduce((attributes2, [key, value])=>{
        if (value == null) {
            return attributes2;
        }
        if (typeof value === "object" && "input" in value && typeof value.input === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
                return attributes2;
            }
            const result = value.input();
            return result == null ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        if (typeof value === "object" && "output" in value && typeof value.output === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
                return attributes2;
            }
            const result = value.output();
            return result == null ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        return {
            ...attributes2,
            [key]: value
        };
    }, {});
}
function getRetryDelayInMs({ error, exponentialBackoffDelay }) {
    const headers = error.responseHeaders;
    if (!headers) return exponentialBackoffDelay;
    let ms;
    const retryAfterMs = headers["retry-after-ms"];
    if (retryAfterMs) {
        const timeoutMs = parseFloat(retryAfterMs);
        if (!Number.isNaN(timeoutMs)) {
            ms = timeoutMs;
        }
    }
    const retryAfter = headers["retry-after"];
    if (retryAfter && ms === void 0) {
        const timeoutSeconds = parseFloat(retryAfter);
        if (!Number.isNaN(timeoutSeconds)) {
            ms = timeoutSeconds * 1e3;
        } else {
            ms = Date.parse(retryAfter) - Date.now();
        }
    }
    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
        return ms;
    }
    return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2, abortSignal } = {})=>async (f)=>_retryWithExponentialBackoff2(f, {
            maxRetries,
            delayInMs: initialDelayInMs,
            backoffFactor,
            abortSignal
        });
async function _retryWithExponentialBackoff2(f, { maxRetries, delayInMs, backoffFactor, abortSignal }, errors = []) {
    try {
        return await f();
    } catch (error) {
        if (isAbortError2(error)) {
            throw error;
        }
        if (maxRetries === 0) {
            throw error;
        }
        const errorMessage = getErrorMessage22(error);
        const newErrors = [
            ...errors,
            error
        ];
        const tryNumber = newErrors.length;
        if (tryNumber > maxRetries) {
            throw new RetryError2({
                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
                reason: "maxRetriesExceeded",
                errors: newErrors
            });
        }
        if (error instanceof Error && APICallError2.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
            await delay2(getRetryDelayInMs({
                error,
                exponentialBackoffDelay: delayInMs
            }), {
                abortSignal
            });
            return _retryWithExponentialBackoff2(f, {
                maxRetries,
                delayInMs: backoffFactor * delayInMs,
                backoffFactor,
                abortSignal
            }, newErrors);
        }
        if (tryNumber === 1) {
            throw error;
        }
        throw new RetryError2({
            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
            reason: "errorNotRetryable",
            errors: newErrors
        });
    }
}
function prepareRetries2({ maxRetries, abortSignal }) {
    if (maxRetries != null) {
        if (!Number.isInteger(maxRetries)) {
            throw new InvalidArgumentError22({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be an integer"
            });
        }
        if (maxRetries < 0) {
            throw new InvalidArgumentError22({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be >= 0"
            });
        }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
        maxRetries: maxRetriesResult,
        retry: retryWithExponentialBackoffRespectingRetryHeaders({
            maxRetries: maxRetriesResult,
            abortSignal
        })
    };
}
createIdGenerator2({
    prefix: "aitxt",
    size: 24
});
function fixJson2(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
async function parsePartialJson2(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = await safeParseJSON2({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = await safeParseJSON2({
        text: fixJson2(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
createIdGenerator2({
    prefix: "aitxt",
    size: 24
});
function splitArray2(array2, chunkSize) {
    if (chunkSize <= 0) {
        throw new Error("chunkSize must be greater than 0");
    }
    const result = [];
    for(let i = 0; i < array2.length; i += chunkSize){
        result.push(array2.slice(i, i + chunkSize));
    }
    return result;
}
async function embedMany2({ model: modelArg, values, maxParallelCalls = Infinity, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {
    const model = resolveEmbeddingModel(modelArg);
    const { maxRetries, retry } = prepareRetries2({
        maxRetries: maxRetriesArg,
        abortSignal
    });
    const headersWithUserAgent = withUserAgentSuffix(headers != null ? headers : {}, `ai/${VERSION32}`);
    const baseTelemetryAttributes = getBaseTelemetryAttributes2({
        model,
        telemetry,
        headers: headersWithUserAgent,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer2(telemetry);
    return recordSpan2({
        name: "ai.embedMany",
        attributes: selectTelemetryAttributes2({
            telemetry,
            attributes: {
                ...assembleOperationName2({
                    operationId: "ai.embedMany",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                    input: ()=>values.map((value)=>JSON.stringify(value))
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            var _a162;
            const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
                model.maxEmbeddingsPerCall,
                model.supportsParallelCalls
            ]);
            if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
                const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(()=>{
                    return recordSpan2({
                        name: "ai.embedMany.doEmbed",
                        attributes: selectTelemetryAttributes2({
                            telemetry,
                            attributes: {
                                ...assembleOperationName2({
                                    operationId: "ai.embedMany.doEmbed",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                // specific settings that only make sense on the outer level:
                                "ai.values": {
                                    input: ()=>values.map((value)=>JSON.stringify(value))
                                }
                            }
                        }),
                        tracer,
                        fn: async (doEmbedSpan)=>{
                            var _a172;
                            const modelResponse = await model.doEmbed({
                                values,
                                abortSignal,
                                headers: headersWithUserAgent,
                                providerOptions
                            });
                            const embeddings3 = modelResponse.embeddings;
                            const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : {
                                tokens: NaN
                            };
                            doEmbedSpan.setAttributes(selectTelemetryAttributes2({
                                telemetry,
                                attributes: {
                                    "ai.embeddings": {
                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))
                                    },
                                    "ai.usage.tokens": usage2.tokens
                                }
                            }));
                            return {
                                embeddings: embeddings3,
                                usage: usage2,
                                providerMetadata: modelResponse.providerMetadata,
                                response: modelResponse.response
                            };
                        }
                    });
                });
                span.setAttributes(selectTelemetryAttributes2({
                    telemetry,
                    attributes: {
                        "ai.embeddings": {
                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                        },
                        "ai.usage.tokens": usage.tokens
                    }
                }));
                return new DefaultEmbedManyResult2({
                    values,
                    embeddings: embeddings2,
                    usage,
                    providerMetadata: providerMetadata2,
                    responses: [
                        response
                    ]
                });
            }
            const valueChunks = splitArray2(values, maxEmbeddingsPerCall);
            const embeddings = [];
            const responses = [];
            let tokens = 0;
            let providerMetadata;
            const parallelChunks = splitArray2(valueChunks, supportsParallelCalls ? maxParallelCalls : 1);
            for (const parallelChunk of parallelChunks){
                const results = await Promise.all(parallelChunk.map((chunk)=>{
                    return retry(()=>{
                        return recordSpan2({
                            name: "ai.embedMany.doEmbed",
                            attributes: selectTelemetryAttributes2({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName2({
                                        operationId: "ai.embedMany.doEmbed",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // specific settings that only make sense on the outer level:
                                    "ai.values": {
                                        input: ()=>chunk.map((value)=>JSON.stringify(value))
                                    }
                                }
                            }),
                            tracer,
                            fn: async (doEmbedSpan)=>{
                                var _a172;
                                const modelResponse = await model.doEmbed({
                                    values: chunk,
                                    abortSignal,
                                    headers: headersWithUserAgent,
                                    providerOptions
                                });
                                const embeddings2 = modelResponse.embeddings;
                                const usage = (_a172 = modelResponse.usage) != null ? _a172 : {
                                    tokens: NaN
                                };
                                doEmbedSpan.setAttributes(selectTelemetryAttributes2({
                                    telemetry,
                                    attributes: {
                                        "ai.embeddings": {
                                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                                        },
                                        "ai.usage.tokens": usage.tokens
                                    }
                                }));
                                return {
                                    embeddings: embeddings2,
                                    usage,
                                    providerMetadata: modelResponse.providerMetadata,
                                    response: modelResponse.response
                                };
                            }
                        });
                    });
                }));
                for (const result of results){
                    embeddings.push(...result.embeddings);
                    responses.push(result.response);
                    tokens += result.usage.tokens;
                    if (result.providerMetadata) {
                        if (!providerMetadata) {
                            providerMetadata = {
                                ...result.providerMetadata
                            };
                        } else {
                            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){
                                providerMetadata[providerName] = {
                                    ...(_a162 = providerMetadata[providerName]) != null ? _a162 : {},
                                    ...metadata
                                };
                            }
                        }
                    }
                }
            }
            span.setAttributes(selectTelemetryAttributes2({
                telemetry,
                attributes: {
                    "ai.embeddings": {
                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": tokens
                }
            }));
            return new DefaultEmbedManyResult2({
                values,
                embeddings,
                usage: {
                    tokens
                },
                providerMetadata,
                responses
            });
        }
    });
}
var DefaultEmbedManyResult2 = class {
    constructor(options){
        this.values = options.values;
        this.embeddings = options.embeddings;
        this.usage = options.usage;
        this.providerMetadata = options.providerMetadata;
        this.responses = options.responses;
    }
};
createIdGenerator2({
    prefix: "aiobj",
    size: 24
});
createIdGenerator2({
    prefix: "aiobj",
    size: 24
});
var output_exports2 = {};
__export2(output_exports2, {
    object: ()=>object2,
    text: ()=>text2
});
var text2 = ()=>({
        type: "text",
        responseFormat: {
            type: "text"
        },
        async parsePartial ({ text: text22 }) {
            return {
                partial: text22
            };
        },
        async parseOutput ({ text: text22 }) {
            return text22;
        }
    });
var object2 = ({ schema: inputSchema })=>{
    const schema = asSchema2(inputSchema);
    return {
        type: "object",
        responseFormat: {
            type: "json",
            schema: schema.jsonSchema
        },
        async parsePartial ({ text: text22 }) {
            const result = await parsePartialJson2(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    return void 0;
                case "repaired-parse":
                case "successful-parse":
                    return {
                        // Note: currently no validation of partial results:
                        partial: result.value
                    };
                default:
                    {
                        const _exhaustiveCheck = result.state;
                        throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
                    }
            }
        },
        async parseOutput ({ text: text22 }, context) {
            const parseResult = await safeParseJSON2({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError2({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const validationResult = await safeValidateTypes2({
                value: parseResult.value,
                schema
            });
            if (!validationResult.success) {
                throw new NoObjectGeneratedError2({
                    message: "No object generated: response did not match schema.",
                    cause: validationResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return validationResult.value;
        }
    };
};
var marker19 = "vercel.ai.error";
var symbol19 = Symbol.for(marker19);
var _a19;
var _b8;
var AISDKError3 = class _AISDKError4 extends (_b8 = Error, _a19 = symbol19, _b8) {
    /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */ constructor({ name: name1422, message, cause }){
        super(message);
        this[_a19] = true;
        this.name = name1422;
        this.cause = cause;
    }
    /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */ static isInstance(error) {
        return _AISDKError4.hasMarker(error, marker19);
    }
    static hasMarker(error, marker1522) {
        const markerSymbol = Symbol.for(marker1522);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
};
var name19 = "AI_APICallError";
var marker25 = `vercel.ai.error.${name19}`;
var symbol25 = Symbol.for(marker25);
var _a25;
var _b22;
var APICallError3 = class extends (_b22 = AISDKError3, _a25 = symbol25, _b22) {
    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500), // server error
    data }){
        super({
            name: name19,
            message,
            cause
        });
        this[_a25] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker25);
    }
};
var name25 = "AI_EmptyResponseBodyError";
var marker35 = `vercel.ai.error.${name25}`;
var symbol35 = Symbol.for(marker35);
var _a35;
var _b32;
var EmptyResponseBodyError2 = class extends (_b32 = AISDKError3, _a35 = symbol35, _b32) {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}){
        super({
            name: name25,
            message
        });
        this[_a35] = true;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker35);
    }
};
function getErrorMessage4(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
var name35 = "AI_InvalidArgumentError";
var marker45 = `vercel.ai.error.${name35}`;
var symbol45 = Symbol.for(marker45);
var _a45;
var _b42;
var InvalidArgumentError4 = class extends (_b42 = AISDKError3, _a45 = symbol45, _b42) {
    constructor({ message, cause, argument }){
        super({
            name: name35,
            message,
            cause
        });
        this[_a45] = true;
        this.argument = argument;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker45);
    }
};
var name65 = "AI_JSONParseError";
var marker75 = `vercel.ai.error.${name65}`;
var symbol75 = Symbol.for(marker75);
var _a75;
var _b72;
var JSONParseError3 = class extends (_b72 = AISDKError3, _a75 = symbol75, _b72) {
    constructor({ text: text4, cause }){
        super({
            name: name65,
            message: `JSON parsing failed: Text: ${text4}.
Error message: ${getErrorMessage4(cause)}`,
            cause
        });
        this[_a75] = true;
        this.text = text4;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker75);
    }
};
var name125 = "AI_TypeValidationError";
var marker135 = `vercel.ai.error.${name125}`;
var symbol135 = Symbol.for(marker135);
var _a135;
var _b13;
var TypeValidationError3 = class _TypeValidationError4 extends (_b13 = AISDKError3, _a135 = symbol135, _b13) {
    constructor({ value, cause }){
        super({
            name: name125,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage4(cause)}`,
            cause
        });
        this[_a135] = true;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker135);
    }
    /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */ static wrap({ value, cause }) {
        return _TypeValidationError4.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError4({
            value,
            cause
        });
    }
};
var ParseError2 = class extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
};
function noop2(_arg) {}
function createParser2(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop2, onError = noop2, onRetry = noop2, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError2(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError2(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines2(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
var EventSourceParserStream2 = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}){
        let parser;
        super({
            start (controller) {
                parser = createParser2({
                    onEvent: (event)=>{
                        controller.enqueue(event);
                    },
                    onError (error) {
                        onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                    },
                    onRetry,
                    onComment
                });
            },
            transform (chunk) {
                parser.feed(chunk);
            }
        });
    }
};
function combineHeaders2(...headers) {
    return headers.reduce((combinedHeaders, currentHeaders)=>({
            ...combinedHeaders,
            ...currentHeaders != null ? currentHeaders : {}
        }), {});
}
async function delay3(delayInMs, options) {
    if (delayInMs == null) {
        return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve22, reject)=>{
        if (signal == null ? void 0 : signal.aborted) {
            reject(createAbortError2());
            return;
        }
        const timeoutId = setTimeout(()=>{
            cleanup();
            resolve22();
        }, delayInMs);
        const cleanup = ()=>{
            clearTimeout(timeoutId);
            signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        };
        const onAbort = ()=>{
            cleanup();
            reject(createAbortError2());
        };
        signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
}
function createAbortError2() {
    return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders2(response) {
    return Object.fromEntries([
        ...response.headers
    ]);
}
var createIdGenerator3 = ({ prefix, size = 16, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", separator = "-" } = {})=>{
    const generator = ()=>{
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for(let i = 0; i < size; i++){
            chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
    };
    if (prefix == null) {
        return generator;
    }
    if (alphabet.includes(separator)) {
        throw new InvalidArgumentError4({
            argument: "separator",
            message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
    }
    return ()=>`${prefix}${separator}${generator()}`;
};
createIdGenerator3();
function getErrorMessage23(error) {
    if (error == null) {
        return "unknown error";
    }
    if (typeof error === "string") {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    return JSON.stringify(error);
}
function isAbortError3(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES2 = [
    "fetch failed",
    "failed to fetch"
];
function handleFetchError2({ error, url, requestBodyValues }) {
    if (isAbortError3(error)) {
        return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error.message.toLowerCase())) {
        const cause = error.cause;
        if (cause != null) {
            return new APICallError3({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
            });
        }
    }
    return error;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
    var _a224, _b222, _c;
    if (globalThisAny.window) {
        return `runtime/browser`;
    }
    if ((_a224 = globalThisAny.navigator) == null ? void 0 : _a224.userAgent) {
        return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b222 = globalThisAny.process) == null ? void 0 : _b222.versions) == null ? void 0 : _c.node) {
        return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
        return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
}
function normalizeHeaders2(headers) {
    if (headers == null) {
        return {};
    }
    const normalized = {};
    if (headers instanceof Headers) {
        headers.forEach((value, key)=>{
            normalized[key.toLowerCase()] = value;
        });
    } else {
        if (!Array.isArray(headers)) {
            headers = Object.entries(headers);
        }
        for (const [key, value] of headers){
            if (value != null) {
                normalized[key.toLowerCase()] = value;
            }
        }
    }
    return normalized;
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
    const normalizedHeaders = new Headers(normalizeHeaders2(headers));
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set("user-agent", [
        currentUserAgentHeader,
        ...userAgentSuffixParts
    ].filter(Boolean).join(" "));
    return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION4 = "4.0.0";
var getOriginalFetch3 = ()=>globalThis.fetch;
var getFromApi2 = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch3() })=>{
    try {
        const response = await fetch2(url, {
            method: "GET",
            headers: withUserAgentSuffix2(headers, `ai-sdk/provider-utils/${VERSION4}`, getRuntimeEnvironmentUserAgent2()),
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders2(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: {}
                });
            } catch (error) {
                if (isAbortError3(error) || APICallError3.isInstance(error)) {
                    throw error;
                }
                throw new APICallError3({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: {}
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: {}
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError3(error) || APICallError3.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError3({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: {}
            });
        }
    } catch (error) {
        throw handleFetchError2({
            error,
            url,
            requestBodyValues: {}
        });
    }
};
function loadOptionalSetting2({ settingValue, environmentVariableName }) {
    if (typeof settingValue === "string") {
        return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
        return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
        return void 0;
    }
    return settingValue;
}
var suspectProtoRx2 = /"__proto__"\s*:/;
var suspectConstructorRx2 = /"constructor"\s*:/;
function _parse2(text4) {
    const obj = JSON.parse(text4);
    if (obj === null || typeof obj !== "object") {
        return obj;
    }
    if (suspectProtoRx2.test(text4) === false && suspectConstructorRx2.test(text4) === false) {
        return obj;
    }
    return filter2(obj);
}
function filter2(obj) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === "object") {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
function secureJsonParse2(text4) {
    const { stackTraceLimit } = Error;
    try {
        Error.stackTraceLimit = 0;
    } catch (e) {
        return _parse2(text4);
    }
    try {
        return _parse2(text4);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema22) {
    if (jsonSchema22.type === "object") {
        jsonSchema22.additionalProperties = false;
        const properties = jsonSchema22.properties;
        if (properties != null) {
            for(const property in properties){
                properties[property] = addAdditionalPropertiesToJsonSchema(properties[property]);
            }
        }
    }
    if (jsonSchema22.type === "array" && jsonSchema22.items != null) {
        if (Array.isArray(jsonSchema22.items)) {
            jsonSchema22.items = jsonSchema22.items.map((item)=>addAdditionalPropertiesToJsonSchema(item));
        } else {
            jsonSchema22.items = addAdditionalPropertiesToJsonSchema(jsonSchema22.items);
        }
    }
    return jsonSchema22;
}
var ignoreOverride3 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions3 = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
        "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
};
var getDefaultOptions3 = (options)=>typeof options === "string" ? {
        ...defaultOptions3,
        name: options
    } : {
        ...defaultOptions3,
        ...options
    };
function parseAnyDef3() {
    return {};
}
function parseArrayDef3(def, refs) {
    var _a224, _b222, _c;
    const res = {
        type: "array"
    };
    if (((_a224 = def.type) == null ? void 0 : _a224._def) && ((_c = (_b222 = def.type) == null ? void 0 : _b222._def) == null ? void 0 : _c.typeName) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny) {
        res.items = parseDef3(def.type._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "items"
            ]
        });
    }
    if (def.minLength) {
        res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
        res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
        res.minItems = def.exactLength.value;
        res.maxItems = def.exactLength.value;
    }
    return res;
}
function parseBigintDef3(def) {
    const res = {
        type: "integer",
        format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseBooleanDef3() {
    return {
        type: "boolean"
    };
}
function parseBrandedDef3(_def, refs) {
    return parseDef3(_def.type._def, refs);
}
var parseCatchDef3 = (def, refs)=>{
    return parseDef3(def.innerType._def, refs);
};
function parseDateDef3(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i)=>parseDateDef3(def, refs, item))
        };
    }
    switch(strategy){
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return integerDateParser3(def);
    }
}
var integerDateParser3 = (def)=>{
    const res = {
        type: "integer",
        format: "unix-time"
    };
    for (const check of def.checks){
        switch(check.kind){
            case "min":
                res.minimum = check.value;
                break;
            case "max":
                res.maximum = check.value;
                break;
        }
    }
    return res;
};
function parseDefaultDef3(_def, refs) {
    return {
        ...parseDef3(_def.innerType._def, refs),
        default: _def.defaultValue()
    };
}
function parseEffectsDef3(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef3(_def.schema._def, refs) : parseAnyDef3();
}
function parseEnumDef3(def) {
    return {
        type: "string",
        enum: Array.from(def.values)
    };
}
var isJsonSchema7AllOfType3 = (type)=>{
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
};
function parseIntersectionDef3(def, refs) {
    const allOf = [
        parseDef3(def.left._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "0"
            ]
        }),
        parseDef3(def.right._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "allOf",
                "1"
            ]
        })
    ].filter((x)=>!!x);
    const mergedAllOf = [];
    allOf.forEach((schema)=>{
        if (isJsonSchema7AllOfType3(schema)) {
            mergedAllOf.push(...schema.allOf);
        } else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length ? {
        allOf: mergedAllOf
    } : void 0;
}
function parseLiteralDef3(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object"
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
    };
}
var emojiRegex3 = void 0;
var zodPatterns3 = {
    /**
   * `c` was changed to `[cC]` to replicate /i flag
   */ cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
   * `a-z` was added to replicate /i flag
   */ email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */ emoji: ()=>{
        if (emojiRegex3 === void 0) {
            emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex3;
    },
    /**
   * Unused
   */ uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
   * Unused
   */ ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
   * Unused
   */ ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef3(def, refs) {
    const res = {
        type: "string"
    };
    if (def.checks) {
        for (const check of def.checks){
            switch(check.kind){
                case "min":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    break;
                case "max":
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "email":
                    switch(refs.emailStrategy){
                        case "format:email":
                            addFormat3(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat3(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern3(res, zodPatterns3.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat3(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat3(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern3(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern3(res, zodPatterns3.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern3(res, zodPatterns3.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern3(res, RegExp(`^${escapeLiteralCheckValue3(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern3(res, RegExp(`${escapeLiteralCheckValue3(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat3(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat3(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat3(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat3(res, "duration", check.message, refs);
                    break;
                case "length":
                    res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                    res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                    break;
                case "includes":
                    {
                        addPattern3(res, RegExp(escapeLiteralCheckValue3(check.value, refs)), check.message, refs);
                        break;
                    }
                case "ip":
                    {
                        if (check.version !== "v6") {
                            addFormat3(res, "ipv4", check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addFormat3(res, "ipv6", check.message, refs);
                        }
                        break;
                    }
                case "base64url":
                    addPattern3(res, zodPatterns3.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern3(res, zodPatterns3.jwt, check.message, refs);
                    break;
                case "cidr":
                    {
                        if (check.version !== "v6") {
                            addPattern3(res, zodPatterns3.ipv4Cidr, check.message, refs);
                        }
                        if (check.version !== "v4") {
                            addPattern3(res, zodPatterns3.ipv6Cidr, check.message, refs);
                        }
                        break;
                    }
                case "emoji":
                    addPattern3(res, zodPatterns3.emoji(), check.message, refs);
                    break;
                case "ulid":
                    {
                        addPattern3(res, zodPatterns3.ulid, check.message, refs);
                        break;
                    }
                case "base64":
                    {
                        switch(refs.base64Strategy){
                            case "format:binary":
                                {
                                    addFormat3(res, "binary", check.message, refs);
                                    break;
                                }
                            case "contentEncoding:base64":
                                {
                                    res.contentEncoding = "base64";
                                    break;
                                }
                            case "pattern:zod":
                                {
                                    addPattern3(res, zodPatterns3.base64, check.message, refs);
                                    break;
                                }
                        }
                        break;
                    }
                case "nanoid":
                    {
                        addPattern3(res, zodPatterns3.nanoid, check.message, refs);
                    }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue3(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric3(literal) : literal;
}
var ALPHA_NUMERIC3 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric3(source) {
    let result = "";
    for(let i = 0; i < source.length; i++){
        if (!ALPHA_NUMERIC3.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat3(schema, value, message, refs) {
    var _a224;
    if (schema.format || ((_a224 = schema.anyOf) == null ? void 0 : _a224.some((x)=>x.format))) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format
            });
            delete schema.format;
        }
        schema.anyOf.push({
            format: value,
            ...message && refs.errorMessages && {
                errorMessage: {
                    format: message
                }
            }
        });
    } else {
        schema.format = value;
    }
}
function addPattern3(schema, regex, message, refs) {
    var _a224;
    if (schema.pattern || ((_a224 = schema.allOf) == null ? void 0 : _a224.some((x)=>x.pattern))) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern
            });
            delete schema.pattern;
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags3(regex, refs),
            ...message && refs.errorMessages && {
                errorMessage: {
                    pattern: message
                }
            }
        });
    } else {
        schema.pattern = stringifyRegExpWithFlags3(regex, refs);
    }
}
function stringifyRegExpWithFlags3(regex, refs) {
    var _a224;
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        // Case-insensitive
        m: regex.flags.includes("m"),
        // `^` and `$` matches adjacent to newline characters
        s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for(let i = 0; i < source.length; i++){
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    } else if (source[i + 1] === "-" && ((_a224 = source[i + 2]) == null ? void 0 : _a224.match(/[a-z]/))) {
                        pattern += source[i];
                        inCharRange = true;
                    } else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
            } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        } else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        } else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}
function parseRecordDef3(def, refs) {
    var _a224, _b222, _c, _d, _e, _f;
    const schema = {
        type: "object",
        additionalProperties: (_a224 = parseDef3(def.valueType._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        })) != null ? _a224 : refs.allowedAdditionalProperties
    };
    if (((_b222 = def.keyType) == null ? void 0 : _b222._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
        const { type, ...keyType } = parseStringDef3(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values
            }
        };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded && def.keyType._def.type._def.typeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
        const { type, ...keyType } = parseBrandedDef3(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType
        };
    }
    return schema;
}
function parseMapDef3(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef3(def, refs);
    }
    const keys = parseDef3(def.keyType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "0"
        ]
    }) || parseAnyDef3();
    const values = parseDef3(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items",
            "items",
            "1"
        ]
    }) || parseAnyDef3();
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [
                keys,
                values
            ],
            minItems: 2,
            maxItems: 2
        }
    };
}
function parseNativeEnumDef3(def) {
    const object4 = def.values;
    const actualKeys = Object.keys(def.values).filter((key)=>{
        return typeof object4[object4[key]] !== "number";
    });
    const actualValues = actualKeys.map((key)=>object4[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values)=>typeof values)));
    return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
            "string",
            "number"
        ],
        enum: actualValues
    };
}
function parseNeverDef3() {
    return {
        not: parseAnyDef3()
    };
}
function parseNullDef3() {
    return {
        type: "null"
    };
}
var primitiveMappings3 = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};
function parseUnionDef3(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x)=>x._def.typeName in primitiveMappings3 && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types2, x)=>{
            const type = primitiveMappings3[x._def.typeName];
            return type && !types2.includes(type) ? [
                ...types2,
                type
            ] : types2;
        }, []);
        return {
            type: types.length > 1 ? types : types[0]
        };
    } else if (options.every((x)=>x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x)=>{
            const type = typeof x._def.value;
            switch(type){
                case "string":
                case "number":
                case "boolean":
                    return [
                        ...acc,
                        type
                    ];
                case "bigint":
                    return [
                        ...acc,
                        "integer"
                    ];
                case "object":
                    if (x._def.value === null) return [
                        ...acc,
                        "null"
                    ];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a)=>a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x)=>{
                    return acc.includes(x._def.value) ? acc : [
                        ...acc,
                        x._def.value
                    ];
                }, [])
            };
        }
    } else if (options.every((x)=>x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x)=>[
                    ...acc,
                    ...x._def.values.filter((x2)=>!acc.includes(x2))
                ], [])
        };
    }
    return asAnyOf3(def, refs);
}
var asAnyOf3 = (def, refs)=>{
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i)=>parseDef3(x._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "anyOf",
                `${i}`
            ]
        })).filter((x)=>!!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? {
        anyOf
    } : void 0;
};
function parseNullableDef3(def, refs) {
    if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        return {
            type: [
                primitiveMappings3[def.innerType._def.typeName],
                "null"
            ]
        };
    }
    const base = parseDef3(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "0"
        ]
    });
    return base && {
        anyOf: [
            base,
            {
                type: "null"
            }
        ]
    };
}
function parseNumberDef3(def) {
    const res = {
        type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks){
        switch(check.kind){
            case "int":
                res.type = "integer";
                break;
            case "min":
                if (check.inclusive) {
                    res.minimum = check.value;
                } else {
                    res.exclusiveMinimum = check.value;
                }
                break;
            case "max":
                if (check.inclusive) {
                    res.maximum = check.value;
                } else {
                    res.exclusiveMaximum = check.value;
                }
                break;
            case "multipleOf":
                res.multipleOf = check.value;
                break;
        }
    }
    return res;
}
function parseObjectDef3(def, refs) {
    const result = {
        type: "object",
        properties: {}
    };
    const required = [];
    const shape = def.shape();
    for(const propName in shape){
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
            continue;
        }
        const propOptional = safeIsOptional3(propDef);
        const parsedDef = parseDef3(propDef._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "properties",
                propName
            ],
            propertyPath: [
                ...refs.currentPath,
                "properties",
                propName
            ]
        });
        if (parsedDef === void 0) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties3(def, refs);
    if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties3(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef3(def.catchall._def, {
            ...refs,
            currentPath: [
                ...refs.currentPath,
                "additionalProperties"
            ]
        });
    }
    switch(def.unknownKeys){
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional3(schema) {
    try {
        return schema.isOptional();
    } catch (e) {
        return true;
    }
}
var parseOptionalDef3 = (def, refs)=>{
    var _a224;
    if (refs.currentPath.toString() === ((_a224 = refs.propertyPath) == null ? void 0 : _a224.toString())) {
        return parseDef3(def.innerType._def, refs);
    }
    const innerSchema = parseDef3(def.innerType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "anyOf",
            "1"
        ]
    });
    return innerSchema ? {
        anyOf: [
            {
                not: parseAnyDef3()
            },
            innerSchema
        ]
    } : parseAnyDef3();
};
var parsePipelineDef3 = (def, refs)=>{
    if (refs.pipeStrategy === "input") {
        return parseDef3(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
        return parseDef3(def.out._def, refs);
    }
    const a = parseDef3(def.in._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            "0"
        ]
    });
    const b = parseDef3(def.out._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "allOf",
            a ? "1" : "0"
        ]
    });
    return {
        allOf: [
            a,
            b
        ].filter((x)=>x !== void 0)
    };
};
function parsePromiseDef3(def, refs) {
    return parseDef3(def.type._def, refs);
}
function parseSetDef3(def, refs) {
    const items = parseDef3(def.valueType._def, {
        ...refs,
        currentPath: [
            ...refs.currentPath,
            "items"
        ]
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items
    };
    if (def.minSize) {
        schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
        schema.maxItems = def.maxSize.value;
    }
    return schema;
}
function parseTupleDef3(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items.map((x, i)=>parseDef3(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], []),
            additionalItems: parseDef3(def.rest._def, {
                ...refs,
                currentPath: [
                    ...refs.currentPath,
                    "additionalItems"
                ]
            })
        };
    } else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items.map((x, i)=>parseDef3(x._def, {
                    ...refs,
                    currentPath: [
                        ...refs.currentPath,
                        "items",
                        `${i}`
                    ]
                })).reduce((acc, x)=>x === void 0 ? acc : [
                    ...acc,
                    x
                ], [])
        };
    }
}
function parseUndefinedDef3() {
    return {
        not: parseAnyDef3()
    };
}
function parseUnknownDef3() {
    return parseAnyDef3();
}
var parseReadonlyDef3 = (def, refs)=>{
    return parseDef3(def.innerType._def, refs);
};
var selectParser3 = (def, typeName, refs)=>{
    switch(typeName){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodString:
            return parseStringDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNumber:
            return parseNumberDef3(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodObject:
            return parseObjectDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBigInt:
            return parseBigintDef3(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBoolean:
            return parseBooleanDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDate:
            return parseDateDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUndefined:
            return parseUndefinedDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNull:
            return parseNullDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodArray:
            return parseArrayDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnion:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDiscriminatedUnion:
            return parseUnionDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodIntersection:
            return parseIntersectionDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodTuple:
            return parseTupleDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodRecord:
            return parseRecordDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLiteral:
            return parseLiteralDef3(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEnum:
            return parseEnumDef3(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNativeEnum:
            return parseNativeEnumDef3(def);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNullable:
            return parseNullableDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodOptional:
            return parseOptionalDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodMap:
            return parseMapDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSet:
            return parseSetDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodLazy:
            return ()=>def.getter()._def;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPromise:
            return parsePromiseDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNaN:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodNever:
            return parseNeverDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodEffects:
            return parseEffectsDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodAny:
            return parseAnyDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodUnknown:
            return parseUnknownDef3();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodDefault:
            return parseDefaultDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodBranded:
            return parseBrandedDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodReadonly:
            return parseReadonlyDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodCatch:
            return parseCatchDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodPipeline:
            return parsePipelineDef3(def, refs);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodFunction:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodVoid:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodFirstPartyTypeKind"].ZodSymbol:
            return void 0;
        default:
            return /* @__PURE__ */ ((_)=>void 0)();
    }
};
var getRelativePath3 = (pathA, pathB)=>{
    let i = 0;
    for(; i < pathA.length && i < pathB.length; i++){
        if (pathA[i] !== pathB[i]) break;
    }
    return [
        (pathA.length - i).toString(),
        ...pathB.slice(i)
    ].join("/");
};
function parseDef3(def, refs, forceResolution = false) {
    var _a224;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = (_a224 = refs.override) == null ? void 0 : _a224.call(refs, def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride3) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref3(seenItem, refs);
        if (seenSchema !== void 0) {
            return seenSchema;
        }
    }
    const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser3(def, def.typeName, refs);
    const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema22) {
        addMeta3(def, refs, jsonSchema22);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
        newItem.jsonSchema = jsonSchema22;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema22;
    return jsonSchema22;
}
var get$ref3 = (item, refs)=>{
    switch(refs.$refStrategy){
        case "root":
            return {
                $ref: item.path.join("/")
            };
        case "relative":
            return {
                $ref: getRelativePath3(refs.currentPath, item.path)
            };
        case "none":
        case "seen":
            {
                if (item.path.length < refs.currentPath.length && item.path.every((value, index)=>refs.currentPath[index] === value)) {
                    console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                    return parseAnyDef3();
                }
                return refs.$refStrategy === "seen" ? parseAnyDef3() : void 0;
            }
    }
};
var addMeta3 = (def, refs, jsonSchema22)=>{
    if (def.description) {
        jsonSchema22.description = def.description;
    }
    return jsonSchema22;
};
var getRefs3 = (options)=>{
    const _options = getDefaultOptions3(options);
    const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
    ] : _options.basePath;
    return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name224, def])=>[
                def._def,
                {
                    def: def._def,
                    path: [
                        ..._options.basePath,
                        _options.definitionPath,
                        name224
                    ],
                    // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                    jsonSchema: void 0
                }
            ]))
    };
};
var zod3ToJsonSchema = (schema, options)=>{
    var _a224;
    const refs = getRefs3(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name324, schema2])=>{
        var _a324;
        return {
            ...acc,
            [name324]: (_a324 = parseDef3(schema2._def, {
                ...refs,
                currentPath: [
                    ...refs.basePath,
                    refs.definitionPath,
                    name324
                ]
            }, true)) != null ? _a324 : parseAnyDef3()
        };
    }, {}) : void 0;
    const name224 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a224 = parseDef3(schema._def, name224 === void 0 ? refs : {
        ...refs,
        currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name224
        ]
    }, false)) != null ? _a224 : parseAnyDef3();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
        main.title = title;
    }
    const combined = name224 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
    } : main : {
        $ref: [
            ...refs.$refStrategy === "relative" ? [] : refs.basePath,
            refs.definitionPath,
            name224
        ].join("/"),
        [refs.definitionPath]: {
            ...definitions,
            [name224]: main
        }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
};
var schemaSymbol3 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
    let schema;
    return ()=>{
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    };
}
function jsonSchema3(jsonSchema22, { validate } = {}) {
    return {
        [schemaSymbol3]: true,
        _type: void 0,
        // should never be used directly
        get jsonSchema () {
            if (typeof jsonSchema22 === "function") {
                jsonSchema22 = jsonSchema22();
            }
            return jsonSchema22;
        },
        validate
    };
}
function isSchema3(value) {
    return typeof value === "object" && value !== null && schemaSymbol3 in value && value[schemaSymbol3] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema3(schema) {
    return schema == null ? jsonSchema3({
        properties: {},
        additionalProperties: false
    }) : isSchema3(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema3(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
    return jsonSchema3(()=>standardSchema2["~standard"].jsonSchema.input({
            target: "draft-07"
        }), {
        validate: async (value)=>{
            const result = await standardSchema2["~standard"].validate(value);
            return "value" in result ? {
                success: true,
                value: result.value
            } : {
                success: false,
                error: new TypeValidationError3({
                    value,
                    cause: result.issues
                })
            };
        }
    });
}
function zod3Schema2(zodSchema22, options) {
    var _a224;
    const useReferences = (_a224 = void 0) != null ? _a224 : false;
    return jsonSchema3(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>zod3ToJsonSchema(zodSchema22, {
            $refStrategy: useReferences ? "root" : "none"
        }), {
        validate: async (value)=>{
            const result = await zodSchema22.safeParseAsync(value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function zod4Schema2(zodSchema22, options) {
    var _a224;
    const useReferences = (_a224 = void 0) != null ? _a224 : false;
    return jsonSchema3(// defer json schema creation to avoid unnecessary computation when only validation is needed
    ()=>addAdditionalPropertiesToJsonSchema(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$core$2f$to$2d$json$2d$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toJSONSchema"](zodSchema22, {
            target: "draft-7",
            io: "input",
            reused: useReferences ? "ref" : "inline"
        })), {
        validate: async (value)=>{
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["safeParseAsync"](zodSchema22, value);
            return result.success ? {
                success: true,
                value: result.data
            } : {
                success: false,
                error: result.error
            };
        }
    });
}
function isZod4Schema2(zodSchema22) {
    return "_zod" in zodSchema22;
}
function zodSchema3(zodSchema22, options) {
    if (isZod4Schema2(zodSchema22)) {
        return zod4Schema2(zodSchema22);
    } else {
        return zod3Schema2(zodSchema22);
    }
}
async function validateTypes2({ value, schema }) {
    const result = await safeValidateTypes3({
        value,
        schema
    });
    if (!result.success) {
        throw TypeValidationError3.wrap({
            value,
            cause: result.error
        });
    }
    return result.value;
}
async function safeValidateTypes3({ value, schema }) {
    const actualSchema = asSchema3(schema);
    try {
        if (actualSchema.validate == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        const result = await actualSchema.validate(value);
        if (result.success) {
            return {
                success: true,
                value: result.value,
                rawValue: value
            };
        }
        return {
            success: false,
            error: TypeValidationError3.wrap({
                value,
                cause: result.error
            }),
            rawValue: value
        };
    } catch (error) {
        return {
            success: false,
            error: TypeValidationError3.wrap({
                value,
                cause: error
            }),
            rawValue: value
        };
    }
}
async function parseJSON2({ text: text4, schema }) {
    try {
        const value = secureJsonParse2(text4);
        if (schema == null) {
            return value;
        }
        return validateTypes2({
            value,
            schema
        });
    } catch (error) {
        if (JSONParseError3.isInstance(error) || TypeValidationError3.isInstance(error)) {
            throw error;
        }
        throw new JSONParseError3({
            text: text4,
            cause: error
        });
    }
}
async function safeParseJSON3({ text: text4, schema }) {
    try {
        const value = secureJsonParse2(text4);
        if (schema == null) {
            return {
                success: true,
                value,
                rawValue: value
            };
        }
        return await safeValidateTypes3({
            value,
            schema
        });
    } catch (error) {
        return {
            success: false,
            error: JSONParseError3.isInstance(error) ? error : new JSONParseError3({
                text: text4,
                cause: error
            }),
            rawValue: void 0
        };
    }
}
function parseJsonEventStream2({ stream, schema }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2()).pipeThrough(new TransformStream({
        async transform ({ data }, controller) {
            if (data === "[DONE]") {
                return;
            }
            controller.enqueue(await safeParseJSON3({
                text: data,
                schema
            }));
        }
    }));
}
var getOriginalFetch22 = ()=>globalThis.fetch;
var postJsonToApi2 = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch: fetch2 })=>postToApi2({
        url,
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        body: {
            content: JSON.stringify(body),
            values: body
        },
        failedResponseHandler,
        successfulResponseHandler,
        abortSignal,
        fetch: fetch2
    });
var postToApi2 = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch: fetch2 = getOriginalFetch22() })=>{
    try {
        const response = await fetch2(url, {
            method: "POST",
            headers: withUserAgentSuffix2(headers, `ai-sdk/provider-utils/${VERSION4}`, getRuntimeEnvironmentUserAgent2()),
            body: body.content,
            signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders2(response);
        if (!response.ok) {
            let errorInformation;
            try {
                errorInformation = await failedResponseHandler({
                    response,
                    url,
                    requestBodyValues: body.values
                });
            } catch (error) {
                if (isAbortError3(error) || APICallError3.isInstance(error)) {
                    throw error;
                }
                throw new APICallError3({
                    message: "Failed to process error response",
                    cause: error,
                    statusCode: response.status,
                    url,
                    responseHeaders,
                    requestBodyValues: body.values
                });
            }
            throw errorInformation.value;
        }
        try {
            return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
            });
        } catch (error) {
            if (error instanceof Error) {
                if (isAbortError3(error) || APICallError3.isInstance(error)) {
                    throw error;
                }
            }
            throw new APICallError3({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
            });
        }
    } catch (error) {
        throw handleFetchError2({
            error,
            url,
            requestBodyValues: body.values
        });
    }
};
async function resolve2(value) {
    if (typeof value === "function") {
        value = value();
    }
    return Promise.resolve(value);
}
var createJsonErrorResponseHandler2 = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const responseHeaders = extractResponseHeaders2(response);
        if (responseBody.trim() === "") {
            return {
                responseHeaders,
                value: new APICallError3({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
        try {
            const parsedError = await parseJSON2({
                text: responseBody,
                schema: errorSchema
            });
            return {
                responseHeaders,
                value: new APICallError3({
                    message: errorToMessage(parsedError),
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    data: parsedError,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
                })
            };
        } catch (parseError) {
            return {
                responseHeaders,
                value: new APICallError3({
                    message: response.statusText,
                    url,
                    requestBodyValues,
                    statusCode: response.status,
                    responseHeaders,
                    responseBody,
                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)
                })
            };
        }
    };
var createEventSourceResponseHandler2 = (chunkSchema)=>async ({ response })=>{
        const responseHeaders = extractResponseHeaders2(response);
        if (response.body == null) {
            throw new EmptyResponseBodyError2({});
        }
        return {
            responseHeaders,
            value: parseJsonEventStream2({
                stream: response.body,
                schema: chunkSchema
            })
        };
    };
var createJsonResponseHandler2 = (responseSchema)=>async ({ response, url, requestBodyValues })=>{
        const responseBody = await response.text();
        const parsedResult = await safeParseJSON3({
            text: responseBody,
            schema: responseSchema
        });
        const responseHeaders = extractResponseHeaders2(response);
        if (!parsedResult.success) {
            throw new APICallError3({
                message: "Invalid JSON response",
                cause: parsedResult.error,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                url,
                requestBodyValues
            });
        }
        return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
        };
    };
function withoutTrailingSlash2(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name144 in all)__defProp22(target, name144, {
                get: all[name144],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var get_context_exports = {};
        __export22(get_context_exports, {
            SYMBOL_FOR_REQ_CONTEXT: ()=>SYMBOL_FOR_REQ_CONTEXT,
            getContext: ()=>getContext3
        });
        module.exports = __toCommonJS(get_context_exports);
        var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
        function getContext3() {
            const fromSymbol = globalThis;
            return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
        }
    }
});
var require_get_vercel_oidc_token2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name144 in all)__defProp22(target, name144, {
                get: all[name144],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var get_vercel_oidc_token_exports = {};
        __export22(get_vercel_oidc_token_exports, {
            getVercelOidcToken: ()=>getVercelOidcToken3,
            getVercelOidcTokenSync: ()=>getVercelOidcTokenSync2
        });
        module.exports = __toCommonJS(get_vercel_oidc_token_exports);
        var import_get_context = require_get_context2();
        var import_token_error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["require_token_error"])();
        async function getVercelOidcToken3() {
            let token = "";
            let err;
            try {
                token = getVercelOidcTokenSync2();
            } catch (error) {
                err = error;
            }
            try {
                const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
                    await __turbopack_context__.A("[project]/node_modules/@mastra/memory/dist/token-util-NEHG7TUY-KSXDO2NO.js [app-route] (ecmascript, async loader)"),
                    await __turbopack_context__.A("[project]/node_modules/@mastra/memory/dist/token-6GSAFR2W-K2BTU23I.js [app-route] (ecmascript, async loader)")
                ]);
                if (!token || isExpired(getTokenPayload(token))) {
                    await refreshToken();
                    token = getVercelOidcTokenSync2();
                }
            } catch (error) {
                if (err?.message && error instanceof Error) {
                    error.message = `${err.message}
${error.message}`;
                }
                throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
            }
            return token;
        }
        function getVercelOidcTokenSync2() {
            const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
            if (!token) {
                throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
            }
            return token;
        }
    }
});
var require_dist2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__commonJS"])({
    "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js" (exports, module) {
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames2 = Object.getOwnPropertyNames;
        var __hasOwnProp2 = Object.prototype.hasOwnProperty;
        var __export22 = (target, all)=>{
            for(var name144 in all)__defProp22(target, name144, {
                get: all[name144],
                enumerable: true
            });
        };
        var __copyProps2 = (to, from, except, desc)=>{
            if (from && typeof from === "object" || typeof from === "function") {
                for (let key of __getOwnPropNames2(from))if (!__hasOwnProp2.call(to, key) && key !== except) __defProp22(to, key, {
                    get: ()=>from[key],
                    enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
                });
            }
            return to;
        };
        var __toCommonJS = (mod)=>__copyProps2(__defProp22({}, "__esModule", {
                value: true
            }), mod);
        var src_exports = {};
        __export22(src_exports, {
            getContext: ()=>import_get_context.getContext,
            getVercelOidcToken: ()=>import_get_vercel_oidc_token.getVercelOidcToken,
            getVercelOidcTokenSync: ()=>import_get_vercel_oidc_token.getVercelOidcTokenSync
        });
        module.exports = __toCommonJS(src_exports);
        var import_get_vercel_oidc_token = require_get_vercel_oidc_token2();
        var import_get_context = require_get_context2();
    }
});
var import_oidc3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist2(), 1);
var import_oidc22 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$memory$2f$dist$2f$chunk$2d$MMUHFOCG$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__toESM"])(require_dist2(), 1);
var marker20 = "vercel.ai.gateway.error";
var symbol20 = Symbol.for(marker20);
var _a20;
var _b16;
var GatewayError2 = class _GatewayError2 extends (_b16 = Error, _a20 = symbol20, _b16) {
    constructor({ message, statusCode = 500, cause }){
        super(message);
        this[_a20] = true;
        this.statusCode = statusCode;
        this.cause = cause;
    }
    /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */ static isInstance(error) {
        return _GatewayError2.hasMarker(error);
    }
    static hasMarker(error) {
        return typeof error === "object" && error !== null && symbol20 in error && error[symbol20] === true;
    }
};
var name20 = "GatewayAuthenticationError";
var marker26 = `vercel.ai.gateway.error.${name20}`;
var symbol26 = Symbol.for(marker26);
var _a26;
var _b23;
var GatewayAuthenticationError2 = class _GatewayAuthenticationError2 extends (_b23 = GatewayError2, _a26 = symbol26, _b23) {
    constructor({ message = "Authentication failed", statusCode = 401, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a26] = true;
        this.name = name20;
        this.type = "authentication_error";
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol26 in error;
    }
    /**
   * Creates a contextual error message when authentication fails
   */ static createContextualError({ apiKeyProvided, oidcTokenProvided, message = "Authentication failed", statusCode = 401, cause }) {
        let contextualMessage;
        if (apiKeyProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
        } else if (oidcTokenProvided) {
            contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
        } else {
            contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
        }
        return new _GatewayAuthenticationError2({
            message: contextualMessage,
            statusCode,
            cause
        });
    }
};
var name26 = "GatewayInvalidRequestError";
var marker36 = `vercel.ai.gateway.error.${name26}`;
var symbol36 = Symbol.for(marker36);
var _a36;
var _b33;
var GatewayInvalidRequestError2 = class extends (_b33 = GatewayError2, _a36 = symbol36, _b33) {
    constructor({ message = "Invalid request", statusCode = 400, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a36] = true;
        this.name = name26;
        this.type = "invalid_request_error";
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol36 in error;
    }
};
var name36 = "GatewayRateLimitError";
var marker46 = `vercel.ai.gateway.error.${name36}`;
var symbol46 = Symbol.for(marker46);
var _a46;
var _b43;
var GatewayRateLimitError2 = class extends (_b43 = GatewayError2, _a46 = symbol46, _b43) {
    constructor({ message = "Rate limit exceeded", statusCode = 429, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a46] = true;
        this.name = name36;
        this.type = "rate_limit_exceeded";
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol46 in error;
    }
};
var name46 = "GatewayModelNotFoundError";
var marker56 = `vercel.ai.gateway.error.${name46}`;
var symbol56 = Symbol.for(marker56);
var modelNotFoundParamSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })));
var _a56;
var _b53;
var GatewayModelNotFoundError2 = class extends (_b53 = GatewayError2, _a56 = symbol56, _b53) {
    constructor({ message = "Model not found", statusCode = 404, modelId, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a56] = true;
        this.name = name46;
        this.type = "model_not_found";
        this.modelId = modelId;
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol56 in error;
    }
};
var name56 = "GatewayInternalServerError";
var marker66 = `vercel.ai.gateway.error.${name56}`;
var symbol66 = Symbol.for(marker66);
var _a66;
var _b63;
var GatewayInternalServerError2 = class extends (_b63 = GatewayError2, _a66 = symbol66, _b63) {
    constructor({ message = "Internal server error", statusCode = 500, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a66] = true;
        this.name = name56;
        this.type = "internal_server_error";
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol66 in error;
    }
};
var name66 = "GatewayResponseError";
var marker76 = `vercel.ai.gateway.error.${name66}`;
var symbol76 = Symbol.for(marker76);
var _a76;
var _b73;
var GatewayResponseError2 = class extends (_b73 = GatewayError2, _a76 = symbol76, _b73) {
    constructor({ message = "Invalid response from Gateway", statusCode = 502, response, validationError, cause } = {}){
        super({
            message,
            statusCode,
            cause
        });
        this[_a76] = true;
        this.name = name66;
        this.type = "response_error";
        this.response = response;
        this.validationError = validationError;
    }
    static isInstance(error) {
        return GatewayError2.hasMarker(error) && symbol76 in error;
    }
};
async function createGatewayErrorFromResponse2({ response, statusCode, defaultMessage = "Gateway request failed", cause, authMethod }) {
    const parseResult = await safeValidateTypes3({
        value: response,
        schema: gatewayErrorResponseSchema2
    });
    if (!parseResult.success) {
        return new GatewayResponseError2({
            message: `Invalid error response format: ${defaultMessage}`,
            statusCode,
            response,
            validationError: parseResult.error,
            cause
        });
    }
    const validatedResponse = parseResult.value;
    const errorType = validatedResponse.error.type;
    const message = validatedResponse.error.message;
    switch(errorType){
        case "authentication_error":
            return GatewayAuthenticationError2.createContextualError({
                apiKeyProvided: authMethod === "api-key",
                oidcTokenProvided: authMethod === "oidc",
                statusCode,
                cause
            });
        case "invalid_request_error":
            return new GatewayInvalidRequestError2({
                message,
                statusCode,
                cause
            });
        case "rate_limit_exceeded":
            return new GatewayRateLimitError2({
                message,
                statusCode,
                cause
            });
        case "model_not_found":
            {
                const modelResult = await safeValidateTypes3({
                    value: validatedResponse.error.param,
                    schema: modelNotFoundParamSchema2
                });
                return new GatewayModelNotFoundError2({
                    message,
                    statusCode,
                    modelId: modelResult.success ? modelResult.value.modelId : void 0,
                    cause
                });
            }
        case "internal_server_error":
            return new GatewayInternalServerError2({
                message,
                statusCode,
                cause
            });
        default:
            return new GatewayInternalServerError2({
                message,
                statusCode,
                cause
            });
    }
}
var gatewayErrorResponseSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            param: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().nullish(),
            code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
            ]).nullish()
        })
    })));
function asGatewayError2(error, authMethod) {
    var _a832;
    if (GatewayError2.isInstance(error)) {
        return error;
    }
    if (APICallError3.isInstance(error)) {
        return createGatewayErrorFromResponse2({
            response: extractApiCallResponse2(error),
            statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
            defaultMessage: "Gateway request failed",
            cause: error,
            authMethod
        });
    }
    return createGatewayErrorFromResponse2({
        response: {},
        statusCode: 500,
        defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
        cause: error,
        authMethod
    });
}
function extractApiCallResponse2(error) {
    if (error.data !== void 0) {
        return error.data;
    }
    if (error.responseBody != null) {
        try {
            return JSON.parse(error.responseBody);
        } catch (e) {
            return error.responseBody;
        }
    }
    return {};
}
var GATEWAY_AUTH_METHOD_HEADER2 = "ai-gateway-auth-method";
async function parseAuthMethod2(headers) {
    const result = await safeValidateTypes3({
        value: headers[GATEWAY_AUTH_METHOD_HEADER2],
        schema: gatewayAuthMethodSchema2
    });
    return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("api-key"),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("oidc")
    ])));
var GatewayFetchMetadata2 = class {
    constructor(config){
        this.config = config;
    }
    async getAvailableModels() {
        try {
            const { value } = await getFromApi2({
                url: `${this.config.baseURL}/config`,
                headers: await resolve2(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler2(gatewayAvailableModelsResponseSchema2),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError2(error);
        }
    }
    async getCredits() {
        try {
            const baseUrl = new URL(this.config.baseURL);
            const { value } = await getFromApi2({
                url: `${baseUrl.origin}/v1/credits`,
                headers: await resolve2(this.config.headers()),
                successfulResponseHandler: createJsonResponseHandler2(gatewayCreditsResponseSchema2),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                fetch: this.config.fetch
            });
            return value;
        } catch (error) {
            throw await asGatewayError2(error);
        }
    }
};
var gatewayAvailableModelsResponseSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        models: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
            pricing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                input_cache_read: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish(),
                input_cache_write: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().nullish()
            }).transform(({ input, output, input_cache_read, input_cache_write })=>({
                    input,
                    output,
                    ...input_cache_read ? {
                        cachedInputTokens: input_cache_read
                    } : {},
                    ...input_cache_write ? {
                        cacheCreationInputTokens: input_cache_write
                    } : {}
                })).nullish(),
            specification: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                specificationVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("v3"),
                provider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                modelId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            modelType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "language",
                "embedding",
                "image"
            ]).nullish()
        }))
    })));
var gatewayCreditsResponseSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        balance: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        total_used: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }).transform(({ balance, total_used })=>({
            balance,
            totalUsed: total_used
        }))));
var GatewayLanguageModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.supportedUrls = {
            "*/*": [
                /.*/
            ]
        };
    }
    get provider() {
        return this.config.provider;
    }
    async getArgs(options) {
        const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
        return {
            args: this.maybeEncodeFileParts(optionsWithoutSignal),
            warnings: []
        };
    }
    async doGenerate(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve2(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue: rawResponse } = await postJsonToApi2({
                url: this.getUrl(),
                headers: combineHeaders2(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, false), await resolve2(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createJsonResponseHandler2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                ...responseBody,
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders,
                    body: rawResponse
                },
                warnings
            };
        } catch (error) {
            throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
        }
    }
    async doStream(options) {
        const { args, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve2(this.config.headers());
        try {
            const { value: response, responseHeaders } = await postJsonToApi2({
                url: this.getUrl(),
                headers: combineHeaders2(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, true), await resolve2(this.config.o11yHeaders)),
                body: args,
                successfulResponseHandler: createEventSourceResponseHandler2(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                stream: response.pipeThrough(new TransformStream({
                    start (controller) {
                        if (warnings.length > 0) {
                            controller.enqueue({
                                type: "stream-start",
                                warnings
                            });
                        }
                    },
                    transform (chunk, controller) {
                        if (chunk.success) {
                            const streamPart = chunk.value;
                            if (streamPart.type === "raw" && !options.includeRawChunks) {
                                return;
                            }
                            if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                                streamPart.timestamp = new Date(streamPart.timestamp);
                            }
                            controller.enqueue(streamPart);
                        } else {
                            controller.error(chunk.error);
                        }
                    }
                })),
                request: {
                    body: args
                },
                response: {
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
        }
    }
    isFilePart(part) {
        return part && typeof part === "object" && "type" in part && part.type === "file";
    }
    /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */ maybeEncodeFileParts(options) {
        for (const message of options.prompt){
            for (const part of message.content){
                if (this.isFilePart(part)) {
                    const filePart = part;
                    if (filePart.data instanceof Uint8Array) {
                        const buffer = Uint8Array.from(filePart.data);
                        const base64Data = Buffer.from(buffer).toString("base64");
                        filePart.data = new URL(`data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`);
                    }
                }
            }
        }
        return options;
    }
    getUrl() {
        return `${this.config.baseURL}/language-model`;
    }
    getModelConfigHeaders(modelId, streaming) {
        return {
            "ai-language-model-specification-version": "2",
            "ai-language-model-id": modelId,
            "ai-language-model-streaming": String(streaming)
        };
    }
};
var GatewayEmbeddingModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
    }
    get provider() {
        return this.config.provider;
    }
    async doEmbed({ values, headers, abortSignal, providerOptions }) {
        var _a832;
        const resolvedHeaders = await resolve2(this.config.headers());
        try {
            const { responseHeaders, value: responseBody, rawValue } = await postJsonToApi2({
                url: this.getUrl(),
                headers: combineHeaders2(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve2(this.config.o11yHeaders)),
                body: {
                    values,
                    ...providerOptions ? {
                        providerOptions
                    } : {}
                },
                successfulResponseHandler: createJsonResponseHandler2(gatewayEmbeddingResponseSchema2),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                embeddings: responseBody.embeddings,
                usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
                providerMetadata: responseBody.providerMetadata,
                response: {
                    headers: responseHeaders,
                    body: rawValue
                },
                warnings: []
            };
        } catch (error) {
            throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/embedding-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-embedding-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var gatewayEmbeddingResponseSchema2 = lazySchema(()=>zodSchema3(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        embeddings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number())),
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            tokens: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
        }).nullish(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown())).optional()
    })));
var GatewayImageModel2 = class {
    constructor(modelId, config){
        this.modelId = modelId;
        this.config = config;
        this.specificationVersion = "v3";
        this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
    }
    get provider() {
        return this.config.provider;
    }
    async doGenerate({ prompt, n, size, aspectRatio, seed, providerOptions, headers, abortSignal }) {
        var _a832;
        const resolvedHeaders = await resolve2(this.config.headers());
        try {
            const { responseHeaders, value: responseBody } = await postJsonToApi2({
                url: this.getUrl(),
                headers: combineHeaders2(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve2(this.config.o11yHeaders)),
                body: {
                    prompt,
                    n,
                    ...size && {
                        size
                    },
                    ...aspectRatio && {
                        aspectRatio
                    },
                    ...seed && {
                        seed
                    },
                    ...providerOptions && {
                        providerOptions
                    }
                },
                successfulResponseHandler: createJsonResponseHandler2(gatewayImageResponseSchema2),
                failedResponseHandler: createJsonErrorResponseHandler2({
                    errorSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any(),
                    errorToMessage: (data)=>data
                }),
                ...abortSignal && {
                    abortSignal
                },
                fetch: this.config.fetch
            });
            return {
                images: responseBody.images,
                // Always base64 strings from server
                warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
                providerMetadata: responseBody.providerMetadata,
                response: {
                    timestamp: /* @__PURE__ */ new Date(),
                    modelId: this.modelId,
                    headers: responseHeaders
                }
            };
        } catch (error) {
            throw asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
        }
    }
    getUrl() {
        return `${this.config.baseURL}/image-model`;
    }
    getModelConfigHeaders() {
        return {
            "ai-image-model-specification-version": "2",
            "ai-model-id": this.modelId
        };
    }
};
var providerMetadataEntrySchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()).optional()
}).catchall(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown());
var gatewayImageResponseSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    images: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
    // Always base64 strings over the wire
    warnings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("other"),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })).optional(),
    providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), providerMetadataEntrySchema2).optional()
});
async function getVercelRequestId2() {
    var _a832;
    return (_a832 = (0, import_oidc3.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION5 = "3.0.0";
var AI_GATEWAY_PROTOCOL_VERSION2 = "0.0.1";
function createGatewayProvider2(options = {}) {
    var _a832, _b83;
    let pendingMetadata = null;
    let metadataCache = null;
    const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
    let lastFetchTime = 0;
    const baseURL = (_b83 = withoutTrailingSlash2(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v3/ai";
    const getHeaders = async ()=>{
        const auth = await getGatewayAuthToken2(options);
        if (auth) {
            return withUserAgentSuffix2({
                Authorization: `Bearer ${auth.token}`,
                "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION2,
                [GATEWAY_AUTH_METHOD_HEADER2]: auth.authMethod,
                ...options.headers
            }, `ai-sdk/gateway/${VERSION5}`);
        }
        throw GatewayAuthenticationError2.createContextualError({
            apiKeyProvided: false,
            oidcTokenProvided: false,
            statusCode: 401
        });
    };
    const createO11yHeaders = ()=>{
        const deploymentId = loadOptionalSetting2({
            settingValue: void 0,
            environmentVariableName: "VERCEL_DEPLOYMENT_ID"
        });
        const environment = loadOptionalSetting2({
            settingValue: void 0,
            environmentVariableName: "VERCEL_ENV"
        });
        const region = loadOptionalSetting2({
            settingValue: void 0,
            environmentVariableName: "VERCEL_REGION"
        });
        return async ()=>{
            const requestId = await getVercelRequestId2();
            return {
                ...deploymentId && {
                    "ai-o11y-deployment-id": deploymentId
                },
                ...environment && {
                    "ai-o11y-environment": environment
                },
                ...region && {
                    "ai-o11y-region": region
                },
                ...requestId && {
                    "ai-o11y-request-id": requestId
                }
            };
        };
    };
    const createLanguageModel = (modelId)=>{
        return new GatewayLanguageModel2(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    const getAvailableModels = async ()=>{
        var _a922, _b92, _c;
        const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
        if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
            lastFetchTime = now2;
            pendingMetadata = new GatewayFetchMetadata2({
                baseURL,
                headers: getHeaders,
                fetch: options.fetch
            }).getAvailableModels().then((metadata)=>{
                metadataCache = metadata;
                return metadata;
            }).catch(async (error)=>{
                throw await asGatewayError2(error, await parseAuthMethod2(await getHeaders()));
            });
        }
        return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
    };
    const getCredits = async ()=>{
        return new GatewayFetchMetadata2({
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
        }).getCredits().catch(async (error)=>{
            throw await asGatewayError2(error, await parseAuthMethod2(await getHeaders()));
        });
    };
    const provider = function(modelId) {
        if (new.target) {
            throw new Error("The Gateway Provider model function cannot be called with the new keyword.");
        }
        return createLanguageModel(modelId);
    };
    provider.specificationVersion = "v3";
    provider.getAvailableModels = getAvailableModels;
    provider.getCredits = getCredits;
    provider.imageModel = (modelId)=>{
        return new GatewayImageModel2(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    provider.languageModel = createLanguageModel;
    const createEmbeddingModel = (modelId)=>{
        return new GatewayEmbeddingModel2(modelId, {
            provider: "gateway",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch,
            o11yHeaders: createO11yHeaders()
        });
    };
    provider.embeddingModel = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    return provider;
}
var gateway2 = createGatewayProvider2();
async function getGatewayAuthToken2(options) {
    const apiKey = loadOptionalSetting2({
        settingValue: options.apiKey,
        environmentVariableName: "AI_GATEWAY_API_KEY"
    });
    if (apiKey) {
        return {
            token: apiKey,
            authMethod: "api-key"
        };
    }
    try {
        const oidcToken = await (0, import_oidc22.getVercelOidcToken)();
        return {
            token: oidcToken,
            authMethod: "oidc"
        };
    } catch (e) {
        return null;
    }
}
var _globalThis3 = typeof globalThis === "object" ? globalThis : /*TURBOPACK member replacement*/ __turbopack_context__.g;
var VERSION23 = "1.9.0";
var re3 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck3(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([
        ownVersion
    ]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re3);
    if (!myVersionMatch) {
        return function() {
            return false;
        };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible22(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re3);
        if (!globalVersionMatch) {
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
var isCompatible3 = _makeCompatibilityCheck3(VERSION23);
var major3 = VERSION23.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY3 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major3);
var _global3 = _globalThis3;
function registerGlobal3(type, instance, diag, allowOverride) {
    var _a146;
    if (allowOverride === void 0) {
        allowOverride = false;
    }
    var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3] = (_a146 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) !== null && _a146 !== void 0 ? _a146 : {
        version: VERSION23
    };
    if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION23) {
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION23);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION23 + ".");
    return true;
}
function getGlobal3(type) {
    var _a146, _b83;
    var globalVersion = (_a146 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _a146 === void 0 ? void 0 : _a146.version;
    if (!globalVersion || !isCompatible3(globalVersion)) {
        return;
    }
    return (_b83 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal3(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION23 + ".");
    var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3];
    if (api) {
        delete api[type];
    }
}
var __read6 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray6 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger3 = /** @class */ function() {
    function DiagComponentLogger22(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger22.prototype.debug = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy3("debug", this._namespace, args);
    };
    DiagComponentLogger22.prototype.error = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy3("error", this._namespace, args);
    };
    DiagComponentLogger22.prototype.info = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy3("info", this._namespace, args);
    };
    DiagComponentLogger22.prototype.warn = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy3("warn", this._namespace, args);
    };
    DiagComponentLogger22.prototype.verbose = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return logProxy3("verbose", this._namespace, args);
    };
    return DiagComponentLogger22;
}();
function logProxy3(funcName, namespace, args) {
    var logger = getGlobal3("diag");
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray6([], __read6(args), false));
}
var DiagLogLevel3;
(function(DiagLogLevel22) {
    DiagLogLevel22[DiagLogLevel22["NONE"] = 0] = "NONE";
    DiagLogLevel22[DiagLogLevel22["ERROR"] = 30] = "ERROR";
    DiagLogLevel22[DiagLogLevel22["WARN"] = 50] = "WARN";
    DiagLogLevel22[DiagLogLevel22["INFO"] = 60] = "INFO";
    DiagLogLevel22[DiagLogLevel22["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel22[DiagLogLevel22["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel22[DiagLogLevel22["ALL"] = 9999] = "ALL";
})(DiagLogLevel3 || (DiagLogLevel3 = {}));
function createLogLevelDiagLogger3(maxLevel, logger) {
    if (maxLevel < DiagLogLevel3.NONE) {
        maxLevel = DiagLogLevel3.NONE;
    } else if (maxLevel > DiagLogLevel3.ALL) {
        maxLevel = DiagLogLevel3.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function() {};
    }
    return {
        error: _filterFunc("error", DiagLogLevel3.ERROR),
        warn: _filterFunc("warn", DiagLogLevel3.WARN),
        info: _filterFunc("info", DiagLogLevel3.INFO),
        debug: _filterFunc("debug", DiagLogLevel3.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel3.VERBOSE)
    };
}
var __read23 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray23 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME5 = "diag";
var DiagAPI3 = /** @class */ function() {
    function DiagAPI22() {
        function _logProxy(funcName) {
            return function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++){
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal3("diag");
                if (!logger) return;
                return logger[funcName].apply(logger, __spreadArray23([], __read23(args), false));
            };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
            var _a146, _b83, _c;
            if (optionsOrLogLevel === void 0) {
                optionsOrLogLevel = {
                    logLevel: DiagLogLevel3.INFO
                };
            }
            if (logger === self) {
                var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                self.error((_a146 = err.stack) !== null && _a146 !== void 0 ? _a146 : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === "number") {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel
                };
            }
            var oldLogger = getGlobal3("diag");
            var newLogger = createLogLevelDiagLogger3((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel3.INFO, logger);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal3("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
            unregisterGlobal3(API_NAME5, self);
        };
        self.createComponentLogger = function(options) {
            return new DiagComponentLogger3(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
    }
    DiagAPI22.instance = function() {
        if (!this._instance) {
            this._instance = new DiagAPI22();
        }
        return this._instance;
    };
    return DiagAPI22;
}();
function createContextKey3(description) {
    return Symbol.for(description);
}
var BaseContext3 = /** @class */ /* @__PURE__ */ function() {
    function BaseContext22(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext22(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext22;
}();
var ROOT_CONTEXT3 = new BaseContext3();
var __read33 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray33 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager3 = /** @class */ function() {
    function NoopContextManager22() {}
    NoopContextManager22.prototype.active = function() {
        return ROOT_CONTEXT3;
    };
    NoopContextManager22.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray33([
            thisArg
        ], __read33(args), false));
    };
    NoopContextManager22.prototype.bind = function(_context, target) {
        return target;
    };
    NoopContextManager22.prototype.enable = function() {
        return this;
    };
    NoopContextManager22.prototype.disable = function() {
        return this;
    };
    return NoopContextManager22;
}();
var __read43 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while(!(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray43 = function(to, from, pack) {
    if (arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME23 = "context";
var NOOP_CONTEXT_MANAGER3 = new NoopContextManager3();
var ContextAPI3 = /** @class */ function() {
    function ContextAPI22() {}
    ContextAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new ContextAPI22();
        }
        return this._instance;
    };
    ContextAPI22.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal3(API_NAME23, contextManager, DiagAPI3.instance());
    };
    ContextAPI22.prototype.active = function() {
        return this._getContextManager().active();
    };
    ContextAPI22.prototype.with = function(context, fn, thisArg) {
        var _a146;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++){
            args[_i - 3] = arguments[_i];
        }
        return (_a146 = this._getContextManager()).with.apply(_a146, __spreadArray43([
            context,
            fn,
            thisArg
        ], __read43(args), false));
    };
    ContextAPI22.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI22.prototype._getContextManager = function() {
        return getGlobal3(API_NAME23) || NOOP_CONTEXT_MANAGER3;
    };
    ContextAPI22.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal3(API_NAME23, DiagAPI3.instance());
    };
    return ContextAPI22;
}();
var TraceFlags3;
(function(TraceFlags22) {
    TraceFlags22[TraceFlags22["NONE"] = 0] = "NONE";
    TraceFlags22[TraceFlags22["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags3 || (TraceFlags3 = {}));
var INVALID_SPANID3 = "0000000000000000";
var INVALID_TRACEID3 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT3 = {
    traceId: INVALID_TRACEID3,
    spanId: INVALID_SPANID3,
    traceFlags: TraceFlags3.NONE
};
var NonRecordingSpan3 = /** @class */ function() {
    function NonRecordingSpan22(_spanContext) {
        if (_spanContext === void 0) {
            _spanContext = INVALID_SPAN_CONTEXT3;
        }
        this._spanContext = _spanContext;
    }
    NonRecordingSpan22.prototype.spanContext = function() {
        return this._spanContext;
    };
    NonRecordingSpan22.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    NonRecordingSpan22.prototype.setAttributes = function(_attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    NonRecordingSpan22.prototype.addLink = function(_link) {
        return this;
    };
    NonRecordingSpan22.prototype.addLinks = function(_links) {
        return this;
    };
    NonRecordingSpan22.prototype.setStatus = function(_status) {
        return this;
    };
    NonRecordingSpan22.prototype.updateName = function(_name) {
        return this;
    };
    NonRecordingSpan22.prototype.end = function(_endTime) {};
    NonRecordingSpan22.prototype.isRecording = function() {
        return false;
    };
    NonRecordingSpan22.prototype.recordException = function(_exception, _time) {};
    return NonRecordingSpan22;
}();
var SPAN_KEY3 = createContextKey3("OpenTelemetry Context Key SPAN");
function getSpan3(context) {
    return context.getValue(SPAN_KEY3) || void 0;
}
function getActiveSpan3() {
    return getSpan3(ContextAPI3.getInstance().active());
}
function setSpan3(context, span) {
    return context.setValue(SPAN_KEY3, span);
}
function deleteSpan3(context) {
    return context.deleteValue(SPAN_KEY3);
}
function setSpanContext3(context, spanContext) {
    return setSpan3(context, new NonRecordingSpan3(spanContext));
}
function getSpanContext3(context) {
    var _a146;
    return (_a146 = getSpan3(context)) === null || _a146 === void 0 ? void 0 : _a146.spanContext();
}
var VALID_TRACEID_REGEX3 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX3 = /^[0-9a-f]{16}$/i;
function isValidTraceId3(traceId) {
    return VALID_TRACEID_REGEX3.test(traceId) && traceId !== INVALID_TRACEID3;
}
function isValidSpanId3(spanId) {
    return VALID_SPANID_REGEX3.test(spanId) && spanId !== INVALID_SPANID3;
}
function isSpanContextValid3(spanContext) {
    return isValidTraceId3(spanContext.traceId) && isValidSpanId3(spanContext.spanId);
}
function wrapSpanContext3(spanContext) {
    return new NonRecordingSpan3(spanContext);
}
var contextApi3 = ContextAPI3.getInstance();
var NoopTracer3 = /** @class */ function() {
    function NoopTracer22() {}
    NoopTracer22.prototype.startSpan = function(name144, options, context) {
        if (context === void 0) {
            context = contextApi3.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan3();
        }
        var parentFromContext = context && getSpanContext3(context);
        if (isSpanContext3(parentFromContext) && isSpanContextValid3(parentFromContext)) {
            return new NonRecordingSpan3(parentFromContext);
        } else {
            return new NonRecordingSpan3();
        }
    };
    NoopTracer22.prototype.startActiveSpan = function(name144, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        } else if (arguments.length === 2) {
            fn = arg2;
        } else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        } else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi3.active();
        var span = this.startSpan(name144, opts, parentContext);
        var contextWithSpanSet = setSpan3(parentContext, span);
        return contextApi3.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer22;
}();
function isSpanContext3(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER3 = new NoopTracer3();
var ProxyTracer3 = /** @class */ function() {
    function ProxyTracer22(_provider, name144, version, options) {
        this._provider = _provider;
        this.name = name144;
        this.version = version;
        this.options = options;
    }
    ProxyTracer22.prototype.startSpan = function(name144, options, context) {
        return this._getTracer().startSpan(name144, options, context);
    };
    ProxyTracer22.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer22.prototype._getTracer = function() {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER3;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer22;
}();
var NoopTracerProvider3 = /** @class */ function() {
    function NoopTracerProvider22() {}
    NoopTracerProvider22.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer3();
    };
    return NoopTracerProvider22;
}();
var NOOP_TRACER_PROVIDER3 = new NoopTracerProvider3();
var ProxyTracerProvider3 = /** @class */ function() {
    function ProxyTracerProvider22() {}
    ProxyTracerProvider22.prototype.getTracer = function(name144, version, options) {
        var _a146;
        return (_a146 = this.getDelegateTracer(name144, version, options)) !== null && _a146 !== void 0 ? _a146 : new ProxyTracer3(this, name144, version, options);
    };
    ProxyTracerProvider22.prototype.getDelegate = function() {
        var _a146;
        return (_a146 = this._delegate) !== null && _a146 !== void 0 ? _a146 : NOOP_TRACER_PROVIDER3;
    };
    ProxyTracerProvider22.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider22.prototype.getDelegateTracer = function(name144, version, options) {
        var _a146;
        return (_a146 = this._delegate) === null || _a146 === void 0 ? void 0 : _a146.getTracer(name144, version, options);
    };
    return ProxyTracerProvider22;
}();
var SpanStatusCode3;
(function(SpanStatusCode22) {
    SpanStatusCode22[SpanStatusCode22["UNSET"] = 0] = "UNSET";
    SpanStatusCode22[SpanStatusCode22["OK"] = 1] = "OK";
    SpanStatusCode22[SpanStatusCode22["ERROR"] = 2] = "ERROR";
})(SpanStatusCode3 || (SpanStatusCode3 = {}));
var API_NAME33 = "trace";
var TraceAPI3 = /** @class */ function() {
    function TraceAPI22() {
        this._proxyTracerProvider = new ProxyTracerProvider3();
        this.wrapSpanContext = wrapSpanContext3;
        this.isSpanContextValid = isSpanContextValid3;
        this.deleteSpan = deleteSpan3;
        this.getSpan = getSpan3;
        this.getActiveSpan = getActiveSpan3;
        this.getSpanContext = getSpanContext3;
        this.setSpan = setSpan3;
        this.setSpanContext = setSpanContext3;
    }
    TraceAPI22.getInstance = function() {
        if (!this._instance) {
            this._instance = new TraceAPI22();
        }
        return this._instance;
    };
    TraceAPI22.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal3(API_NAME33, this._proxyTracerProvider, DiagAPI3.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    TraceAPI22.prototype.getTracerProvider = function() {
        return getGlobal3(API_NAME33) || this._proxyTracerProvider;
    };
    TraceAPI22.prototype.getTracer = function(name144, version) {
        return this.getTracerProvider().getTracer(name144, version);
    };
    TraceAPI22.prototype.disable = function() {
        unregisterGlobal3(API_NAME33, DiagAPI3.instance());
        this._proxyTracerProvider = new ProxyTracerProvider3();
    };
    return TraceAPI22;
}();
var trace3 = TraceAPI3.getInstance();
var __defProp4 = Object.defineProperty;
var __export3 = (target, all)=>{
    for(var name144 in all)__defProp4(target, name144, {
        get: all[name144],
        enumerable: true
    });
};
var name76 = "AI_InvalidArgumentError";
var marker86 = `vercel.ai.error.${name76}`;
var symbol86 = Symbol.for(marker86);
var _a86;
var InvalidArgumentError23 = class extends AISDKError3 {
    constructor({ parameter, value, message }){
        super({
            name: name76,
            message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a86] = true;
        this.parameter = parameter;
        this.value = value;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker86);
    }
};
_a86 = symbol86;
var name523 = "AI_NoObjectGeneratedError";
var marker523 = `vercel.ai.error.${name523}`;
var symbol523 = Symbol.for(marker523);
var _a523;
var NoObjectGeneratedError3 = class extends AISDKError3 {
    constructor({ message = "No object generated.", cause, text: text22, response, usage, finishReason }){
        super({
            name: name523,
            message,
            cause
        });
        this[_a523] = true;
        this.text = text22;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker523);
    }
};
_a523 = symbol523;
var UnsupportedModelVersionError3 = class extends AISDKError3 {
    constructor(options){
        super({
            name: "AI_UnsupportedModelVersionError",
            message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
        });
        this.version = options.version;
        this.provider = options.provider;
        this.modelId = options.modelId;
    }
};
var name126 = "AI_RetryError";
var marker125 = `vercel.ai.error.${name126}`;
var symbol125 = Symbol.for(marker125);
var _a125;
var RetryError3 = class extends AISDKError3 {
    constructor({ message, reason, errors }){
        super({
            name: name126,
            message
        });
        this[_a125] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
        return AISDKError3.hasMarker(error, marker125);
    }
};
_a125 = symbol125;
function formatWarning({ warning, provider, model }) {
    const prefix = `AI SDK Warning (${provider} / ${model}):`;
    switch(warning.type){
        case "unsupported":
            {
                let message = `${prefix} The feature "${warning.feature}" is not supported.`;
                if (warning.details) {
                    message += ` ${warning.details}`;
                }
                return message;
            }
        case "compatibility":
            {
                let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
                if (warning.details) {
                    message += ` ${warning.details}`;
                }
                return message;
            }
        case "other":
            {
                return `${prefix} ${warning.message}`;
            }
        default:
            {
                return `${prefix} ${JSON.stringify(warning, null, 2)}`;
            }
    }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (options)=>{
    if (options.warnings.length === 0) {
        return;
    }
    const logger = globalThis.AI_SDK_LOG_WARNINGS;
    if (logger === false) {
        return;
    }
    if (typeof logger === "function") {
        logger(options);
        return;
    }
    if (!hasLoggedBefore) {
        hasLoggedBefore = true;
        console.info(FIRST_WARNING_INFO_MESSAGE);
    }
    for (const warning of options.warnings){
        console.warn(formatWarning({
            warning,
            provider: options.provider,
            model: options.model
        }));
    }
};
function logV2CompatibilityWarning({ provider, modelId }) {
    logWarnings({
        warnings: [
            {
                type: "compatibility",
                feature: "specificationVersion",
                details: `Using v2 specification compatibility mode. Some features may not be available.`
            }
        ],
        provider,
        model: modelId
    });
}
function asEmbeddingModelV3(model) {
    if (model.specificationVersion === "v3") {
        return model;
    }
    logV2CompatibilityWarning({
        provider: model.provider,
        modelId: model.modelId
    });
    return new Proxy(model, {
        get (target, prop) {
            if (prop === "specificationVersion") return "v3";
            return target[prop];
        }
    });
}
function resolveEmbeddingModel2(model) {
    if (typeof model !== "string") {
        if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
            const unsupportedModel = model;
            throw new UnsupportedModelVersionError3({
                version: unsupportedModel.specificationVersion,
                provider: unsupportedModel.provider,
                modelId: unsupportedModel.modelId
            });
        }
        return asEmbeddingModelV3(model);
    }
    return getGlobalProvider2().embeddingModel(model);
}
function getGlobalProvider2() {
    var _a146;
    return (_a146 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a146 : gateway2;
}
var VERSION33 = "6.0.1";
var dataContentSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>{
        var _a146, _b83;
        return (_b83 = (_a146 = globalThis.Buffer) == null ? void 0 : _a146.isBuffer(value)) != null ? _b83 : false;
    }, {
        message: "Must be a Buffer"
    })
]);
var jsonValueSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema3.optional()),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(jsonValueSchema3)
    ]));
var providerMetadataSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema3.optional()));
var textPartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema3.optional()
});
var imagePartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema3,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    providerOptions: providerMetadataSchema3.optional()
});
var filePartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema3,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema3.optional()
});
var reasoningPartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema3.optional()
});
var toolCallPartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    providerOptions: providerMetadataSchema3.optional(),
    providerExecuted: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional()
});
var outputSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].discriminatedUnion("type", [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        providerOptions: providerMetadataSchema3.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("json"),
        value: jsonValueSchema3,
        providerOptions: providerMetadataSchema3.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("execution-denied"),
        reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        providerOptions: providerMetadataSchema3.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-text"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        providerOptions: providerMetadataSchema3.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error-json"),
        value: jsonValueSchema3,
        providerOptions: providerMetadataSchema3.optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("content"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
                text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("media"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-data"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-url"),
                url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file-id"),
                fileId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
                ]),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-data"),
                data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-url"),
                url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image-file-id"),
                fileId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
                ]),
                providerOptions: providerMetadataSchema3.optional()
            }),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("custom"),
                providerOptions: providerMetadataSchema3.optional()
            })
        ]))
    })
]);
var toolResultPartSchema3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    output: outputSchema2,
    providerOptions: providerMetadataSchema3.optional()
});
var toolApprovalRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-approval-request"),
    approvalId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
var toolApprovalResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-approval-response"),
    approvalId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    approved: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
    reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
var systemModelMessageSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("system"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema3.optional()
});
var userModelMessageSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("user"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema3,
            imagePartSchema3,
            filePartSchema3
        ]))
    ]),
    providerOptions: providerMetadataSchema3.optional()
});
var assistantModelMessageSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("assistant"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema3,
            filePartSchema3,
            reasoningPartSchema3,
            toolCallPartSchema3,
            toolResultPartSchema3,
            toolApprovalRequestSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema3.optional()
});
var toolModelMessageSchema2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        toolResultPartSchema3,
        toolApprovalResponseSchema
    ])),
    providerOptions: providerMetadataSchema3.optional()
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    systemModelMessageSchema2,
    userModelMessageSchema2,
    assistantModelMessageSchema2,
    toolModelMessageSchema2
]);
function assembleOperationName3({ operationId, telemetry }) {
    return {
        // standardized operation and resource name:
        "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
        "resource.name": telemetry == null ? void 0 : telemetry.functionId,
        // detailed, AI SDK specific data:
        "ai.operationId": operationId,
        "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
}
function getBaseTelemetryAttributes3({ model, settings, telemetry, headers }) {
    var _a146;
    return {
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // settings:
        ...Object.entries(settings).reduce((attributes, [key, value])=>{
            attributes[`ai.settings.${key}`] = value;
            return attributes;
        }, {}),
        // add metadata as attributes:
        ...Object.entries((_a146 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a146 : {}).reduce((attributes, [key, value])=>{
            attributes[`ai.telemetry.metadata.${key}`] = value;
            return attributes;
        }, {}),
        // request headers
        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{
            if (value !== void 0) {
                attributes[`ai.request.headers.${key}`] = value;
            }
            return attributes;
        }, {})
    };
}
var noopTracer3 = {
    startSpan () {
        return noopSpan3;
    },
    startActiveSpan (name144, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
            return arg1(noopSpan3);
        }
        if (typeof arg2 === "function") {
            return arg2(noopSpan3);
        }
        if (typeof arg3 === "function") {
            return arg3(noopSpan3);
        }
    }
};
var noopSpan3 = {
    spanContext () {
        return noopSpanContext3;
    },
    setAttribute () {
        return this;
    },
    setAttributes () {
        return this;
    },
    addEvent () {
        return this;
    },
    addLink () {
        return this;
    },
    addLinks () {
        return this;
    },
    setStatus () {
        return this;
    },
    updateName () {
        return this;
    },
    end () {
        return this;
    },
    isRecording () {
        return false;
    },
    recordException () {
        return this;
    }
};
var noopSpanContext3 = {
    traceId: "",
    spanId: "",
    traceFlags: 0
};
function getTracer3({ isEnabled = false, tracer } = {}) {
    if (!isEnabled) {
        return noopTracer3;
    }
    if (tracer) {
        return tracer;
    }
    return trace3.getTracer("ai");
}
async function recordSpan3({ name: name144, tracer, attributes, fn, endWhenDone = true }) {
    return tracer.startActiveSpan(name144, {
        attributes: await attributes
    }, async (span)=>{
        try {
            const result = await fn(span);
            if (endWhenDone) {
                span.end();
            }
            return result;
        } catch (error) {
            try {
                recordErrorOnSpan3(span, error);
            } finally{
                span.end();
            }
            throw error;
        }
    });
}
function recordErrorOnSpan3(span, error) {
    if (error instanceof Error) {
        span.recordException({
            name: error.name,
            message: error.message,
            stack: error.stack
        });
        span.setStatus({
            code: SpanStatusCode3.ERROR,
            message: error.message
        });
    } else {
        span.setStatus({
            code: SpanStatusCode3.ERROR
        });
    }
}
async function selectTelemetryAttributes3({ telemetry, attributes }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
        return {};
    }
    const resultAttributes = {};
    for (const [key, value] of Object.entries(attributes)){
        if (value == null) {
            continue;
        }
        if (typeof value === "object" && "input" in value && typeof value.input === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
                continue;
            }
            const result = await value.input();
            if (result != null) {
                resultAttributes[key] = result;
            }
            continue;
        }
        if (typeof value === "object" && "output" in value && typeof value.output === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
                continue;
            }
            const result = await value.output();
            if (result != null) {
                resultAttributes[key] = result;
            }
            continue;
        }
        resultAttributes[key] = value;
    }
    return resultAttributes;
}
function getRetryDelayInMs2({ error, exponentialBackoffDelay }) {
    const headers = error.responseHeaders;
    if (!headers) return exponentialBackoffDelay;
    let ms;
    const retryAfterMs = headers["retry-after-ms"];
    if (retryAfterMs) {
        const timeoutMs = parseFloat(retryAfterMs);
        if (!Number.isNaN(timeoutMs)) {
            ms = timeoutMs;
        }
    }
    const retryAfter = headers["retry-after"];
    if (retryAfter && ms === void 0) {
        const timeoutSeconds = parseFloat(retryAfter);
        if (!Number.isNaN(timeoutSeconds)) {
            ms = timeoutSeconds * 1e3;
        } else {
            ms = Date.parse(retryAfter) - Date.now();
        }
    }
    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
        return ms;
    }
    return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders2 = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2, abortSignal } = {})=>async (f)=>_retryWithExponentialBackoff3(f, {
            maxRetries,
            delayInMs: initialDelayInMs,
            backoffFactor,
            abortSignal
        });
async function _retryWithExponentialBackoff3(f, { maxRetries, delayInMs, backoffFactor, abortSignal }, errors = []) {
    try {
        return await f();
    } catch (error) {
        if (isAbortError3(error)) {
            throw error;
        }
        if (maxRetries === 0) {
            throw error;
        }
        const errorMessage = getErrorMessage23(error);
        const newErrors = [
            ...errors,
            error
        ];
        const tryNumber = newErrors.length;
        if (tryNumber > maxRetries) {
            throw new RetryError3({
                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
                reason: "maxRetriesExceeded",
                errors: newErrors
            });
        }
        if (error instanceof Error && APICallError3.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
            await delay3(getRetryDelayInMs2({
                error,
                exponentialBackoffDelay: delayInMs
            }), {
                abortSignal
            });
            return _retryWithExponentialBackoff3(f, {
                maxRetries,
                delayInMs: backoffFactor * delayInMs,
                backoffFactor,
                abortSignal
            }, newErrors);
        }
        if (tryNumber === 1) {
            throw error;
        }
        throw new RetryError3({
            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
            reason: "errorNotRetryable",
            errors: newErrors
        });
    }
}
function prepareRetries3({ maxRetries, abortSignal }) {
    if (maxRetries != null) {
        if (!Number.isInteger(maxRetries)) {
            throw new InvalidArgumentError23({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be an integer"
            });
        }
        if (maxRetries < 0) {
            throw new InvalidArgumentError23({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be >= 0"
            });
        }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
        maxRetries: maxRetriesResult,
        retry: retryWithExponentialBackoffRespectingRetryHeaders2({
            maxRetries: maxRetriesResult,
            abortSignal
        })
    };
}
var output_exports3 = {};
__export3(output_exports3, {
    array: ()=>array,
    choice: ()=>choice,
    json: ()=>json,
    object: ()=>object3,
    text: ()=>text3
});
function fixJson3(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
async function parsePartialJson3(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = await safeParseJSON3({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = await safeParseJSON3({
        text: fixJson3(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
var text3 = ()=>({
        responseFormat: Promise.resolve({
            type: "text"
        }),
        async parseCompleteOutput ({ text: text22 }) {
            return text22;
        },
        async parsePartialOutput ({ text: text22 }) {
            return {
                partial: text22
            };
        }
    });
var object3 = ({ schema: inputSchema, name: name144, description })=>{
    const schema = asSchema3(inputSchema);
    return {
        responseFormat: resolve2(schema.jsonSchema).then((jsonSchema22)=>({
                type: "json",
                schema: jsonSchema22,
                ...name144 != null && {
                    name: name144
                },
                ...description != null && {
                    description
                }
            })),
        async parseCompleteOutput ({ text: text22 }, context) {
            const parseResult = await safeParseJSON3({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const validationResult = await safeValidateTypes3({
                value: parseResult.value,
                schema
            });
            if (!validationResult.success) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: response did not match schema.",
                    cause: validationResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return validationResult.value;
        },
        async parsePartialOutput ({ text: text22 }) {
            const result = await parsePartialJson3(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        return {
                            // Note: currently no validation of partial results:
                            partial: result.value
                        };
                    }
            }
        }
    };
};
var array = ({ element: inputElementSchema, name: name144, description })=>{
    const elementSchema = asSchema3(inputElementSchema);
    return {
        // JSON schema that describes an array of elements:
        responseFormat: resolve2(elementSchema.jsonSchema).then((jsonSchema22)=>{
            const { $schema, ...itemSchema } = jsonSchema22;
            return {
                type: "json",
                schema: {
                    $schema: "http://json-schema.org/draft-07/schema#",
                    type: "object",
                    properties: {
                        elements: {
                            type: "array",
                            items: itemSchema
                        }
                    },
                    required: [
                        "elements"
                    ],
                    additionalProperties: false
                },
                ...name144 != null && {
                    name: name144
                },
                ...description != null && {
                    description
                }
            };
        }),
        async parseCompleteOutput ({ text: text22 }, context) {
            const parseResult = await safeParseJSON3({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const outerValue = parseResult.value;
            if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: response did not match schema.",
                    cause: new TypeValidationError3({
                        value: outerValue,
                        cause: "response must be an object with an elements array"
                    }),
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            for (const element of outerValue.elements){
                const validationResult = await safeValidateTypes3({
                    value: element,
                    schema: elementSchema
                });
                if (!validationResult.success) {
                    throw new NoObjectGeneratedError3({
                        message: "No object generated: response did not match schema.",
                        cause: validationResult.error,
                        text: text22,
                        response: context.response,
                        usage: context.usage,
                        finishReason: context.finishReason
                    });
                }
            }
            return outerValue.elements;
        },
        async parsePartialOutput ({ text: text22 }) {
            const result = await parsePartialJson3(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        const outerValue = result.value;
                        if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
                            return void 0;
                        }
                        const rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;
                        const parsedElements = [];
                        for (const rawElement of rawElements){
                            const validationResult = await safeValidateTypes3({
                                value: rawElement,
                                schema: elementSchema
                            });
                            if (validationResult.success) {
                                parsedElements.push(validationResult.value);
                            }
                        }
                        return {
                            partial: parsedElements
                        };
                    }
            }
        }
    };
};
var choice = ({ options: choiceOptions, name: name144, description })=>{
    return {
        // JSON schema that describes an enumeration:
        responseFormat: Promise.resolve({
            type: "json",
            schema: {
                $schema: "http://json-schema.org/draft-07/schema#",
                type: "object",
                properties: {
                    result: {
                        type: "string",
                        enum: choiceOptions
                    }
                },
                required: [
                    "result"
                ],
                additionalProperties: false
            },
            ...name144 != null && {
                name: name144
            },
            ...description != null && {
                description
            }
        }),
        async parseCompleteOutput ({ text: text22 }, context) {
            const parseResult = await safeParseJSON3({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const outerValue = parseResult.value;
            if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result)) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: response did not match schema.",
                    cause: new TypeValidationError3({
                        value: outerValue,
                        cause: "response must be an object that contains a choice value."
                    }),
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return outerValue.result;
        },
        async parsePartialOutput ({ text: text22 }) {
            const result = await parsePartialJson3(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        const outerValue = result.value;
                        if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string") {
                            return void 0;
                        }
                        const potentialMatches = choiceOptions.filter((choiceOption)=>choiceOption.startsWith(outerValue.result));
                        if (result.state === "successful-parse") {
                            return potentialMatches.includes(outerValue.result) ? {
                                partial: outerValue.result
                            } : void 0;
                        } else {
                            return potentialMatches.length === 1 ? {
                                partial: potentialMatches[0]
                            } : void 0;
                        }
                    }
            }
        }
    };
};
var json = ({ name: name144, description } = {})=>{
    return {
        responseFormat: Promise.resolve({
            type: "json",
            ...name144 != null && {
                name: name144
            },
            ...description != null && {
                description
            }
        }),
        async parseCompleteOutput ({ text: text22 }, context) {
            const parseResult = await safeParseJSON3({
                text: text22
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError3({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text22,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return parseResult.value;
        },
        async parsePartialOutput ({ text: text22 }) {
            const result = await parsePartialJson3(text22);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    {
                        return void 0;
                    }
                case "repaired-parse":
                case "successful-parse":
                    {
                        return result.value === void 0 ? void 0 : {
                            partial: result.value
                        };
                    }
            }
        }
    };
};
createIdGenerator3({
    prefix: "aitxt",
    size: 24
});
createIdGenerator3({
    prefix: "aitxt",
    size: 24
});
function splitArray3(array2, chunkSize) {
    if (chunkSize <= 0) {
        throw new Error("chunkSize must be greater than 0");
    }
    const result = [];
    for(let i = 0; i < array2.length; i += chunkSize){
        result.push(array2.slice(i, i + chunkSize));
    }
    return result;
}
async function embedMany3({ model: modelArg, values, maxParallelCalls = Infinity, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {
    const model = resolveEmbeddingModel2(modelArg);
    const { maxRetries, retry } = prepareRetries3({
        maxRetries: maxRetriesArg,
        abortSignal
    });
    const headersWithUserAgent = withUserAgentSuffix2(headers != null ? headers : {}, `ai/${VERSION33}`);
    const baseTelemetryAttributes = getBaseTelemetryAttributes3({
        model,
        telemetry,
        headers: headersWithUserAgent,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer3(telemetry);
    return recordSpan3({
        name: "ai.embedMany",
        attributes: selectTelemetryAttributes3({
            telemetry,
            attributes: {
                ...assembleOperationName3({
                    operationId: "ai.embedMany",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                    input: ()=>values.map((value)=>JSON.stringify(value))
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            var _a146;
            const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
                model.maxEmbeddingsPerCall,
                model.supportsParallelCalls
            ]);
            if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
                const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(()=>{
                    return recordSpan3({
                        name: "ai.embedMany.doEmbed",
                        attributes: selectTelemetryAttributes3({
                            telemetry,
                            attributes: {
                                ...assembleOperationName3({
                                    operationId: "ai.embedMany.doEmbed",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                // specific settings that only make sense on the outer level:
                                "ai.values": {
                                    input: ()=>values.map((value)=>JSON.stringify(value))
                                }
                            }
                        }),
                        tracer,
                        fn: async (doEmbedSpan)=>{
                            var _a154;
                            const modelResponse = await model.doEmbed({
                                values,
                                abortSignal,
                                headers: headersWithUserAgent,
                                providerOptions
                            });
                            const embeddings3 = modelResponse.embeddings;
                            const usage2 = (_a154 = modelResponse.usage) != null ? _a154 : {
                                tokens: NaN
                            };
                            doEmbedSpan.setAttributes(await selectTelemetryAttributes3({
                                telemetry,
                                attributes: {
                                    "ai.embeddings": {
                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))
                                    },
                                    "ai.usage.tokens": usage2.tokens
                                }
                            }));
                            return {
                                embeddings: embeddings3,
                                usage: usage2,
                                warnings: modelResponse.warnings,
                                providerMetadata: modelResponse.providerMetadata,
                                response: modelResponse.response
                            };
                        }
                    });
                });
                span.setAttributes(await selectTelemetryAttributes3({
                    telemetry,
                    attributes: {
                        "ai.embeddings": {
                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                        },
                        "ai.usage.tokens": usage.tokens
                    }
                }));
                logWarnings({
                    warnings: warnings2,
                    provider: model.provider,
                    model: model.modelId
                });
                return new DefaultEmbedManyResult3({
                    values,
                    embeddings: embeddings2,
                    usage,
                    warnings: warnings2,
                    providerMetadata: providerMetadata2,
                    responses: [
                        response
                    ]
                });
            }
            const valueChunks = splitArray3(values, maxEmbeddingsPerCall);
            const embeddings = [];
            const warnings = [];
            const responses = [];
            let tokens = 0;
            let providerMetadata;
            const parallelChunks = splitArray3(valueChunks, supportsParallelCalls ? maxParallelCalls : 1);
            for (const parallelChunk of parallelChunks){
                const results = await Promise.all(parallelChunk.map((chunk)=>{
                    return retry(()=>{
                        return recordSpan3({
                            name: "ai.embedMany.doEmbed",
                            attributes: selectTelemetryAttributes3({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName3({
                                        operationId: "ai.embedMany.doEmbed",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // specific settings that only make sense on the outer level:
                                    "ai.values": {
                                        input: ()=>chunk.map((value)=>JSON.stringify(value))
                                    }
                                }
                            }),
                            tracer,
                            fn: async (doEmbedSpan)=>{
                                var _a154;
                                const modelResponse = await model.doEmbed({
                                    values: chunk,
                                    abortSignal,
                                    headers: headersWithUserAgent,
                                    providerOptions
                                });
                                const embeddings2 = modelResponse.embeddings;
                                const usage = (_a154 = modelResponse.usage) != null ? _a154 : {
                                    tokens: NaN
                                };
                                doEmbedSpan.setAttributes(await selectTelemetryAttributes3({
                                    telemetry,
                                    attributes: {
                                        "ai.embeddings": {
                                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                                        },
                                        "ai.usage.tokens": usage.tokens
                                    }
                                }));
                                return {
                                    embeddings: embeddings2,
                                    usage,
                                    warnings: modelResponse.warnings,
                                    providerMetadata: modelResponse.providerMetadata,
                                    response: modelResponse.response
                                };
                            }
                        });
                    });
                }));
                for (const result of results){
                    embeddings.push(...result.embeddings);
                    warnings.push(...result.warnings);
                    responses.push(result.response);
                    tokens += result.usage.tokens;
                    if (result.providerMetadata) {
                        if (!providerMetadata) {
                            providerMetadata = {
                                ...result.providerMetadata
                            };
                        } else {
                            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){
                                providerMetadata[providerName] = {
                                    ...(_a146 = providerMetadata[providerName]) != null ? _a146 : {},
                                    ...metadata
                                };
                            }
                        }
                    }
                }
            }
            span.setAttributes(await selectTelemetryAttributes3({
                telemetry,
                attributes: {
                    "ai.embeddings": {
                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": tokens
                }
            }));
            logWarnings({
                warnings,
                provider: model.provider,
                model: model.modelId
            });
            return new DefaultEmbedManyResult3({
                values,
                embeddings,
                usage: {
                    tokens
                },
                warnings,
                providerMetadata,
                responses
            });
        }
    });
}
var DefaultEmbedManyResult3 = class {
    constructor(options){
        this.values = options.values;
        this.embeddings = options.embeddings;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.responses = options.responses;
    }
};
createIdGenerator3({
    prefix: "aiobj",
    size: 24
});
createIdGenerator3({
    prefix: "aiobj",
    size: 24
});
function deepMergeWorkingMemory(existing, update) {
    if (!update || typeof update !== "object" || Object.keys(update).length === 0) {
        return existing && typeof existing === "object" ? {
            ...existing
        } : {};
    }
    if (!existing || typeof existing !== "object") {
        return update;
    }
    const result = {
        ...existing
    };
    for (const key of Object.keys(update)){
        const updateValue = update[key];
        const existingValue = result[key];
        if (updateValue === null) {
            delete result[key];
        } else if (Array.isArray(updateValue)) {
            result[key] = updateValue;
        } else if (typeof updateValue === "object" && updateValue !== null && typeof existingValue === "object" && existingValue !== null && !Array.isArray(existingValue)) {
            result[key] = deepMergeWorkingMemory(existingValue, updateValue);
        } else {
            result[key] = updateValue;
        }
    }
    return result;
}
var updateWorkingMemoryTool = (memoryConfig)=>{
    const schema = memoryConfig?.workingMemory?.schema;
    let inputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        memory: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().describe(`The Markdown formatted working memory content to store. This MUST be a string. Never pass an object.`)
    });
    if (schema) {
        inputSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            memory: schema instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodObject"] ? schema : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertSchemaToZod"])({
                jsonSchema: schema
            }).describe(`The JSON formatted working memory content to store.`)
        });
    }
    const usesMergeSemantics = Boolean(schema);
    const description = schema ? `Update the working memory with new information. Data is merged with existing memory - you only need to include fields you want to add or update. Set a field to null to remove it. Arrays are replaced entirely when provided.` : `Update the working memory with new information. Any data not included will be overwritten. Always pass data as string to the memory field. Never pass an object.`;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTool"])({
        id: "update-working-memory",
        description,
        inputSchema,
        execute: async (inputData, context)=>{
            const threadId = context?.agent?.threadId;
            const resourceId = context?.agent?.resourceId;
            const memory = context?.memory;
            if (!threadId || !memory || !resourceId) {
                throw new Error("Thread ID, Memory instance, and resourceId are required for working memory updates");
            }
            let thread = await memory.getThreadById({
                threadId
            });
            if (!thread) {
                thread = await memory.createThread({
                    threadId,
                    resourceId,
                    memoryConfig
                });
            }
            if (thread.resourceId && thread.resourceId !== resourceId) {
                throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
            }
            let workingMemory;
            if (usesMergeSemantics) {
                const existingRaw = await memory.getWorkingMemory({
                    threadId,
                    resourceId,
                    memoryConfig
                });
                let existingData = null;
                if (existingRaw) {
                    try {
                        existingData = typeof existingRaw === "string" ? JSON.parse(existingRaw) : existingRaw;
                    } catch  {
                        existingData = null;
                    }
                }
                if (inputData.memory === void 0 || inputData.memory === null) {
                    return {
                        success: true,
                        message: "No memory data provided, existing memory unchanged."
                    };
                }
                let newData;
                if (typeof inputData.memory === "string") {
                    try {
                        newData = JSON.parse(inputData.memory);
                    } catch (parseError) {
                        const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
                        throw new Error(`Failed to parse working memory input as JSON: ${errorMessage}. Raw input: ${inputData.memory.length > 500 ? inputData.memory.slice(0, 500) + "..." : inputData.memory}`);
                    }
                } else {
                    newData = inputData.memory;
                }
                const mergedData = deepMergeWorkingMemory(existingData, newData);
                workingMemory = JSON.stringify(mergedData);
            } else {
                workingMemory = typeof inputData.memory === "string" ? inputData.memory : JSON.stringify(inputData.memory);
            }
            await memory.updateWorkingMemory({
                threadId,
                resourceId,
                workingMemory,
                memoryConfig
            });
            return {
                success: true
            };
        }
    });
};
var __experimental_updateWorkingMemoryToolVNext = (config)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$N3PAHTKU$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTool"])({
        id: "update-working-memory",
        description: "Update the working memory with new information.",
        inputSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            newMemory: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().describe(`The ${config.workingMemory?.schema ? "JSON" : "Markdown"} formatted working memory content to store`),
            searchString: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().describe("The working memory string to find. Will be replaced with the newMemory string. If this is omitted or doesn't exist, the newMemory string will be appended to the end of your working memory. Replacing single lines at a time is encouraged for greater accuracy. If updateReason is not 'append-new-memory', this search string must be provided or the tool call will be rejected."),
            updateReason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "append-new-memory",
                "clarify-existing-memory",
                "replace-irrelevant-memory"
            ]).optional().describe("The reason you're updating working memory. Passing any value other than 'append-new-memory' requires a searchString to be provided. Defaults to append-new-memory")
        }),
        execute: async (inputData, context)=>{
            const threadId = context?.agent?.threadId;
            const resourceId = context?.agent?.resourceId;
            const memory = context?.memory;
            if (!threadId || !memory || !resourceId) {
                throw new Error("Thread ID, Memory instance, and resourceId are required for working memory updates");
            }
            let thread = await memory.getThreadById({
                threadId
            });
            if (!thread) {
                thread = await memory.createThread({
                    threadId,
                    resourceId,
                    memoryConfig: config
                });
            }
            if (thread.resourceId && thread.resourceId !== resourceId) {
                throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
            }
            const workingMemory = inputData.newMemory || "";
            if (!inputData.updateReason) inputData.updateReason = `append-new-memory`;
            if (inputData.searchString && config.workingMemory?.scope === `resource` && inputData.updateReason === `replace-irrelevant-memory`) {
                inputData.searchString = void 0;
            }
            if (inputData.updateReason === `append-new-memory` && inputData.searchString) {
                inputData.searchString = void 0;
            }
            if (inputData.updateReason !== `append-new-memory` && !inputData.searchString) {
                return {
                    success: false,
                    reason: `updateReason was ${inputData.updateReason} but no searchString was provided. Unable to replace undefined with "${inputData.newMemory}"`
                };
            }
            const result = await memory.__experimental_updateWorkingMemoryVNext({
                threadId,
                resourceId,
                workingMemory,
                searchString: inputData.searchString,
                memoryConfig: config
            });
            if (result) {
                return result;
            }
            return {
                success: true
            };
        }
    });
};
var CHARS_PER_TOKEN = 4;
var DEFAULT_MESSAGE_RANGE = {
    before: 1,
    after: 1
};
var DEFAULT_TOP_K = 4;
var isZodObject = (v)=>v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodObject"];
var Memory = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MastraMemory"] {
    constructor(config = {}){
        super({
            name: "Memory",
            ...config
        });
        const mergedConfig = this.getMergedThreadConfig({
            workingMemory: config.options?.workingMemory || {
                // these defaults are now set inside @mastra/core/memory in getMergedThreadConfig.
                // In a future release we can remove it from this block - for now if we remove it
                // and someone bumps @mastra/memory without bumping @mastra/core the defaults wouldn't exist yet
                enabled: false,
                template: this.defaultWorkingMemoryTemplate
            }
        });
        this.threadConfig = mergedConfig;
    }
    /**
   * Gets the memory storage domain, throwing if not available.
   */ async getMemoryStore() {
        const store = await this.storage.getStore("memory");
        if (!store) {
            throw new Error(`Memory storage domain is not available on ${this.storage.constructor.name}`);
        }
        return store;
    }
    async validateThreadIsOwnedByResource(threadId, resourceId, config) {
        const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
        const thread = await this.getThreadById({
            threadId
        });
        if (!thread && !resourceScope) {
            throw new Error(`No thread found with id ${threadId}`);
        }
        if (thread && thread.resourceId !== resourceId) {
            throw new Error(`Thread with id ${threadId} is for resource with id ${thread.resourceId} but resource ${resourceId} was queried.`);
        }
    }
    async recall(args) {
        const { threadId, resourceId, perPage: perPageArg, page, orderBy, threadConfig, vectorSearchString, filter: filter3 } = args;
        const config = this.getMergedThreadConfig(threadConfig || {});
        if (resourceId) await this.validateThreadIsOwnedByResource(threadId, resourceId, config);
        const perPage = perPageArg !== void 0 ? perPageArg : config.lastMessages;
        const shouldGetNewestAndReverse = !orderBy && perPage !== false;
        const effectiveOrderBy = shouldGetNewestAndReverse ? {
            field: "createdAt",
            direction: "DESC"
        } : orderBy;
        const vectorResults = [];
        this.logger.debug(`Memory recall() with:`, {
            threadId,
            perPage,
            page,
            orderBy: effectiveOrderBy,
            hasWorkingMemorySchema: Boolean(config.workingMemory?.schema),
            workingMemoryEnabled: config.workingMemory?.enabled,
            semanticRecallEnabled: Boolean(config.semanticRecall)
        });
        const defaultRange = DEFAULT_MESSAGE_RANGE;
        const defaultTopK = DEFAULT_TOP_K;
        const vectorConfig = typeof config?.semanticRecall === `boolean` ? {
            topK: defaultTopK,
            messageRange: defaultRange
        } : {
            topK: config?.semanticRecall?.topK ?? defaultTopK,
            messageRange: config?.semanticRecall?.messageRange ?? defaultRange
        };
        const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
        if (resourceScope && !resourceId && config?.semanticRecall && vectorSearchString) {
            throw new Error(`Memory error: Resource-scoped semantic recall is enabled but no resourceId was provided. Either provide a resourceId or explicitly set semanticRecall.scope to 'thread'.`);
        }
        if (config?.semanticRecall && vectorSearchString && this.vector) {
            const { embeddings, dimension } = await this.embedMessageContent(vectorSearchString);
            const { indexName } = await this.createEmbeddingIndex(dimension, config);
            await Promise.all(embeddings.map(async (embedding)=>{
                if (typeof this.vector === `undefined`) {
                    throw new Error(`Tried to query vector index ${indexName} but this Memory instance doesn't have an attached vector db.`);
                }
                vectorResults.push(...await this.vector.query({
                    indexName,
                    queryVector: embedding,
                    topK: vectorConfig.topK,
                    filter: resourceScope ? {
                        resource_id: resourceId
                    } : {
                        thread_id: threadId
                    }
                }));
            }));
        }
        const memoryStore = await this.getMemoryStore();
        const paginatedResult = await memoryStore.listMessages({
            threadId,
            resourceId,
            perPage,
            page,
            orderBy: effectiveOrderBy,
            filter: filter3,
            ...vectorResults?.length ? {
                include: vectorResults.map((r)=>({
                        id: r.metadata?.message_id,
                        threadId: r.metadata?.thread_id,
                        withNextMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.after,
                        withPreviousMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.before
                    }))
            } : {}
        });
        const rawMessages = shouldGetNewestAndReverse ? paginatedResult.messages.reverse() : paginatedResult.messages;
        const list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]({
            threadId,
            resourceId
        }).add(rawMessages, "memory");
        const messages = list.get.all.db();
        return {
            messages
        };
    }
    async getThreadById({ threadId }) {
        const memoryStore = await this.getMemoryStore();
        return memoryStore.getThreadById({
            threadId
        });
    }
    async listThreadsByResourceId(args) {
        const memoryStore = await this.getMemoryStore();
        return memoryStore.listThreadsByResourceId(args);
    }
    async handleWorkingMemoryFromMetadata({ workingMemory, resourceId, memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig || {});
        if (config.workingMemory?.enabled) {
            const scope = config.workingMemory.scope || "resource";
            if (scope === "resource" && resourceId) {
                const memoryStore = await this.getMemoryStore();
                await memoryStore.updateResource({
                    resourceId,
                    workingMemory
                });
            }
        }
    }
    async saveThread({ thread, memoryConfig }) {
        const memoryStore = await this.getMemoryStore();
        const savedThread = await memoryStore.saveThread({
            thread
        });
        if (thread.metadata?.workingMemory && typeof thread.metadata.workingMemory === "string" && thread.resourceId) {
            await this.handleWorkingMemoryFromMetadata({
                workingMemory: thread.metadata.workingMemory,
                resourceId: thread.resourceId,
                memoryConfig
            });
        }
        return savedThread;
    }
    async updateThread({ id, title, metadata, memoryConfig }) {
        const memoryStore = await this.getMemoryStore();
        const updatedThread = await memoryStore.updateThread({
            id,
            title,
            metadata
        });
        if (metadata?.workingMemory && typeof metadata.workingMemory === "string" && updatedThread.resourceId) {
            await this.handleWorkingMemoryFromMetadata({
                workingMemory: metadata.workingMemory,
                resourceId: updatedThread.resourceId,
                memoryConfig
            });
        }
        return updatedThread;
    }
    async deleteThread(threadId) {
        const memoryStore = await this.getMemoryStore();
        await memoryStore.deleteThread({
            threadId
        });
    }
    async updateWorkingMemory({ threadId, resourceId, workingMemory, memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig || {});
        if (!config.workingMemory?.enabled) {
            throw new Error("Working memory is not enabled for this memory instance");
        }
        const scope = config.workingMemory.scope || "resource";
        if (scope === "resource" && !resourceId) {
            throw new Error(`Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`);
        }
        const memoryStore = await this.getMemoryStore();
        if (scope === "resource" && resourceId) {
            await memoryStore.updateResource({
                resourceId,
                workingMemory
            });
        } else {
            const thread = await this.getThreadById({
                threadId
            });
            if (!thread) {
                throw new Error(`Thread ${threadId} not found`);
            }
            await memoryStore.updateThread({
                id: threadId,
                title: thread.title || "Untitled Thread",
                metadata: {
                    ...thread.metadata,
                    workingMemory
                }
            });
        }
    }
    updateWorkingMemoryMutexes = /* @__PURE__ */ new Map();
    /**
   * @warning experimental! can be removed or changed at any time
   */ async __experimental_updateWorkingMemoryVNext({ threadId, resourceId, workingMemory, searchString, memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig || {});
        if (!config.workingMemory?.enabled) {
            throw new Error("Working memory is not enabled for this memory instance");
        }
        const mutexKey = memoryConfig?.workingMemory?.scope === `resource` ? `resource-${resourceId}` : `thread-${threadId}`;
        const mutex = this.updateWorkingMemoryMutexes.has(mutexKey) ? this.updateWorkingMemoryMutexes.get(mutexKey) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$mutex$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mutex"]();
        this.updateWorkingMemoryMutexes.set(mutexKey, mutex);
        const release = await mutex.acquire();
        try {
            const existingWorkingMemory = await this.getWorkingMemory({
                threadId,
                resourceId,
                memoryConfig
            }) || "";
            const template = await this.getWorkingMemoryTemplate({
                memoryConfig
            });
            let reason = "";
            if (existingWorkingMemory) {
                if (searchString && existingWorkingMemory?.includes(searchString)) {
                    workingMemory = existingWorkingMemory.replace(searchString, workingMemory);
                    reason = `found and replaced searchString with newMemory`;
                } else if (existingWorkingMemory.includes(workingMemory) || template?.content?.trim() === workingMemory.trim()) {
                    return {
                        success: false,
                        reason: `attempted to insert duplicate data into working memory. this entry was skipped`
                    };
                } else {
                    if (searchString) {
                        reason = `attempted to replace working memory string that doesn't exist. Appending to working memory instead.`;
                    } else {
                        reason = `appended newMemory to end of working memory`;
                    }
                    workingMemory = existingWorkingMemory + `
${workingMemory}`;
                }
            } else if (workingMemory === template?.content) {
                return {
                    success: false,
                    reason: `try again when you have data to add. newMemory was equal to the working memory template`
                };
            } else {
                reason = `started new working memory`;
            }
            workingMemory = template?.content ? workingMemory.replaceAll(template?.content, "") : workingMemory;
            const scope = config.workingMemory.scope || "resource";
            if (scope === "resource" && !resourceId) {
                throw new Error(`Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`);
            }
            const memoryStore = await this.getMemoryStore();
            if (scope === "resource" && resourceId) {
                await memoryStore.updateResource({
                    resourceId,
                    workingMemory
                });
                if (reason) {
                    return {
                        success: true,
                        reason
                    };
                }
            } else {
                const thread = await this.getThreadById({
                    threadId
                });
                if (!thread) {
                    throw new Error(`Thread ${threadId} not found`);
                }
                await memoryStore.updateThread({
                    id: threadId,
                    title: thread.title || "Untitled Thread",
                    metadata: {
                        ...thread.metadata,
                        workingMemory
                    }
                });
            }
            return {
                success: true,
                reason
            };
        } catch (e) {
            this.logger.error(e instanceof Error ? e.stack || e.message : JSON.stringify(e));
            return {
                success: false,
                reason: "Tool error."
            };
        } finally{
            release();
        }
    }
    chunkText(text4, tokenSize = 4096) {
        const charSize = tokenSize * CHARS_PER_TOKEN;
        const chunks = [];
        let currentChunk = "";
        const words = text4.split(/\s+/);
        for (const word of words){
            const wordWithSpace = currentChunk ? " " + word : word;
            if (currentChunk.length + wordWithSpace.length > charSize) {
                chunks.push(currentChunk);
                currentChunk = word;
            } else {
                currentChunk += wordWithSpace;
            }
        }
        if (currentChunk) {
            chunks.push(currentChunk);
        }
        return chunks;
    }
    hasher = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xxhash$2d$wasm$2f$esm$2f$xxhash$2d$wasm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])();
    // embedding is computationally expensive so cache content -> embeddings/chunks
    embeddingCache = /* @__PURE__ */ new Map();
    firstEmbed;
    async embedMessageContent(content) {
        const key = (await this.hasher).h32(content);
        const cached = this.embeddingCache.get(key);
        if (cached) return cached;
        const chunks = this.chunkText(content);
        if (typeof this.embedder === `undefined`) {
            throw new Error(`Tried to embed message content but this Memory instance doesn't have an attached embedder.`);
        }
        const isFastEmbed = this.embedder.provider === `fastembed`;
        if (isFastEmbed && this.firstEmbed instanceof Promise) {
            await this.firstEmbed;
        }
        let embedFn;
        const specVersion = this.embedder.specificationVersion;
        switch(specVersion){
            case "v3":
                embedFn = embedMany3;
                break;
            case "v2":
                embedFn = embedMany2;
                break;
            default:
                embedFn = embedMany;
                break;
        }
        const promise = embedFn({
            values: chunks,
            maxRetries: 3,
            // @ts-ignore
            model: this.embedder,
            ...this.embedderOptions || {}
        });
        if (isFastEmbed && !this.firstEmbed) this.firstEmbed = promise;
        const { embeddings } = await promise;
        const result = {
            embeddings,
            chunks,
            dimension: embeddings[0]?.length
        };
        this.embeddingCache.set(key, result);
        return result;
    }
    async saveMessages({ messages, memoryConfig }) {
        const updatedMessages = messages.map((m)=>{
            return this.updateMessageToHideWorkingMemoryV2(m);
        }).filter((m)=>Boolean(m));
        const config = this.getMergedThreadConfig(memoryConfig);
        const dbMessages = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$PSIJ6OSV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MessageList"]({
            generateMessageId: ()=>this.generateId()
        }).add(updatedMessages, "memory").get.all.db();
        const memoryStore = await this.getMemoryStore();
        const result = await memoryStore.saveMessages({
            messages: dbMessages
        });
        if (this.vector && config.semanticRecall) {
            const embeddingData = [];
            let dimension;
            await Promise.all(updatedMessages.map(async (message)=>{
                let textForEmbedding = null;
                if (message.content.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
                    textForEmbedding = message.content.content;
                } else if (message.content.parts && message.content.parts.length > 0) {
                    const joined = message.content.parts.filter((part)=>part.type === "text").map((part)=>part.text).join(" ").trim();
                    if (joined) textForEmbedding = joined;
                }
                if (!textForEmbedding) return;
                const result2 = await this.embedMessageContent(textForEmbedding);
                dimension = result2.dimension;
                embeddingData.push({
                    embeddings: result2.embeddings,
                    metadata: result2.chunks.map(()=>({
                            message_id: message.id,
                            thread_id: message.threadId,
                            resource_id: message.resourceId
                        }))
                });
            }));
            if (embeddingData.length > 0 && dimension !== void 0) {
                if (typeof this.vector === `undefined`) {
                    throw new Error(`Tried to upsert embeddings but this Memory instance doesn't have an attached vector db.`);
                }
                const { indexName } = await this.createEmbeddingIndex(dimension, config);
                const allVectors = [];
                const allMetadata = [];
                for (const data of embeddingData){
                    allVectors.push(...data.embeddings);
                    allMetadata.push(...data.metadata);
                }
                await this.vector.upsert({
                    indexName,
                    vectors: allVectors,
                    metadata: allMetadata
                });
            }
        }
        return result;
    }
    updateMessageToHideWorkingMemoryV2(message) {
        const newMessage = {
            ...message
        };
        if (message.content && typeof message.content === "object" && !Array.isArray(message.content)) {
            newMessage.content = {
                ...message.content
            };
        }
        if (typeof newMessage.content?.content === "string" && newMessage.content.content.length > 0) {
            newMessage.content.content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["removeWorkingMemoryTags"])(newMessage.content.content).trim();
        }
        if (Array.isArray(newMessage.content?.parts)) {
            newMessage.content.parts = newMessage.content.parts.filter((part)=>{
                if (part?.type === "tool-invocation") {
                    return part.toolInvocation?.toolName !== "updateWorkingMemory";
                }
                return true;
            }).map((part)=>{
                if (part?.type === "text") {
                    const text4 = typeof part.text === "string" ? part.text : "";
                    return {
                        ...part,
                        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["removeWorkingMemoryTags"])(text4).trim()
                    };
                }
                return part;
            });
            if (newMessage.content.parts.length === 0) {
                return null;
            }
        }
        return newMessage;
    }
    parseWorkingMemory(text4) {
        if (!this.threadConfig.workingMemory?.enabled) return null;
        const content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$5A5RM7PH$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractWorkingMemoryContent"])(text4);
        return content?.trim() ?? null;
    }
    async getWorkingMemory({ threadId, resourceId, memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig || {});
        if (!config.workingMemory?.enabled) {
            return null;
        }
        const scope = config.workingMemory.scope || "resource";
        let workingMemoryData = null;
        if (scope === "resource" && !resourceId) {
            throw new Error(`Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`);
        }
        if (scope === "resource" && resourceId) {
            const memoryStore = await this.getMemoryStore();
            const resource = await memoryStore.getResourceById({
                resourceId
            });
            workingMemoryData = resource?.workingMemory || null;
        } else {
            const thread = await this.getThreadById({
                threadId
            });
            workingMemoryData = thread?.metadata?.workingMemory;
        }
        if (!workingMemoryData) {
            return null;
        }
        return workingMemoryData;
    }
    /**
   * Gets the working memory template for the current memory configuration.
   * Supports both ZodObject and JSONSchema7 schemas.
   *
   * @param memoryConfig - The memory configuration containing the working memory settings
   * @returns The working memory template with format and content, or null if working memory is disabled
   */ async getWorkingMemoryTemplate({ memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig);
        if (!config.workingMemory?.enabled) {
            return null;
        }
        if (config.workingMemory?.schema) {
            try {
                const schema = config.workingMemory.schema;
                let convertedSchema;
                if (isZodObject(schema)) {
                    convertedSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$schema$2d$compat$2f$dist$2f$chunk$2d$3RG3ZAXL$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(schema);
                } else {
                    convertedSchema = schema;
                }
                return {
                    format: "json",
                    content: JSON.stringify(convertedSchema)
                };
            } catch (error) {
                this.logger.error("Error converting schema", error);
                throw error;
            }
        }
        const memory = config.workingMemory.template || this.defaultWorkingMemoryTemplate;
        return {
            format: "markdown",
            content: memory.trim()
        };
    }
    async getSystemMessage({ threadId, resourceId, memoryConfig }) {
        const config = this.getMergedThreadConfig(memoryConfig);
        if (!config.workingMemory?.enabled) {
            return null;
        }
        const workingMemoryTemplate = await this.getWorkingMemoryTemplate({
            memoryConfig
        });
        const workingMemoryData = await this.getWorkingMemory({
            threadId,
            resourceId,
            memoryConfig: config
        });
        if (!workingMemoryTemplate) {
            return null;
        }
        return this.isVNextWorkingMemoryConfig(memoryConfig) ? this.__experimental_getWorkingMemoryToolInstructionVNext({
            template: workingMemoryTemplate,
            data: workingMemoryData
        }) : this.getWorkingMemoryToolInstruction({
            template: workingMemoryTemplate,
            data: workingMemoryData
        });
    }
    defaultWorkingMemoryTemplate = `
# User Information
- **First Name**: 
- **Last Name**: 
- **Location**: 
- **Occupation**: 
- **Interests**: 
- **Goals**: 
- **Events**: 
- **Facts**: 
- **Projects**: 
`;
    getWorkingMemoryToolInstruction({ template, data }) {
        const emptyWorkingMemoryTemplateObject = template.format === "json" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mastra$2f$core$2f$dist$2f$chunk$2d$MCVLH3QV$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateEmptyFromSchema"])(template.content) : null;
        const hasEmptyWorkingMemoryTemplateObject = emptyWorkingMemoryTemplateObject && Object.keys(emptyWorkingMemoryTemplateObject).length > 0;
        return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool. If information might be referenced again - store it!

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
${template.format !== "json" ? `5. IMPORTANT: When calling updateWorkingMemory, the only valid parameter is the memory field. DO NOT pass an object.
6. IMPORTANT: ALWAYS pass the data you want to store in the memory field as a string. DO NOT pass an object.
7. IMPORTANT: Data must only be sent as a string no matter which format is used.` : ""}


${template.format !== "json" ? `<working_memory_template>
${template.content}
</working_memory_template>` : ""}

${hasEmptyWorkingMemoryTemplateObject ? "When working with json data, the object format below represents the template:" : ""}
${hasEmptyWorkingMemoryTemplateObject ? JSON.stringify(emptyWorkingMemoryTemplateObject) : ""}

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- Do not remove empty sections - you must include the empty sections along with the ones you're filling in
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the entire ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it.
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.`;
    }
    __experimental_getWorkingMemoryToolInstructionVNext({ template, data }) {
        return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool.

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
5. If your memory has not changed, you do not need to call the updateWorkingMemory tool. By default it will persist and be available for you in future interactions
6. Information not being relevant to the current conversation is not a valid reason to replace or remove working memory information. Your working memory spans across multiple conversations and may be needed again later, even if it's not currently relevant.

<working_memory_template>
${template.content}
</working_memory_template>

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
${template.content !== this.defaultWorkingMemoryTemplate ? `- Only store information if it's in the working memory template, do not store other information unless the user asks you to remember it, as that non-template information may be irrelevant` : `- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
`}
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it. 
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information if that information is not already stored.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.
`;
    }
    isVNextWorkingMemoryConfig(config) {
        if (!config?.workingMemory) return false;
        const isMDWorkingMemory = !(`schema` in config.workingMemory) && (typeof config.workingMemory.template === `string` || config.workingMemory.template) && config.workingMemory;
        return Boolean(isMDWorkingMemory && isMDWorkingMemory.version === `vnext`);
    }
    listTools(config) {
        const mergedConfig = this.getMergedThreadConfig(config);
        if (mergedConfig.workingMemory?.enabled) {
            return {
                updateWorkingMemory: this.isVNextWorkingMemoryConfig(mergedConfig) ? // use the new experimental tool
                __experimental_updateWorkingMemoryToolVNext(mergedConfig) : updateWorkingMemoryTool(mergedConfig)
            };
        }
        return {};
    }
    /**
   * Updates a list of messages and syncs the vector database for semantic recall.
   * When message content is updated, the corresponding vector embeddings are also updated
   * to ensure semantic recall stays in sync with the message content.
   *
   * @param messages - The list of messages to update (must include id, can include partial content)
   * @param memoryConfig - Optional memory configuration to determine if semantic recall is enabled
   * @returns The list of updated messages
   */ async updateMessages({ messages, memoryConfig }) {
        if (messages.length === 0) return [];
        const memoryStore = await this.getMemoryStore();
        const config = this.getMergedThreadConfig(memoryConfig);
        if (this.vector && config.semanticRecall) {
            const messagesWithContent = messages.filter((m)=>m.content !== void 0);
            if (messagesWithContent.length > 0) {
                const existingMessagesResult = await memoryStore.listMessagesById({
                    messageIds: messagesWithContent.map((m)=>m.id)
                });
                const existingMessagesMap = new Map(existingMessagesResult.messages.map((m)=>[
                        m.id,
                        m
                    ]));
                const embeddingData = [];
                let dimension;
                const messageIdsWithNewEmbeddings = /* @__PURE__ */ new Set();
                const messageIdsWithClearedContent = /* @__PURE__ */ new Set();
                await Promise.all(messagesWithContent.map(async (message)=>{
                    const existingMessage = existingMessagesMap.get(message.id);
                    if (!existingMessage) return;
                    let textForEmbedding = null;
                    const content = message.content;
                    if (content) {
                        if ("content" in content && content.content && typeof content.content === "string" && content.content.trim() !== "") {
                            textForEmbedding = content.content;
                        } else if ("parts" in content && content.parts && Array.isArray(content.parts) && content.parts.length > 0) {
                            const joined = content.parts.filter((part)=>part?.type === "text").map((part)=>part.text).join(" ").trim();
                            if (joined) textForEmbedding = joined;
                        }
                    }
                    if (textForEmbedding) {
                        const result = await this.embedMessageContent(textForEmbedding);
                        dimension = result.dimension;
                        embeddingData.push({
                            embeddings: result.embeddings,
                            metadata: result.chunks.map(()=>({
                                    message_id: message.id,
                                    thread_id: existingMessage.threadId,
                                    resource_id: existingMessage.resourceId
                                }))
                        });
                        messageIdsWithNewEmbeddings.add(message.id);
                    } else {
                        messageIdsWithClearedContent.add(message.id);
                    }
                }));
                const messageIdsNeedingDeletion = /* @__PURE__ */ new Set([
                    ...messageIdsWithClearedContent,
                    ...messageIdsWithNewEmbeddings
                ]);
                if (messageIdsNeedingDeletion.size > 0) {
                    try {
                        const indexes = await this.vector.listIndexes();
                        const memoryIndexes = indexes.filter((name21)=>name21.startsWith("memory_messages"));
                        for (const indexName of memoryIndexes){
                            for (const messageId of messageIdsNeedingDeletion){
                                try {
                                    await this.vector.deleteVectors({
                                        indexName,
                                        filter: {
                                            message_id: messageId
                                        }
                                    });
                                } catch  {
                                    this.logger.debug(`No existing vectors found for message ${messageId} in ${indexName}, skipping delete`);
                                }
                            }
                        }
                    } catch  {
                        this.logger.debug(`No memory indexes found to delete from`);
                    }
                }
                if (embeddingData.length > 0 && dimension !== void 0) {
                    const { indexName } = await this.createEmbeddingIndex(dimension, config);
                    const allVectors = [];
                    const allMetadata = [];
                    for (const data of embeddingData){
                        allVectors.push(...data.embeddings);
                        allMetadata.push(...data.metadata);
                    }
                    await this.vector.upsert({
                        indexName,
                        vectors: allVectors,
                        metadata: allMetadata
                    });
                }
            }
        }
        return memoryStore.updateMessages({
            messages
        });
    }
    /**
   * Deletes one or more messages
   * @param input - Must be an array containing either:
   *   - Message ID strings
   *   - Message objects with 'id' properties
   * @returns Promise that resolves when all messages are deleted
   */ async deleteMessages(input) {
        let messageIds;
        if (!Array.isArray(input)) {
            throw new Error("Invalid input: must be an array of message IDs or message objects");
        }
        if (input.length === 0) {
            return;
        }
        messageIds = input.map((item)=>{
            if (typeof item === "string") {
                return item;
            } else if (item && typeof item === "object" && "id" in item) {
                return item.id;
            } else {
                throw new Error("Invalid input: array items must be strings or objects with an id property");
            }
        });
        const invalidIds = messageIds.filter((id)=>!id || typeof id !== "string");
        if (invalidIds.length > 0) {
            throw new Error("All message IDs must be non-empty strings");
        }
        const memoryStore = await this.getMemoryStore();
        await memoryStore.deleteMessages(messageIds);
    }
    /**
   * Clone a thread and its messages to create a new independent thread.
   * The cloned thread will have metadata tracking its source.
   *
   * If semantic recall is enabled, the cloned messages will also be embedded
   * and added to the vector store for semantic search.
   *
   * @param args - Clone configuration options
   * @param args.sourceThreadId - ID of the thread to clone
   * @param args.newThreadId - ID for the new cloned thread (if not provided, a random UUID will be generated)
   * @param args.resourceId - Resource ID for the new thread (defaults to source thread's resourceId)
   * @param args.title - Title for the new cloned thread
   * @param args.metadata - Additional metadata to merge with clone metadata
   * @param args.options - Options for filtering which messages to include
   * @param args.options.messageLimit - Maximum number of messages to copy (from most recent)
   * @param args.options.messageFilter - Filter messages by date range or specific IDs
   * @param memoryConfig - Optional memory configuration override
   * @returns The newly created thread and the cloned messages
   *
   * @example
   * ```typescript
   * // Clone entire thread
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   * });
   *
   * // Clone with custom ID
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   newThreadId: 'my-custom-thread-id',
   * });
   *
   * // Clone with message limit
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   title: 'My cloned conversation',
   *   options: {
   *     messageLimit: 10, // Only clone last 10 messages
   *   },
   * });
   *
   * // Clone with date filter
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   options: {
   *     messageFilter: {
   *       startDate: new Date('2024-01-01'),
   *       endDate: new Date('2024-06-01'),
   *     },
   *   },
   * });
   * ```
   */ async cloneThread(args, memoryConfig) {
        const memoryStore = await this.getMemoryStore();
        const result = await memoryStore.cloneThread(args);
        const config = this.getMergedThreadConfig(memoryConfig);
        if (this.vector && config.semanticRecall && result.clonedMessages.length > 0) {
            await this.embedClonedMessages(result.clonedMessages, config);
        }
        return result;
    }
    /**
   * Embed cloned messages for semantic recall.
   * This is similar to the embedding logic in saveMessages but operates on already-saved messages.
   */ async embedClonedMessages(messages, config) {
        if (!this.vector || !this.embedder) {
            return;
        }
        const embeddingData = [];
        let dimension;
        await Promise.all(messages.map(async (message)=>{
            let textForEmbedding = null;
            if (message.content?.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
                textForEmbedding = message.content.content;
            } else if (message.content?.parts && message.content.parts.length > 0) {
                const joined = message.content.parts.filter((part)=>part.type === "text").map((part)=>part.text).join(" ").trim();
                if (joined) textForEmbedding = joined;
            }
            if (!textForEmbedding) return;
            const result = await this.embedMessageContent(textForEmbedding);
            dimension = result.dimension;
            embeddingData.push({
                embeddings: result.embeddings,
                metadata: result.chunks.map(()=>({
                        message_id: message.id,
                        thread_id: message.threadId,
                        resource_id: message.resourceId
                    }))
            });
        }));
        if (embeddingData.length > 0 && dimension !== void 0) {
            const { indexName } = await this.createEmbeddingIndex(dimension, config);
            const allVectors = [];
            const allMetadata = [];
            for (const data of embeddingData){
                allVectors.push(...data.embeddings);
                allMetadata.push(...data.metadata);
            }
            await this.vector.upsert({
                indexName,
                vectors: allVectors,
                metadata: allMetadata
            });
        }
    }
    /**
   * Get the clone metadata from a thread if it was cloned from another thread.
   *
   * @param thread - The thread to check
   * @returns The clone metadata if the thread is a clone, null otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * const cloneInfo = memory.getCloneMetadata(thread);
   * if (cloneInfo) {
   *   console.log(`This thread was cloned from ${cloneInfo.sourceThreadId}`);
   * }
   * ```
   */ getCloneMetadata(thread) {
        if (!thread?.metadata?.clone) {
            return null;
        }
        return thread.metadata.clone;
    }
    /**
   * Check if a thread is a clone of another thread.
   *
   * @param thread - The thread to check
   * @returns True if the thread is a clone, false otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * if (memory.isClone(thread)) {
   *   console.log('This is a cloned thread');
   * }
   * ```
   */ isClone(thread) {
        return this.getCloneMetadata(thread) !== null;
    }
    /**
   * Get the source thread that a cloned thread was created from.
   *
   * @param threadId - ID of the cloned thread
   * @returns The source thread if found, null if the thread is not a clone or source doesn't exist
   *
   * @example
   * ```typescript
   * const sourceThread = await memory.getSourceThread('cloned-thread-123');
   * if (sourceThread) {
   *   console.log(`Original thread: ${sourceThread.title}`);
   * }
   * ```
   */ async getSourceThread(threadId) {
        const thread = await this.getThreadById({
            threadId
        });
        const cloneMetadata = this.getCloneMetadata(thread);
        if (!cloneMetadata) {
            return null;
        }
        return this.getThreadById({
            threadId: cloneMetadata.sourceThreadId
        });
    }
    /**
   * List all threads that were cloned from a specific source thread.
   *
   * @param sourceThreadId - ID of the source thread
   * @param resourceId - Optional resource ID to filter by
   * @returns Array of threads that are clones of the source thread
   *
   * @example
   * ```typescript
   * const clones = await memory.listClones('original-thread-123', 'user-456');
   * console.log(`Found ${clones.length} clones of this thread`);
   * ```
   */ async listClones(sourceThreadId, resourceId) {
        let targetResourceId = resourceId;
        if (!targetResourceId) {
            const sourceThread = await this.getThreadById({
                threadId: sourceThreadId
            });
            if (!sourceThread) {
                return [];
            }
            targetResourceId = sourceThread.resourceId;
        }
        const { threads } = await this.listThreadsByResourceId({
            resourceId: targetResourceId,
            perPage: false
        });
        return threads.filter((thread)=>{
            const cloneMetadata = this.getCloneMetadata(thread);
            return cloneMetadata?.sourceThreadId === sourceThreadId;
        });
    }
    /**
   * Get the clone history chain for a thread (all ancestors back to the original).
   *
   * @param threadId - ID of the thread to get history for
   * @returns Array of threads from oldest ancestor to the given thread (inclusive)
   *
   * @example
   * ```typescript
   * const history = await memory.getCloneHistory('deeply-cloned-thread');
   * // Returns: [originalThread, firstClone, secondClone, deeplyClonedThread]
   * ```
   */ async getCloneHistory(threadId) {
        const history = [];
        let currentThreadId = threadId;
        while(currentThreadId){
            const thread = await this.getThreadById({
                threadId: currentThreadId
            });
            if (!thread) {
                break;
            }
            history.unshift(thread);
            const cloneMetadata = this.getCloneMetadata(thread);
            currentThreadId = cloneMetadata?.sourceThreadId ?? null;
        }
        return history;
    }
};
;
 //# sourceMappingURL=index.js.map
 //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_%40mastra_memory_dist_1c9aadc2._.js.map