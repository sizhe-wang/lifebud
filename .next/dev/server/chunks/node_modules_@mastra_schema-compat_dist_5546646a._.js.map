{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/schema-compat/dist/json-to-zod.js","sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/json-to-zod.ts"],"sourcesContent":["import type { JsonSchema, JsonSchemaObject, Options, Refs } from 'json-schema-to-zod';\nimport jsonSchemaToZodOriginal, {\n  addJsdocs,\n  its,\n  parseAllOf,\n  parseAnyOf,\n  parseOneOf,\n  parseSchema,\n} from 'json-schema-to-zod';\n\nfunction parseObject(objectSchema: JsonSchemaObject & { type: 'object' }, refs: Refs): string {\n  let properties: string | undefined = undefined;\n\n  if (objectSchema.properties) {\n    if (!Object.keys(objectSchema.properties).length) {\n      properties = 'z.object({})';\n    } else {\n      properties = 'z.object({ ';\n\n      properties += Object.keys(objectSchema.properties)\n        .map(key => {\n          const propSchema = objectSchema.properties![key];\n\n          let result = `${JSON.stringify(key)}: ${parseSchema(propSchema!, {\n            ...refs,\n            path: [...refs.path, 'properties', key],\n          })}`;\n\n          if (refs.withJsdocs && typeof propSchema === 'object') {\n            result = addJsdocs(propSchema, result);\n          }\n\n          const hasDefault = typeof propSchema === 'object' && propSchema.default !== undefined;\n\n          const required = Array.isArray(objectSchema.required)\n            ? objectSchema.required.includes(key)\n            : typeof propSchema === 'object' && propSchema.required === true;\n\n          const optional = !hasDefault && !required;\n\n          return optional ? `${result}.optional()` : result;\n        })\n        .join(', ');\n\n      properties += ' })';\n    }\n  }\n\n  const additionalProperties =\n    objectSchema.additionalProperties !== undefined && objectSchema.additionalProperties !== false\n      ? parseSchema(objectSchema.additionalProperties, {\n          ...refs,\n          path: [...refs.path, 'additionalProperties'],\n        })\n      : undefined;\n\n  let patternProperties: string | undefined = undefined;\n\n  if (objectSchema.patternProperties) {\n    const parsedPatternProperties = Object.fromEntries(\n      Object.entries(objectSchema.patternProperties).map(([key, value]) => {\n        return [\n          key,\n          parseSchema(value, {\n            ...refs,\n            path: [...refs.path, 'patternProperties', key],\n          }),\n        ];\n      }, {}),\n    );\n\n    patternProperties = '';\n\n    if (properties) {\n      if (additionalProperties) {\n        patternProperties += `.catchall(z.union([${[\n          ...Object.values(parsedPatternProperties),\n          additionalProperties,\n        ].join(', ')}]))`;\n      } else if (Object.keys(parsedPatternProperties).length > 1) {\n        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(', ')}]))`;\n      } else {\n        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;\n      }\n    } else {\n      if (additionalProperties) {\n        patternProperties += `z.record(z.union([${[\n          ...Object.values(parsedPatternProperties),\n          additionalProperties,\n        ].join(', ')}]))`;\n      } else if (Object.keys(parsedPatternProperties).length > 1) {\n        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(', ')}]))`;\n      } else {\n        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;\n      }\n    }\n\n    patternProperties += '.superRefine((value, ctx) => {\\n';\n\n    patternProperties += 'for (const key in value) {\\n';\n\n    if (additionalProperties) {\n      if (objectSchema.properties) {\n        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties)\n          .map(key => JSON.stringify(key))\n          .join(', ')}].includes(key)\\n`;\n      } else {\n        patternProperties += `let evaluated = false\\n`;\n      }\n    }\n\n    for (const key in objectSchema.patternProperties) {\n      patternProperties += 'if (key.match(new RegExp(' + JSON.stringify(key) + '))) {\\n';\n      if (additionalProperties) {\n        patternProperties += 'evaluated = true\\n';\n      }\n      patternProperties += 'const result = ' + parsedPatternProperties[key] + '.safeParse(value[key])\\n';\n      patternProperties += 'if (!result.success) {\\n';\n\n      patternProperties += `ctx.addIssue({\n          path: [...ctx.path, key],\n          code: 'custom',\n          message: \\`Invalid input: Key matching regex /\\${key}/ must match schema\\`,\n          params: {\n            issues: result.error.issues\n          }\n        })\\n`;\n\n      patternProperties += '}\\n';\n      patternProperties += '}\\n';\n    }\n\n    if (additionalProperties) {\n      patternProperties += 'if (!evaluated) {\\n';\n      patternProperties += 'const result = ' + additionalProperties + '.safeParse(value[key])\\n';\n      patternProperties += 'if (!result.success) {\\n';\n\n      patternProperties += `ctx.addIssue({\n          path: [...ctx.path, key],\n          code: 'custom',\n          message: \\`Invalid input: must match catchall schema\\`,\n          params: {\n            issues: result.error.issues\n          }\n        })\\n`;\n\n      patternProperties += '}\\n';\n      patternProperties += '}\\n';\n    }\n    patternProperties += '}\\n';\n    patternProperties += '})';\n  }\n\n  let output = properties\n    ? patternProperties\n      ? properties + patternProperties\n      : additionalProperties\n        ? additionalProperties === 'z.never()'\n          ? properties + '.strict()'\n          : properties + `.catchall(${additionalProperties})`\n        : properties\n    : patternProperties\n      ? patternProperties\n      : additionalProperties\n        ? `z.record(${additionalProperties})`\n        : 'z.record(z.any())';\n\n  if (its.an.anyOf(objectSchema)) {\n    output += `.and(${parseAnyOf(\n      {\n        ...objectSchema,\n        anyOf: objectSchema.anyOf.map(x =>\n          typeof x === 'object' && !x.type && (x.properties || x.additionalProperties || x.patternProperties)\n            ? { ...x, type: 'object' }\n            : x,\n        ) as any,\n      },\n      refs,\n    )})`;\n  }\n\n  if (its.a.oneOf(objectSchema)) {\n    output += `.and(${parseOneOf(\n      {\n        ...objectSchema,\n        oneOf: objectSchema.oneOf.map(x =>\n          typeof x === 'object' && !x.type && (x.properties || x.additionalProperties || x.patternProperties)\n            ? { ...x, type: 'object' }\n            : x,\n        ) as any,\n      },\n      refs,\n    )})`;\n  }\n\n  if (its.an.allOf(objectSchema)) {\n    output += `.and(${parseAllOf(\n      {\n        ...objectSchema,\n        allOf: objectSchema.allOf.map(x =>\n          typeof x === 'object' && !x.type && (x.properties || x.additionalProperties || x.patternProperties)\n            ? { ...x, type: 'object' }\n            : x,\n        ) as any,\n      },\n      refs,\n    )})`;\n  }\n\n  return output;\n}\n\nconst parserOverride = (schema: JsonSchemaObject, refs: Refs) => {\n  let parsed = '';\n  let seen = refs.seen.get(schema);\n  if (its.an.anyOf(schema)) {\n    const allObjects = schema.anyOf.every(\n      item => typeof item === 'object' && its.an.object(item) && item.properties !== undefined,\n    );\n    if (schema.anyOf.length > 1 && allObjects) {\n      const propertiesWithConst: string[][] = schema.anyOf.reduce((acc, item) => {\n        if (typeof item === 'object' && its.an.object(item)) {\n          const propertyWithConst = Object.entries(item.properties ?? {}).filter(\n            ([_, value]) => typeof value === 'object' && (value as any)?.const !== undefined,\n          );\n          if (propertyWithConst?.length) {\n            const ppties = propertyWithConst.map(([key, _]) => key);\n            acc.push(ppties);\n          }\n        }\n        return acc;\n      }, [] as string[][]);\n\n      if (propertiesWithConst.length === schema.anyOf.length) {\n        if (seen) {\n          if (seen.r !== undefined) {\n            return seen.r;\n          }\n\n          if (refs.depth === undefined || seen.n >= refs.depth) {\n            return 'z.any()';\n          }\n\n          seen.n += 1;\n        } else {\n          seen = { r: undefined, n: 0 };\n          refs.seen.set(schema, seen);\n        }\n\n        const discriminators =\n          propertiesWithConst.length > 0 && propertiesWithConst[0]\n            ? propertiesWithConst.reduce((common, properties) => {\n                return common.filter(prop => properties.includes(prop));\n              }, propertiesWithConst[0])\n            : [];\n\n        if (discriminators.length > 0) {\n          const discriminator = discriminators[0];\n          if (discriminator) {\n            parsed = `z.discriminatedUnion(\"${discriminator}\", [${schema.anyOf\n              .map((schema, i) =>\n                parseSchema(schema, {\n                  ...refs,\n                  path: [...refs.path, 'anyOf', i],\n                }),\n              )\n              .join(', ')}])`;\n          }\n        }\n      }\n    }\n  } else if (its.an.object(schema)) {\n    if (seen) {\n      if (seen.r !== undefined) {\n        return seen.r;\n      }\n\n      if (refs.depth === undefined || seen.n >= refs.depth) {\n        return 'z.any()';\n      }\n\n      seen.n += 1;\n    } else {\n      seen = { r: undefined, n: 0 };\n      refs.seen.set(schema, seen);\n    }\n\n    parsed = parseObject(schema, refs);\n  }\n  if (parsed) {\n    if (!refs.withoutDescribes) {\n      parsed = addDescribes(schema, parsed);\n    }\n\n    if (!refs.withoutDefaults) {\n      parsed = addDefaults(schema, parsed);\n    }\n\n    parsed = addAnnotations(schema, parsed);\n\n    if (seen) {\n      seen.r = parsed;\n    }\n\n    return parsed;\n  }\n};\n\nconst addDescribes = (schema: JsonSchemaObject, parsed: string): string => {\n  if (schema.description) {\n    parsed += `.describe(${JSON.stringify(schema.description)})`;\n  }\n\n  return parsed;\n};\n\nconst addDefaults = (schema: JsonSchemaObject, parsed: string): string => {\n  if (schema.default !== undefined) {\n    parsed += `.default(${JSON.stringify(schema.default)})`;\n  }\n\n  return parsed;\n};\n\nconst addAnnotations = (schema: JsonSchemaObject, parsed: string): string => {\n  if (schema.readOnly) {\n    parsed += '.readonly()';\n  }\n\n  return parsed;\n};\n\nexport function jsonSchemaToZod(schema: JsonSchema, options: Options = {}): string {\n  const result = jsonSchemaToZodOriginal(schema, { ...options, parserOverride });\n\n  // Fix: The upstream json-schema-to-zod generates TypeScript syntax `reduce<z.ZodError[]>`\n  // in parseOneOf which fails when evaluated at runtime with Function().\n  // This catches any oneOf usage that bypasses our parserOverride (e.g., non-object contexts).\n  // See: https://github.com/mastra-ai/mastra/issues/11610\n  return result.replace(/\\.reduce<[^>]+>/g, '.reduce');\n}\n\n// Re-export all named exports from json-schema-to-zod (excluding the default export)\nexport * from 'json-schema-to-zod';\n"],"names":["schema","jsonSchemaToZodOriginal"],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/schema-compat/dist/chunk-3RG3ZAXL.js","sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/zod-to-json.ts"],"sourcesContent":["import type { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport type { ZodSchema as ZodSchemaV3 } from 'zod/v3';\nimport type { ZodType as ZodSchemaV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport zodToJsonSchemaOriginal from 'zod-to-json-schema';\n\n// Symbol to mark schemas as already patched (for idempotency)\nconst PATCHED = Symbol('__mastra_patched__');\n\n/**\n * Recursively patch Zod v4 record schemas that are missing valueType.\n * This fixes a bug in Zod v4 where z.record(valueSchema) doesn't set def.valueType.\n * The single-arg form should set valueType but instead only sets keyType.\n */\nfunction patchRecordSchemas(schema: any): any {\n  if (!schema || typeof schema !== 'object') return schema;\n\n  // Skip if already patched (idempotency check)\n  if ((schema as any)[PATCHED]) return schema;\n  (schema as any)[PATCHED] = true;\n\n  // Check the _zod.def location (v4 structure)\n  const def = schema._zod?.def;\n\n  // Fix record schemas with missing valueType\n  if (def?.type === 'record' && def.keyType && !def.valueType) {\n    // The bug: z.record(valueSchema) puts the value in keyType instead of valueType\n    // Fix: move it to valueType and set keyType to string (the default)\n    def.valueType = def.keyType;\n    def.keyType = (z as any).string();\n  }\n\n  // Recursively patch nested schemas\n  if (!def) return schema;\n\n  if (def.type === 'object' && def.shape) {\n    const shape = typeof def.shape === 'function' ? def.shape() : def.shape;\n    for (const key of Object.keys(shape)) {\n      patchRecordSchemas(shape[key]);\n    }\n  }\n\n  if (def.type === 'array' && def.element) {\n    patchRecordSchemas(def.element);\n  }\n\n  if (def.type === 'union' && def.options) {\n    def.options.forEach(patchRecordSchemas);\n  }\n\n  if (def.type === 'record') {\n    if (def.keyType) patchRecordSchemas(def.keyType);\n    if (def.valueType) patchRecordSchemas(def.valueType);\n  }\n\n  // Handle intersection types\n  if (def.type === 'intersection') {\n    if (def.left) patchRecordSchemas(def.left);\n    if (def.right) patchRecordSchemas(def.right);\n  }\n\n  // Handle lazy types - patch the schema returned by the getter\n  if (def.type === 'lazy') {\n    // For lazy schemas, we need to patch the schema when it's accessed\n    // Store the original getter and wrap it\n    if (def.getter && typeof def.getter === 'function') {\n      const originalGetter = def.getter;\n      def.getter = function () {\n        const innerSchema = originalGetter();\n        if (innerSchema) {\n          patchRecordSchemas(innerSchema);\n        }\n        return innerSchema;\n      };\n    }\n  }\n\n  // Handle wrapper types that have innerType\n  // This covers: optional, nullable, default, catch, nullish, and any other wrappers\n  if (def.innerType) {\n    patchRecordSchemas(def.innerType);\n  }\n\n  return schema;\n}\n\nexport function zodToJsonSchema(\n  zodSchema: ZodSchemaV3 | ZodSchemaV4,\n  target: Targets = 'jsonSchema7',\n  strategy: 'none' | 'seen' | 'root' | 'relative' = 'relative',\n): JSONSchema7 {\n  const fn = 'toJSONSchema';\n\n  if (fn in z) {\n    // Zod v4 path - patch record schemas before converting\n    patchRecordSchemas(zodSchema);\n\n    return (z as any)[fn](zodSchema, {\n      unrepresentable: 'any',\n      override: (ctx: any) => {\n        // Handle both Zod v4 structures: _def directly or nested in _zod\n        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;\n        // Check for date type using both possible property names\n        if (def && (def.typeName === 'ZodDate' || def.type === 'date')) {\n          ctx.jsonSchema.type = 'string';\n          ctx.jsonSchema.format = 'date-time';\n        }\n      },\n    }) satisfies JSONSchema7;\n  } else {\n    // Zod v3 path - use the original converter\n    return zodToJsonSchemaOriginal(zodSchema as ZodSchemaV3, {\n      $refStrategy: strategy,\n      target,\n    }) as JSONSchema7;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/schema-compat/dist/index.js","sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/secure-json-parse%402.7.0/node_modules/secure-json-parse/index.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider%401.1.3/node_modules/%40ai-sdk/provider/src/errors/ai-sdk-error.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider%401.1.3/node_modules/%40ai-sdk/provider/src/errors/get-error-message.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider%401.1.3/node_modules/%40ai-sdk/provider/src/errors/invalid-argument-error.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider%401.1.3/node_modules/%40ai-sdk/provider/src/errors/json-parse-error.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider%401.1.3/node_modules/%40ai-sdk/provider/src/errors/type-validation-error.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/nanoid%403.3.11/node_modules/nanoid/non-secure/index.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%402.2.8_zod%403.25.76/node_modules/%40ai-sdk/provider-utils/src/parse-json.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%402.2.8_zod%403.25.76/node_modules/%40ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%402.2.8_zod%403.25.76/node_modules/%40ai-sdk/provider-utils/src/generate-id.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%402.2.8_zod%403.25.76/node_modules/%40ai-sdk/provider-utils/src/validator.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bprovider-utils%402.2.8_zod%403.25.76/node_modules/%40ai-sdk/provider-utils/src/validate-types.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/Refs.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/errorMessages.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/any.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/array.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/date.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/default.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/map.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/never.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/null.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/union.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/number.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/object.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/set.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/parseDef.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/zod-to-json-schema%403.24.6_zod%403.25.76/node_modules/zod-to-json-schema/dist/esm/index.js","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bui-utils%401.2.11_zod%403.25.76/node_modules/%40ai-sdk/ui-utils/src/fix-json.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bui-utils%401.2.11_zod%403.25.76/node_modules/%40ai-sdk/ui-utils/src/parse-partial-json.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bui-utils%401.2.11_zod%403.25.76/node_modules/%40ai-sdk/ui-utils/src/data-stream-parts.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bui-utils%401.2.11_zod%403.25.76/node_modules/%40ai-sdk/ui-utils/src/zod-schema.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40ai-sdk%2Bui-utils%401.2.11_zod%403.25.76/node_modules/%40ai-sdk/ui-utils/src/schema.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/platform/node/globalThis.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/version.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/internal/semver.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/internal/global-utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/diag/ComponentLogger.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/diag/types.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/diag/internal/logLevelLogger.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/api/diag.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/context/context.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/context/NoopContextManager.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/api/context.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/trace_flags.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/invalid-span-constants.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/NonRecordingSpan.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/context-utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/spancontext-utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/NoopTracer.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/ProxyTracer.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/NoopTracerProvider.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/ProxyTracerProvider.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace/status.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/api/trace.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/%40opentelemetry%2Bapi%401.9.0/node_modules/%40opentelemetry/api/src/trace-api.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/util/prepare-response-headers.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/errors/no-object-generated-error.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/prompt/data-content.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/types/json-value.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/types/provider-metadata.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/prompt/tool-result-content.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/prompt/content-part.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/prompt/message.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-object/inject-json-instruction.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-object/generate-object.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-object/stream-object.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-text/generate-text.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-text/output.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/util/merge-streams.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/generate-text/stream-text.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/tool/mcp/types.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/core/tool/mcp/json-rpc-message.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/streams/langchain-adapter.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/streams/stream-callbacks.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/node_modules/.pnpm/ai%404.3.19_react%4019.2.3_zod%403.25.76/node_modules/ai/streams/llamaindex-adapter.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/schema-compatibility-v3.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/schema-compatibility-v4.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/schema-compatibility.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/zodTypes.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/anthropic.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/deepseek.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/google.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/meta.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/openai.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40mastra/schema-compat/src/provider-compats/openai-reasoning.ts"],"sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n","import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n","import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            /* c8 ignore next */\n            return ((_) => undefined)(typeName);\n    }\n};\n","import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./getRelativePath.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;\n","type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n","import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    // TODO v5 remove usage from finish event (only on step-finish)\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst redactedReasoningStreamPart: DataStreamPart<\n  'i',\n  'redacted_reasoning',\n  { data: string }\n> = {\n  code: 'i',\n  name: 'redacted_reasoning',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string'\n    ) {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.',\n      );\n    }\n    return { type: 'redacted_reasoning', value: { data: value.data } };\n  },\n};\n\nconst reasoningSignatureStreamPart: DataStreamPart<\n  'j',\n  'reasoning_signature',\n  { signature: string }\n> = {\n  code: 'j',\n  name: 'reasoning_signature',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('signature' in value) ||\n      typeof value.signature !== 'string'\n    ) {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.',\n      );\n    }\n    return {\n      type: 'reasoning_signature',\n      value: { signature: value.signature },\n    };\n  },\n};\n\nconst fileStreamPart: DataStreamPart<\n  'k',\n  'file',\n  {\n    data: string; // base64 encoded data\n    mimeType: string;\n  }\n> = {\n  code: 'k',\n  name: 'file',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string' ||\n      !('mimeType' in value) ||\n      typeof value.mimeType !== 'string'\n    ) {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.',\n      );\n    }\n    return { type: 'file', value: value as { data: string; mimeType: string } };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: useReferences ? 'root' : 'none',\n      target: 'jsonSchema7', // note: openai mode breaks various gemini conversions\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n","import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexport const _globalThis = typeof globalThis === 'object' ? globalThis : global;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n","export function prepareResponseHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const responseHeaders = new Headers(headers ?? {});\n\n  if (!responseHeaders.has('Content-Type')) {\n    responseHeaders.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    responseHeaders.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return responseHeaders;\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { LanguageModelResponseMetadata } from '../core/types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../core/types/usage';\nimport { FinishReason } from '../core';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n\nexport function verifyNoObjectGeneratedError(\n  error: unknown,\n  expected: {\n    message: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n) {\n  expect(NoObjectGeneratedError.isInstance(error)).toBeTruthy();\n  const noObjectGeneratedError = error as NoObjectGeneratedError;\n  expect(noObjectGeneratedError.message).toStrictEqual(expected.message);\n  expect(noObjectGeneratedError.response).toStrictEqual(expected.response);\n  expect(noObjectGeneratedError.usage).toStrictEqual(expected.usage);\n  expect(noObjectGeneratedError.finishReason).toStrictEqual(\n    expected.finishReason,\n  );\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n","import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\n/**\nAdditional provider-specific options.\n\nThey are passed through to the provider from the AI SDK and enable\nprovider-specific functionality that can be fully encapsulated in the provider.\n */\n// TODO change to LanguageModelV2ProviderOptions in language model v2\nexport type ProviderOptions = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n","import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n","import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nOptional filename of the file.\n   */\n  filename?: string;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mimeType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * Reasoning content part of a prompt. It contains a reasoning.\n */\nexport interface ReasoningPart {\n  type: 'reasoning';\n\n  /**\nThe reasoning text.\n   */\n  text: string;\n\n  /**\nAn optional signature for verifying that the reasoning originated from the model.\n   */\n  signature?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nRedacted reasoning content part of a prompt.\n */\nexport interface RedactedReasoningPart {\n  type: 'redacted-reasoning';\n\n  /**\nRedacted reasoning data.\n   */\n  data: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const redactedReasoningPartSchema: z.ZodType<RedactedReasoningPart> =\n  z.object({\n    type: z.literal('redacted-reasoning'),\n    data: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n","import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport {\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  ReasoningPart,\n  reasoningPartSchema,\n  RedactedReasoningPart,\n  redactedReasoningPartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          redactedReasoningPartSchema,\n          toolCallPartSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nContent of an assistant message.\nIt can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.\n */\nexport type AssistantContent =\n  | string\n  | Array<\n      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart\n    >;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n","import { JSONSchema7 } from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n\nShould return the repaired text or null if the text cannot be repaired.\n     */\nexport type RepairTextFunction = (options: {\n  text: string;\n  error: JSONParseError | TypeValidationError;\n}) => Promise<string | null>;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_repairText?: RepairTextFunction;\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    providerOptions?: ProviderOptions;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse:\n        | { headers?: Record<string, string>; body?: unknown }\n        | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                    ? system\n                    : injectJsonInstruction({\n                        prompt: system,\n                        schema: outputStrategy.jsonSchema,\n                      }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message:\n                      'No object generated: the model did not return a response.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n                      'ai.response.providerMetadata': JSON.stringify(\n                        result.providerMetadata,\n                      ),\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message: 'No object generated: the tool was not called.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n                      'ai.response.providerMetadata': JSON.stringify(\n                        result.providerMetadata,\n                      ),\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      function processResult(result: string): RESULT {\n        const parseResult = safeParseJSON({ text: result });\n\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: could not parse the response.',\n            cause: parseResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n          },\n        );\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        return validationResult.value;\n      }\n\n      let object: RESULT;\n      try {\n        object = processResult(result);\n      } catch (error) {\n        if (\n          repairText != null &&\n          NoObjectGeneratedError.isInstance(error) &&\n          (JSONParseError.isInstance(error.cause) ||\n            TypeValidationError.isInstance(error.cause))\n        ) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause,\n          });\n\n          if (repairedText === null) {\n            throw error;\n          }\n\n          object = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(object),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n          body: rawResponse?.body,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n","import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n\n  /**\n@deprecated Use `providerMetadata` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  Array<ELEMENT>,\n  Array<ELEMENT>,\n  AsyncIterableStream<ELEMENT>\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<JSONValue, JSONValue, never>;\nexport function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    providerOptions?: ProviderOptions;\n    experimental_providerMetadata?: ProviderMetadata;\n    onError?: StreamObjectOnErrorCallback;\n    onFinish?: StreamObjectOnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly objectPromise = new DelayedPromise<RESULT>();\n  private readonly usagePromise = new DelayedPromise<LanguageModelUsage>();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly warningsPromise = new DelayedPromise<\n    CallWarning[] | undefined\n  >();\n  private readonly requestPromise =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly responsePromise =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    mode: 'auto' | 'json' | 'tool' | undefined;\n    onError: StreamObjectOnErrorCallback | undefined;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError?.({ error: chunk.error });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            outputStrategy.jsonSchema != null\n              ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n          'ai.settings.mode': mode,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        // use the default provider mode when the mode is set to 'auto' or unspecified\n        if (mode === 'auto' || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n\n        let callOptions: LanguageModelV1CallOptions;\n        let transformer: Transformer<\n          LanguageModelV1StreamPart,\n          string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n        >;\n\n        switch (mode) {\n          case 'json': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system:\n                  outputStrategy.jsonSchema == null\n                    ? injectJsonInstruction({ prompt: system })\n                    : model.supportsStructuredOutputs\n                      ? system\n                      : injectJsonInstruction({\n                          prompt: system,\n                          schema: outputStrategy.jsonSchema,\n                        }),\n                prompt,\n                messages,\n              },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-json',\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription,\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case 'text-delta':\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case 'tool': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-tool',\n                tool: {\n                  type: 'function',\n                  name: schemaName ?? 'json',\n                  description:\n                    schemaDescription ?? 'Respond with a JSON object.',\n                  parameters: outputStrategy.jsonSchema!,\n                },\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case 'tool-call-delta':\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case undefined: {\n            throw new Error(\n              'Model does not have a default object generation mode.',\n            );\n          }\n\n          default: {\n            const _exhaustiveCheck: never = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => callOptions.inputFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n                'ai.settings.mode': mode,\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self.requestPromise.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let usage: LanguageModelUsage | undefined;\n        let finishReason: LanguageModelV1FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let response: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    response = {\n                      id: chunk.id ?? response.id,\n                      timestamp: chunk.timestamp ?? response.timestamp,\n                      modelId: chunk.modelId ?? response.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = calculateLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({ ...chunk, usage, response });\n\n                    // resolve promises that can be resolved now:\n                    self.usagePromise.resolve(usage);\n                    self.providerMetadataPromise.resolve(providerMetadata);\n                    self.responsePromise.resolve({\n                      ...response,\n                      headers: rawResponse?.headers,\n                    });\n\n                    // resolve the object promise with the latest object:\n                    const validationResult = outputStrategy.validateFinalResult(\n                      latestObjectJson,\n                      {\n                        text: accumulatedText,\n                        response,\n                        usage,\n                      },\n                    );\n\n                    if (validationResult.success) {\n                      object = validationResult.value;\n                      self.objectPromise.resolve(object);\n                    } else {\n                      error = new NoObjectGeneratedError({\n                        message:\n                          'No object generated: response did not match schema.',\n                        cause: validationResult.error,\n                        text: accumulatedText,\n                        response,\n                        usage,\n                        finishReason: finishReason,\n                      });\n                      self.objectPromise.reject(error);\n                    }\n\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': response.id,\n                        'ai.response.model': response.modelId,\n                        'ai.response.timestamp':\n                          response.timestamp.toISOString(),\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': response.id,\n                        'gen_ai.response.model': response.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                        'gen_ai.usage.output_tokens':\n                          finalUsage.completionTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...response,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                    experimental_providerMetadata: providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this.objectPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n","import { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { ToolExecutionError } from '../../errors/tool-execution-error';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\nimport { CoreAssistantMessage, CoreMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordErrorOnSpan, recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile, GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { parseToolCall } from './parse-tool-call';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage, StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  OUTPUT_PARTIAL = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n     */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, OUTPUT_PARTIAL>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.maxSteps - The maximum number of steps.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    experimental_prepareStep?: (options: {\n      steps: Array<StepResult<TOOLS>>;\n      stepNumber: number;\n      maxSteps: number;\n      model: LanguageModel;\n    }) => PromiseLike<\n      | {\n          model?: LanguageModel;\n          toolChoice?: ToolChoice<TOOLS>;\n          experimental_activeTools?: Array<keyof TOOLS>;\n        }\n      | undefined\n    >;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: GenerateTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n      prompt,\n      messages,\n    },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        'ai.model.provider': model.provider,\n        'ai.model.id': model.modelId,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let currentReasoningDetails: Array<ReasoningDetail> = [];\n      let stepCount = 0;\n      const responseMessages: Array<ResponseMessage> = [];\n      let text = '';\n      const sources: GenerateTextResult<TOOLS, OUTPUT>['sources'] = [];\n      const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n      let usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages,\n        ];\n\n        const prepareStepResult = await prepareStep?.({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount,\n        });\n\n        const stepToolChoice = prepareStepResult?.toolChoice ?? toolChoice;\n        const stepActiveTools =\n          prepareStepResult?.experimental_activeTools ?? activeTools;\n        const stepModel = prepareStepResult?.model ?? model;\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages,\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support 'this' context\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools,\n          }),\n        };\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                'ai.model.provider': stepModel.provider,\n                'ai.model.id': stepModel.modelId,\n                // prompt:\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': stepModel.provider,\n                'gen_ai.request.model': stepModel.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output?.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? stepModel.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n                    'ai.response.providerMetadata': JSON.stringify(\n                      result.providerMetadata,\n                    ),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = await Promise.all(\n          (currentModelResponse.toolCalls ?? []).map(toolCall =>\n            parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages,\n            }),\n          ),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning,\n        );\n\n        // sources:\n        sources.push(...(currentModelResponse.sources ?? []));\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: currentModelResponse.sources ?? [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n            body: currentModelResponse.rawResponse?.body,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages),\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n            'ai.response.providerMetadata': JSON.stringify(\n              currentModelResponse.providerMetadata,\n            ),\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n\n          return output.parseOutput(\n            { text },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason,\n            },\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          body: currentModelResponse.rawResponse?.body,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool = tools[toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolName,\n            'ai.toolCall.id': toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          try {\n            const result = await tool.execute!(args, {\n              toolCallId,\n              messages,\n              abortSignal,\n            });\n\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.toolCall.result': {\n                      output: () => JSON.stringify(result),\n                    },\n                  },\n                }),\n              );\n            } catch (ignored) {\n              // JSON stringify might fail if the result is not serializable,\n              // in which case we just ignore it. In the future we might want to\n              // add an optional serialize method to the tool interface and warn\n              // if the result is not serializable.\n            }\n\n            return result;\n          } catch (error) {\n            recordErrorOnSpan(span, error);\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error,\n            });\n          }\n        },\n      });\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n  readonly files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n  readonly reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n  readonly reasoningDetails: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['reasoningDetails'];\n  readonly toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n  readonly request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n  readonly sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n\n  private readonly outputResolver: () => GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_output'];\n\n  constructor(options: {\n    text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n    files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n    reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n    reasoningDetails: GenerateTextResult<TOOLS, OUTPUT>['reasoningDetails'];\n    toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n    usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n    warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n    logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS, OUTPUT>['providerMetadata'];\n    response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n    request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n    outputResolver: () => GenerateTextResult<\n      TOOLS,\n      OUTPUT\n    >['experimental_output'];\n    sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n  }) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n\n  get experimental_output() {\n    return this.outputResolver();\n  }\n}\n\nfunction asReasoningDetails(\n  reasoning:\n    | string\n    | Array<\n        | { type: 'text'; text: string; signature?: string }\n        | { type: 'redacted'; data: string }\n      >\n    | undefined,\n): Array<\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string }\n> {\n  if (reasoning == null) {\n    return [];\n  }\n\n  if (typeof reasoning === 'string') {\n    return [{ type: 'text', text: reasoning }];\n  }\n\n  return reasoning;\n}\n\nfunction asFiles(\n  files:\n    | Array<{\n        data: string | Uint8Array;\n        mimeType: string;\n      }>\n    | undefined,\n): Array<GeneratedFile> {\n  return files?.map(file => new DefaultGeneratedFile(file)) ?? [];\n}\n","import { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors';\nimport { injectJsonInstruction } from '../generate-object/inject-json-instruction';\nimport {\n  FinishReason,\n  LanguageModel,\n  LanguageModelV1CallOptions,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nexport interface Output<OUTPUT, PARTIAL> {\n  readonly type: 'object' | 'text';\n  injectIntoSystemPrompt(options: {\n    system: string | undefined;\n    model: LanguageModel;\n  }): string | undefined;\n\n  responseFormat: (options: {\n    model: LanguageModel;\n  }) => LanguageModelV1CallOptions['responseFormat'];\n\n  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;\n\n  parseOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): OUTPUT;\n}\n\nexport const text = (): Output<string, string> => ({\n  type: 'text',\n\n  responseFormat: () => ({ type: 'text' }),\n\n  injectIntoSystemPrompt({ system }: { system: string | undefined }) {\n    return system;\n  },\n\n  parsePartial({ text }: { text: string }) {\n    return { partial: text };\n  },\n\n  parseOutput({ text }: { text: string }) {\n    return text;\n  },\n});\n\nexport const object = <OUTPUT>({\n  schema: inputSchema,\n}: {\n  schema: z.Schema<OUTPUT, z.ZodTypeDef, any> | Schema<OUTPUT>;\n}): Output<OUTPUT, DeepPartial<OUTPUT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    type: 'object',\n\n    responseFormat: ({ model }) => ({\n      type: 'json',\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : undefined,\n    }),\n\n    injectIntoSystemPrompt({ system, model }) {\n      // when the model supports structured outputs,\n      // we can use the system prompt as is:\n      return model.supportsStructuredOutputs\n        ? system\n        : injectJsonInstruction({\n            prompt: system,\n            schema: schema.jsonSchema,\n          });\n    },\n\n    parsePartial({ text }: { text: string }) {\n      const result = parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input':\n          return undefined;\n\n        case 'repaired-parse':\n        case 'successful-parse':\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OUTPUT>,\n          };\n\n        default: {\n          const _exhaustiveCheck: never = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    parseOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n  };\n};\n","/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n","import { AISDKError, LanguageModelV1Source } from '@ai-sdk/provider';\nimport { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { InvalidStreamPartError } from '../../errors/invalid-stream-part-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { UnsupportedModelVersionError } from '../../errors/unsupported-model-version-error';\nimport { StreamData } from '../../streams/stream-data';\nimport { asArray } from '../../util/as-array';\nimport { consumeStream } from '../../util/consume-stream';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { DataStreamWriter } from '../data-stream/data-stream-writer';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { CoreAssistantMessage } from '../prompt/message';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ToolChoice,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport { addLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { ResponseMessage, StepResult } from './step-result';\nimport {\n  ConsumeStreamOptions,\n  DataStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning'\n        | 'source'\n        | 'tool-call'\n        | 'tool-call-streaming-start'\n        | 'tool-call-delta'\n        | 'tool-result';\n    }\n  >;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n    /**\nDetails for all steps.\n   */\n    readonly steps: StepResult<TOOLS>[];\n  },\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  PARTIAL_OUTPUT = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, PARTIAL_OUTPUT>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    toolCallStreaming?: boolean;\n\n    /**\n@deprecated Use `toolCallStreaming` instead.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, PARTIAL_OUTPUT> {\n  if (typeof model === 'string' || model.specificationVersion !== 'v1') {\n    throw new UnsupportedModelVersionError();\n  }\n\n  return new DefaultStreamTextResult<TOOLS, OUTPUT, PARTIAL_OUTPUT>({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT,\n  PARTIAL_OUTPUT,\n>(\n  output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n> {\n  if (!output) {\n    return new TransformStream<\n      TextStreamPart<TOOLS>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n      },\n    });\n  }\n\n  let text = '';\n  let textChunk = '';\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >;\n    partialOutput?: PARTIAL_OUTPUT;\n  }) {\n    controller.enqueue({\n      part: { type: 'text-delta', textDelta: textChunk },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n  >({\n    transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'step-finish') {\n        publishTextChunk({ controller });\n      }\n\n      if (chunk.type !== 'text-delta') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.textDelta;\n      textChunk += chunk.textDelta;\n\n      // only publish if partial json can be parsed:\n      const result = output.parsePartial({ text });\n      if (result != null) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n\n    flush(controller) {\n      // publish remaining text (there should be none if the content was correctly formatted):\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT>\n  implements StreamTextResult<TOOLS, PARTIAL_OUTPUT>\n{\n  private readonly warningsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['warnings']>\n  >();\n  private readonly usagePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['usage']>\n  >();\n  private readonly finishReasonPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['finishReason']>\n  >();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    Awaited<\n      StreamTextResult<TOOLS, PARTIAL_OUTPUT>['experimental_providerMetadata']\n    >\n  >();\n  private readonly textPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['text']>\n  >();\n  private readonly reasoningPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoning']>\n  >();\n  private readonly reasoningDetailsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoningDetails']>\n  >();\n  private readonly sourcesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['sources']>\n  >();\n  private readonly filesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['files']>\n  >();\n  private readonly toolCallsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolCalls']>\n  >();\n  private readonly toolResultsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolResults']>\n  >();\n  private readonly requestPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['request']>\n  >();\n  private readonly responsePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['response']>\n  >();\n  private readonly stepsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>>;\n\n  private output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    toolCallStreaming: boolean;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    maxSteps: number;\n    output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n    continueSteps: boolean;\n    providerOptions: ProviderOptions | undefined;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    generateMessageId: () => string;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: undefined | StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxSteps',\n        value: maxSteps,\n        message: 'maxSteps must be at least 1',\n      });\n    }\n\n    this.output = output;\n\n    // event processor for telemetry, invoking callbacks, etc.\n    // The event processor reads the transformed stream to enable correct\n    // recording of the final transformed outputs.\n    let recordedStepText = '';\n    let recordedContinuationText = '';\n    let recordedFullText = '';\n\n    let stepReasoning: Array<ReasoningDetail> = [];\n    let stepFiles: Array<GeneratedFile> = [];\n    let activeReasoningText: undefined | (ReasoningDetail & { type: 'text' }) =\n      undefined;\n\n    let recordedStepSources: LanguageModelV1Source[] = [];\n    const recordedSources: LanguageModelV1Source[] = [];\n\n    const recordedResponse: LanguageModelResponseMetadata & {\n      messages: Array<ResponseMessage>;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: [],\n    };\n    let recordedToolCalls: ToolCallUnion<TOOLS>[] = [];\n    let recordedToolResults: ToolResultUnion<TOOLS>[] = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedUsage: LanguageModelUsage | undefined = undefined;\n    let stepType: 'initial' | 'continue' | 'tool-result' = 'initial';\n    const recordedSteps: StepResult<TOOLS>[] = [];\n    let rootSpan!: Span;\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-call-streaming-start' ||\n          part.type === 'tool-call-delta'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError?.({ error: part.error });\n        }\n\n        if (part.type === 'text-delta') {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n\n        if (part.type === 'reasoning') {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: 'text', text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n\n        if (part.type === 'reasoning-signature') {\n          if (activeReasoningText == null) {\n            throw new AISDKError({\n              name: 'InvalidStreamPart',\n              message: 'reasoning-signature without reasoning',\n            });\n          }\n\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = undefined; // signature concludes reasoning part\n        }\n\n        if (part.type === 'redacted-reasoning') {\n          stepReasoning.push({ type: 'redacted', data: part.data });\n        }\n\n        if (part.type === 'file') {\n          stepFiles.push(part);\n        }\n\n        if (part.type === 'source') {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedToolCalls.push(part);\n        }\n\n        if (part.type === 'tool-result') {\n          recordedToolResults.push(part);\n        }\n\n        if (part.type === 'step-finish') {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools ?? ({} as TOOLS),\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId,\n          });\n\n          // determine the next step type\n          const currentStep = recordedSteps.length;\n          let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n          if (currentStep + 1 < maxSteps) {\n            if (\n              continueSteps &&\n              part.finishReason === 'length' &&\n              // only use continue when there are no tool calls:\n              recordedToolCalls.length === 0\n            ) {\n              nextStepType = 'continue';\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 &&\n              // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = 'tool-result';\n            }\n          }\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages],\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued,\n          };\n\n          await onStepFinish?.(currentStepResult);\n\n          recordedSteps.push(currentStepResult);\n\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = '';\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = undefined;\n\n          if (nextStepType !== 'done') {\n            stepType = nextStepType;\n          }\n\n          if (nextStepType !== 'continue') {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = '';\n          }\n        }\n\n        if (part.type === 'finish') {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // from last step (when there are errors there may be no last step)\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata,\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'unknown';\n          const usage = recordedUsage ?? {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN,\n          };\n\n          // from finish:\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n\n          // aggregate results:\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n\n          // call onFinish callback:\n          await onFinish?.({\n            finishReason,\n            logprobs: undefined,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: lastStep.request ?? {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata:\n              lastStep.experimental_providerMetadata,\n            steps: recordedSteps,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => recordedFullText },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    lastStep.toolCalls?.length\n                      ? JSON.stringify(lastStep.toolCalls)\n                      : undefined,\n                },\n\n                'ai.usage.promptTokens': usage.promptTokens,\n                'ai.usage.completionTokens': usage.completionTokens,\n                'ai.response.providerMetadata': JSON.stringify(\n                  lastStep.providerMetadata,\n                ),\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    let stream = stitchableStream.stream;\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n        prompt,\n        messages,\n      },\n      tools,\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.settings.maxSteps': maxSteps,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n          stepType: 'initial' | 'continue' | 'tool-result';\n          previousStepText: string;\n          hasLeadingWhitespace: boolean;\n          messageId: string;\n        }) {\n          // after the 1st step, we need to switch to messages format:\n          const promptFormat =\n            responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages,\n          ];\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages,\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const mode = {\n            type: 'regular' as const,\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n          };\n\n          const {\n            result: { stream, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => promptFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      mode.toolChoice != null\n                        ? JSON.stringify(mode.toolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output?.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                }),\n              }),\n            }),\n          );\n\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n          const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n\n          const stepReasoning: Array<ReasoningDetail> = [];\n          const stepFiles: Array<GeneratedFile> = [];\n          let activeReasoningText:\n            | undefined\n            | (ReasoningDetail & { type: 'text' }) = undefined;\n\n          let stepFinishReason: FinishReason = 'unknown';\n          let stepUsage: LanguageModelUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          };\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepText = '';\n          let fullStepText = stepType === 'continue' ? previousStepText : '';\n          let stepLogProbs: LogProbs | undefined;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // chunk buffer when using continue:\n          let chunkBuffer = '';\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n          async function publishTextChunk({\n            controller,\n            chunk,\n          }: {\n            controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n            chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n          }) {\n            controller.enqueue(chunk);\n\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'step-start',\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  // Filter out empty text deltas\n                  if (\n                    chunk.type === 'text-delta' &&\n                    chunk.textDelta.length === 0\n                  ) {\n                    return;\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'text-delta': {\n                      if (continueSteps) {\n                        // when a new step starts, leading whitespace is to be discarded\n                        // when there is already preceding whitespace in the chunk buffer\n                        const trimmedChunkText =\n                          inWhitespacePrefix && hasLeadingWhitespace\n                            ? chunk.textDelta.trimStart()\n                            : chunk.textDelta;\n\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n\n                        const split = splitOnLastWhitespace(chunkBuffer);\n\n                        // publish the text until the last whitespace:\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: 'text-delta',\n                              textDelta: split.prefix + split.whitespace,\n                            },\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n\n                    case 'reasoning': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        activeReasoningText = {\n                          type: 'text',\n                          text: chunk.textDelta,\n                        };\n                        stepReasoning.push(activeReasoningText);\n                      } else {\n                        activeReasoningText.text += chunk.textDelta;\n                      }\n\n                      break;\n                    }\n\n                    case 'reasoning-signature': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: 'reasoning-signature without reasoning',\n                        });\n                      }\n\n                      activeReasoningText.signature = chunk.signature;\n                      activeReasoningText = undefined; // signature concludes reasoning part\n                      break;\n                    }\n\n                    case 'redacted-reasoning': {\n                      controller.enqueue(chunk);\n                      stepReasoning.push({\n                        type: 'redacted',\n                        data: chunk.data,\n                      });\n\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n                      // store tool results for onFinish callback and toolResults promise:\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata =\n                        chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgCompletionTokensPerSecond':\n                          (1000 * stepUsage.completionTokens) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      stepFiles.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    // forward:\n                    case 'source':\n                    case 'tool-call-streaming-start':\n                    case 'tool-call-delta': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // determine the next step type\n                  let nextStepType: 'done' | 'continue' | 'tool-result' =\n                    'done';\n                  if (currentStep + 1 < maxSteps) {\n                    if (\n                      continueSteps &&\n                      stepFinishReason === 'length' &&\n                      // only use continue when there are no tool calls:\n                      stepToolCalls.length === 0\n                    ) {\n                      nextStepType = 'continue';\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 &&\n                      // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = 'tool-result';\n                    }\n                  }\n\n                  // when using continuation, publish buffer on final step or if there\n                  // was no whitespace in the step:\n                  if (\n                    continueSteps &&\n                    chunkBuffer.length > 0 &&\n                    (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                      (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n                  ) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: 'text-delta',\n                        textDelta: chunkBuffer,\n                      },\n                    });\n                    chunkBuffer = '';\n                  }\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': { output: () => stepText },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n                          'ai.response.providerMetadata':\n                            JSON.stringify(stepProviderMetadata),\n\n                          'ai.usage.promptTokens': stepUsage.promptTokens,\n                          'ai.usage.completionTokens':\n                            stepUsage.completionTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                          'gen_ai.usage.output_tokens':\n                            stepUsage.completionTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'step-finish',\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    isContinued: nextStepType === 'continue',\n                    messageId,\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  if (nextStepType === 'done') {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse?.headers,\n                      },\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  } else {\n                    // append to messages for the next step:\n                    if (stepType === 'continue') {\n                      // continue step: update the last assistant message\n                      // continue is only possible when there are no tool calls,\n                      // so we can assume that there is a single last assistant message:\n                      const lastMessage = responseMessages[\n                        responseMessages.length - 1\n                      ] as CoreAssistantMessage;\n\n                      if (typeof lastMessage.content === 'string') {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: 'text',\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles,\n                          reasoning: stepReasoning,\n                          tools: tools ?? ({} as TOOLS),\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId,\n                        }),\n                      );\n                    }\n\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId:\n                        // keep the same id when continuing a step:\n                        nextStepType === 'continue'\n                          ? messageId\n                          : generateMessageId(),\n                    });\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          },\n          previousStepText: '',\n          stepType: 'initial',\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get text() {\n    return this.textPromise.value;\n  }\n\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n\n  get files() {\n    return this.filesPromise.value;\n  }\n\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get steps() {\n    return this.stepsPromise.value;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>, string>({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.textDelta);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<PARTIAL_OUTPUT> {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          PARTIAL_OUTPUT\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  private toDataStreamInternal({\n    getErrorMessage = () => 'An error occurred.', // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true,\n  }: {\n    getErrorMessage: ((error: unknown) => string) | undefined;\n    sendUsage: boolean | undefined;\n    sendReasoning: boolean | undefined;\n    sendSources: boolean | undefined;\n    experimental_sendFinish: boolean | undefined;\n  }): ReadableStream<DataStreamString> {\n    return this.fullStream.pipeThrough(\n      new TransformStream<TextStreamPart<TOOLS>, DataStreamString>({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case 'text-delta': {\n              controller.enqueue(formatDataStreamPart('text', chunk.textDelta));\n              break;\n            }\n\n            case 'reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning', chunk.textDelta),\n                );\n              }\n              break;\n            }\n\n            case 'redacted-reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('redacted_reasoning', {\n                    data: chunk.data,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'reasoning-signature': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning_signature', {\n                    signature: chunk.signature,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue(\n                formatDataStreamPart('file', {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64,\n                }),\n              );\n              break;\n            }\n\n            case 'source': {\n              if (sendSources) {\n                controller.enqueue(\n                  formatDataStreamPart('source', chunk.source),\n                );\n              }\n              break;\n            }\n\n            case 'tool-call-streaming-start': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_streaming_start', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call-delta': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_delta', {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-result': {\n              controller.enqueue(\n                formatDataStreamPart('tool_result', {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result,\n                }),\n              );\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue(\n                formatDataStreamPart('error', getErrorMessage(chunk.error)),\n              );\n              break;\n            }\n\n            case 'step-start': {\n              controller.enqueue(\n                formatDataStreamPart('start_step', {\n                  messageId: chunk.messageId,\n                }),\n              );\n              break;\n            }\n\n            case 'step-finish': {\n              controller.enqueue(\n                formatDataStreamPart('finish_step', {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage\n                    ? {\n                        promptTokens: chunk.usage.promptTokens,\n                        completionTokens: chunk.usage.completionTokens,\n                      }\n                    : undefined,\n                  isContinued: chunk.isContinued,\n                }),\n              );\n              break;\n            }\n\n            case 'finish': {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  formatDataStreamPart('finish_message', {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage\n                      ? {\n                          promptTokens: chunk.usage.promptTokens,\n                          completionTokens: chunk.usage.completionTokens,\n                        }\n                      : undefined,\n                  }),\n                );\n              }\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      }),\n    );\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    {\n      status,\n      statusText,\n      headers,\n      data,\n      getErrorMessage,\n      sendUsage,\n      sendReasoning,\n      sendSources,\n      experimental_sendFinish,\n    }: ResponseInit &\n      DataStreamOptions & {\n        data?: StreamData;\n        getErrorMessage?: (error: unknown) => string;\n      } = {},\n  ) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(\n    options?: DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    },\n  ) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n      sendReasoning: options?.sendReasoning,\n      sendSources: options?.sendSources,\n      experimental_sendFinish: options?.experimental_sendFinish,\n    }).pipeThrough(new TextEncoderStream());\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options?.sendUsage,\n        sendReasoning: options?.sendReasoning,\n        sendSources: options?.sendSources,\n        experimental_sendFinish: options?.experimental_sendFinish,\n      }),\n    );\n  }\n\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n  }: ResponseInit &\n    DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    } = {}): Response {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n","import { z } from 'zod';\nimport {\n  inferParameters,\n  Tool,\n  ToolExecutionOptions,\n  ToolParameters,\n} from '../tool';\n\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2024-10-07',\n];\n\nexport type ToolSchemas =\n  | Record<string, { parameters: ToolParameters }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { parameters: ToolParameters }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: Tool<\n          TOOL_SCHEMAS[K]['parameters'],\n          CallToolResult\n        > & {\n          execute: (\n            args: inferParameters<TOOL_SCHEMAS[K]['parameters']>,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      }\n    : {\n        [k: string]: Tool<z.ZodUnknown, CallToolResult> & {\n          execute: (\n            args: unknown,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      };\n\nconst ClientOrServerImplementationSchema = z\n  .object({\n    name: z.string(),\n    version: z.string(),\n  })\n  .passthrough();\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z\n  .object({\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z\n  .object({\n    experimental: z.optional(z.object({}).passthrough()),\n    logging: z.optional(z.object({}).passthrough()),\n    prompts: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    resources: z.optional(\n      z\n        .object({\n          subscribe: z.optional(z.boolean()),\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    tools: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .passthrough();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.string().base64(),\n    mimeType: z.string(),\n  })\n  .passthrough();\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.string().base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n","import { z } from 'zod';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n","import { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\nfunction toDataStreamInternal(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\n/**\nConverts LangChain output streams to an AI SDK Data Stream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  const dataStream = toDataStreamInternal(\n    stream,\n    options?.callbacks,\n  ).pipeThrough(new TextEncoderStream());\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options: { dataStream: DataStreamWriter; callbacks?: StreamCallbacks },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n","/**\n * Configuration options and helper callback methods for stream lifecycle events.\n */\nexport interface StreamCallbacks {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n\n  /**\n   * `onCompletion`: Called for each tokenized message.\n   *\n   * @deprecated Use `onFinal` instead.\n   */\n  onCompletion?: (completion: string) => Promise<void> | void;\n\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time a completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {StreamCallbacks} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  callbacks: StreamCallbacks | undefined = {},\n): TransformStream<string, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      controller.enqueue(textEncoder.encode(message));\n\n      aggregatedResponse += message;\n\n      if (callbacks.onToken) await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n","import { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\nimport { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nfunction toDataStreamInternal(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  const trimStart = trimStartOfStream();\n\n  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())\n    .pipeThrough(\n      new TransformStream({\n        async transform(message, controller): Promise<void> {\n          controller.enqueue(trimStart(message.delta));\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    dataStream: DataStreamWriter;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction trimStartOfStream(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n","import { z } from 'zod';\nimport type { ZodSchema as ZodSchemaV3, ZodType as ZodTypeV3 } from 'zod/v3';\nimport type { ZodType as ZodSchemaV4, ZodType as ZodTypeV4 } from 'zod/v4';\nimport { convertJsonSchemaToZod } from 'zod-from-json-schema';\nimport { convertJsonSchemaToZod as convertJsonSchemaToZodV3 } from 'zod-from-json-schema-v3';\nimport type { Targets } from 'zod-to-json-schema';\nimport type { JSONSchema7, Schema } from './json-schema';\nimport { jsonSchema } from './json-schema';\nimport type { SchemaCompatLayer } from './schema-compatibility';\nimport { zodToJsonSchema } from './zod-to-json';\n\ntype ZodSchema = ZodSchemaV3 | ZodSchemaV4;\ntype ZodType = ZodTypeV3 | ZodTypeV4;\n\n/**\n * Converts a Zod schema to an AI SDK Schema with validation support.\n *\n * This function mirrors the behavior of Vercel's AI SDK zod-schema utility but allows\n * customization of the JSON Schema target format.\n *\n * @param zodSchema - The Zod schema to convert\n * @param target - The JSON Schema target format (defaults to 'jsonSchema7')\n * @returns An AI SDK Schema object with built-in validation\n *\n * @example\n * ```typescript\n * import { z } from 'zod';\n * import { convertZodSchemaToAISDKSchema } from '@mastra/schema-compat';\n *\n * const userSchema = z.object({\n *   name: z.string(),\n *   age: z.number().min(0)\n * });\n *\n * const aiSchema = convertZodSchemaToAISDKSchema(userSchema);\n * ```\n */\n// mirrors https://github.com/vercel/ai/blob/main/packages/ui-utils/src/zod-schema.ts#L21 but with a custom target\nexport function convertZodSchemaToAISDKSchema(zodSchema: ZodSchema, target: Targets = 'jsonSchema7'): Schema<any> {\n  const jsonSchemaToUse = zodToJsonSchema(zodSchema, target) as JSONSchema7;\n\n  return jsonSchema(jsonSchemaToUse, {\n    validate: value => {\n      const result = zodSchema.safeParse(value);\n      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n    },\n  });\n}\n\n/**\n * Checks if a value is a Zod type by examining its properties and methods.\n *\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n * @internal\n */\nexport function isZodType(value: unknown): value is ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  // _def is used in Zod v3, _zod is used in Zod v4\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    ('_def' in value || '_zod' in value) &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n/**\n * Converts an AI SDK Schema or Zod schema to a Zod schema.\n *\n * If the input is already a Zod schema, it returns it unchanged.\n * If the input is an AI SDK Schema, it extracts the JSON schema and converts it to Zod.\n *\n * @param schema - The schema to convert (AI SDK Schema or Zod schema)\n * @returns A Zod schema equivalent of the input\n * @throws Error if the conversion fails\n *\n * @example\n * ```typescript\n * import { jsonSchema } from 'ai';\n * import { convertSchemaToZod } from '@mastra/schema-compat';\n *\n * const aiSchema = jsonSchema({\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' }\n *   }\n * });\n *\n * const zodSchema = convertSchemaToZod(aiSchema);\n * ```\n */\nexport function convertSchemaToZod(schema: Schema | ZodSchema | JSONSchema7): ZodType {\n  if (isZodType(schema)) {\n    return schema;\n  } else {\n    const jsonSchemaToConvert = 'jsonSchema' in schema ? schema.jsonSchema : schema;\n    try {\n      if ('toJSONSchema' in z) {\n        // @ts-expect-error - type issue in convertJsonSchemaToZod\n        return convertJsonSchemaToZod(jsonSchemaToConvert);\n      } else {\n        // @ts-expect-error - type issue in convertJsonSchemaToZodV3\n        return convertJsonSchemaToZodV3(jsonSchemaToConvert);\n      }\n    } catch (e: unknown) {\n      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;\n      console.error(errorMessage, e);\n      throw new Error(errorMessage + (e instanceof Error ? `\\n${e.stack}` : '\\nUnknown error object'));\n    }\n  }\n}\n\n/**\n * Processes a schema using provider compatibility layers and converts it to an AI SDK Schema.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Must be 'aiSdkSchema'\n * @returns Processed schema as an AI SDK Schema\n */\nexport function applyCompatLayer(options: {\n  schema: Schema | ZodSchema | JSONSchema7;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'aiSdkSchema';\n}): Schema;\n\n/**\n * Processes a schema using provider compatibility layers and converts it to a JSON Schema.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Must be 'jsonSchema'\n * @returns Processed schema as a JSONSchema7\n */\nexport function applyCompatLayer(options: {\n  schema: Schema | ZodSchema | JSONSchema7;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'jsonSchema';\n}): JSONSchema7;\n\n/**\n * Processes a schema using provider compatibility layers and converts it to the specified format.\n *\n * This function automatically applies the first matching compatibility layer from the provided\n * list based on the model configuration. If no compatibility applies, it falls back to\n * standard conversion.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Output format: 'jsonSchema' for JSONSchema7 or 'aiSdkSchema' for AI SDK Schema\n * @returns Processed schema in the requested format\n *\n * @example\n * ```typescript\n * import { z } from 'zod';\n * import { applyCompatLayer, OpenAISchemaCompatLayer, AnthropicSchemaCompatLayer } from '@mastra/schema-compat';\n *\n * const schema = z.object({\n *   query: z.string().email(),\n *   limit: z.number().min(1).max(100)\n * });\n *\n * const compatLayers = [\n *   new OpenAISchemaCompatLayer(model),\n *   new AnthropicSchemaCompatLayer(model)\n * ];\n *\n * const result = applyCompatLayer({\n *   schema,\n *   compatLayers,\n *   mode: 'aiSdkSchema'\n * });\n * ```\n */\nexport function applyCompatLayer({\n  schema,\n  compatLayers,\n  mode,\n}: {\n  schema: Schema | ZodSchema | JSONSchema7;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'jsonSchema' | 'aiSdkSchema';\n}): JSONSchema7 | Schema {\n  let zodSchema: ZodSchema;\n\n  if (!isZodType(schema)) {\n    // Convert non-zod schema to Zod\n    zodSchema = convertSchemaToZod(schema);\n  } else {\n    zodSchema = schema;\n  }\n\n  for (const compat of compatLayers) {\n    if (compat.shouldApply()) {\n      return mode === 'jsonSchema' ? compat.processToJSONSchema(zodSchema) : compat.processToAISDKSchema(zodSchema);\n    }\n  }\n  // If no compatibility applied, convert back to appropriate format\n  if (mode === 'jsonSchema') {\n    return zodToJsonSchema(zodSchema, 'jsonSchema7') as JSONSchema7;\n  } else {\n    return convertZodSchemaToAISDKSchema(zodSchema);\n  }\n}\n","import {\n  z,\n  ZodOptional,\n  ZodObject,\n  ZodArray,\n  ZodUnion,\n  ZodString,\n  ZodNumber,\n  ZodDate,\n  ZodDefault,\n  ZodNull,\n  ZodNullable,\n} from 'zod';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport type { JSONSchema7, Schema } from './json-schema';\nimport type { SchemaCompatLayer as ParentSchemaCompatLayer } from './schema-compatibility';\nimport type { ModelInformation } from './types';\nimport { convertZodSchemaToAISDKSchema } from './utils';\n\n/**\n * All supported string validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_STRING_CHECKS = ['regex', 'emoji', 'email', 'url', 'uuid', 'cuid', 'min', 'max'] as const;\n\n/**\n * All supported number validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_NUMBER_CHECKS = [\n  'min', // gte internally\n  'max', // lte internally\n  'multipleOf',\n] as const;\n\n/**\n * All supported array validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_ARRAY_CHECKS = ['min', 'max', 'length'] as const;\n\nexport const isOptional = (v: ZodTypeAny): v is ZodOptional<any> => v instanceof ZodOptional;\nexport const isObj = (v: ZodTypeAny): v is ZodObject<any, any, any> => v instanceof ZodObject;\nexport const isNull = (v: ZodTypeAny): v is ZodNull => v instanceof ZodNull;\nexport const isNullable = (v: ZodTypeAny): v is ZodNullable<any> => v instanceof ZodNullable;\nexport const isArr = (v: ZodTypeAny): v is ZodArray<any, any> => v instanceof ZodArray;\nexport const isUnion = (v: ZodTypeAny): v is ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> => v instanceof ZodUnion;\nexport const isString = (v: ZodTypeAny): v is ZodString => v instanceof ZodString;\nexport const isNumber = (v: ZodTypeAny): v is ZodNumber => v instanceof ZodNumber;\nexport const isDate = (v: ZodTypeAny): v is ZodDate => v instanceof ZodDate;\nexport const isDefault = (v: ZodTypeAny): v is ZodDefault<any> => v instanceof ZodDefault;\n\n/**\n * Zod types that are not supported by most AI model providers and should be avoided.\n * @constant\n */\nexport const UNSUPPORTED_ZOD_TYPES = ['ZodIntersection', 'ZodNever', 'ZodNull', 'ZodTuple', 'ZodUndefined'] as const;\n\n/**\n * Zod types that are generally supported by AI model providers.\n * @constant\n */\nexport const SUPPORTED_ZOD_TYPES = [\n  'ZodObject',\n  'ZodArray',\n  'ZodUnion',\n  'ZodString',\n  'ZodNumber',\n  'ZodDate',\n  'ZodAny',\n  'ZodDefault',\n  'ZodNullable',\n] as const;\n\n/**\n * All Zod types (both supported and unsupported).\n * @constant\n */\nexport const ALL_ZOD_TYPES = [...SUPPORTED_ZOD_TYPES, ...UNSUPPORTED_ZOD_TYPES] as const;\n\n/**\n * Type representing string validation checks.\n */\nexport type StringCheckType = (typeof ALL_STRING_CHECKS)[number];\n\n/**\n * Type representing number validation checks.\n */\nexport type NumberCheckType = (typeof ALL_NUMBER_CHECKS)[number];\n\n/**\n * Type representing array validation checks.\n */\nexport type ArrayCheckType = (typeof ALL_ARRAY_CHECKS)[number];\n\n/**\n * Type representing unsupported Zod schema types.\n */\nexport type UnsupportedZodType = (typeof UNSUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing supported Zod schema types.\n */\nexport type SupportedZodType = (typeof SUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing all Zod schema types (supported and unsupported).\n */\nexport type AllZodType = (typeof ALL_ZOD_TYPES)[number];\n\n/**\n * Utility type to extract the shape of a Zod object schema.\n */\nexport type ZodShape<T extends z.AnyZodObject> = T['shape'];\n\n/**\n * Utility type to extract the keys from a Zod object shape.\n */\nexport type ShapeKey<T extends z.AnyZodObject> = keyof ZodShape<T>;\n\n/**\n * Utility type to extract the value types from a Zod object shape.\n */\nexport type ShapeValue<T extends z.AnyZodObject> = ZodShape<T>[ShapeKey<T>];\n\n// Add constraint types at the top\n\ntype ConstraintHelperText = string[];\n\n/**\n * Abstract base class for creating schema compatibility layers for different AI model providers.\n *\n * This class provides a framework for transforming Zod schemas to work with specific AI model\n * provider requirements and limitations. Each provider may have different support levels for\n * JSON Schema features, validation constraints, and data types.\n *\n *\n * @example\n * ```typescript\n * import { SchemaCompatLayer } from '@mastra/schema-compat';\n * import type { LanguageModelV1 } from 'ai';\n *\n * class CustomProviderCompat extends SchemaCompatLayer {\n *   constructor(model: ModelInformation) {\n *     super(model);\n *   }\n *\n *   shouldApply(): boolean {\n *     return this.getModel().provider === 'custom-provider';\n *   }\n *\n *   getSchemaTarget() {\n *     return 'jsonSchema7';\n *   }\n *\n *   processZodType<T extends z.AnyZodObject>(value: z.ZodTypeAny): ShapeValue<T> {\n *     // Custom processing logic for this provider\n *     switch (value._def.typeName) {\n *       case 'ZodString':\n *         return this.defaultZodStringHandler(value, ['email', 'url']);\n *       default:\n *         return this.defaultUnsupportedZodTypeHandler(value);\n *     }\n *   }\n * }\n * ```\n */\nexport class SchemaCompatLayer {\n  private model: ModelInformation;\n  private parent: ParentSchemaCompatLayer;\n\n  /**\n   * Creates a new schema compatibility instance.\n   *\n   * @param model - The language model this compatibility layer applies to\n   */\n  constructor(model: ModelInformation, parent: ParentSchemaCompatLayer) {\n    this.model = model;\n    this.parent = parent;\n  }\n\n  /**\n   * Gets the language model associated with this compatibility layer.\n   *\n   * @returns The language model instance\n   */\n  getModel(): ModelInformation {\n    return this.model;\n  }\n\n  getUnsupportedZodTypes(): readonly string[] {\n    return UNSUPPORTED_ZOD_TYPES;\n  }\n\n  /**\n   * Type guard for optional Zod types\n   */\n  isOptional(v: ZodTypeAny): v is ZodOptional<any> {\n    return v instanceof ZodOptional;\n  }\n\n  /**\n   * Type guard for object Zod types\n   */\n  isObj(v: ZodTypeAny): v is ZodObject<any, any, any> {\n    return v instanceof ZodObject;\n  }\n\n  /**\n   * Type guard for null Zod types\n   */\n  isNull(v: ZodTypeAny): v is ZodNull {\n    return v instanceof ZodNull;\n  }\n\n  /**\n   * Type guard for array Zod types\n   */\n  isArr(v: ZodTypeAny): v is ZodArray<any, any> {\n    return v instanceof ZodArray;\n  }\n\n  /**\n   * Type guard for union Zod types\n   */\n  isUnion(v: ZodTypeAny): v is ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> {\n    return v instanceof ZodUnion;\n  }\n\n  /**\n   * Type guard for string Zod types\n   */\n  isString(v: ZodTypeAny): v is ZodString {\n    return v instanceof ZodString;\n  }\n\n  /**\n   * Type guard for number Zod types\n   */\n  isNumber(v: ZodTypeAny): v is ZodNumber {\n    return v instanceof ZodNumber;\n  }\n\n  /**\n   * Type guard for date Zod types\n   */\n  isDate(v: ZodTypeAny): v is ZodDate {\n    return v instanceof ZodDate;\n  }\n\n  /**\n   * Type guard for default Zod types\n   */\n  isDefault(v: ZodTypeAny): v is ZodDefault<any> {\n    return v instanceof ZodDefault;\n  }\n\n  /**\n   * Determines whether this compatibility layer should be applied for the current model.\n   *\n   * @returns True if this compatibility layer should be used, false otherwise\n   * @abstract\n   */\n  shouldApply(): boolean {\n    return this.parent.shouldApply();\n  }\n\n  /**\n   * Returns the JSON Schema target format for this provider.\n   *\n   * @returns The schema target format, or undefined to use the default 'jsonSchema7'\n   * @abstract\n   */\n  getSchemaTarget(): Targets | undefined {\n    return this.parent.getSchemaTarget();\n  }\n\n  /**\n   * Processes a specific Zod type according to the provider's requirements.\n   *\n   * @param value - The Zod type to process\n   * @returns The processed Zod type\n   * @abstract\n   */\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    return this.parent.processZodType(value);\n  }\n\n  /**\n   * Default handler for Zod object types. Recursively processes all properties in the object.\n   *\n   * @param value - The Zod object to process\n   * @returns The processed Zod object\n   */\n  public defaultZodObjectHandler(\n    value: ZodObject<any, any, any>,\n    options: { passthrough?: boolean } = { passthrough: true },\n  ): ZodObject<any, any, any> {\n    const processedShape = Object.entries(value.shape).reduce<Record<string, ZodTypeAny>>((acc, [key, propValue]) => {\n      acc[key] = this.processZodType(propValue as ZodTypeAny);\n      return acc;\n    }, {});\n\n    let result: ZodObject<any, any, any> = z.object(processedShape);\n\n    if (value._def.unknownKeys === 'strict') {\n      result = result.strict();\n    }\n    if (value._def.catchall && !(value._def.catchall instanceof z.ZodNever)) {\n      result = result.catchall(value._def.catchall);\n    }\n\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n\n    if (options.passthrough && value._def.unknownKeys === 'passthrough') {\n      result = result.passthrough();\n    }\n\n    return result;\n  }\n\n  /**\n   * Merges validation constraints into a parameter description.\n   *\n   * This helper method converts validation constraints that may not be supported\n   * by a provider into human-readable descriptions.\n   *\n   * @param description - The existing parameter description\n   * @param constraints - The validation constraints to merge\n   * @returns The updated description with constraints, or undefined if no constraints\n   */\n  public mergeParameterDescription(\n    description: string | undefined,\n    constraints: ConstraintHelperText,\n  ): string | undefined {\n    if (constraints.length > 0) {\n      return (description ? description + '\\n' : '') + `constraints: ${constraints.join(`, `)}`;\n    } else {\n      return description;\n    }\n  }\n\n  /**\n   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.\n   *\n   * @param value - The Zod type to check\n   * @param throwOnTypes - Array of type names to throw errors for\n   * @returns The original value if not in the throw list\n   * @throws Error if the type is in the unsupported list\n   */\n  public defaultUnsupportedZodTypeHandler<T extends z.AnyZodObject>(\n    value: z.ZodTypeAny,\n    throwOnTypes: readonly UnsupportedZodType[] = UNSUPPORTED_ZOD_TYPES,\n  ): ShapeValue<T> {\n    if (throwOnTypes.includes(value._def?.typeName as UnsupportedZodType)) {\n      throw new Error(`${this.model.modelId} does not support zod type: ${value._def?.typeName}`);\n    }\n    return value as ShapeValue<T>;\n  }\n\n  /**\n   * Default handler for Zod array types. Processes array constraints according to provider support.\n   *\n   * @param value - The Zod array to process\n   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod array\n   */\n  public defaultZodArrayHandler(\n    value: ZodArray<any, any>,\n    handleChecks: readonly ArrayCheckType[] = ALL_ARRAY_CHECKS,\n  ): ZodArray<any, any> {\n    const zodArrayDef = value._def;\n    const processedType = this.processZodType(zodArrayDef.type);\n\n    let result = z.array(processedType);\n\n    const constraints: ConstraintHelperText = [];\n\n    if (zodArrayDef.minLength?.value !== undefined) {\n      if (handleChecks.includes('min')) {\n        constraints.push(`minimum length ${zodArrayDef.minLength.value}`);\n      } else {\n        result = result.min(zodArrayDef.minLength.value);\n      }\n    }\n\n    if (zodArrayDef.maxLength?.value !== undefined) {\n      if (handleChecks.includes('max')) {\n        constraints.push(`maximum length ${zodArrayDef.maxLength.value}`);\n      } else {\n        result = result.max(zodArrayDef.maxLength.value);\n      }\n    }\n\n    if (zodArrayDef.exactLength?.value !== undefined) {\n      if (handleChecks.includes('length')) {\n        constraints.push(`exact length ${zodArrayDef.exactLength.value}`);\n      } else {\n        result = result.length(zodArrayDef.exactLength.value);\n      }\n    }\n\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod union types. Processes all union options.\n   *\n   * @param value - The Zod union to process\n   * @returns The processed Zod union\n   * @throws Error if union has fewer than 2 options\n   */\n  public defaultZodUnionHandler(value: ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]>): ZodTypeAny {\n    const processedOptions = value._def.options.map((option: ZodTypeAny) => this.processZodType(option));\n    if (processedOptions.length < 2) throw new Error('Union must have at least 2 options');\n    let result = z.union(processedOptions as [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]);\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod string types. Processes string validation constraints.\n   *\n   * @param value - The Zod string to process\n   * @param handleChecks - String constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod string\n   */\n  public defaultZodStringHandler(\n    value: ZodString,\n    handleChecks: readonly StringCheckType[] = ALL_STRING_CHECKS,\n  ): ZodString {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._def.checks || [];\n    type ZodStringCheck = (typeof checks)[number];\n    const newChecks: ZodStringCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        if (handleChecks.includes(check.kind as StringCheckType)) {\n          switch (check.kind) {\n            case 'regex': {\n              constraints.push(`input must match this regex ${check.regex.source}`);\n              break;\n            }\n            case 'emoji':\n            case 'email':\n            case 'url':\n            case 'uuid':\n            case 'cuid': {\n              constraints.push(`a valid ${check.kind}`);\n              break;\n            }\n            case 'min':\n            case 'max': {\n              constraints.push(`${check.kind}imum length ${check.value}`);\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.string();\n    for (const check of newChecks) {\n      result = result._addCheck(check);\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod number types. Processes number validation constraints.\n   *\n   * @param value - The Zod number to process\n   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod number\n   */\n  public defaultZodNumberHandler(\n    value: ZodNumber,\n    handleChecks: readonly NumberCheckType[] = ALL_NUMBER_CHECKS,\n  ): ZodNumber {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._def.checks || [];\n    type ZodNumberCheck = (typeof checks)[number];\n    const newChecks: ZodNumberCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        if (handleChecks.includes(check.kind as NumberCheckType)) {\n          switch (check.kind) {\n            case 'min':\n              if (check.inclusive) {\n                constraints.push(`greater than or equal to ${check.value}`);\n              } else {\n                constraints.push(`greater than ${check.value}`);\n              }\n              break;\n            case 'max':\n              if (check.inclusive) {\n                constraints.push(`lower than or equal to ${check.value}`);\n              } else {\n                constraints.push(`lower than ${check.value}`);\n              }\n              break;\n            case 'multipleOf': {\n              constraints.push(`multiple of ${check.value}`);\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.number();\n    for (const check of newChecks) {\n      switch (check.kind) {\n        case 'int':\n          result = result.int();\n          break;\n        case 'finite':\n          result = result.finite();\n          break;\n        default:\n          result = result._addCheck(check);\n      }\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.\n   *\n   * @param value - The Zod date to process\n   * @returns A Zod string schema representing the date in ISO format\n   */\n  public defaultZodDateHandler(value: ZodDate): ZodString {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._def.checks || [];\n    type ZodDateCheck = (typeof checks)[number];\n    const newChecks: ZodDateCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        switch (check.kind) {\n          case 'min':\n            const minDate = new Date(check.value);\n            if (!isNaN(minDate.getTime())) {\n              constraints.push(`Date must be newer than ${minDate.toISOString()} (ISO)`);\n            }\n            break;\n          case 'max':\n            const maxDate = new Date(check.value);\n            if (!isNaN(maxDate.getTime())) {\n              constraints.push(`Date must be older than ${maxDate.toISOString()} (ISO)`);\n            }\n            break;\n          default:\n            newChecks.push(check);\n        }\n      }\n    }\n    constraints.push(`Date format is date-time`);\n    let result = z.string().describe('date-time');\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod optional types. Processes the inner type and maintains optionality.\n   *\n   * @param value - The Zod optional to process\n   * @param handleTypes - Types that should be processed vs passed through\n   * @returns The processed Zod optional\n   */\n  public defaultZodOptionalHandler(\n    value: ZodOptional<any>,\n    handleTypes: readonly AllZodType[] = SUPPORTED_ZOD_TYPES,\n  ): ZodTypeAny {\n    if (handleTypes.includes(value._def.innerType._def.typeName as AllZodType)) {\n      return this.processZodType(value._def.innerType).optional();\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to an AI SDK Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns An AI SDK Schema with provider-specific compatibility applied\n   */\n  public processToAISDKSchema(zodSchema: z.ZodSchema): Schema {\n    const processedSchema = this.processZodType(zodSchema);\n\n    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to a JSON Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns A JSONSchema7 object with provider-specific compatibility applied\n   */\n  public processToJSONSchema(zodSchema: z.ZodSchema): JSONSchema7 {\n    return this.processToAISDKSchema(zodSchema).jsonSchema;\n  }\n}\n","import {\n  z,\n  ZodOptional,\n  ZodObject,\n  ZodArray,\n  ZodUnion,\n  ZodString,\n  ZodNumber,\n  ZodDate,\n  ZodDefault,\n  ZodNull,\n  ZodNullable,\n} from 'zod/v4';\nimport type { ZodAny, ZodType } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport type { JSONSchema7, Schema } from './json-schema';\nimport type { SchemaCompatLayer as ParentSchemaCompatLayer } from './schema-compatibility';\nimport type { ModelInformation } from './types';\nimport { convertZodSchemaToAISDKSchema } from './utils';\n\n/**\n * All supported string validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_STRING_CHECKS = [\n  'regex',\n  'emoji',\n  'email',\n  'url',\n  'uuid',\n  'cuid',\n  'min_length',\n  'max_length',\n  'string_format',\n] as const;\n\n/**\n * All supported number validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_NUMBER_CHECKS = ['greater_than', 'less_than', 'multiple_of'] as const;\n\n/**\n * All supported array validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_ARRAY_CHECKS = ['min', 'max', 'length'] as const;\n\n/**\n * Zod types that are not supported by most AI model providers and should be avoided.\n * @constant\n */\nexport const UNSUPPORTED_ZOD_TYPES = ['ZodIntersection', 'ZodNever', 'ZodNull', 'ZodTuple', 'ZodUndefined'] as const;\n\n/**\n * Zod types that are generally supported by AI model providers.\n * @constant\n */\nexport const SUPPORTED_ZOD_TYPES = [\n  'ZodObject',\n  'ZodArray',\n  'ZodUnion',\n  'ZodString',\n  'ZodNumber',\n  'ZodDate',\n  'ZodAny',\n  'ZodDefault',\n  'ZodNullable',\n] as const;\n\n/**\n * All Zod types (both supported and unsupported).\n * @constant\n */\nexport const ALL_ZOD_TYPES = [...SUPPORTED_ZOD_TYPES, ...UNSUPPORTED_ZOD_TYPES] as const;\n\n/**\n * Type representing string validation checks.\n */\nexport type StringCheckType = (typeof ALL_STRING_CHECKS)[number];\n\n/**\n * Type representing number validation checks.\n */\nexport type NumberCheckType = (typeof ALL_NUMBER_CHECKS)[number];\n\n/**\n * Type representing array validation checks.\n */\nexport type ArrayCheckType = (typeof ALL_ARRAY_CHECKS)[number];\n\n/**\n * Type representing unsupported Zod schema types.\n */\nexport type UnsupportedZodType = (typeof UNSUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing supported Zod schema types.\n */\nexport type SupportedZodType = (typeof SUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing all Zod schema types (supported and unsupported).\n */\nexport type AllZodType = (typeof ALL_ZOD_TYPES)[number];\n\n/**\n * Utility type to extract the shape of a Zod object schema.\n */\nexport type ZodShape<T extends z.ZodObject<any, any>> = T['shape'];\n\n/**\n * Utility type to extract the keys from a Zod object shape.\n */\nexport type ShapeKey<T extends z.ZodObject<any, any>> = keyof ZodShape<T>;\n\n/**\n * Utility type to extract the value types from a Zod object shape.\n */\nexport type ShapeValue<T extends z.ZodObject<any, any>> = ZodShape<T>[ShapeKey<T>];\n\ntype ConstraintHelperText = string[];\n\n/**\n * Abstract base class for creating schema compatibility layers for different AI model providers.\n *\n * This class provides a framework for transforming Zod schemas to work with specific AI model\n * provider requirements and limitations. Each provider may have different support levels for\n * JSON Schema features, validation constraints, and data types.\n *\n *\n * @example\n * ```typescript\n * import { SchemaCompatLayer } from '@mastra/schema-compat';\n * import type { LanguageModelV1 } from 'ai';\n *\n * class CustomProviderCompat extends SchemaCompatLayer {\n *   constructor(model: LanguageModelV1) {\n *     super(model);\n *   }\n *\n *   shouldApply(): boolean {\n *     return this.getModel().provider === 'custom-provider';\n *   }\n *\n *   getSchemaTarget() {\n *     return 'jsonSchema7';\n *   }\n *\n *   processZodType<T extends z.AnyZodObject>(value: z.ZodAny): ShapeValue<T> {\n *     // Custom processing logic for this provider\n *     switch (value._def.typeName) {\n *       case 'ZodString':\n *         return this.defaultZodStringHandler(value, ['email', 'url']);\n *       default:\n *         return this.defaultUnsupportedZodTypeHandler(value);\n *     }\n *   }\n * }\n * ```\n */\nexport class SchemaCompatLayer {\n  private model: ModelInformation;\n  private parent: ParentSchemaCompatLayer;\n\n  /**\n   * Creates a new schema compatibility instance.\n   *\n   * @param model - The language model this compatibility layer applies to\n   */\n  constructor(model: ModelInformation, parent: ParentSchemaCompatLayer) {\n    this.model = model;\n    this.parent = parent;\n  }\n\n  /**\n   * Gets the language model associated with this compatibility layer.\n   *\n   * @returns The language model instance\n   */\n  getModel(): ModelInformation {\n    return this.model;\n  }\n\n  getUnsupportedZodTypes(): readonly string[] {\n    return UNSUPPORTED_ZOD_TYPES;\n  }\n\n  /**\n   * Type guard for optional Zod types\n   */\n  isOptional(v: ZodAny | ZodOptional<any>): v is ZodOptional<any> {\n    return v instanceof ZodOptional;\n  }\n\n  /**\n   * Type guard for object Zod types\n   */\n  isObj(v: ZodAny | ZodObject<any, any>): v is ZodObject<any, any> {\n    return v instanceof ZodObject;\n  }\n\n  /**\n   * Type guard for null Zod types\n   */\n  isNull(v: ZodAny | ZodNull): v is ZodNull {\n    return v instanceof ZodNull;\n  }\n\n  /**\n   * Type guard for nullable Zod types\n   */\n  isNullable(v: ZodAny | ZodNullable<any>): v is ZodNullable<any> {\n    return v instanceof ZodNullable;\n  }\n\n  /**\n   * Type guard for array Zod types\n   */\n  isArr(v: ZodAny | ZodArray<any>): v is ZodArray<any> {\n    return v instanceof ZodArray;\n  }\n\n  /**\n   * Type guard for union Zod types\n   */\n  isUnion(v: ZodAny | ZodUnion<[ZodAny, ...ZodAny[]]>): v is ZodUnion<[ZodAny, ...ZodAny[]]> {\n    return v instanceof ZodUnion;\n  }\n\n  /**\n   * Type guard for string Zod types\n   */\n  isString(v: ZodAny | ZodString): v is ZodString {\n    return v instanceof ZodString;\n  }\n\n  /**\n   * Type guard for number Zod types\n   */\n  isNumber(v: ZodAny | ZodNumber): v is ZodNumber {\n    return v instanceof ZodNumber;\n  }\n\n  /**\n   * Type guard for date Zod types\n   */\n  isDate(v: ZodAny | ZodDate): v is ZodDate {\n    return v instanceof ZodDate;\n  }\n\n  /**\n   * Type guard for default Zod types\n   */\n  isDefault(v: ZodAny | ZodDefault<any>): v is ZodDefault<any> {\n    return v instanceof ZodDefault;\n  }\n\n  /**\n   * Determines whether this compatibility layer should be applied for the current model.\n   *\n   * @returns True if this compatibility layer should be used, false otherwise\n   * @abstract\n   */\n  shouldApply(): boolean {\n    return this.parent.shouldApply();\n  }\n\n  /**\n   * Returns the JSON Schema target format for this provider.\n   *\n   * @returns The schema target format, or undefined to use the default 'jsonSchema7'\n   * @abstract\n   */\n  getSchemaTarget(): Targets | undefined {\n    return this.parent.getSchemaTarget();\n  }\n\n  /**\n   * Processes a specific Zod type according to the provider's requirements.\n   *\n   * @param value - The Zod type to process\n   * @returns The processed Zod type\n   * @abstract\n   */\n  processZodType(value: ZodType): ZodType {\n    return this.parent.processZodType(value);\n  }\n\n  /**\n   * Default handler for Zod object types. Recursively processes all properties in the object.\n   *\n   * @param value - The Zod object to process\n   * @returns The processed Zod object\n   */\n  public defaultZodObjectHandler(\n    value: ZodObject<any, any>,\n    options: { passthrough?: boolean } = { passthrough: true },\n  ): ZodObject<any, any> {\n    const processedShape = Object.entries(value.shape).reduce<Record<string, ZodType>>((acc, [key, propValue]) => {\n      acc[key] = this.processZodType(propValue as ZodAny);\n      return acc;\n    }, {});\n\n    let result: ZodObject<any, any> = z.object(processedShape);\n\n    if (value._zod.def.catchall instanceof z.ZodNever) {\n      result = z.strictObject(processedShape);\n    }\n    if (value._zod.def.catchall && !(value._zod.def.catchall instanceof z.ZodNever)) {\n      result = result.catchall(value._zod.def.catchall);\n    }\n\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n\n    if (options.passthrough && value._zod.def.catchall instanceof z.ZodUnknown) {\n      result = z.looseObject(processedShape);\n    }\n\n    return result;\n  }\n\n  /**\n   * Merges validation constraints into a parameter description.\n   *\n   * This helper method converts validation constraints that may not be supported\n   * by a provider into human-readable descriptions.\n   *\n   * @param description - The existing parameter description\n   * @param constraints - The validation constraints to merge\n   * @returns The updated description with constraints, or undefined if no constraints\n   */\n  public mergeParameterDescription(\n    description: string | undefined,\n    constraints: ConstraintHelperText,\n  ): string | undefined {\n    if (constraints.length > 0) {\n      return (description ? description + '\\n' : '') + `constraints: ${constraints.join(`, `)}`;\n    } else {\n      return description;\n    }\n  }\n\n  /**\n   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.\n   *\n   * @param value - The Zod type to check\n   * @param throwOnTypes - Array of type names to throw errors for\n   * @returns The original value if not in the throw list\n   * @throws Error if the type is in the unsupported list\n   */\n  public defaultUnsupportedZodTypeHandler<T extends z.ZodObject<any, any>>(\n    value: z.ZodAny,\n    throwOnTypes: readonly UnsupportedZodType[] = UNSUPPORTED_ZOD_TYPES,\n  ): ShapeValue<T> {\n    if (throwOnTypes.includes(value.constructor.name as UnsupportedZodType)) {\n      throw new Error(`${this.model.modelId} does not support zod type: ${value.constructor.name}`);\n    }\n    return value as ShapeValue<T>;\n  }\n\n  /**\n   * Default handler for Zod array types. Processes array constraints according to provider support.\n   *\n   * @param value - The Zod array to process\n   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod array\n   */\n  public defaultZodArrayHandler(\n    value: ZodArray<any>,\n    handleChecks: readonly ArrayCheckType[] = ALL_ARRAY_CHECKS,\n  ): ZodArray<any> {\n    const zodArrayDef = value._zod.def;\n    const processedType = this.processZodType(zodArrayDef.element);\n\n    let result = z.array(processedType);\n\n    const constraints: ConstraintHelperText = [];\n    if (zodArrayDef.checks) {\n      for (const check of zodArrayDef.checks) {\n        if (check._zod.def.check === 'min_length') {\n          if (handleChecks.includes('min')) {\n            // @ts-expect-error - fix later\n            constraints.push(`minimum length ${check._zod.def.minimum}`);\n          } else {\n            // @ts-expect-error - fix later\n            result = result.min(check._zod.def.minimum);\n          }\n        }\n        if (check._zod.def.check === 'max_length') {\n          if (handleChecks.includes('max')) {\n            // @ts-expect-error - fix later\n            constraints.push(`maximum length ${check._zod.def.maximum}`);\n          } else {\n            // @ts-expect-error - fix later\n            result = result.max(check._zod.def.maximum);\n          }\n        }\n        if (check._zod.def.check === 'length_equals') {\n          if (handleChecks.includes('length')) {\n            // @ts-expect-error - fix later\n            constraints.push(`exact length ${check._zod.def.length}`);\n          } else {\n            // @ts-expect-error - fix later\n            result = result.length(check._zod.def.length);\n          }\n        }\n      }\n    }\n\n    const metaDescription = value.meta()?.description;\n    const legacyDescription = value.description;\n\n    const description = this.mergeParameterDescription(metaDescription || legacyDescription, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod union types. Processes all union options.\n   *\n   * @param value - The Zod union to process\n   * @returns The processed Zod union\n   * @throws Error if union has fewer than 2 options\n   */\n  public defaultZodUnionHandler(value: ZodUnion<[ZodAny, ...ZodAny[]]>): ZodAny {\n    const processedOptions = value._zod.def.options.map((option: ZodAny) => this.processZodType(option));\n    if (processedOptions.length < 2) throw new Error('Union must have at least 2 options');\n    let result = z.union(processedOptions as [ZodAny, ZodAny, ...ZodAny[]]);\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n    // @ts-expect-error - fix later\n    return result;\n  }\n\n  /**\n   * Default handler for Zod string types. Processes string validation constraints.\n   *\n   * @param value - The Zod string to process\n   * @param handleChecks - String constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod string\n   */\n  public defaultZodStringHandler(\n    value: ZodString,\n    handleChecks: readonly StringCheckType[] = ALL_STRING_CHECKS,\n  ): ZodString {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._zod.def.checks || [];\n    type ZodStringCheck = (typeof checks)[number];\n    const newChecks: ZodStringCheck[] = [];\n\n    if (checks) {\n      for (const check of checks) {\n        if (handleChecks.includes(check._zod.def.check as StringCheckType)) {\n          switch (check._zod.def.check) {\n            case 'min_length':\n              // @ts-expect-error - fix later\n              constraints.push(`minimum length ${check._zod.def.minimum}`);\n              break;\n            case 'max_length':\n              // @ts-expect-error - fix later\n              constraints.push(`maximum length ${check._zod.def.maximum}`);\n              break;\n            case 'string_format':\n              {\n                // @ts-expect-error - fix later\n                switch (check._zod.def.format) {\n                  case 'email':\n                  case 'url':\n                  case 'emoji':\n                  case 'uuid':\n                  case 'cuid':\n                    // @ts-expect-error - fix later\n                    constraints.push(`a valid ${check._zod.def.format}`);\n                    break;\n                  case 'regex':\n                    // @ts-expect-error - fix later\n                    constraints.push(`input must match this regex ${check._zod.def.pattern}`);\n                    break;\n                }\n              }\n              break;\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n\n    let result = z.string();\n    for (const check of newChecks) {\n      result = result.check(check);\n    }\n\n    const metaDescription = value.meta()?.description;\n    const legacyDescription = value.description;\n\n    const description = this.mergeParameterDescription(metaDescription || legacyDescription, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod number types. Processes number validation constraints.\n   *\n   * @param value - The Zod number to process\n   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod number\n   */\n  public defaultZodNumberHandler(\n    value: ZodNumber,\n    handleChecks: readonly NumberCheckType[] = ALL_NUMBER_CHECKS,\n  ): ZodNumber {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._zod.def.checks || [];\n    type ZodNumberCheck = (typeof checks)[number];\n    const newChecks: ZodNumberCheck[] = [];\n\n    if (checks) {\n      for (const check of checks) {\n        if (handleChecks.includes(check._zod.def.check as NumberCheckType)) {\n          switch (check._zod.def.check) {\n            case 'greater_than':\n              // @ts-expect-error - fix later\n              if (check._zod.def.inclusive) {\n                // @ts-expect-error - fix later\n                constraints.push(`greater than or equal to ${check._zod.def.value}`);\n              } else {\n                // @ts-expect-error - fix later\n                constraints.push(`greater than ${check._zod.def.value}`);\n              }\n              break;\n            case 'less_than':\n              // @ts-expect-error - fix later\n              if (check._zod.def.inclusive) {\n                // @ts-expect-error - fix later\n                constraints.push(`lower than or equal to ${check._zod.def.value}`);\n              } else {\n                // @ts-expect-error - fix later\n                constraints.push(`lower than ${check._zod.def.value}`);\n              }\n              break;\n            case 'multiple_of': {\n              // @ts-expect-error - fix later\n              constraints.push(`multiple of ${check._zod.def.value}`);\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.number();\n\n    for (const check of newChecks) {\n      switch (check._zod.def.check) {\n        case 'number_format': {\n          // @ts-expect-error - fix later\n          switch (check._zod.def.format) {\n            case 'safeint':\n              result = result.int();\n              break;\n          }\n          break;\n        }\n        default:\n          // @ts-expect-error - fix later\n          result = result.check(check);\n      }\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.\n   *\n   * @param value - The Zod date to process\n   * @returns A Zod string schema representing the date in ISO format\n   */\n  public defaultZodDateHandler(value: ZodDate): ZodString {\n    const constraints: ConstraintHelperText = [];\n    const checks = value._zod.def.checks || [];\n    type ZodDateCheck = (typeof checks)[number];\n    const newChecks: ZodDateCheck[] = [];\n    if (checks) {\n      for (const check of checks) {\n        switch (check._zod.def.check) {\n          case 'less_than':\n            // @ts-expect-error - fix later\n            const minDate = new Date(check._zod.def.value);\n            if (!isNaN(minDate.getTime())) {\n              constraints.push(`Date must be newer than ${minDate.toISOString()} (ISO)`);\n            }\n            break;\n          case 'greater_than':\n            // @ts-expect-error - fix later\n            const maxDate = new Date(check._zod.def.value);\n            if (!isNaN(maxDate.getTime())) {\n              constraints.push(`Date must be older than ${maxDate.toISOString()} (ISO)`);\n            }\n            break;\n          default:\n            newChecks.push(check);\n        }\n      }\n    }\n    constraints.push(`Date format is date-time`);\n    let result = z.string().describe('date-time');\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod optional types. Processes the inner type and maintains optionality.\n   *\n   * @param value - The Zod optional to process\n   * @param handleTypes - Types that should be processed vs passed through\n   * @returns The processed Zod optional\n   */\n  public defaultZodOptionalHandler(\n    value: ZodOptional<any>,\n    handleTypes: readonly AllZodType[] = SUPPORTED_ZOD_TYPES,\n  ): ZodType {\n    if (handleTypes.includes(value.constructor.name as AllZodType)) {\n      return this.processZodType(value._zod.def.innerType).optional();\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to an AI SDK Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns An AI SDK Schema with provider-specific compatibility applied\n   */\n  public processToAISDKSchema(zodSchema: ZodType): Schema {\n    const processedSchema = this.processZodType(zodSchema);\n\n    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to a JSON Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns A JSONSchema7 object with provider-specific compatibility applied\n   */\n  public processToJSONSchema(zodSchema: ZodType): JSONSchema7 {\n    return this.processToAISDKSchema(zodSchema).jsonSchema;\n  }\n}\n","import type { z as zV3 } from 'zod/v3';\nimport type { z as zV4, ZodType } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport type { JSONSchema7, Schema } from './json-schema';\nimport {\n  SchemaCompatLayer as SchemaCompatLayerV3,\n  ALL_STRING_CHECKS,\n  ALL_NUMBER_CHECKS,\n  ALL_ARRAY_CHECKS,\n  UNSUPPORTED_ZOD_TYPES as UNSUPPORTED_ZOD_TYPES_V3,\n  SUPPORTED_ZOD_TYPES as SUPPORTED_ZOD_TYPES_V3,\n} from './schema-compatibility-v3';\nimport type {\n  UnsupportedZodType as UnsupportedZodTypeV3,\n  ShapeValue as ShapeValueV3,\n  StringCheckType,\n  NumberCheckType,\n  ArrayCheckType,\n  AllZodType as AllZodTypeV3,\n} from './schema-compatibility-v3';\nimport {\n  SchemaCompatLayer as SchemaCompatLayerV4,\n  UNSUPPORTED_ZOD_TYPES as UNSUPPORTED_ZOD_TYPES_V4,\n  SUPPORTED_ZOD_TYPES as SUPPORTED_ZOD_TYPES_V4,\n} from './schema-compatibility-v4';\nimport type {\n  UnsupportedZodType as UnsupportedZodTypeV4,\n  ShapeValue as ShapeValueV4,\n  AllZodType as AllZodTypeV4,\n} from './schema-compatibility-v4';\nimport type { ModelInformation } from './types';\n\nimport { convertZodSchemaToAISDKSchema } from './utils';\n\ntype ConstraintHelperText = string[];\n\nexport abstract class SchemaCompatLayer {\n  private model: ModelInformation;\n  private v3Layer: SchemaCompatLayerV3;\n  private v4Layer: SchemaCompatLayerV4;\n\n  /**\n   * Creates a new schema compatibility instance.\n   *\n   * @param model - The language model this compatibility layer applies to\n   */\n  constructor(model: ModelInformation) {\n    this.model = model;\n    this.v3Layer = new SchemaCompatLayerV3(model, this);\n    this.v4Layer = new SchemaCompatLayerV4(model, this);\n  }\n\n  /**\n   * Gets the language model associated with this compatibility layer.\n   *\n   * @returns The language model instance\n   */\n  getModel(): ModelInformation {\n    return this.model;\n  }\n\n  getUnsupportedZodTypes(v: ZodType): readonly string[] {\n    if ('_zod' in v) {\n      return this.v4Layer.getUnsupportedZodTypes();\n    } else {\n      return this.v3Layer.getUnsupportedZodTypes();\n    }\n  }\n\n  /**\n   * Type guard for optional Zod types\n   */\n  isOptional(v: zV4.ZodType): v is zV4.ZodOptional<any>;\n  isOptional(v: zV3.ZodType): v is zV3.ZodOptional<any>;\n  isOptional(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isOptional(v);\n    } else {\n      return this.v3Layer.isOptional(v);\n    }\n  }\n\n  /**\n   * Type guard for object Zod types\n   */\n  isObj(v: zV4.ZodType): v is zV4.ZodObject<any, any>;\n  isObj(v: zV3.ZodType): v is zV3.ZodObject<any, any, any, any, any>;\n  isObj(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isObj(v);\n    } else {\n      return this.v3Layer.isObj(v);\n    }\n  }\n\n  /**\n   * Type guard for null Zod types\n   */\n  isNull(v: zV4.ZodType): v is zV4.ZodNull;\n  isNull(v: zV3.ZodType): v is zV3.ZodNull;\n  isNull(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isNull(v);\n    } else {\n      return this.v3Layer.isNull(v);\n    }\n  }\n\n  /**\n   * Type guard for array Zod types\n   */\n  isArr(v: zV4.ZodType): v is zV4.ZodArray<any>;\n  isArr(v: zV3.ZodType): v is zV3.ZodArray<any, any>;\n  isArr(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isArr(v);\n    } else {\n      return this.v3Layer.isArr(v);\n    }\n  }\n\n  /**\n   * Type guard for union Zod types\n   */\n  isUnion(v: zV4.ZodType): v is zV4.ZodUnion<[zV4.ZodType, ...zV4.ZodType[]]>;\n  isUnion(v: zV3.ZodType): v is zV3.ZodUnion<[zV3.ZodType, ...zV3.ZodType[]]>;\n  isUnion(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isUnion(v);\n    } else {\n      return this.v3Layer.isUnion(v);\n    }\n  }\n\n  /**\n   * Type guard for string Zod types\n   */\n  isString(v: zV4.ZodType): v is zV4.ZodString;\n  isString(v: zV3.ZodType): v is zV3.ZodString;\n  isString(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isString(v);\n    } else {\n      return this.v3Layer.isString(v);\n    }\n  }\n\n  /**\n   * Type guard for number Zod types\n   */\n  isNumber(v: zV4.ZodType): v is zV4.ZodNumber;\n  isNumber(v: zV3.ZodType): v is zV3.ZodNumber;\n  isNumber(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isNumber(v);\n    } else {\n      return this.v3Layer.isNumber(v);\n    }\n  }\n\n  /**\n   * Type guard for date Zod types\n   */\n  isDate(v: zV4.ZodType): v is zV4.ZodDate;\n  isDate(v: zV3.ZodType): v is zV3.ZodDate;\n  isDate(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isDate(v);\n    } else {\n      return this.v3Layer.isDate(v);\n    }\n  }\n\n  /**\n   * Type guard for default Zod types\n   */\n  isDefault(v: zV4.ZodType): v is zV4.ZodDefault<any>;\n  isDefault(v: zV3.ZodType): v is zV3.ZodDefault<any>;\n  isDefault(v: zV3.ZodType | zV4.ZodType) {\n    if ('_zod' in v) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.isDefault(v);\n    } else {\n      return this.v3Layer.isDefault(v);\n    }\n  }\n\n  /**\n   * Determines whether this compatibility layer should be applied for the current model.\n   *\n   * @returns True if this compatibility layer should be used, false otherwise\n   * @abstract\n   */\n  abstract shouldApply(): boolean;\n\n  /**\n   * Returns the JSON Schema target format for this provider.\n   *\n   * @returns The schema target format, or undefined to use the default 'jsonSchema7'\n   * @abstract\n   */\n  abstract getSchemaTarget(): Targets | undefined;\n\n  /**\n   * Processes a specific Zod type according to the provider's requirements.\n   *\n   * @param value - The Zod type to process\n   * @returns The processed Zod type\n   * @abstract\n   */\n  abstract processZodType(value: zV4.ZodType): zV4.ZodType;\n  abstract processZodType(value: zV3.ZodType): zV3.ZodType;\n  abstract processZodType(value: zV4.ZodType | zV3.ZodType): zV4.ZodType | zV3.ZodType;\n\n  /**\n   * Default handler for Zod object types. Recursively processes all properties in the object.\n   *\n   * @param value - The Zod object to process\n   * @returns The processed Zod object\n   */\n  public defaultZodObjectHandler(\n    value: zV4.ZodObject<any, any>,\n    options?: { passthrough?: boolean },\n  ): zV4.ZodObject<any, any>;\n  public defaultZodObjectHandler(\n    value: zV3.ZodObject<any, any>,\n    options?: { passthrough?: boolean },\n  ): zV3.ZodObject<any, any>;\n  public defaultZodObjectHandler(\n    value: zV3.ZodObject<any, any, any, any, any> | zV4.ZodObject<any, any>,\n    options: { passthrough?: boolean } = { passthrough: true },\n  ): zV3.ZodObject<any, any, any, any, any> | zV4.ZodObject<any, any> {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodObjectHandler(value, options);\n    } else {\n      return this.v3Layer.defaultZodObjectHandler(value, options);\n    }\n  }\n\n  /**\n   * Merges validation constraints into a parameter description.\n   *\n   * This helper method converts validation constraints that may not be supported\n   * by a provider into human-readable descriptions.\n   *\n   * @param description - The existing parameter description\n   * @param constraints - The validation constraints to merge\n   * @returns The updated description with constraints, or undefined if no constraints\n   */\n  public mergeParameterDescription(\n    description: string | undefined,\n    constraints: ConstraintHelperText,\n  ): string | undefined {\n    // This method doesn't depend on Zod version, so we can use either layer\n    return this.v3Layer.mergeParameterDescription(description, constraints);\n  }\n\n  /**\n   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.\n   *\n   * @param value - The Zod type to check\n   * @param throwOnTypes - Array of type names to throw errors for\n   * @returns The original value if not in the throw list\n   * @throws Error if the type is in the unsupported list\n   */\n  public defaultUnsupportedZodTypeHandler<T extends zV4.ZodObject | zV3.AnyZodObject>(\n    value: T,\n    throwOnTypes?: T extends zV4.ZodObject\n      ? UnsupportedZodTypeV4[]\n      : T extends zV3.AnyZodObject\n        ? UnsupportedZodTypeV3[]\n        : never,\n  ): T extends zV4.ZodObject ? ShapeValueV4<T> : T extends zV3.AnyZodObject ? ShapeValueV3<T> : never {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultUnsupportedZodTypeHandler(\n        // @ts-expect-error - fix later\n        value,\n        (throwOnTypes ?? UNSUPPORTED_ZOD_TYPES_V4) as typeof UNSUPPORTED_ZOD_TYPES_V4,\n      );\n    } else {\n      return this.v3Layer.defaultUnsupportedZodTypeHandler(\n        value,\n        (throwOnTypes ?? UNSUPPORTED_ZOD_TYPES_V3) as typeof UNSUPPORTED_ZOD_TYPES_V3,\n      );\n    }\n  }\n\n  /**\n   * Default handler for Zod array types. Processes array constraints according to provider support.\n   *\n   * @param value - The Zod array to process\n   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod array\n   */\n  public defaultZodArrayHandler(value: zV4.ZodArray<any>, handleChecks?: readonly ArrayCheckType[]): zV4.ZodArray<any>;\n  public defaultZodArrayHandler(\n    value: zV3.ZodArray<any, any>,\n    handleChecks?: readonly ArrayCheckType[],\n  ): zV3.ZodArray<any, any>;\n  public defaultZodArrayHandler(\n    value: zV4.ZodArray<any> | zV3.ZodArray<any, any>,\n    handleChecks: readonly ArrayCheckType[] = ALL_ARRAY_CHECKS,\n  ): zV4.ZodArray<any> | zV3.ZodArray<any, any> {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodArrayHandler(value, handleChecks);\n    } else {\n      return this.v3Layer.defaultZodArrayHandler(value, handleChecks);\n    }\n  }\n\n  /**\n   * Default handler for Zod union types. Processes all union options.\n   *\n   * @param value - The Zod union to process\n   * @returns The processed Zod union\n   * @throws Error if union has fewer than 2 options\n   */\n  public defaultZodUnionHandler(value: zV4.ZodUnion<[zV4.ZodType, ...zV4.ZodType[]]>): zV4.ZodType;\n  public defaultZodUnionHandler(value: zV3.ZodUnion<[zV3.ZodType, ...zV3.ZodType[]]>): zV3.ZodType;\n  public defaultZodUnionHandler(\n    value: zV4.ZodUnion<[zV4.ZodType, ...zV4.ZodType[]]> | zV3.ZodUnion<[zV3.ZodType, ...zV3.ZodType[]]>,\n  ): zV4.ZodType | zV3.ZodType {\n    if ('_zod' in value) {\n      // @ts-expect-error - fix later\n      return this.v4Layer.defaultZodUnionHandler(value);\n    } else {\n      return this.v3Layer.defaultZodUnionHandler(value);\n    }\n  }\n\n  /**\n   * Default handler for Zod string types. Processes string validation constraints.\n   *\n   * @param value - The Zod string to process\n   * @param handleChecks - String constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod string\n   */\n  public defaultZodStringHandler(value: zV4.ZodString, handleChecks?: readonly StringCheckType[]): zV4.ZodString;\n  public defaultZodStringHandler(value: zV3.ZodString, handleChecks?: readonly StringCheckType[]): zV3.ZodString;\n  public defaultZodStringHandler(\n    value: zV4.ZodString | zV3.ZodString,\n    handleChecks: readonly StringCheckType[] = ALL_STRING_CHECKS,\n  ): zV4.ZodString | zV3.ZodString {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodStringHandler(value);\n    } else {\n      return this.v3Layer.defaultZodStringHandler(value, handleChecks);\n    }\n  }\n\n  /**\n   * Default handler for Zod number types. Processes number validation constraints.\n   *\n   * @param value - The Zod number to process\n   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod number\n   */\n  public defaultZodNumberHandler(value: zV4.ZodNumber, handleChecks?: readonly NumberCheckType[]): zV4.ZodNumber;\n  public defaultZodNumberHandler(value: zV3.ZodNumber, handleChecks?: readonly NumberCheckType[]): zV3.ZodNumber;\n  public defaultZodNumberHandler(\n    value: zV4.ZodNumber | zV3.ZodNumber,\n    handleChecks: readonly NumberCheckType[] = ALL_NUMBER_CHECKS,\n  ): zV4.ZodNumber | zV3.ZodNumber {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodNumberHandler(value);\n    } else {\n      return this.v3Layer.defaultZodNumberHandler(value, handleChecks);\n    }\n  }\n\n  /**\n   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.\n   *\n   * @param value - The Zod date to process\n   * @returns A Zod string schema representing the date in ISO format\n   */\n  public defaultZodDateHandler(value: zV4.ZodDate): zV4.ZodString;\n  public defaultZodDateHandler(value: zV3.ZodDate): zV3.ZodString;\n  public defaultZodDateHandler(value: zV4.ZodDate | zV3.ZodDate): zV4.ZodString | zV3.ZodString {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodDateHandler(value);\n    } else {\n      return this.v3Layer.defaultZodDateHandler(value);\n    }\n  }\n\n  /**\n   * Default handler for Zod optional types. Processes the inner type and maintains optionality.\n   *\n   * @param value - The Zod optional to process\n   * @param handleTypes - Types that should be processed vs passed through\n   * @returns The processed Zod optional\n   */\n  public defaultZodOptionalHandler(value: zV4.ZodOptional<any>, handleTypes?: readonly AllZodTypeV4[]): zV4.ZodType;\n  public defaultZodOptionalHandler(value: zV3.ZodOptional<any>, handleTypes?: readonly AllZodTypeV3[]): zV3.ZodType;\n  public defaultZodOptionalHandler(\n    value: zV4.ZodOptional<any> | zV3.ZodOptional<any>,\n    handleTypes?: readonly AllZodTypeV3[] | readonly AllZodTypeV4[],\n  ): zV4.ZodType | zV3.ZodType {\n    if ('_zod' in value) {\n      return this.v4Layer.defaultZodOptionalHandler(value, handleTypes ?? SUPPORTED_ZOD_TYPES_V4);\n    } else {\n      return this.v3Layer.defaultZodOptionalHandler(value, handleTypes ?? SUPPORTED_ZOD_TYPES_V3);\n    }\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to an AI SDK Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns An AI SDK Schema with provider-specific compatibility applied\n   */\n  public processToAISDKSchema(zodSchema: zV3.ZodSchema | zV4.ZodType): Schema {\n    const processedSchema = this.processZodType(zodSchema);\n\n    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to a JSON Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns A JSONSchema7 object with provider-specific compatibility applied\n   */\n  public processToJSONSchema(zodSchema: zV3.ZodSchema | zV4.ZodType): JSONSchema7 {\n    return this.processToAISDKSchema(zodSchema).jsonSchema;\n  }\n}\n","import type { z as zV3 } from 'zod/v3';\nimport type { z as zV4 } from 'zod/v4';\n\nexport function isOptional<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodOptional<any>;\nexport function isOptional<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodOptional<any>;\nexport function isOptional<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodOptional'] => v instanceof z['ZodOptional'];\n}\n\nexport function isObj<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodObject<any>;\nexport function isObj<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodObject;\nexport function isObj<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodObject'] => v instanceof z['ZodObject'];\n}\n\nexport function isNull<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodNull;\nexport function isNull<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodNull;\nexport function isNull<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodNull'] => v instanceof z['ZodNull'];\n}\n\nexport function isArr<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodArray<any>;\nexport function isArr<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodArray;\nexport function isArr<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodArray'] => v instanceof z['ZodArray'];\n}\n\nexport function isUnion<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodUnion<any>;\nexport function isUnion<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodUnion;\nexport function isUnion<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodUnion'] => v instanceof z['ZodUnion'];\n}\n\nexport function isString<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodString;\nexport function isString<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodString;\nexport function isString<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodString'] => v instanceof z['ZodString'];\n}\n\nexport function isNumber<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodNumber;\nexport function isNumber<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodNumber;\nexport function isNumber<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodNumber'] => v instanceof z['ZodNumber'];\n}\n\nexport function isDate<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodDate;\nexport function isDate<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodDate;\nexport function isDate<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodDate'] => v instanceof z['ZodDate'];\n}\n\nexport function isDefault<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodDefault<any>;\nexport function isDefault<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodDefault;\nexport function isDefault<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodDefault'] => v instanceof z['ZodDefault'];\n}\n\nexport function isNullable<Z extends typeof zV3>(z: Z): (v: any) => v is zV3.ZodNullable<any>;\nexport function isNullable<Z extends typeof zV4>(z: Z): (v: any) => v is zV4.ZodNullable;\nexport function isNullable<Z extends typeof zV3 | typeof zV4>(z: Z) {\n  return (v: any): v is Z['ZodNullable'] => v instanceof z['ZodNullable'];\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3, ZodObject as ZodObjectV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4, ZodObject as ZodObjectV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { AllZodType as AllZodTypeV3 } from '../schema-compatibility-v3';\nimport type { AllZodType as AllZodTypeV4 } from '../schema-compatibility-v4';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isObj, isArr, isUnion, isString } from '../zodTypes';\n\nexport class AnthropicSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().modelId.includes('claude');\n  }\n\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      const handleTypes: AllZodTypeV3[] | AllZodTypeV4 = [\n        'ZodObject',\n        'ZodArray',\n        'ZodUnion',\n        'ZodNever',\n        'ZodUndefined',\n        'ZodTuple',\n      ];\n      if (this.getModel().modelId.includes('claude-3.5-haiku')) handleTypes.push('ZodString');\n      return this.defaultZodOptionalHandler(value, handleTypes);\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(z)(value)) {\n      // the claude-3.5-haiku model support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n\n      if (this.getModel().modelId.includes('claude-3.5-haiku')) {\n        return this.defaultZodStringHandler(value, ['max', 'min']);\n      } else {\n        return value;\n      }\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value as ZodObjectV4<any> | ZodObjectV3<any>, [\n      'ZodNever',\n      'ZodTuple',\n      'ZodUndefined',\n    ]);\n  }\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isObj, isArr, isUnion, isString } from '../zodTypes';\n\nexport class DeepSeekSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    // Deepseek R1 performs perfectly without this compat layer\n    return this.getModel().modelId.includes('deepseek') && !this.getModel().modelId.includes('r1');\n  }\n\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      return this.defaultZodOptionalHandler(value, ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodString', 'ZodNumber']);\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value, ['min', 'max']);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(z)(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n\n    return value;\n  }\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3, ZodObject as ZodObjectV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4, ZodObject as ZodObjectV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isNull, isObj, isArr, isUnion, isString, isNumber } from '../zodTypes';\n\nexport class GoogleSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().provider.includes('google') || this.getModel().modelId.includes('google');\n  }\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      return this.defaultZodOptionalHandler(value, ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodString', 'ZodNumber']);\n    } else if (isNull(z)(value)) {\n      // Google models don't support null, so we need to convert it to any and then refine it to null\n      return z\n        .any()\n        .refine(v => v === null, { message: 'must be null' })\n        .describe(value.description || 'must be null');\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(z)(value)) {\n      // Google models support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n      return this.defaultZodStringHandler(value);\n    } else if (isNumber(z)(value)) {\n      // Google models support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n      return this.defaultZodNumberHandler(value);\n    }\n    return this.defaultUnsupportedZodTypeHandler(value as ZodObjectV4<any> | ZodObjectV3<any>);\n  }\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isObj, isArr, isUnion, isNumber, isString } from '../zodTypes';\n\nexport class MetaSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().modelId.includes('meta');\n  }\n\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      return this.defaultZodOptionalHandler(value, ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodString', 'ZodNumber']);\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value, ['min', 'max']);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isNumber(z)(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(z)(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n\n    return value;\n  }\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3, ZodObject as ZodObjectV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4, ZodObject as ZodObjectV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isObj, isUnion, isArr, isString, isNullable, isDefault } from '../zodTypes';\n\nexport class OpenAISchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return `jsonSchema7`;\n  }\n\n  shouldApply(): boolean {\n    if (\n      !this.getModel().supportsStructuredOutputs &&\n      (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      // For OpenAI strict mode, convert .optional() to .nullable() with transform\n      // This ensures all fields are in the required array but can accept null values\n      // The transform converts null -> undefined to match original .optional() semantics\n      const innerType = '_def' in value ? value._def.innerType : (value as any)._zod?.def?.innerType;\n\n      if (innerType) {\n        // If inner is nullable, just process and return it with transform (strips the optional wrapper)\n        // This converts .optional().nullable() -> .nullable() with transform\n        if (isNullable(z)(innerType)) {\n          const processed = this.processZodType(innerType);\n          return processed.transform((val: any) => (val === null ? undefined : val));\n        }\n\n        // Otherwise, process inner, make it nullable, and add transform\n        // This converts .optional() -> .nullable() with transform that converts null to undefined\n        const processedInner = this.processZodType(innerType);\n        return processedInner.nullable().transform((val: any) => (val === null ? undefined : val));\n      }\n\n      return value;\n    } else if (isNullable(z)(value)) {\n      // Process nullable: unwrap, process inner, and re-wrap with nullable\n      const innerType = '_def' in value ? value._def.innerType : (value as any)._zod?.def?.innerType;\n      if (innerType) {\n        // Special case: if inner is optional, strip it and add transform for OpenAI strict mode\n        // This converts .nullable().optional() -> .nullable() with transform\n        if (isOptional(z)(innerType)) {\n          const innerInnerType =\n            '_def' in innerType ? innerType._def.innerType : (innerType as any)._zod?.def?.innerType;\n          if (innerInnerType) {\n            const processedInnerInner = this.processZodType(innerInnerType);\n            return processedInnerInner.nullable().transform((val: any) => (val === null ? undefined : val));\n          }\n        }\n\n        const processedInner = this.processZodType(innerType);\n        return processedInner.nullable();\n      }\n      return value;\n    } else if (isDefault(z)(value)) {\n      // For OpenAI strict mode, convert .default() to .nullable() with transform\n      // This ensures all fields are in the required array but can accept null values\n      // The transform converts null -> default value to match original .default() semantics\n      const innerType = '_def' in value ? value._def.innerType : (value as any)._zod?.def?.innerType;\n      const defaultValue = '_def' in value ? value._def.defaultValue : (value as any)._zod?.def?.defaultValue;\n\n      if (innerType) {\n        const processedInner = this.processZodType(innerType);\n        // Transform null -> default value (call defaultValue() if it's a function)\n        return processedInner.nullable().transform((val: any) => {\n          if (val === null) {\n            return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n          }\n          return val;\n        });\n      }\n\n      return value;\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isString(z)(value)) {\n      const model = this.getModel();\n      const checks = ['emoji'] as const;\n\n      if (model.modelId.includes('gpt-4o-mini')) {\n        return this.defaultZodStringHandler(value, ['emoji', 'regex']);\n      }\n\n      return this.defaultZodStringHandler(value, checks);\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value as ZodObjectV4<any> | ZodObjectV3<any>, [\n      'ZodNever',\n      'ZodUndefined',\n      'ZodTuple',\n    ]);\n  }\n}\n","import { z } from 'zod';\nimport type { ZodType as ZodTypeV3, ZodObject as ZodObjectV3 } from 'zod/v3';\nimport type { ZodType as ZodTypeV4, ZodObject as ZodObjectV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer } from '../schema-compatibility';\nimport type { ModelInformation } from '../types';\nimport { isOptional, isObj, isArr, isUnion, isDefault, isNumber, isString, isDate, isNullable } from '../zodTypes';\n\nexport class OpenAIReasoningSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: ModelInformation) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return `openApi3`;\n  }\n\n  isReasoningModel(): boolean {\n    // there isn't a good way to automatically detect reasoning models besides doing this.\n    // in the future when o5 is released this compat wont apply and we'll want to come back and update this class + our tests\n    return (\n      this.getModel().modelId.includes(`o3`) ||\n      this.getModel().modelId.includes(`o4`) ||\n      this.getModel().modelId.includes(`o1`)\n    );\n  }\n\n  shouldApply(): boolean {\n    if (\n      this.isReasoningModel() &&\n      (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  processZodType(value: ZodTypeV3): ZodTypeV3;\n  processZodType(value: ZodTypeV4): ZodTypeV4;\n  processZodType(value: ZodTypeV3 | ZodTypeV4): ZodTypeV3 | ZodTypeV4 {\n    if (isOptional(z)(value)) {\n      // For OpenAI reasoning models strict mode, convert .optional() to .nullable() with transform\n      // The transform converts null -> undefined to match original .optional() semantics\n      const innerType = '_def' in value ? value._def.innerType : (value as any)._zod?.def?.innerType;\n\n      if (innerType) {\n        // If inner is nullable, just process and return it with transform (strips the optional wrapper)\n        if (isNullable(z)(innerType)) {\n          const processed = this.processZodType(innerType);\n          return processed.transform((val: any) => (val === null ? undefined : val));\n        }\n\n        // Otherwise, process inner, make it nullable, and add transform\n        const processedInner = this.processZodType(innerType);\n        return processedInner.nullable().transform((val: any) => (val === null ? undefined : val));\n      }\n\n      return value;\n    } else if (isNullable(z)(value)) {\n      // Handle nullable: if inner is optional, strip it and add transform\n      // This converts .optional().nullable() -> .nullable() with transform\n      const innerType = '_def' in value ? value._def.innerType : (value as any)._zod?.def?.innerType;\n      if (innerType && isOptional(z)(innerType)) {\n        const innerInnerType = '_def' in innerType ? innerType._def.innerType : (innerType as any)._zod?.def?.innerType;\n        if (innerInnerType) {\n          const processedInnerInner = this.processZodType(innerInnerType);\n          return processedInnerInner.nullable().transform((val: any) => (val === null ? undefined : val));\n        }\n      }\n      // Otherwise process inner and re-wrap with nullable (no transform - intentionally nullable)\n      if (innerType) {\n        const processedInner = this.processZodType(innerType);\n        return processedInner.nullable();\n      }\n      return value;\n    } else if (isObj(z)(value)) {\n      return this.defaultZodObjectHandler(value, { passthrough: false });\n    } else if (isArr(z)(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isUnion(z)(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isDefault(z)(value)) {\n      const defaultDef = value._def;\n      const innerType = defaultDef.innerType;\n      // Handle both Zod v3 (function) and v4 (direct value)\n      const defaultValue =\n        typeof defaultDef.defaultValue === 'function' ? defaultDef.defaultValue() : defaultDef.defaultValue;\n      const constraints: string[] = [];\n      if (defaultValue !== undefined) {\n        constraints.push(`the default value is ${defaultValue}`);\n      }\n\n      const description = this.mergeParameterDescription(value.description, constraints);\n      let result = this.processZodType(innerType);\n      if (description) {\n        result = result.describe(description);\n      }\n      return result;\n    } else if (isNumber(z)(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(z)(value)) {\n      return this.defaultZodStringHandler(value);\n    } else if (isDate(z)(value)) {\n      return this.defaultZodDateHandler(value);\n    } else if (value.constructor.name === 'ZodAny') {\n      // It's bad practice in the tool to use any, it's not reasonable for models that don't support that OOTB, to cast every single possible type\n      // in the schema. Usually when it's \"any\" it could be a json object or a union of specific types.\n      return z\n        .string()\n        .describe(\n          (value.description ?? '') +\n            `\\nArgument was an \"any\" type, but you (the LLM) do not support \"any\", so it was cast to a \"string\" type`,\n        );\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value as ZodObjectV4<any> | ZodObjectV3<any>);\n  }\n}\n"],"names":["text","_AISDKError","name","marker","symbol","_a","_TypeValidationError","zodSchema","validator","SecureJSON","ZodFirstPartyTypeKind","object","types","x","base","jsonSchema","zodToJsonSchema","schema","textStreamPart","errorStreamPart","isCompatible","DiagComponentLogger","DiagLogLevel","DiagAPI","__spreadArray","__read","BaseContext","NoopContextManager","API_NAME","ContextAPI","TraceFlags","NonRecordingSpan","NoopTracer","ProxyTracer","NoopTracerProvider","ProxyTracerProvider","SpanStatusCode","TraceAPI","AISDKError","z","createIdGenerator","asSchema","parsePartialJson","safeParseJSON","safeValidateTypes","result","formatDataStreamPart","mergeIntoDataStream","toDataStream","toDataStreamResponse","toDataStreamInternal","convertJsonSchemaToZodV3","ALL_STRING_CHECKS","ALL_NUMBER_CHECKS","ALL_ARRAY_CHECKS","UNSUPPORTED_ZOD_TYPES","SUPPORTED_ZOD_TYPES","SchemaCompatLayer","ZodOptional","ZodObject","ZodNull","ZodNullable","ZodArray","ZodUnion","ZodString","ZodNumber","ZodDate","ZodDefault","isOptional","isObj","isArr","isUnion","isString","isNumber"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,4BAAA,UAAA,CAAA;IAAA,6FAAA,EAAA,OAAA,EAAA,MAAA,EAAA;QAEA,IAAM,SAAA,GAAY,OAAO,MAAA,KAAW,WAAA;QACpC,IAAM,cAAA,GAAiB,+IAAA;QACvB,IAAM,oBAAA,GAAuB,gKAAA;QAE7B,SAAS,MAAA,CAAQA,KAAAA,EAAM,OAAA,EAAS,OAAA,EAAS;YAEvC,IAAI,WAAW,IAAA,EAAM;gBACnB,IAAI,OAAA,KAAY,IAAA,IAAQ,OAAO,OAAA,KAAY,QAAA,EAAU;oBACnD,OAAA,GAAU,OAAA;oBACV,OAAA,GAAU,KAAA,CAAA;gBACZ;YACF;YAEA,IAAI,SAAA,IAAa,MAAA,CAAO,QAAA,CAASA,KAAI,CAAA,EAAG;gBACtCA,KAAAA,GAAOA,MAAK,QAAA,EAAA;YACd;YAGA,IAAIA,KAAAA,IAAQA,KAAAA,CAAK,UAAA,CAAW,CAAC,MAAM,KAAA,EAAQ;gBACzCA,KAAAA,GAAOA,KAAAA,CAAK,KAAA,CAAM,CAAC,CAAA;YACrB;YAGA,MAAM,GAAA,GAAM,IAAA,CAAK,KAAA,CAAMA,KAAAA,EAAM,OAAO,CAAA;YAGpC,IAAI,GAAA,KAAQ,IAAA,IAAQ,OAAO,GAAA,KAAQ,QAAA,EAAU;gBAC3C,OAAO,GAAA;YACT;YAEA,MAAM,WAAA,GAAe,OAAA,IAAW,OAAA,CAAQ,WAAA,IAAgB,OAAA;YACxD,MAAM,iBAAA,GAAqB,OAAA,IAAW,OAAA,CAAQ,iBAAA,IAAsB,OAAA;YAGpE,IAAI,WAAA,KAAgB,QAAA,IAAY,iBAAA,KAAsB,QAAA,EAAU;gBAC9D,OAAO,GAAA;YACT;YAEA,IAAI,WAAA,KAAgB,QAAA,IAAY,iBAAA,KAAsB,QAAA,EAAU;gBAC9D,IAAI,cAAA,CAAe,IAAA,CAAKA,KAAI,CAAA,KAAM,SAAS,oBAAA,CAAqB,IAAA,CAAKA,KAAI,CAAA,KAAM,KAAA,EAAO;oBACpF,OAAO,GAAA;gBACT;YACF,CAAA,MAAA,IAAW,WAAA,KAAgB,QAAA,IAAY,iBAAA,KAAsB,QAAA,EAAU;gBACrE,IAAI,cAAA,CAAe,IAAA,CAAKA,KAAI,CAAA,KAAM,KAAA,EAAO;oBACvC,OAAO,GAAA;gBACT;YACF,CAAA,MAAO;gBACL,IAAI,oBAAA,CAAqB,IAAA,CAAKA,KAAI,CAAA,KAAM,KAAA,EAAO;oBAC7C,OAAO,GAAA;gBACT;YACF;YAGA,OAAO,MAAA,CAAO,KAAK;gBAAE,WAAA;gBAAa;gBAAmB,IAAA,EAAM,OAAA,IAAW,OAAA,CAAQ,IAAA;YAAA,CAAM,CAAA;QACtF;QAEA,SAAS,MAAA,CAAQ,GAAA,EAAK,EAAE,WAAA,GAAc,OAAA,EAAS,oBAAoB,OAAA,EAAS,IAAA,EAAA,GAAS,CAAA,CAAA,EAAI;YACvF,IAAI,IAAA,GAAO;gBAAC,GAAG;aAAA;YAEf,MAAO,KAAK,MAAA,CAAQ;gBAClB,MAAM,KAAA,GAAQ,IAAA;gBACd,IAAA,GAAO,EAAA;gBAEP,KAAA,MAAW,QAAQ,KAAA,CAAO;oBACxB,IAAI,WAAA,KAAgB,YAAY,MAAA,CAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,IAAA,EAAM,WAAW,CAAA,EAAG;wBACvF,IAAI,SAAS,IAAA,EAAM;4BACjB,OAAO,IAAA;wBACT,CAAA,MAAA,IAAW,gBAAgB,OAAA,EAAS;4BAClC,MAAM,IAAI,YAAY,8CAA8C,CAAA;wBACtE;wBAEA,OAAO,IAAA,CAAK,SAAA;oBACd;oBAEA,IAAI,sBAAsB,QAAA,IACtB,MAAA,CAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,IAAA,EAAM,aAAa,CAAA,IACxD,MAAA,CAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,WAAA,EAAa,WAAW,CAAA,EAAG;wBACvE,IAAI,SAAS,IAAA,EAAM;4BACjB,OAAO,IAAA;wBACT,CAAA,MAAA,IAAW,sBAAsB,OAAA,EAAS;4BACxC,MAAM,IAAI,YAAY,8CAA8C,CAAA;wBACtE;wBAEA,OAAO,IAAA,CAAK,WAAA;oBACd;oBAEA,IAAA,MAAW,OAAO,IAAA,CAAM;wBACtB,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAG,CAAA;wBACtB,IAAI,KAAA,IAAS,OAAO,KAAA,KAAU,QAAA,EAAU;4BACtC,IAAA,CAAK,IAAA,CAAK,KAAK,CAAA;wBACjB;oBACF;gBACF;YACF;YACA,OAAO,GAAA;QACT;QAEA,SAAS,KAAA,CAAOA,KAAAA,EAAM,OAAA,EAAS,OAAA,EAAS;YACtC,MAAM,kBAAkB,KAAA,CAAM,eAAA;YAC9B,KAAA,CAAM,eAAA,GAAkB,CAAA;YACxB,IAAI;gBACF,OAAO,MAAA,CAAOA,KAAAA,EAAM,OAAA,EAAS,OAAO,CAAA;YACtC,CAAA,QAAA;gBACE,KAAA,CAAM,eAAA,GAAkB,eAAA;YAC1B;QACF;QAEA,SAAS,SAAA,CAAWA,KAAAA,EAAM,OAAA,EAAS;YACjC,MAAM,kBAAkB,KAAA,CAAM,eAAA;YAC9B,KAAA,CAAM,eAAA,GAAkB,CAAA;YACxB,IAAI;gBACF,OAAO,OAAOA,KAAAA,EAAM,OAAA,EAAS;oBAAE,IAAA,EAAM;gBAAA,CAAM,CAAA;YAC7C,CAAA,CAAA,OAAS,EAAA,EAAI;gBACX,OAAO,IAAA;YACT,CAAA,QAAA;gBACE,KAAA,CAAM,eAAA,GAAkB,eAAA;YAC1B;QACF;QAEA,MAAA,CAAO,OAAA,GAAU,KAAA;QACjB,MAAA,CAAO,OAAA,CAAQ,OAAA,GAAU,KAAA;QACzB,MAAA,CAAO,OAAA,CAAQ,KAAA,GAAQ,KAAA;QACvB,MAAA,CAAO,OAAA,CAAQ,SAAA,GAAY,SAAA;QAC3B,MAAA,CAAO,OAAA,CAAQ,IAAA,GAAO,MAAA;IAAA;AAAA,CAAA,CAAA;ACzHtB,IAAM,MAAA,GAAS,iBAAA;AACf,IAAM,MAAA,GAAS,MAAA,CAAO,GAAA,CAAI,MAAM,CAAA;AALhC,IAAA,EAAA;AAWO,IAAM,WAAA,GAAN,MAAMC,YAAAA,SAAmB,KAAA,CAAM;;;;;;;;MAgBpC,WAAA,CAAY,EACV,IAAA,EAAAC,OAAAA,EACA,OAAA,EACA,KAAA,EAKC,CAAA;QACD,KAAA,CAAM,OAAO,CAAA;QAxBf,IAAA,CAAkB,EAAA,CAAA,GAAU,IAAA;QA0B1B,IAAA,CAAK,IAAA,GAAOA,OAAAA;QACZ,IAAA,CAAK,KAAA,GAAQ,KAAA;IACf;;;;;MAOA,OAAO,WAAW,KAAA,EAAqC;QACrD,OAAOD,YAAAA,CAAW,SAAA,CAAU,KAAA,EAAO,MAAM,CAAA;IAC3C;IAEA,OAAiB,SAAA,CAAU,KAAA,EAAgBE,SAAAA,EAAyB;QAClE,MAAM,YAAA,GAAe,MAAA,CAAO,GAAA,CAAIA,SAAM,CAAA;QACtC,OACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,YACjB,YAAA,IAAgB,KAAA,IAChB,OAAO,KAAA,CAAM,YAAY,CAAA,KAAM,SAAA,IAC/B,KAAA,CAAM,YAAY,CAAA,KAAM,IAAA;IAE5B;AACF,CAAA;AAjDoB,EAAA,GAAA,MAAA;AADb,IAAM,UAAA,GAAN,WAAA;ACXA,SAAS,gBAAgB,KAAA,EAA4B;IAC1D,IAAI,SAAS,IAAA,EAAM;QACjB,OAAO,eAAA;IACT;IAEA,IAAI,OAAO,UAAU,QAAA,EAAU;QAC7B,OAAO,KAAA;IACT;IAEA,IAAI,iBAAiB,KAAA,EAAO;QAC1B,OAAO,KAAA,CAAM,OAAA;IACf;IAEA,OAAO,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA;AAC7B;ACZA,IAAMD,KAAAA,GAAO,yBAAA;AACb,IAAMC,OAAAA,GAAS,CAAA,gBAAA,EAAmBD,KAAI,CAAA,CAAA;AACtC,IAAME,OAAAA,GAAS,MAAA,CAAO,GAAA,CAAID,OAAM,CAAA;AAJhC,IAAAE,GAAAA;AASO,IAAM,oBAAA,GAAN,cAAmC,UAAA,CAAW;IAKnD,WAAA,CAAY,EACV,OAAA,EACA,KAAA,EACA,QAAA,EAKC,CAAA;QACD,KAAA,CAAM;YAAE,IAAA,EAAAH,KAAAA;YAAM,OAAA;YAAS;QAAA,CAAO,CAAA;QAbhC,IAAA,CAAkBG,GAAAA,CAAAA,GAAU,IAAA;QAe1B,IAAA,CAAK,QAAA,GAAW,QAAA;IAClB;IAEA,OAAO,WAAW,KAAA,EAA+C;QAC/D,OAAO,UAAA,CAAW,SAAA,CAAU,KAAA,EAAOF,OAAM,CAAA;IAC3C;AACF,CAAA;AArBoBE,GAAAA,GAAAD,OAAAA;ACPpB,IAAMF,KAAAA,GAAO,mBAAA;AACb,IAAMC,OAAAA,GAAS,CAAA,gBAAA,EAAmBD,KAAI,CAAA,CAAA;AACtC,IAAME,OAAAA,GAAS,MAAA,CAAO,GAAA,CAAID,OAAM,CAAA;AALhC,IAAAE,GAAAA;AAQO,IAAM,cAAA,GAAN,cAA6B,UAAA,CAAW;IAK7C,WAAA,CAAY,EAAE,IAAA,EAAAL,KAAAA,EAAM,KAAA,EAAA,CAA2C;QAC7D,KAAA,CAAM;YACJ,IAAA,EAAAE,KAAAA;YACA,OAAA,EACE,CAAA,2BAAA,EACSF,KAAI,CAAA;eACK,EAAA,eAAA,CAAgB,KAAK,CAAC,CAAA,CAAA;YAC1C;QACD,CAAA,CAAA;QAZH,IAAA,CAAkBK,GAAAA,CAAAA,GAAU,IAAA;QAc1B,IAAA,CAAK,IAAA,GAAOL,KAAAA;IACd;IAEA,OAAO,WAAW,KAAA,EAAyC;QACzD,OAAO,UAAA,CAAW,SAAA,CAAU,KAAA,EAAOG,OAAM,CAAA;IAC3C;AACF,CAAA;AApBoBE,GAAAA,GAAAD,OAAAA;ACNpB,IAAMF,MAAAA,GAAO,wBAAA;AACb,IAAMC,QAAAA,GAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA,CAAA;AACtC,IAAME,QAAAA,GAAS,MAAA,CAAO,GAAA,CAAID,QAAM,CAAA;AALhC,IAAAE,IAAAA;AAOO,IAAM,oBAAA,GAAN,MAAMC,qBAAAA,SAA4B,UAAA,CAAW;IAKlD,WAAA,CAAY,EAAE,KAAA,EAAO,KAAA,EAAA,CAA6C;QAChE,KAAA,CAAM;YACJ,IAAA,EAAAJ,MAAAA;YACA,OAAA,EACE,CAAA,+BAAA,EACU,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA;eACb,EAAA,eAAA,CAAgB,KAAK,CAAC,CAAA,CAAA;YAC1C;QACD,CAAA,CAAA;QAZH,IAAA,CAAkBG,IAAAA,CAAAA,GAAU,IAAA;QAc1B,IAAA,CAAK,KAAA,GAAQ,KAAA;IACf;IAEA,OAAO,WAAW,KAAA,EAA8C;QAC9D,OAAO,UAAA,CAAW,SAAA,CAAU,KAAA,EAAOF,QAAM,CAAA;IAC3C;;;;;;;;;;MAYA,OAAO,IAAA,CAAK,EACV,KAAA,EACA,KAAA,EAIsB,EAAA;QACtB,OAAOG,qBAAAA,CAAoB,UAAA,CAAW,KAAK,CAAA,IAAK,KAAA,CAAM,KAAA,KAAU,KAAA,GAC5D,KAAA,GACA,IAAIA,qBAAAA,CAAoB;YAAE,KAAA;YAAO;QAAA,CAAO,CAAA;IAC9C;AACF,CAAA;AA1CoBD,IAAAA,GAAAD,QAAAA;AADb,IAAM,mBAAA,GAAN,oBAAA;ACLP,IAAI,cAAA,GAAiB,CAAC,QAAA,EAAU,WAAA,GAAc,EAAA,KAAO;IACnD,OAAO,CAAC,OAAO,WAAA,KAAgB;QAC7B,IAAI,EAAA,GAAK,EAAA;QACT,IAAI,IAAI,IAAA,GAAO,CAAA;QACf,MAAO,CAAA,EAAA,CAAK;YACV,EAAA,IAAM,QAAA,CAAU,IAAA,CAAK,MAAA,EAAA,GAAW,QAAA,CAAS,MAAA,GAAU,CAAC,CAAA;QACtD;QACA,OAAO,EAAA;IACT,CAAA;AACF,CAAA;ACNA,IAAA,wBAAA,GAAuB,OAAA,CAAA,yBAAA,EAAA,CAAA;ACEhB,SAAS,qCACd,QAAA,EACmB;IACnB,OAAO,IAAI,cAAA,CAAkB;;;;;;QAO3B,MAAM,MAAK,UAAA,EAAY;YACrB,IAAI;gBACF,MAAM,EAAE,KAAA,EAAO,IAAA,EAAA,GAAS,MAAM,SAAS,IAAA,EAAA;gBACvC,IAAI,IAAA,EAAM;oBACR,UAAA,CAAW,KAAA,EAAA;gBACb,CAAA,MAAO;oBACL,UAAA,CAAW,OAAA,CAAQ,KAAK,CAAA;gBAC1B;YACF,CAAA,CAAA,OAAS,KAAA,EAAO;gBACd,UAAA,CAAW,KAAA,CAAM,KAAK,CAAA;YACxB;QACF,CAAA;;;QAIA,MAAA,GAAS,EAAC;IACX,CAAA,CAAA;AACH;ACpBO,IAAM,oBAAoB,CAAC,EAChC,MAAA,EACA,IAAA,EAAM,WAAA,GAAc,EAAA,EACpB,QAAA,GAAW,gEAAA,EACX,SAAA,GAAY,GAAA,EACd,GAKI,CAAA,CAAA,KAAoC;IACtC,MAAM,SAAA,GAAY,cAAA,CAAe,QAAA,EAAU,WAAW,CAAA;IAEtD,IAAI,UAAU,IAAA,EAAM;QAClB,OAAO,SAAA;IACT;IAGA,IAAI,QAAA,CAAS,QAAA,CAAS,SAAS,CAAA,EAAG;QAChC,MAAM,IAAI,oBAAA,CAAqB;YAC7B,QAAA,EAAU,WAAA;YACV,OAAA,EAAS,CAAA,eAAA,EAAkB,SAAS,CAAA,oCAAA,EAAuC,QAAQ,CAAA,EAAA,CAAA;QACpF,CAAA,CAAA;IACH;IAEA,OAAO,CAAA,OAAQ,CAAA,EAAG,MAAM,GAAG,SAAS,CAAA,EAAG,SAAA,CAAU,IAAI,CAAC,CAAA,CAAA;AACxD,CAAA;AAY0B,iBAAA;AC/CnB,IAAM,eAAA,GAAA,aAAA,GAAkB,MAAA,CAAO,GAAA,CAAI,qBAAqB,CAAA;AAwBxD,SAAS,UACd,QAAA,EACmB;IACnB,OAAO;QAAE,CAAC,eAAe,CAAA,EAAG;QAAM,QAAA;IAAA,CAAA;AACpC;AAEO,SAAS,YAAY,KAAA,EAAoC;IAC9D,OACE,OAAO,KAAA,KAAU,QAAA,IACjB,KAAA,KAAU,IAAA,IACV,eAAA,IAAmB,KAAA,IACnB,KAAA,CAAM,eAAe,CAAA,KAAM,IAAA,IAC3B,UAAA,IAAc,KAAA;AAElB;AAEO,SAAS,YACd,KAAA,EACmB;IACnB,OAAO,WAAA,CAAY,KAAK,CAAA,GAAI,KAAA,GAAQ,aAAa,KAAK,CAAA;AACxD;AAEO,SAAS,aACdG,UAAAA,EACmB;IACnB,OAAO,SAAA,CAAU,CAAA,KAAA,KAAS;QACxB,MAAM,MAAA,GAASA,UAAAA,CAAU,SAAA,CAAU,KAAK,CAAA;QACxC,OAAO,MAAA,CAAO,OAAA,GACV;YAAE,OAAA,EAAS;YAAM,KAAA,EAAO,MAAA,CAAO,IAAA;QAAA,CAAA,GAC/B;YAAE,OAAA,EAAS,KAAA;YAAO,KAAA,EAAO,OAAO,KAAA;QAAA,CAAA;IACtC,CAAC,CAAA;AACH;ACtBO,SAAS,iBAAA,CAAqB,EACnC,KAAA,EACA,MAAA,EACF,EAKmD;IACjD,MAAMC,UAAAA,GAAY,YAAY,MAAM,CAAA;IAEpC,IAAI;QACF,IAAIA,UAAAA,CAAU,QAAA,IAAY,IAAA,EAAM;YAC9B,OAAO;gBAAE,OAAA,EAAS,IAAA;gBAAM,KAAA;YAAA,CAAA;QAC1B;QAEA,MAAM,MAAA,GAASA,UAAAA,CAAU,QAAA,CAAS,KAAK,CAAA;QAEvC,IAAI,OAAO,OAAA,EAAS;YAClB,OAAO,MAAA;QACT;QAEA,OAAO;YACL,OAAA,EAAS,KAAA;YACT,KAAA,EAAO,oBAAoB,IAAA,CAAK;gBAAE;gBAAO,KAAA,EAAO,MAAA,CAAO,KAAA;YAAA,CAAO;QAChE,CAAA;IACF,CAAA,CAAA,OAAS,KAAA,EAAO;QACd,OAAO;YACL,OAAA,EAAS,KAAA;YACT,KAAA,EAAO,oBAAoB,IAAA,CAAK;gBAAE,KAAA;gBAAO,KAAA,EAAO;YAAA,CAAO;QACzD,CAAA;IACF;AACF;AJeO,SAAS,aAAA,CAAiB,EAC/B,IAAA,EAAAR,KAAAA,EACA,MAAA,EACF,EAGmB;IACjB,IAAI;QACF,MAAM,KAAA,GAAQ,wBAAA,CAAAS,OAAAA,CAAW,KAAA,CAAMT,KAAI,CAAA;QAEnC,IAAI,UAAU,IAAA,EAAM;YAClB,OAAO;gBAAE,OAAA,EAAS,IAAA;gBAAM,KAAA;gBAAmB,UAAU,KAAA;YAAA,CAAA;QACvD;QAEA,MAAM,gBAAA,GAAmB,iBAAA,CAAkB;YAAE,KAAA;YAAO;QAAA,CAAQ,CAAA;QAE5D,OAAO,iBAAiB,OAAA,GACpB;YAAE,GAAG,gBAAA;YAAkB,QAAA,EAAU;QAAA,CAAA,GACjC,gBAAA;IACN,CAAA,CAAA,OAAS,KAAA,EAAO;QACd,OAAO;YACL,OAAA,EAAS,KAAA;YACT,KAAA,EAAO,cAAA,CAAe,UAAA,CAAW,KAAK,CAAA,GAClC,KAAA,GACA,IAAI,cAAA,CAAe;gBAAE,IAAA,EAAAA,KAAAA;gBAAM,KAAA,EAAO,KAAA;YAAA,CAAO;QAC/C,CAAA;IACF;AACF;AKhHO,IAAM,cAAA,GAAA,aAAA,GAAA,OAAwB,mDAAmD,CAAA;AAajF,IAAM,cAAA,GAAiB;IAC1B,IAAA,EAAM,KAAA,CAAA;IACN,YAAA,EAAc,MAAA;IACd,QAAA,EAAU;QAAC,GAAG;KAAA;IACd,cAAA,EAAgB,OAAA;IAChB,YAAA,EAAc,KAAA;IACd,YAAA,EAAc,kBAAA;IACd,WAAA,EAAa,SAAA;IACb,wBAAA,EAA0B,aAAA;IAC1B,2BAAA,EAA6B,IAAA;IAC7B,4BAAA,EAA8B,KAAA;IAC9B,cAAA,EAAgB,aAAA;IAChB,MAAA,EAAQ,aAAA;IACR,YAAA,EAAc,KAAA;IACd,WAAA,EAAa,CAAA,CAAA;IACb,aAAA,EAAe,KAAA;IACf,mBAAA,EAAqB,KAAA;IACrB,eAAA,EAAiB,QAAA;IACjB,eAAA,EAAiB,KAAA;IACjB,aAAA,EAAe,cAAA;IACf,cAAA,EAAgB,wBAAA;IAChB,YAAA,EAAc,KAAA;IACd,iBAAA,EAAmB;AACvB,CAAA;AACO,IAAM,iBAAA,GAAoB,CAAC,OAAA,GAAa,OAAO,YAAY,QAAA,GAC5D;QACE,GAAG,cAAA;QACH,IAAA,EAAM;IACV,CAAA,GACE;QACE,GAAG,cAAA;QACH,GAAG,OAAA;IACP,CAAA;AC5CG,IAAM,OAAA,GAAU,CAAC,OAAA,KAAY;IAChC,MAAM,QAAA,GAAW,kBAAkB,OAAO,CAAA;IAC1C,MAAM,WAAA,GAAc,QAAA,CAAS,IAAA,KAAS,KAAA,CAAA,GAChC,CAAC;WAAG,QAAA,CAAS,QAAA;QAAU,QAAA,CAAS,cAAA;QAAgB,QAAA,CAAS,IAAI;KAAA,GAC7D,QAAA,CAAS,QAAA;IACf,OAAO;QACH,GAAG,QAAA;QACH,KAAA,EAAO;YAAE,4BAA4B,KAAA;QAAA,CAAA;QACrC,WAAA;QACA,YAAA,EAAc,KAAA,CAAA;QACd,IAAA,EAAM,IAAI,GAAA,CAAI,MAAA,CAAO,OAAA,CAAQ,QAAA,CAAS,WAAW,CAAA,CAAE,GAAA,CAAI,CAAC,CAACE,MAAAA,EAAM,GAAG,CAAA,GAAM;gBACpE,GAAA,CAAI,IAAA;gBACJ;oBACI,GAAA,EAAK,GAAA,CAAI,IAAA;oBACT,IAAA,EAAM,CAAC;2BAAG,QAAA,CAAS,QAAA;wBAAU,QAAA,CAAS,cAAA;wBAAgBA,MAAI;qBAAA;;oBAE1D,UAAA,EAAY,KAAA;gBAAA;aAEnB,CAAC;IAAA,CAAA;AAEV,CAAA;ACrBO,SAAS,eAAA,CAAgB,GAAA,EAAK,GAAA,EAAK,YAAA,EAAc,IAAA,EAAM;IAC1D,IAAI,CAAC,IAAA,EAAM,aAAA,EACP;IACJ,IAAI,YAAA,EAAc;QACd,GAAA,CAAI,YAAA,GAAe;YACf,GAAG,GAAA,CAAI,YAAA;YACP,CAAC,GAAG,CAAA,EAAG;QAAA,CAAA;IAEf;AACJ;AACO,SAAS,yBAAA,CAA0B,GAAA,EAAK,GAAA,EAAK,KAAA,EAAO,YAAA,EAAc,IAAA,EAAM;IAC3E,GAAA,CAAI,GAAG,CAAA,GAAI,KAAA;IACX,eAAA,CAAgB,GAAA,EAAK,GAAA,EAAK,YAAA,EAAc,IAAI,CAAA;AAChD;ACbO,IAAM,eAAA,GAAkB,CAAC,KAAA,EAAO,KAAA,KAAU;IAC7C,IAAI,CAAA,GAAI,CAAA;IACR,MAAO,IAAI,KAAA,CAAM,MAAA,IAAU,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,CAAK;QAC9C,IAAI,KAAA,CAAM,CAAC,CAAA,KAAM,KAAA,CAAM,CAAC,CAAA,EACpB;IACR;IACA,OAAO;QAAA,CAAE,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG,QAAA,EAAA,EAAY;WAAG,KAAA,CAAM,KAAA,CAAM,CAAC,CAAC;KAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AACtE,CAAA;ACNO,SAAS,YAAY,IAAA,EAAM;IAC9B,IAAI,IAAA,CAAK,MAAA,KAAW,QAAA,EAAU;QAC1B,OAAO,CAAA,CAAA;IACX;IACA,MAAM,iBAAA,GAAoB;WACnB,IAAA,CAAK,QAAA;QACR,IAAA,CAAK,cAAA;QACL,IAAA,CAAK,iBAAA;KAAA;IAET,IAAA,CAAK,KAAA,CAAM,0BAAA,GAA6B,IAAA;IACxC,OAAO;QACH,IAAA,EAAM,IAAA,CAAK,YAAA,KAAiB,UAAA,GACtB,eAAA,CAAgB,iBAAA,EAAmB,KAAK,WAAW,CAAA,GACnD,iBAAA,CAAkB,IAAA,CAAK,GAAG;IAAA,CAAA;AAExC;ACbO,SAAS,aAAA,CAAc,GAAA,EAAK,IAAA,EAAM;IACrC,MAAM,GAAA,GAAM;QACR,IAAA,EAAM;IAAA,CAAA;IAEV,IAAI,GAAA,CAAI,IAAA,EAAM,IAAA,IACV,GAAA,CAAI,IAAA,EAAM,IAAA,EAAM,QAAA,KAAa,6JAAA,CAAsB,MAAA,EAAQ;QAC3D,GAAA,CAAI,KAAA,GAAQ,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM;YAChC,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa,OAAO;aAAA;SAC7C,CAAA;IACL;IACA,IAAI,IAAI,SAAA,EAAW;QACf,yBAAA,CAA0B,GAAA,EAAK,YAAY,GAAA,CAAI,SAAA,CAAU,KAAA,EAAO,GAAA,CAAI,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA;IAC/F;IACA,IAAI,IAAI,SAAA,EAAW;QACf,yBAAA,CAA0B,GAAA,EAAK,YAAY,GAAA,CAAI,SAAA,CAAU,KAAA,EAAO,GAAA,CAAI,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA;IAC/F;IACA,IAAI,IAAI,WAAA,EAAa;QACjB,yBAAA,CAA0B,GAAA,EAAK,YAAY,GAAA,CAAI,WAAA,CAAY,KAAA,EAAO,GAAA,CAAI,WAAA,CAAY,OAAA,EAAS,IAAI,CAAA;QAC/F,yBAAA,CAA0B,GAAA,EAAK,YAAY,GAAA,CAAI,WAAA,CAAY,KAAA,EAAO,GAAA,CAAI,WAAA,CAAY,OAAA,EAAS,IAAI,CAAA;IACnG;IACA,OAAO,GAAA;AACX;ACxBO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;IACtC,MAAM,GAAA,GAAM;QACR,IAAA,EAAM,SAAA;QACN,MAAA,EAAQ;IAAA,CAAA;IAEZ,IAAI,CAAC,GAAA,CAAI,MAAA,EACL,OAAO,GAAA;IACX,KAAA,MAAW,KAAA,IAAS,IAAI,MAAA,CAAQ;QAC5B,OAAQ,MAAM,IAAA;YACV,KAAK,KAAA;gBACD,IAAI,IAAA,CAAK,MAAA,KAAW,aAAA,EAAe;oBAC/B,IAAI,MAAM,SAAA,EAAW;wBACjB,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC9E,CAAA,MACK;wBACD,yBAAA,CAA0B,KAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACvF;gBACJ,CAAA,MACK;oBACD,IAAI,CAAC,MAAM,SAAA,EAAW;wBAClB,GAAA,CAAI,gBAAA,GAAmB,IAAA;oBAC3B;oBACA,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC9E;gBACA;YACJ,KAAK,KAAA;gBACD,IAAI,IAAA,CAAK,MAAA,KAAW,aAAA,EAAe;oBAC/B,IAAI,MAAM,SAAA,EAAW;wBACjB,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC9E,CAAA,MACK;wBACD,yBAAA,CAA0B,KAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACvF;gBACJ,CAAA,MACK;oBACD,IAAI,CAAC,MAAM,SAAA,EAAW;wBAClB,GAAA,CAAI,gBAAA,GAAmB,IAAA;oBAC3B;oBACA,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC9E;gBACA;YACJ,KAAK,YAAA;gBACD,yBAAA,CAA0B,KAAK,YAAA,EAAc,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC7E;QAAA;IAEZ;IACA,OAAO,GAAA;AACX;AChDO,SAAS,eAAA,GAAkB;IAC9B,OAAO;QACH,IAAA,EAAM;IAAA,CAAA;AAEd;ACHO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;IACxC,OAAO,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,IAAA,EAAM,IAAI,CAAA;AACxC;ACFO,IAAM,aAAA,GAAgB,CAAC,GAAA,EAAK,IAAA,KAAS;IACxC,OAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;AAC5C,CAAA;ACFO,SAAS,YAAA,CAAa,GAAA,EAAK,IAAA,EAAM,oBAAA,EAAsB;IAC1D,MAAM,QAAA,GAAW,wBAAwB,IAAA,CAAK,YAAA;IAC9C,IAAI,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,EAAG;QACzB,OAAO;YACH,KAAA,EAAO,QAAA,CAAS,GAAA,CAAI,CAAC,IAAA,EAAM,IAAM,YAAA,CAAa,GAAA,EAAK,IAAA,EAAM,IAAI,CAAC;QAAA,CAAA;IAEtE;IACA,OAAQ,QAAA;QACJ,KAAK,QAAA;QACL,KAAK,kBAAA;YACD,OAAO;gBACH,IAAA,EAAM,QAAA;gBACN,MAAA,EAAQ;YAAA,CAAA;QAEhB,KAAK,aAAA;YACD,OAAO;gBACH,IAAA,EAAM,QAAA;gBACN,MAAA,EAAQ;YAAA,CAAA;QAEhB,KAAK,SAAA;YACD,OAAO,iBAAA,CAAkB,KAAK,IAAI,CAAA;IAAA;AAE9C;AACA,IAAM,iBAAA,GAAoB,CAAC,GAAA,EAAK,IAAA,KAAS;IACrC,MAAM,GAAA,GAAM;QACR,IAAA,EAAM,SAAA;QACN,MAAA,EAAQ;IAAA,CAAA;IAEZ,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,EAAY;QAC5B,OAAO,GAAA;IACX;IACA,KAAA,MAAW,KAAA,IAAS,IAAI,MAAA,CAAQ;QAC5B,OAAQ,MAAM,IAAA;YACV,KAAK,KAAA;gBACD,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA;gBAChD,KAAA,CAAM,OAAA,EAAS;gBACf;YACJ,KAAK,KAAA;gBACD,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA;gBAChD,KAAA,CAAM,OAAA,EAAS;gBACf;QAAA;IAEZ;IACA,OAAO,GAAA;AACX,CAAA;AC5CO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;IACxC,OAAO;QACH,GAAG,QAAA,CAAS,IAAA,CAAK,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;QACrC,OAAA,EAAS,KAAK,YAAA;IAAa,CAAA;AAEnC;ACJO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;IACxC,OAAO,IAAA,CAAK,cAAA,KAAmB,OAAA,GACzB,QAAA,CAAS,IAAA,CAAK,MAAA,CAAO,IAAA,EAAM,IAAI,CAAA,GAC/B,WAAA,CAAY,IAAI,CAAA;AAC1B;ACNO,SAAS,aAAa,GAAA,EAAK;IAC9B,OAAO;QACH,IAAA,EAAM,QAAA;QACN,IAAA,EAAM,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAM;IAAA,CAAA;AAEnC;ACJA,IAAM,sBAAA,GAAyB,CAAC,IAAA,KAAS;IACrC,IAAI,MAAA,IAAU,IAAA,IAAQ,IAAA,CAAK,IAAA,KAAS,QAAA,EAChC,OAAO,KAAA;IACX,OAAO,OAAA,IAAW,IAAA;AACtB,CAAA;AACO,SAAS,oBAAA,CAAqB,GAAA,EAAK,IAAA,EAAM;IAC5C,MAAM,KAAA,GAAQ;QACV,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM;YACpB,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa;gBAAS,GAAG;aAAA;SAClD,CAAA;QACD,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,IAAA,EAAM;YACrB,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa;gBAAS,GAAG;aAAA;SAClD;KAAA,CACH,MAAA,CAAO,CAAC,CAAA,GAAM,CAAC,CAAC,CAAC,CAAA;IACnB,IAAI,wBAAwB,IAAA,CAAK,MAAA,KAAW,sBACtC;QAAE,qBAAA,EAAuB;IAAA,CAAA,GACzB,KAAA,CAAA;IACN,MAAM,cAAc,EAAA;IAEpB,KAAA,CAAM,OAAA,CAAQ,CAAC,MAAA,KAAW;QACtB,IAAI,sBAAA,CAAuB,MAAM,CAAA,EAAG;YAChC,WAAA,CAAY,IAAA,CAAK,GAAG,MAAA,CAAO,KAAK,CAAA;YAChC,IAAI,MAAA,CAAO,qBAAA,KAA0B,KAAA,CAAA,EAAW;gBAG5C,qBAAA,GAAwB,KAAA,CAAA;YAC5B;QACJ,CAAA,MACK;YACD,IAAI,YAAA,GAAe,MAAA;YACnB,IAAI,sBAAA,IAA0B,MAAA,IAC1B,MAAA,CAAO,oBAAA,KAAyB,KAAA,EAAO;gBACvC,MAAM,EAAE,oBAAA,EAAsB,GAAG,IAAA,EAAA,GAAS,MAAA;gBAC1C,YAAA,GAAe,IAAA;YACnB,CAAA,MACK;gBAED,qBAAA,GAAwB,KAAA,CAAA;YAC5B;YACA,WAAA,CAAY,IAAA,CAAK,YAAY,CAAA;QACjC;IACJ,CAAC,CAAA;IACD,OAAO,YAAY,MAAA,GACb;QACE,KAAA,EAAO,WAAA;QACP,GAAG,qBAAA;KAAA,GAEL,KAAA,CAAA;AACV;ACnDO,SAAS,eAAA,CAAgB,GAAA,EAAK,IAAA,EAAM;IACvC,MAAM,UAAA,GAAa,OAAO,GAAA,CAAI,KAAA;IAC9B,IAAI,eAAe,QAAA,IACf,UAAA,KAAe,YACf,UAAA,KAAe,SAAA,IACf,eAAe,QAAA,EAAU;QACzB,OAAO;YACH,IAAA,EAAM,KAAA,CAAM,OAAA,CAAQ,GAAA,CAAI,KAAK,IAAI,OAAA,GAAU;QAAA,CAAA;IAEnD;IACA,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,EAAY;QAC5B,OAAO;YACH,IAAA,EAAM,UAAA,KAAe,WAAW,SAAA,GAAY,UAAA;YAC5C,IAAA,EAAM;gBAAC,IAAI,KAAK;aAAA;QAAA,CAAA;IAExB;IACA,OAAO;QACH,IAAA,EAAM,UAAA,KAAe,WAAW,SAAA,GAAY,UAAA;QAC5C,KAAA,EAAO,GAAA,CAAI,KAAA;IAAA,CAAA;AAEnB;ACnBA,IAAI,UAAA,GAAa,KAAA,CAAA;AAOV,IAAM,WAAA,GAAc;;;MAIvB,IAAA,EAAM,kBAAA;IACN,KAAA,EAAO,aAAA;IACP,IAAA,EAAM,0BAAA;;;MAIN,KAAA,EAAO,kGAAA;;;;;;;;;;;MAYP,KAAA,EAAO,MAAM;QACT,IAAI,eAAe,KAAA,CAAA,EAAW;YAC1B,UAAA,GAAa,MAAA,CAAO,wDAAwD,GAAG,CAAA;QACnF;QACA,OAAO,UAAA;IACX,CAAA;;;MAIA,IAAA,EAAM,uFAAA;;;MAIN,IAAA,EAAM,qHAAA;IACN,QAAA,EAAU,0IAAA;;;MAIV,IAAA,EAAM,8XAAA;IACN,QAAA,EAAU,yrBAAA;IACV,MAAA,EAAQ,kEAAA;IACR,SAAA,EAAW,wEAAA;IACX,MAAA,EAAQ,qBAAA;IACR,GAAA,EAAK;AACT,CAAA;AACO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;IACtC,MAAM,GAAA,GAAM;QACR,IAAA,EAAM;IAAA,CAAA;IAEV,IAAI,IAAI,MAAA,EAAQ;QACZ,KAAA,MAAW,KAAA,IAAS,IAAI,MAAA,CAAQ;YAC5B,OAAQ,MAAM,IAAA;gBACV,KAAK,KAAA;oBACD,yBAAA,CAA0B,KAAK,WAAA,EAAa,OAAO,GAAA,CAAI,SAAA,KAAc,WAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,MAAM,KAAK,CAAA,GACnC,MAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACtC;gBACJ,KAAK,KAAA;oBACD,yBAAA,CAA0B,KAAK,WAAA,EAAa,OAAO,GAAA,CAAI,SAAA,KAAc,WAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,MAAM,KAAK,CAAA,GACnC,MAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACtC;gBACJ,KAAK,OAAA;oBACD,OAAQ,KAAK,aAAA;wBACT,KAAK,cAAA;4BACD,SAAA,CAAU,GAAA,EAAK,OAAA,EAAS,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;4BAC3C;wBACJ,KAAK,kBAAA;4BACD,SAAA,CAAU,GAAA,EAAK,WAAA,EAAa,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;4BAC/C;wBACJ,KAAK,aAAA;4BACD,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;4BACtD;oBAAA;oBAER;gBACJ,KAAK,KAAA;oBACD,SAAA,CAAU,GAAA,EAAK,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACzC;gBACJ,KAAK,MAAA;oBACD,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC1C;gBACJ,KAAK,OAAA;oBACD,UAAA,CAAW,GAAA,EAAK,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAChD;gBACJ,KAAK,MAAA;oBACD,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,IAAA,EAAM,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACrD;gBACJ,KAAK,OAAA;oBACD,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACtD;gBACJ,KAAK,YAAA;oBACD,UAAA,CAAW,GAAA,EAAK,MAAA,CAAO,CAAA,CAAA,EAAI,uBAAA,CAAwB,KAAA,CAAM,KAAA,EAAO,IAAI,CAAC,CAAA,CAAE,CAAA,EAAG,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC7F;gBACJ,KAAK,UAAA;oBACD,UAAA,CAAW,GAAA,EAAK,MAAA,CAAO,CAAA,EAAG,uBAAA,CAAwB,KAAA,CAAM,KAAA,EAAO,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA,EAAG,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC7F;gBACJ,KAAK,UAAA;oBACD,SAAA,CAAU,GAAA,EAAK,WAAA,EAAa,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC/C;gBACJ,KAAK,MAAA;oBACD,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC1C;gBACJ,KAAK,MAAA;oBACD,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC1C;gBACJ,KAAK,UAAA;oBACD,SAAA,CAAU,GAAA,EAAK,UAAA,EAAY,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC9C;gBACJ,KAAK,QAAA;oBACD,yBAAA,CAA0B,KAAK,WAAA,EAAa,OAAO,GAAA,CAAI,SAAA,KAAc,WAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,MAAM,KAAK,CAAA,GACnC,MAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACtC,yBAAA,CAA0B,KAAK,WAAA,EAAa,OAAO,GAAA,CAAI,SAAA,KAAc,WAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,MAAM,KAAK,CAAA,GACnC,MAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACtC;gBACJ,KAAK,UAAA;oBAAY;wBACb,UAAA,CAAW,GAAA,EAAK,MAAA,CAAO,uBAAA,CAAwB,KAAA,CAAM,KAAA,EAAO,IAAI,CAAC,CAAA,EAAG,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBACvF;oBACJ;gBACA,KAAK,IAAA;oBAAM;wBACP,IAAI,KAAA,CAAM,OAAA,KAAY,IAAA,EAAM;4BACxB,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBAC9C;wBACA,IAAI,KAAA,CAAM,OAAA,KAAY,IAAA,EAAM;4BACxB,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBAC9C;wBACA;oBACJ;gBACA,KAAK,WAAA;oBACD,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,SAAA,EAAW,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC1D;gBACJ,KAAK,KAAA;oBACD,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,GAAA,EAAK,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACpD;gBACJ,KAAK,MAAA;oBAAQ;wBACT,IAAI,KAAA,CAAM,OAAA,KAAY,IAAA,EAAM;4BACxB,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,QAAA,EAAU,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBAC7D;wBACA,IAAI,KAAA,CAAM,OAAA,KAAY,IAAA,EAAM;4BACxB,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,QAAA,EAAU,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBAC7D;wBACA;oBACJ;gBACA,KAAK,OAAA;oBACD,UAAA,CAAW,KAAK,WAAA,CAAY,KAAA,EAAA,EAAS,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACxD;gBACJ,KAAK,MAAA;oBAAQ;wBACT,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,IAAA,EAAM,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;wBACrD;oBACJ;gBACA,KAAK,QAAA;oBAAU;wBACX,OAAQ,KAAK,cAAA;4BACT,KAAK,eAAA;gCAAiB;oCAClB,SAAA,CAAU,GAAA,EAAK,QAAA,EAAU,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oCAC5C;gCACJ;4BACA,KAAK,wBAAA;gCAA0B;oCAC3B,yBAAA,CAA0B,GAAA,EAAK,iBAAA,EAAmB,QAAA,EAAU,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oCAC/E;gCACJ;4BACA,KAAK,aAAA;gCAAe;oCAChB,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oCACvD;gCACJ;wBAAA;wBAEJ;oBACJ;gBACA,KAAK,QAAA;oBAAU;wBACX,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC3D;YAOsB;QAE9B;IACJ;IACA,OAAO,GAAA;AACX;AACA,SAAS,uBAAA,CAAwB,OAAA,EAAS,IAAA,EAAM;IAC5C,OAAO,IAAA,CAAK,eAAA,KAAoB,QAAA,GAC1B,qBAAA,CAAsB,OAAO,CAAA,GAC7B,OAAA;AACV;AACA,IAAM,aAAA,GAAgB,IAAI,GAAA,CAAI,8DAA8D,CAAA;AAC5F,SAAS,sBAAsB,MAAA,EAAQ;IACnC,IAAI,MAAA,GAAS,EAAA;IACb,IAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,CAAK;QACpC,IAAI,CAAC,aAAA,CAAc,GAAA,CAAI,MAAA,CAAO,CAAC,CAAC,CAAA,EAAG;YAC/B,MAAA,IAAU,IAAA;QACd;QACA,MAAA,IAAU,MAAA,CAAO,CAAC,CAAA;IACtB;IACA,OAAO,MAAA;AACX;AAEA,SAAS,SAAA,CAAU,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,IAAA,EAAM;IAC7C,IAAI,MAAA,CAAO,MAAA,IAAU,MAAA,CAAO,KAAA,EAAO,KAAK,CAAC,CAAA,GAAM,CAAA,CAAE,MAAM,CAAA,EAAG;QACtD,IAAI,CAAC,OAAO,KAAA,EAAO;YACf,MAAA,CAAO,KAAA,GAAQ,EAAA;QACnB;QACA,IAAI,OAAO,MAAA,EAAQ;YACf,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK;gBACd,MAAA,EAAQ,MAAA,CAAO,MAAA;gBACf,GAAI,MAAA,CAAO,YAAA,IACP,IAAA,CAAK,aAAA,IAAiB;oBACtB,YAAA,EAAc;wBAAE,MAAA,EAAQ,MAAA,CAAO,YAAA,CAAa,MAAA;oBAAA;gBAAO,CAAA;aAE1D,CAAA;YACD,OAAO,MAAA,CAAO,MAAA;YACd,IAAI,OAAO,YAAA,EAAc;gBACrB,OAAO,OAAO,YAAA,CAAa,MAAA;gBAC3B,IAAI,OAAO,IAAA,CAAK,MAAA,CAAO,YAAY,CAAA,CAAE,MAAA,KAAW,CAAA,EAAG;oBAC/C,OAAO,MAAA,CAAO,YAAA;gBAClB;YACJ;QACJ;QACA,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK;YACd,MAAA,EAAQ,KAAA;YACR,GAAI,OAAA,IACA,KAAK,aAAA,IAAiB;gBAAE,cAAc;oBAAE,MAAA,EAAQ;gBAAA,CAAA;YAAA,CAAA;SACvD,CAAA;IACL,CAAA,MACK;QACD,yBAAA,CAA0B,MAAA,EAAQ,QAAA,EAAU,KAAA,EAAO,OAAA,EAAS,IAAI,CAAA;IACpE;AACJ;AAEA,SAAS,UAAA,CAAW,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,IAAA,EAAM;IAC9C,IAAI,MAAA,CAAO,OAAA,IAAW,MAAA,CAAO,KAAA,EAAO,KAAK,CAAC,CAAA,GAAM,CAAA,CAAE,OAAO,CAAA,EAAG;QACxD,IAAI,CAAC,OAAO,KAAA,EAAO;YACf,MAAA,CAAO,KAAA,GAAQ,EAAA;QACnB;QACA,IAAI,OAAO,OAAA,EAAS;YAChB,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK;gBACd,OAAA,EAAS,MAAA,CAAO,OAAA;gBAChB,GAAI,MAAA,CAAO,YAAA,IACP,IAAA,CAAK,aAAA,IAAiB;oBACtB,YAAA,EAAc;wBAAE,OAAA,EAAS,MAAA,CAAO,YAAA,CAAa,OAAA;oBAAA;gBAAQ,CAAA;aAE5D,CAAA;YACD,OAAO,MAAA,CAAO,OAAA;YACd,IAAI,OAAO,YAAA,EAAc;gBACrB,OAAO,OAAO,YAAA,CAAa,OAAA;gBAC3B,IAAI,OAAO,IAAA,CAAK,MAAA,CAAO,YAAY,CAAA,CAAE,MAAA,KAAW,CAAA,EAAG;oBAC/C,OAAO,MAAA,CAAO,YAAA;gBAClB;YACJ;QACJ;QACA,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK;YACd,OAAA,EAAS,wBAAA,CAAyB,OAAO,IAAI,CAAA;YAC7C,GAAI,OAAA,IACA,KAAK,aAAA,IAAiB;gBAAE,cAAc;oBAAE,OAAA,EAAS;gBAAA,CAAA;YAAA,CAAA;SACxD,CAAA;IACL,CAAA,MACK;QACD,yBAAA,CAA0B,QAAQ,SAAA,EAAW,wBAAA,CAAyB,OAAO,IAAI,CAAA,EAAG,SAAS,IAAI,CAAA;IACrG;AACJ;AAEA,SAAS,wBAAA,CAAyB,KAAA,EAAO,IAAA,EAAM;IAC3C,IAAI,CAAC,IAAA,CAAK,eAAA,IAAmB,CAAC,MAAM,KAAA,EAAO;QACvC,OAAO,KAAA,CAAM,MAAA;IACjB;IAEA,MAAM,KAAA,GAAQ;QACV,CAAA,EAAG,KAAA,CAAM,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA;QAC3B,CAAA,EAAG,KAAA,CAAM,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA;QAC3B,CAAA,EAAG,KAAA,CAAM,KAAA,CAAM,QAAA,CAAS,GAAG;IAAA,CAAA;IAG/B,MAAM,SAAS,KAAA,CAAM,CAAA,GAAI,MAAM,MAAA,CAAO,WAAA,KAAgB,KAAA,CAAM,MAAA;IAC5D,IAAI,OAAA,GAAU,EAAA;IACd,IAAI,SAAA,GAAY,KAAA;IAChB,IAAI,WAAA,GAAc,KAAA;IAClB,IAAI,WAAA,GAAc,KAAA;IAClB,IAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,CAAK;QACpC,IAAI,SAAA,EAAW;YACX,OAAA,IAAW,MAAA,CAAO,CAAC,CAAA;YACnB,SAAA,GAAY,KAAA;YACZ;QACJ;QACA,IAAI,MAAM,CAAA,EAAG;YACT,IAAI,WAAA,EAAa;gBACb,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAM,OAAO,CAAA,EAAG;oBAC1B,IAAI,WAAA,EAAa;wBACb,OAAA,IAAW,MAAA,CAAO,CAAC,CAAA;wBACnB,OAAA,IAAW,CAAA,EAAG,MAAA,CAAO,CAAA,GAAI,CAAC,CAAC,CAAA,CAAA,EAAI,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA,CAAG,WAAA,EAAA;wBAC3C,WAAA,GAAc,KAAA;oBAClB,CAAA,MAAA,IACS,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,KAAM,GAAA,IAAO,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,EAAG,KAAA,CAAM,OAAO,CAAA,EAAG;wBAC7D,OAAA,IAAW,MAAA,CAAO,CAAC,CAAA;wBACnB,WAAA,GAAc,IAAA;oBAClB,CAAA,MACK;wBACD,OAAA,IAAW,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,GAAG,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAa,CAAA,CAAA;oBACrD;oBACA;gBACJ;YACJ,CAAA,MAAA,IACS,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAM,OAAO,CAAA,EAAG;gBAC/B,OAAA,IAAW,CAAA,CAAA,EAAI,MAAA,CAAO,CAAC,CAAC,GAAG,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAa,CAAA,CAAA,CAAA;gBAClD;YACJ;QACJ;QACA,IAAI,MAAM,CAAA,EAAG;YACT,IAAI,MAAA,CAAO,CAAC,CAAA,KAAM,GAAA,EAAK;gBACnB,OAAA,IAAW,CAAA;;gBACX;YACJ,CAAA,MAAA,IACS,MAAA,CAAO,CAAC,CAAA,KAAM,GAAA,EAAK;gBACxB,OAAA,IAAW,CAAA;;gBACX;YACJ;QACJ;QACA,IAAI,KAAA,CAAM,CAAA,IAAK,MAAA,CAAO,CAAC,CAAA,KAAM,GAAA,EAAK;YAC9B,OAAA,IAAW,WAAA,GAAc,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAA;IAAS,CAAA,CAAA,EAAI,MAAA,CAAO,CAAC,CAAC,CAAA;;YAC3D;QACJ;QACA,OAAA,IAAW,MAAA,CAAO,CAAC,CAAA;QACnB,IAAI,MAAA,CAAO,CAAC,CAAA,KAAM,IAAA,EAAM;YACpB,SAAA,GAAY,IAAA;QAChB,CAAA,MAAA,IACS,WAAA,IAAe,MAAA,CAAO,CAAC,CAAA,KAAM,GAAA,EAAK;YACvC,WAAA,GAAc,KAAA;QAClB,CAAA,MAAA,IACS,CAAC,WAAA,IAAe,MAAA,CAAO,CAAC,CAAA,KAAM,GAAA,EAAK;YACxC,WAAA,GAAc,IAAA;QAClB;IACJ;IAQA,OAAO,OAAA;AACX;AC3VO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;IACtC,IAAI,IAAA,CAAK,MAAA,KAAW,QAAA,EAAU;QAC1B,OAAA,CAAQ,IAAA,CAAK,8FAA8F,CAAA;IAC/G;IACA,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,IAChB,GAAA,CAAI,OAAA,EAAS,IAAA,CAAK,QAAA,KAAaQ,6JAAAA,CAAsB,OAAA,EAAS;QAC9D,OAAO;YACH,IAAA,EAAM,QAAA;YACN,QAAA,EAAU,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,MAAA;YAC3B,UAAA,EAAY,IAAI,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,CAAC,KAAK,GAAA,GAAA,CAAS;oBACtD,GAAG,GAAA;oBACH,CAAC,GAAG,CAAA,EAAG,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;wBAChC,GAAG,IAAA;wBACH,WAAA,EAAa,CAAC;+BAAG,IAAA,CAAK,WAAA;4BAAa;4BAAc,GAAG;yBAAA;qBACvD,CAAA,IAAK,YAAY,IAAI;gBAAA,CAAA,CAAA,EACtB,CAAA,CAAE,CAAA;YACN,oBAAA,EAAsB,IAAA,CAAK,4BAAA;QAAA,CAAA;IAEnC;IACA,MAAM,MAAA,GAAS;QACX,IAAA,EAAM,QAAA;QACN,oBAAA,EAAsB,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;YAC/C,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa,sBAAsB;aAAA;QAAA,CAC5D,KAAK,IAAA,CAAK,2BAAA;IAAA,CAAA;IAEf,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,EAAY;QAC5B,OAAO,MAAA;IACX;IACA,IAAI,GAAA,CAAI,OAAA,EAAS,IAAA,CAAK,QAAA,KAAaA,6JAAAA,CAAsB,SAAA,IACrD,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,MAAA,EAAQ,MAAA,EAAQ;QACjC,MAAM,EAAE,IAAA,EAAM,GAAG,OAAA,EAAA,GAAY,cAAA,CAAe,GAAA,CAAI,OAAA,CAAQ,IAAA,EAAM,IAAI,CAAA;QAClE,OAAO;YACH,GAAG,MAAA;YACH,aAAA,EAAe;QAAA,CAAA;IAEvB,CAAA,MAAA,IACS,GAAA,CAAI,OAAA,EAAS,IAAA,CAAK,QAAA,KAAaA,6JAAAA,CAAsB,OAAA,EAAS;QACnE,OAAO;YACH,GAAG,MAAA;YACH,aAAA,EAAe;gBACX,IAAA,EAAM,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,MAAA;YAAA;QAC3B,CAAA;IAER,CAAA,MAAA,IACS,GAAA,CAAI,OAAA,EAAS,IAAA,CAAK,QAAA,KAAaA,6JAAAA,CAAsB,UAAA,IAC1D,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,QAAA,KAAaA,6JAAAA,CAAsB,SAAA,IAC9D,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,MAAA,EAAQ,MAAA,EAAQ;QAC3C,MAAM,EAAE,IAAA,EAAM,GAAG,OAAA,EAAA,GAAY,eAAA,CAAgB,GAAA,CAAI,OAAA,CAAQ,IAAA,EAAM,IAAI,CAAA;QACnE,OAAO;YACH,GAAG,MAAA;YACH,aAAA,EAAe;QAAA,CAAA;IAEvB;IACA,OAAO,MAAA;AACX;ACzDO,SAAS,WAAA,CAAY,GAAA,EAAK,IAAA,EAAM;IACnC,IAAI,IAAA,CAAK,WAAA,KAAgB,QAAA,EAAU;QAC/B,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;IACnC;IACA,MAAM,IAAA,GAAO,QAAA,CAAS,GAAA,CAAI,OAAA,CAAQ,IAAA,EAAM;QACpC,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa,OAAA;YAAS;YAAS,GAAG;SAAA;KAC3D,CAAA,IAAK,YAAY,IAAI,CAAA;IACtB,MAAM,MAAA,GAAS,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;QACxC,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa,OAAA;YAAS;YAAS,GAAG;SAAA;KAC3D,CAAA,IAAK,YAAY,IAAI,CAAA;IACtB,OAAO;QACH,IAAA,EAAM,OAAA;QACN,QAAA,EAAU,GAAA;QACV,KAAA,EAAO;YACH,IAAA,EAAM,OAAA;YACN,KAAA,EAAO;gBAAC;gBAAM,MAAM;aAAA;YACpB,QAAA,EAAU,CAAA;YACV,QAAA,EAAU;QAAA;IACd,CAAA;AAER;ACzBO,SAAS,mBAAmB,GAAA,EAAK;IACpC,MAAMC,UAAS,GAAA,CAAI,MAAA;IACnB,MAAM,UAAA,GAAa,OAAO,IAAA,CAAK,GAAA,CAAI,MAAM,CAAA,CAAE,MAAA,CAAO,CAAC,GAAA,KAAQ;QACvD,OAAO,OAAOA,OAAAA,CAAOA,OAAAA,CAAO,GAAG,CAAC,CAAA,KAAM,QAAA;IAC1C,CAAC,CAAA;IACD,MAAM,eAAe,UAAA,CAAW,GAAA,CAAI,CAAC,GAAA,GAAQA,OAAAA,CAAO,GAAG,CAAC,CAAA;IACxD,MAAM,WAAA,GAAc,KAAA,CAAM,IAAA,CAAK,IAAI,GAAA,CAAI,YAAA,CAAa,GAAA,CAAI,CAAC,MAAA,GAAW,OAAO,MAAM,CAAC,CAAC,CAAA;IACnF,OAAO;QACH,IAAA,EAAM,WAAA,CAAY,MAAA,KAAW,CAAA,GACvB,WAAA,CAAY,CAAC,CAAA,KAAM,QAAA,GACf,QAAA,GACA,QAAA,GACJ;YAAC,QAAA;YAAU,QAAQ;SAAA;QACzB,IAAA,EAAM;IAAA,CAAA;AAEd;ACdO,SAAS,cAAc,IAAA,EAAM;IAChC,OAAO,IAAA,CAAK,MAAA,KAAW,QAAA,GACjB,KAAA,CAAA,GACA;QACE,GAAA,EAAK,WAAA,CAAY;YACb,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa,KAAK;aAAA;SAC3C;IAAA,CAAA;AAEb;ACVO,SAAS,aAAa,IAAA,EAAM;IAC/B,OAAO,IAAA,CAAK,MAAA,KAAW,UAAA,GACjB;QACE,IAAA,EAAM;YAAC,MAAM;SAAA;QACb,QAAA,EAAU;KAAA,GAEZ;QACE,IAAA,EAAM;IAAA,CAAA;AAElB;ACRO,IAAM,iBAAA,GAAoB;IAC7B,SAAA,EAAW,QAAA;IACX,SAAA,EAAW,QAAA;IACX,SAAA,EAAW,SAAA;IACX,UAAA,EAAY,SAAA;IACZ,OAAA,EAAS;AACb,CAAA;AACO,SAAS,aAAA,CAAc,GAAA,EAAK,IAAA,EAAM;IACrC,IAAI,KAAK,MAAA,KAAW,UAAA,EAChB,OAAO,OAAA,CAAQ,KAAK,IAAI,CAAA;IAC5B,MAAM,OAAA,GAAU,GAAA,CAAI,OAAA,YAAmB,GAAA,GAAM,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,GAAA,CAAI,OAAA;IAEpF,IAAI,QAAQ,KAAA,CAAM,CAAC,CAAA,GAAM,CAAA,CAAE,IAAA,CAAK,QAAA,IAAY,iBAAA,IAAA,CACvC,CAAC,CAAA,CAAE,IAAA,CAAK,MAAA,IAAU,CAAC,EAAE,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,CAAA,EAAG;QAE5C,MAAM,KAAA,GAAQ,OAAA,CAAQ,MAAA,CAAO,CAACC,QAAO,CAAA,KAAM;YACvC,MAAM,IAAA,GAAO,iBAAA,CAAkB,CAAA,CAAE,IAAA,CAAK,QAAQ,CAAA;YAC9C,OAAO,IAAA,IAAQ,CAACA,MAAAA,CAAM,QAAA,CAAS,IAAI,IAAI,CAAC;mBAAGA,MAAAA;gBAAO,IAAI;aAAA,GAAIA,MAAAA;QAC9D,CAAA,EAAG,EAAE,CAAA;QACL,OAAO;YACH,IAAA,EAAM,KAAA,CAAM,MAAA,GAAS,CAAA,GAAI,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA;QAAA,CAAA;IAEhD,CAAA,MAAA,IACS,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA,GAAM,CAAA,CAAE,IAAA,CAAK,QAAA,KAAa,YAAA,IAAgB,CAAC,CAAA,CAAE,WAAW,CAAA,EAAG;QAE/E,MAAM,KAAA,GAAQ,OAAA,CAAQ,MAAA,CAAO,CAAC,KAAK,CAAA,KAAM;YACrC,MAAM,IAAA,GAAO,OAAO,CAAA,CAAE,IAAA,CAAK,KAAA;YAC3B,OAAQ,IAAA;gBACJ,KAAK,QAAA;gBACL,KAAK,QAAA;gBACL,KAAK,SAAA;oBACD,OAAO,CAAC;2BAAG,GAAA;wBAAK,IAAI;qBAAA;gBACxB,KAAK,QAAA;oBACD,OAAO,CAAC;2BAAG,GAAA;wBAAK,SAAS;qBAAA;gBAC7B,KAAK,QAAA;oBACD,IAAI,CAAA,CAAE,IAAA,CAAK,KAAA,KAAU,IAAA,EACjB,OAAO,CAAC;2BAAG,GAAA;wBAAK,MAAM;qBAAA;gBAC9B,KAAK,QAAA;gBACL,KAAK,WAAA;gBACL,KAAK,UAAA;gBACL;oBACI,OAAO,GAAA;YAAA;QAEnB,CAAA,EAAG,EAAE,CAAA;QACL,IAAI,KAAA,CAAM,MAAA,KAAW,OAAA,CAAQ,MAAA,EAAQ;YAEjC,MAAM,WAAA,GAAc,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA,EAAG,CAAA,EAAG,CAAA,GAAM,CAAA,CAAE,OAAA,CAAQ,CAAC,CAAA,KAAM,CAAC,CAAA;YAChE,OAAO;gBACH,IAAA,EAAM,WAAA,CAAY,MAAA,GAAS,CAAA,GAAI,WAAA,GAAc,WAAA,CAAY,CAAC,CAAA;gBAC1D,IAAA,EAAM,OAAA,CAAQ,MAAA,CAAO,CAAC,GAAA,EAAK,CAAA,KAAM;oBAC7B,OAAO,GAAA,CAAI,QAAA,CAAS,CAAA,CAAE,IAAA,CAAK,KAAK,CAAA,GAAI,GAAA,GAAM,CAAC;2BAAG,GAAA;wBAAK,CAAA,CAAE,IAAA,CAAK,KAAK;qBAAA;gBACnE,CAAA,EAAG,EAAE;YAAA,CAAA;QAEb;IACJ,CAAA,MAAA,IACS,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA,GAAM,EAAE,IAAA,CAAK,QAAA,KAAa,SAAS,CAAA,EAAG;QAC1D,OAAO;YACH,IAAA,EAAM,QAAA;YACN,IAAA,EAAM,OAAA,CAAQ,MAAA,CAAO,CAAC,GAAA,EAAK,CAAA,GAAM;uBAC1B,GAAA;uBACA,CAAA,CAAE,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,CAACC,KAAM,CAAC,GAAA,CAAI,QAAA,CAASA,EAAC,CAAC;iBAAA,EAChD,EAAE;QAAA,CAAA;IAEb;IACA,OAAO,OAAA,CAAQ,KAAK,IAAI,CAAA;AAC5B;AACA,IAAM,OAAA,GAAU,CAAC,GAAA,EAAK,IAAA,KAAS;IAC3B,MAAM,QAAA,CAAS,GAAA,CAAI,OAAA,YAAmB,MAChC,KAAA,CAAM,IAAA,CAAK,IAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAC/B,GAAA,CAAI,OAAA,EACL,GAAA,CAAI,CAAC,GAAG,CAAA,GAAM,QAAA,CAAS,EAAE,IAAA,EAAM;YAChC,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa,OAAA;gBAAS,CAAA,EAAG,CAAC,CAAA,CAAE;aAAA;QAAA,CACrD,CAAC,CAAA,CACG,MAAA,CAAO,CAAC,CAAA,GAAM,CAAC,CAAC,CAAA,IAAA,CAChB,CAAC,KAAK,YAAA,IACF,OAAO,MAAM,QAAA,IAAY,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA,CAAE,MAAA,GAAS,CAAA,CAAG,CAAA;IAC7D,OAAO,KAAA,CAAM,MAAA,GAAS;QAAE,KAAA;IAAA,CAAA,GAAU,KAAA,CAAA;AACtC,CAAA;AC7EO,SAAS,gBAAA,CAAiB,GAAA,EAAK,IAAA,EAAM;IACxC,IAAI;QAAC;QAAa,WAAA;QAAa,WAAA;QAAa;QAAc,SAAS;KAAA,CAAE,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,QAAQ,CAAA,IAAA,CACpG,CAAC,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,MAAA,IAAU,CAAC,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,MAAA,CAAO,MAAA,CAAA,EAAS;QACnE,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,EAAY;YAC5B,OAAO;gBACH,IAAA,EAAM,iBAAA,CAAkB,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,QAAQ,CAAA;gBACnD,QAAA,EAAU;YAAA,CAAA;QAElB;QACA,OAAO;YACH,IAAA,EAAM;gBACF,iBAAA,CAAkB,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,QAAQ,CAAA;gBAC7C;aAAA;QACJ,CAAA;IAER;IACA,IAAI,IAAA,CAAK,MAAA,KAAW,UAAA,EAAY;QAC5B,MAAMC,KAAAA,GAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;YACtC,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAW;aAAA;SACpC,CAAA;QACD,IAAIA,SAAQ,MAAA,IAAUA,KAAAA,EAClB,OAAO;YAAE,KAAA,EAAO;gBAACA,KAAI;aAAA;YAAG,UAAU,IAAA;QAAA,CAAA;QACtC,OAAOA,KAAAA,IAAQ;YAAE,GAAGA,KAAAA;YAAM,UAAU,IAAA;QAAA,CAAA;IACxC;IACA,MAAM,IAAA,GAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;QACtC,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa;YAAS,GAAG;SAAA;KAClD,CAAA;IACD,OAAO,IAAA,IAAQ;QAAE,KAAA,EAAO;YAAC;YAAM;gBAAE,IAAA,EAAM,MAAA;YAAA,CAAQ;SAAA;IAAA,CAAA;AACnD;AC/BO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;IACtC,MAAM,GAAA,GAAM;QACR,IAAA,EAAM;IAAA,CAAA;IAEV,IAAI,CAAC,GAAA,CAAI,MAAA,EACL,OAAO,GAAA;IACX,KAAA,MAAW,KAAA,IAAS,IAAI,MAAA,CAAQ;QAC5B,OAAQ,MAAM,IAAA;YACV,KAAK,KAAA;gBACD,GAAA,CAAI,IAAA,GAAO,SAAA;gBACX,eAAA,CAAgB,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAChD;YACJ,KAAK,KAAA;gBACD,IAAI,IAAA,CAAK,MAAA,KAAW,aAAA,EAAe;oBAC/B,IAAI,MAAM,SAAA,EAAW;wBACjB,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC9E,CAAA,MACK;wBACD,yBAAA,CAA0B,KAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACvF;gBACJ,CAAA,MACK;oBACD,IAAI,CAAC,MAAM,SAAA,EAAW;wBAClB,GAAA,CAAI,gBAAA,GAAmB,IAAA;oBAC3B;oBACA,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC9E;gBACA;YACJ,KAAK,KAAA;gBACD,IAAI,IAAA,CAAK,MAAA,KAAW,aAAA,EAAe;oBAC/B,IAAI,MAAM,SAAA,EAAW;wBACjB,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBAC9E,CAAA,MACK;wBACD,yBAAA,CAA0B,KAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;oBACvF;gBACJ,CAAA,MACK;oBACD,IAAI,CAAC,MAAM,SAAA,EAAW;wBAClB,GAAA,CAAI,gBAAA,GAAmB,IAAA;oBAC3B;oBACA,yBAAA,CAA0B,KAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC9E;gBACA;YACJ,KAAK,YAAA;gBACD,yBAAA,CAA0B,KAAK,YAAA,EAAc,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;gBAC7E;QAAA;IAEZ;IACA,OAAO,GAAA;AACX;AClDO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;IACtC,MAAM,yBAAA,GAA4B,KAAK,MAAA,KAAW,QAAA;IAClD,MAAM,MAAA,GAAS;QACX,IAAA,EAAM,QAAA;QACN,UAAA,EAAY,CAAA;IAAC,CAAA;IAEjB,MAAM,WAAW,EAAA;IACjB,MAAM,KAAA,GAAQ,IAAI,KAAA,EAAA;IAClB,IAAA,MAAW,YAAY,KAAA,CAAO;QAC1B,IAAI,OAAA,GAAU,KAAA,CAAM,QAAQ,CAAA;QAC5B,IAAI,OAAA,KAAY,KAAA,CAAA,IAAa,OAAA,CAAQ,IAAA,KAAS,KAAA,CAAA,EAAW;YACrD;QACJ;QACA,IAAI,YAAA,GAAe,eAAe,OAAO,CAAA;QACzC,IAAI,gBAAgB,yBAAA,EAA2B;YAC3C,IAAI,OAAA,CAAQ,IAAA,CAAK,QAAA,KAAa,aAAA,EAAe;gBACzC,OAAA,GAAU,QAAQ,IAAA,CAAK,SAAA;YAC3B;YACA,IAAI,CAAC,OAAA,CAAQ,UAAA,EAAA,EAAc;gBACvB,OAAA,GAAU,QAAQ,QAAA,EAAA;YACtB;YACA,YAAA,GAAe,KAAA;QACnB;QACA,MAAM,SAAA,GAAY,QAAA,CAAS,OAAA,CAAQ,IAAA,EAAM;YACrC,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa;gBAAc,QAAQ;aAAA;YACzD,YAAA,EAAc,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa;gBAAc,QAAQ;aAAA;SAC7D,CAAA;QACD,IAAI,cAAc,KAAA,CAAA,EAAW;YACzB;QACJ;QACA,MAAA,CAAO,UAAA,CAAW,QAAQ,CAAA,GAAI,SAAA;QAC9B,IAAI,CAAC,YAAA,EAAc;YACf,QAAA,CAAS,IAAA,CAAK,QAAQ,CAAA;QAC1B;IACJ;IACA,IAAI,SAAS,MAAA,EAAQ;QACjB,MAAA,CAAO,QAAA,GAAW,QAAA;IACtB;IACA,MAAM,oBAAA,GAAuB,0BAAA,CAA2B,GAAA,EAAK,IAAI,CAAA;IACjE,IAAI,yBAAyB,KAAA,CAAA,EAAW;QACpC,MAAA,CAAO,oBAAA,GAAuB,oBAAA;IAClC;IACA,OAAO,MAAA;AACX;AACA,SAAS,0BAAA,CAA2B,GAAA,EAAK,IAAA,EAAM;IAC3C,IAAI,GAAA,CAAI,QAAA,CAAS,IAAA,CAAK,QAAA,KAAa,UAAA,EAAY;QAC3C,OAAO,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,IAAA,EAAM;YAC/B,GAAG,IAAA;YACH,WAAA,EAAa,CAAC;mBAAG,IAAA,CAAK,WAAA;gBAAa,sBAAsB;aAAA;SAC5D,CAAA;IACL;IACA,OAAQ,IAAI,WAAA;QACR,KAAK,aAAA;YACD,OAAO,IAAA,CAAK,2BAAA;QAChB,KAAK,QAAA;YACD,OAAO,IAAA,CAAK,4BAAA;QAChB,KAAK,OAAA;YACD,OAAO,IAAA,CAAK,wBAAA,KAA6B,QAAA,GACnC,IAAA,CAAK,2BAAA,GACL,IAAA,CAAK,4BAAA;IAAA;AAEvB;AACA,SAAS,eAAe,MAAA,EAAQ;IAC5B,IAAI;QACA,OAAO,OAAO,UAAA,EAAA;IAClB,CAAA,CAAA,OACM;QACF,OAAO,IAAA;IACX;AACJ;ACrEO,IAAM,gBAAA,GAAmB,CAAC,GAAA,EAAK,IAAA,KAAS;IAC3C,IAAI,KAAK,WAAA,CAAY,QAAA,OAAe,IAAA,CAAK,YAAA,EAAc,UAAA,EAAY;QAC/D,OAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;IAC5C;IACA,MAAM,WAAA,GAAc,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;QAC7C,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa;YAAS,GAAG;SAAA;KAClD,CAAA;IACD,OAAO,WAAA,GACD;QACE,KAAA,EAAO;YACH;gBACI,GAAA,EAAK,YAAY,IAAI;YAAA,CAAA;YAEzB;SAAA;IACJ,CAAA,GAEF,YAAY,IAAI,CAAA;AAC1B,CAAA;ACnBO,IAAM,gBAAA,GAAmB,CAAC,GAAA,EAAK,IAAA,KAAS;IAC3C,IAAI,IAAA,CAAK,YAAA,KAAiB,OAAA,EAAS;QAC/B,OAAO,QAAA,CAAS,GAAA,CAAI,EAAA,CAAG,IAAA,EAAM,IAAI,CAAA;IACrC,CAAA,MAAA,IACS,IAAA,CAAK,YAAA,KAAiB,QAAA,EAAU;QACrC,OAAO,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAA,EAAM,IAAI,CAAA;IACtC;IACA,MAAM,CAAA,GAAI,QAAA,CAAS,GAAA,CAAI,EAAA,CAAG,IAAA,EAAM;QAC5B,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa;YAAS,GAAG;SAAA;KAClD,CAAA;IACD,MAAM,CAAA,GAAI,QAAA,CAAS,GAAA,CAAI,GAAA,CAAI,IAAA,EAAM;QAC7B,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa,OAAA;YAAS,CAAA,GAAI,MAAM,GAAG;SAAA;KAC5D,CAAA;IACD,OAAO;QACH,KAAA,EAAO;YAAC;YAAG,CAAC;SAAA,CAAE,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,KAAA,CAAS;IAAA,CAAA;AAEnD,CAAA;AClBO,SAAS,eAAA,CAAgB,GAAA,EAAK,IAAA,EAAM;IACvC,OAAO,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM,IAAI,CAAA;AACvC;ACDO,SAAS,WAAA,CAAY,GAAA,EAAK,IAAA,EAAM;IACnC,MAAM,KAAA,GAAQ,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM;QACvC,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,WAAA;YAAa,OAAO;SAAA;KAC7C,CAAA;IACD,MAAM,MAAA,GAAS;QACX,IAAA,EAAM,OAAA;QACN,WAAA,EAAa,IAAA;QACb;IAAA,CAAA;IAEJ,IAAI,IAAI,OAAA,EAAS;QACb,yBAAA,CAA0B,MAAA,EAAQ,YAAY,GAAA,CAAI,OAAA,CAAQ,KAAA,EAAO,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS,IAAI,CAAA;IAC9F;IACA,IAAI,IAAI,OAAA,EAAS;QACb,yBAAA,CAA0B,MAAA,EAAQ,YAAY,GAAA,CAAI,OAAA,CAAQ,KAAA,EAAO,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS,IAAI,CAAA;IAC9F;IACA,OAAO,MAAA;AACX;AClBO,SAAS,aAAA,CAAc,GAAA,EAAK,IAAA,EAAM;IACrC,IAAI,IAAI,IAAA,EAAM;QACV,OAAO;YACH,IAAA,EAAM,OAAA;YACN,QAAA,EAAU,IAAI,KAAA,CAAM,MAAA;YACpB,KAAA,EAAO,GAAA,CAAI,KAAA,CACN,GAAA,CAAI,CAAC,GAAG,CAAA,GAAM,QAAA,CAAS,EAAE,IAAA,EAAM;oBAChC,GAAG,IAAA;oBACH,WAAA,EAAa,CAAC;2BAAG,IAAA,CAAK,WAAA;wBAAa,OAAA;wBAAS,CAAA,EAAG,CAAC,CAAA,CAAE;qBAAA;gBAAA,CACrD,CAAC,CAAA,CACG,MAAA,CAAO,CAAC,KAAK,CAAA,GAAO,CAAA,KAAM,KAAA,CAAA,GAAY,GAAA,GAAM,CAAC;uBAAG,GAAA;oBAAK,CAAC;iBAAA,EAAI,EAAE,CAAA;YACjE,eAAA,EAAiB,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM;gBACrC,GAAG,IAAA;gBACH,WAAA,EAAa,CAAC;uBAAG,IAAA,CAAK,WAAA;oBAAa,iBAAiB;iBAAA;aACvD;QAAA,CAAA;IAET,CAAA,MACK;QACD,OAAO;YACH,IAAA,EAAM,OAAA;YACN,QAAA,EAAU,IAAI,KAAA,CAAM,MAAA;YACpB,QAAA,EAAU,IAAI,KAAA,CAAM,MAAA;YACpB,KAAA,EAAO,GAAA,CAAI,KAAA,CACN,GAAA,CAAI,CAAC,GAAG,CAAA,GAAM,QAAA,CAAS,EAAE,IAAA,EAAM;oBAChC,GAAG,IAAA;oBACH,WAAA,EAAa,CAAC;2BAAG,IAAA,CAAK,WAAA;wBAAa,OAAA;wBAAS,CAAA,EAAG,CAAC,CAAA,CAAE;qBAAA;gBAAA,CACrD,CAAC,CAAA,CACG,MAAA,CAAO,CAAC,KAAK,CAAA,GAAO,CAAA,KAAM,KAAA,CAAA,GAAY,GAAA,GAAM,CAAC;uBAAG,GAAA;oBAAK,CAAC;iBAAA,EAAI,EAAE;QAAA,CAAA;IAEzE;AACJ;AC9BO,SAAS,kBAAkB,IAAA,EAAM;IACpC,OAAO;QACH,GAAA,EAAK,YAAY,IAAI;IAAA,CAAA;AAE7B;ACJO,SAAS,gBAAgB,IAAA,EAAM;IAClC,OAAO,YAAY,IAAI,CAAA;AAC3B;ACFO,IAAM,gBAAA,GAAmB,CAAC,GAAA,EAAK,IAAA,KAAS;IAC3C,OAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;AAC5C,CAAA;AC4BO,IAAM,YAAA,GAAe,CAAC,GAAA,EAAK,QAAA,EAAU,IAAA,KAAS;IACjD,OAAQ,QAAA;QACJ,KAAKJ,6JAAAA,CAAsB,SAAA;YACvB,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;QACnC,KAAKA,6JAAAA,CAAsB,SAAA;YACvB,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;QACnC,KAAKA,6JAAAA,CAAsB,SAAA;YACvB,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;QACnC,KAAKA,6JAAAA,CAAsB,SAAA;YACvB,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;QACnC,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,EAAA;QACX,KAAKA,6JAAAA,CAAsB,OAAA;YACvB,OAAO,YAAA,CAAa,KAAK,IAAI,CAAA;QACjC,KAAKA,6JAAAA,CAAsB,YAAA;YACvB,OAAO,kBAAkB,IAAI,CAAA;QACjC,KAAKA,6JAAAA,CAAsB,OAAA;YACvB,OAAO,aAAa,IAAI,CAAA;QAC5B,KAAKA,6JAAAA,CAAsB,QAAA;YACvB,OAAO,aAAA,CAAc,KAAK,IAAI,CAAA;QAClC,KAAKA,6JAAAA,CAAsB,QAAA;QAC3B,KAAKA,6JAAAA,CAAsB,qBAAA;YACvB,OAAO,aAAA,CAAc,KAAK,IAAI,CAAA;QAClC,KAAKA,6JAAAA,CAAsB,eAAA;YACvB,OAAO,oBAAA,CAAqB,KAAK,IAAI,CAAA;QACzC,KAAKA,6JAAAA,CAAsB,QAAA;YACvB,OAAO,aAAA,CAAc,KAAK,IAAI,CAAA;QAClC,KAAKA,6JAAAA,CAAsB,SAAA;YACvB,OAAO,cAAA,CAAe,KAAK,IAAI,CAAA;QACnC,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,CAAgB,KAAK,IAAI,CAAA;QACpC,KAAKA,6JAAAA,CAAsB,OAAA;YACvB,OAAO,aAAa,GAAG,CAAA;QAC3B,KAAKA,6JAAAA,CAAsB,aAAA;YACvB,OAAO,mBAAmB,GAAG,CAAA;QACjC,KAAKA,6JAAAA,CAAsB,WAAA;YACvB,OAAO,gBAAA,CAAiB,KAAK,IAAI,CAAA;QACrC,KAAKA,6JAAAA,CAAsB,WAAA;YACvB,OAAO,gBAAA,CAAiB,KAAK,IAAI,CAAA;QACrC,KAAKA,6JAAAA,CAAsB,MAAA;YACvB,OAAO,WAAA,CAAY,KAAK,IAAI,CAAA;QAChC,KAAKA,6JAAAA,CAAsB,MAAA;YACvB,OAAO,WAAA,CAAY,KAAK,IAAI,CAAA;QAChC,KAAKA,6JAAAA,CAAsB,OAAA;YACvB,OAAO,IAAM,GAAA,CAAI,MAAA,EAAA,CAAS,IAAA;QAC9B,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,CAAgB,KAAK,IAAI,CAAA;QACpC,KAAKA,6JAAAA,CAAsB,MAAA;QAC3B,KAAKA,6JAAAA,CAAsB,QAAA;YACvB,OAAO,cAAc,IAAI,CAAA;QAC7B,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,CAAgB,KAAK,IAAI,CAAA;QACpC,KAAKA,6JAAAA,CAAsB,MAAA;YACvB,OAAO,YAAY,IAAI,CAAA;QAC3B,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,gBAAgB,IAAI,CAAA;QAC/B,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,CAAgB,KAAK,IAAI,CAAA;QACpC,KAAKA,6JAAAA,CAAsB,UAAA;YACvB,OAAO,eAAA,CAAgB,KAAK,IAAI,CAAA;QACpC,KAAKA,6JAAAA,CAAsB,WAAA;YACvB,OAAO,gBAAA,CAAiB,KAAK,IAAI,CAAA;QACrC,KAAKA,6JAAAA,CAAsB,QAAA;YACvB,OAAO,aAAA,CAAc,KAAK,IAAI,CAAA;QAClC,KAAKA,6JAAAA,CAAsB,WAAA;YACvB,OAAO,gBAAA,CAAiB,KAAK,IAAI,CAAA;QACrC,KAAKA,6JAAAA,CAAsB,WAAA;QAC3B,KAAKA,6JAAAA,CAAsB,OAAA;QAC3B,KAAKA,6JAAAA,CAAsB,SAAA;YACvB,OAAO,KAAA,CAAA;QACX;YAEI,OAAA,aAAA,GAAQ,CAAA,CAAC,IAAM,KAAA,CAAA,GAAmB;IAAA;AAE9C,CAAA;ACrGO,SAAS,QAAA,CAAS,GAAA,EAAK,IAAA,EAAM,eAAA,GAAkB,KAAA,EAAO;IACzD,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,GAAG,CAAA;IAClC,IAAI,KAAK,QAAA,EAAU;QACf,MAAM,iBAAiB,IAAA,CAAK,QAAA,GAAW,GAAA,EAAK,IAAA,EAAM,UAAU,eAAe,CAAA;QAC3E,IAAI,mBAAmB,cAAA,EAAgB;YACnC,OAAO,cAAA;QACX;IACJ;IACA,IAAI,QAAA,IAAY,CAAC,eAAA,EAAiB;QAC9B,MAAM,UAAA,GAAa,OAAA,CAAQ,QAAA,EAAU,IAAI,CAAA;QACzC,IAAI,eAAe,KAAA,CAAA,EAAW;YAC1B,OAAO,UAAA;QACX;IACJ;IACA,MAAM,UAAU;QAAE,GAAA;QAAK,MAAM,IAAA,CAAK,WAAA;QAAa,YAAY,KAAA,CAAA;IAAA,CAAA;IAC3D,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,OAAO,CAAA;IAC1B,MAAM,kBAAA,GAAqB,YAAA,CAAa,GAAA,EAAK,GAAA,CAAI,QAAA,EAAU,IAAI,CAAA;IAE/D,MAAMK,WAAAA,GAAa,OAAO,kBAAA,KAAuB,UAAA,GAC3C,SAAS,kBAAA,EAAA,EAAsB,IAAI,CAAA,GACnC,kBAAA;IACN,IAAIA,WAAAA,EAAY;QACZ,OAAA,CAAQ,GAAA,EAAK,MAAMA,WAAU,CAAA;IACjC;IACA,IAAI,KAAK,WAAA,EAAa;QAClB,MAAM,iBAAA,GAAoB,IAAA,CAAK,WAAA,CAAYA,WAAAA,EAAY,KAAK,IAAI,CAAA;QAChE,OAAA,CAAQ,UAAA,GAAaA,WAAAA;QACrB,OAAO,iBAAA;IACX;IACA,OAAA,CAAQ,UAAA,GAAaA,WAAAA;IACrB,OAAOA,WAAAA;AACX;AACA,IAAM,OAAA,GAAU,CAAC,IAAA,EAAM,IAAA,KAAS;IAC5B,OAAQ,KAAK,YAAA;QACT,KAAK,MAAA;YACD,OAAO;gBAAE,IAAA,EAAM,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA;YAAA,CAAA;QACrC,KAAK,UAAA;YACD,OAAO;gBAAE,IAAA,EAAM,eAAA,CAAgB,KAAK,WAAA,EAAa,IAAA,CAAK,IAAI,CAAA;YAAA,CAAA;QAC9D,KAAK,MAAA;QACL,KAAK,MAAA;YAAQ;gBACT,IAAI,KAAK,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,WAAA,CAAY,MAAA,IACpC,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,CAAC,OAAO,KAAA,GAAU,IAAA,CAAK,WAAA,CAAY,KAAK,CAAA,KAAM,KAAK,CAAA,EAAG;oBACtE,OAAA,CAAQ,IAAA,CAAK,CAAA,gCAAA,EAAmC,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,GAAG,CAAC,CAAA,mBAAA,CAAqB,CAAA;oBAC/F,OAAO,YAAY,IAAI,CAAA;gBAC3B;gBACA,OAAO,IAAA,CAAK,YAAA,KAAiB,MAAA,GAAS,WAAA,CAAY,IAAI,CAAA,GAAI,KAAA,CAAA;YAC9D;IAAA;AAER,CAAA;AACA,IAAM,OAAA,GAAU,CAAC,GAAA,EAAK,IAAA,EAAMA,WAAAA,KAAe;IACvC,IAAI,IAAI,WAAA,EAAa;QACjBA,WAAAA,CAAW,WAAA,GAAc,GAAA,CAAI,WAAA;QAC7B,IAAI,KAAK,mBAAA,EAAqB;YAC1BA,WAAAA,CAAW,mBAAA,GAAsB,GAAA,CAAI,WAAA;QACzC;IACJ;IACA,OAAOA,WAAAA;AACX,CAAA;AC1DA,IAAMC,gBAAAA,GAAkB,CAAC,MAAA,EAAQ,OAAA,KAAY;IACzC,MAAM,IAAA,GAAO,QAAQ,OAAO,CAAA;IAC5B,IAAI,cAAc,OAAO,OAAA,KAAY,QAAA,IAAY,OAAA,CAAQ,WAAA,GACnD,MAAA,CAAO,OAAA,CAAQ,OAAA,CAAQ,WAAW,EAAE,MAAA,CAAO,CAAC,KAAK,CAACd,MAAAA,EAAMe,OAAM,CAAA,GAAA,CAAO;YACnE,GAAG,GAAA;YACH,CAACf,MAAI,CAAA,EAAG,QAAA,CAASe,OAAAA,CAAO,IAAA,EAAM;gBAC1B,GAAG,IAAA;gBACH,WAAA,EAAa,CAAC;uBAAG,IAAA,CAAK,QAAA;oBAAU,IAAA,CAAK,cAAA;oBAAgBf,MAAI;iBAAA;aAAA,EAC1D,IAAI,CAAA,IAAK,WAAA,CAAY,IAAI;SAAA,CAAA,EAC5B,CAAA,CAAE,CAAA,GACJ,KAAA,CAAA;IACN,MAAMA,MAAAA,GAAO,OAAO,OAAA,KAAY,QAAA,GAC1B,UACA,OAAA,EAAS,YAAA,KAAiB,OAAA,GACtB,KAAA,CAAA,GACA,OAAA,EAAS,IAAA;IACnB,MAAM,OAAO,QAAA,CAAS,MAAA,CAAO,IAAA,EAAMA,MAAAA,KAAS,KAAA,IACtC,IAAA,GACA;QACE,GAAG,IAAA;QACH,WAAA,EAAa,CAAC;eAAG,IAAA,CAAK,QAAA;YAAU,IAAA,CAAK,cAAA;YAAgBA,MAAI;SAAA;KAAA,EAC1D,KAAK,CAAA,IAAK,WAAA,CAAY,IAAI,CAAA;IACjC,MAAM,KAAA,GAAQ,OAAO,OAAA,KAAY,QAAA,IAC7B,OAAA,CAAQ,IAAA,KAAS,KAAA,CAAA,IACjB,OAAA,CAAQ,YAAA,KAAiB,OAAA,GACvB,OAAA,CAAQ,IAAA,GACR,KAAA,CAAA;IACN,IAAI,UAAU,KAAA,CAAA,EAAW;QACrB,IAAA,CAAK,KAAA,GAAQ,KAAA;IACjB;IACA,IAAI,IAAA,CAAK,KAAA,CAAM,0BAAA,EAA4B;QACvC,IAAI,CAAC,WAAA,EAAa;YACd,WAAA,GAAc,CAAA,CAAA;QAClB;QACA,IAAI,CAAC,WAAA,CAAY,IAAA,CAAK,iBAAiB,CAAA,EAAG;YACtC,WAAA,CAAY,IAAA,CAAK,iBAAiB,CAAA,GAAI;;gBAElC,IAAA,EAAM;oBAAC,QAAA;oBAAU,QAAA;oBAAU,SAAA;oBAAW,SAAA;oBAAW;oBAAS,MAAM;iBAAA;gBAChE,KAAA,EAAO;oBACH,IAAA,EAAM,IAAA,CAAK,YAAA,KAAiB,UAAA,GACtB,GAAA,GACA;2BACK,IAAA,CAAK,QAAA;wBACR,IAAA,CAAK,cAAA;wBACL,IAAA,CAAK,iBAAA;qBAAA,CACP,IAAA,CAAK,GAAG;gBAAA;YAClB,CAAA;QAER;IACJ;IACA,MAAM,QAAA,GAAWA,MAAAA,KAAS,KAAA,CAAA,GACpB,WAAA,GACI;QACE,GAAG,IAAA;QACH,CAAC,IAAA,CAAK,cAAc,CAAA,EAAG;IAAA,CAAA,GAEzB,IAAA,GACJ;QACE,IAAA,EAAM;eACE,IAAA,CAAK,YAAA,KAAiB,UAAA,GAAa,EAAA,GAAK,IAAA,CAAK,QAAA;YACjD,IAAA,CAAK,cAAA;YACLA;SAAA,CACF,IAAA,CAAK,GAAG,CAAA;QACV,CAAC,IAAA,CAAK,cAAc,CAAA,EAAG;YACnB,GAAG,WAAA;YACH,CAACA,MAAI,CAAA,EAAG;QAAA;IACZ,CAAA;IAER,IAAI,IAAA,CAAK,MAAA,KAAW,aAAA,EAAe;QAC/B,QAAA,CAAS,OAAA,GAAU,yCAAA;IACvB,CAAA,MAAA,IACS,IAAA,CAAK,MAAA,KAAW,mBAAA,IAAuB,IAAA,CAAK,MAAA,KAAW,QAAA,EAAU;QACtE,QAAA,CAAS,OAAA,GAAU,+CAAA;IACvB;IACA,IAAI,IAAA,CAAK,MAAA,KAAW,QAAA,IAAA,CACf,OAAA,IAAW,YACR,OAAA,IAAW,QAAA,IACX,OAAA,IAAW,QAAA,IACV,UAAU,QAAA,IAAY,KAAA,CAAM,OAAA,CAAQ,QAAA,CAAS,IAAI,CAAA,CAAA,EAAK;QAC3D,OAAA,CAAQ,IAAA,CAAK,sGAAsG,CAAA;IACvH;IACA,OAAO,QAAA;AACX,CAAA;AC9CA,IAAO,WAAA,GAAQc,gBAAAA;ACbR,SAAS,QAAQ,KAAA,EAAuB;IAC7C,MAAM,KAAA,GAAiB;QAAC,MAAM;KAAA;IAC9B,IAAI,cAAA,GAAiB,CAAA,CAAA;IACrB,IAAI,YAAA,GAA8B,IAAA;IAElC,SAAS,iBAAA,CAAkB,IAAA,EAAc,CAAA,EAAW,SAAA,EAAkB;QACpE;YACE,OAAQ,IAAA;gBACN,KAAK,GAAA;oBAAK;wBACR,cAAA,GAAiB,CAAA;wBACjB,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,eAAe,CAAA;wBAC1B;oBACF;gBAEA,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;oBAAK;wBACR,cAAA,GAAiB,CAAA;wBACjB,YAAA,GAAe,CAAA;wBACf,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,gBAAgB,CAAA;wBAC3B;oBACF;gBAEA,KAAK,GAAA;oBAAK;wBACR,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,eAAe,CAAA;wBAC1B;oBACF;gBACA,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;gBACL,KAAK,GAAA;oBAAK;wBACR,cAAA,GAAiB,CAAA;wBACjB,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,eAAe,CAAA;wBAC1B;oBACF;gBAEA,KAAK,GAAA;oBAAK;wBACR,cAAA,GAAiB,CAAA;wBACjB,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,qBAAqB,CAAA;wBAChC;oBACF;gBAEA,KAAK,GAAA;oBAAK;wBACR,cAAA,GAAiB,CAAA;wBACjB,KAAA,CAAM,GAAA,EAAA;wBACN,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;wBACpB,KAAA,CAAM,IAAA,CAAK,oBAAoB,CAAA;wBAC/B;oBACF;YACF;QACF;IACF;IAEA,SAAS,uBAAA,CAAwB,IAAA,EAAc,CAAA,EAAW;QACxD,OAAQ,IAAA;YACN,KAAK,GAAA;gBAAK;oBACR,KAAA,CAAM,GAAA,EAAA;oBACN,KAAA,CAAM,IAAA,CAAK,2BAA2B,CAAA;oBACtC;gBACF;YACA,KAAK,GAAA;gBAAK;oBACR,cAAA,GAAiB,CAAA;oBACjB,KAAA,CAAM,GAAA,EAAA;oBACN;gBACF;QACF;IACF;IAEA,SAAS,sBAAA,CAAuB,IAAA,EAAc,CAAA,EAAW;QACvD,OAAQ,IAAA;YACN,KAAK,GAAA;gBAAK;oBACR,KAAA,CAAM,GAAA,EAAA;oBACN,KAAA,CAAM,IAAA,CAAK,0BAA0B,CAAA;oBACrC;gBACF;YACA,KAAK,GAAA;gBAAK;oBACR,cAAA,GAAiB,CAAA;oBACjB,KAAA,CAAM,GAAA,EAAA;oBACN;gBACF;QACF;IACF;IAEA,IAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,CAAK;QACrC,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;QACpB,MAAM,YAAA,GAAe,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;QAE3C,OAAQ,YAAA;YACN,KAAK,MAAA;gBACH,iBAAA,CAAkB,IAAA,EAAM,GAAG,QAAQ,CAAA;gBACnC;YAEF,KAAK,qBAAA;gBAAuB;oBAC1B,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,KAAA,CAAM,IAAA,CAAK,mBAAmB,CAAA;gCAC9B;4BACF;wBACA,KAAK,GAAA;4BAAK;gCACR,cAAA,GAAiB,CAAA;gCACjB,KAAA,CAAM,GAAA,EAAA;gCACN;4BACF;oBACF;oBACA;gBACF;YAEA,KAAK,2BAAA;gBAA6B;oBAChC,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,KAAA,CAAM,IAAA,CAAK,mBAAmB,CAAA;gCAC9B;4BACF;oBACF;oBACA;gBACF;YAEA,KAAK,mBAAA;gBAAqB;oBACxB,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,KAAA,CAAM,IAAA,CAAK,yBAAyB,CAAA;gCACpC;4BACF;oBACF;oBACA;gBACF;YAEA,KAAK,yBAAA;gBAA2B;oBAC9B,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,KAAA,CAAM,IAAA,CAAK,4BAA4B,CAAA;gCAEvC;4BACF;oBACF;oBACA;gBACF;YAEA,KAAK,4BAAA;gBAA8B;oBACjC,iBAAA,CAAkB,IAAA,EAAM,GAAG,2BAA2B,CAAA;oBACtD;gBACF;YAEA,KAAK,2BAAA;gBAA6B;oBAChC,uBAAA,CAAwB,MAAM,CAAC,CAAA;oBAC/B;gBACF;YAEA,KAAK,eAAA;gBAAiB;oBACpB,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,cAAA,GAAiB,CAAA;gCACjB;4BACF;wBAEA,KAAK,IAAA;4BAAM;gCACT,KAAA,CAAM,IAAA,CAAK,sBAAsB,CAAA;gCACjC;4BACF;wBAEA;4BAAS;gCACP,cAAA,GAAiB,CAAA;4BACnB;oBACF;oBAEA;gBACF;YAEA,KAAK,oBAAA;gBAAsB;oBACzB,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,cAAA,GAAiB,CAAA;gCACjB,KAAA,CAAM,GAAA,EAAA;gCACN;4BACF;wBAEA;4BAAS;gCACP,cAAA,GAAiB,CAAA;gCACjB,iBAAA,CAAkB,IAAA,EAAM,GAAG,0BAA0B,CAAA;gCACrD;4BACF;oBACF;oBACA;gBACF;YAEA,KAAK,0BAAA;gBAA4B;oBAC/B,OAAQ,IAAA;wBACN,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCACN,KAAA,CAAM,IAAA,CAAK,0BAA0B,CAAA;gCACrC;4BACF;wBAEA,KAAK,GAAA;4BAAK;gCACR,cAAA,GAAiB,CAAA;gCACjB,KAAA,CAAM,GAAA,EAAA;gCACN;4BACF;wBAEA;4BAAS;gCACP,cAAA,GAAiB,CAAA;gCACjB;4BACF;oBACF;oBAEA;gBACF;YAEA,KAAK,0BAAA;gBAA4B;oBAC/B,iBAAA,CAAkB,IAAA,EAAM,GAAG,0BAA0B,CAAA;oBACrD;gBACF;YAEA,KAAK,sBAAA;gBAAwB;oBAC3B,KAAA,CAAM,GAAA,EAAA;oBACN,cAAA,GAAiB,CAAA;oBAEjB;gBACF;YAEA,KAAK,eAAA;gBAAiB;oBACpB,OAAQ,IAAA;wBACN,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;4BAAK;gCACR,cAAA,GAAiB,CAAA;gCACjB;4BACF;wBAEA,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;wBACL,KAAK,GAAA;4BAAK;gCACR;4BACF;wBAEA,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCAEN,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,0BAAA,EAA4B;oCAC1D,sBAAA,CAAuB,MAAM,CAAC,CAAA;gCAChC;gCAEA,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,2BAAA,EAA6B;oCAC3D,uBAAA,CAAwB,MAAM,CAAC,CAAA;gCACjC;gCAEA;4BACF;wBAEA,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCAEN,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,2BAAA,EAA6B;oCAC3D,uBAAA,CAAwB,MAAM,CAAC,CAAA;gCACjC;gCAEA;4BACF;wBAEA,KAAK,GAAA;4BAAK;gCACR,KAAA,CAAM,GAAA,EAAA;gCAEN,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,0BAAA,EAA4B;oCAC1D,sBAAA,CAAuB,MAAM,CAAC,CAAA;gCAChC;gCAEA;4BACF;wBAEA;4BAAS;gCACP,KAAA,CAAM,GAAA,EAAA;gCACN;4BACF;oBACF;oBAEA;gBACF;YAEA,KAAK,gBAAA;gBAAkB;oBACrB,MAAM,cAAA,GAAiB,KAAA,CAAM,SAAA,CAAU,YAAA,EAAe,IAAI,CAAC,CAAA;oBAE3D,IACE,CAAC,OAAA,CAAQ,UAAA,CAAW,cAAc,KAClC,CAAC,MAAA,CAAO,UAAA,CAAW,cAAc,CAAA,IACjC,CAAC,MAAA,CAAO,UAAA,CAAW,cAAc,CAAA,EACjC;wBACA,KAAA,CAAM,GAAA,EAAA;wBAEN,IAAI,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,2BAAA,EAA6B;4BAC3D,uBAAA,CAAwB,MAAM,CAAC,CAAA;wBACjC,CAAA,MAAA,IAAW,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,KAAM,0BAAA,EAA4B;4BACjE,sBAAA,CAAuB,MAAM,CAAC,CAAA;wBAChC;oBACF,CAAA,MAAO;wBACL,cAAA,GAAiB,CAAA;oBACnB;oBAEA;gBACF;QACF;IACF;IAEA,IAAI,MAAA,GAAS,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,iBAAiB,CAAC,CAAA;IAE9C,IAAA,IAAS,IAAI,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,GAAG,CAAA,EAAA,CAAK;QAC1C,MAAM,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA;QAErB,OAAQ,KAAA;YACN,KAAK,eAAA;gBAAiB;oBACpB,MAAA,IAAU,GAAA;oBACV;gBACF;YAEA,KAAK,mBAAA;YACL,KAAK,yBAAA;YACL,KAAK,2BAAA;YACL,KAAK,qBAAA;YACL,KAAK,4BAAA;YACL,KAAK,2BAAA;gBAA6B;oBAChC,MAAA,IAAU,GAAA;oBACV;gBACF;YAEA,KAAK,oBAAA;YACL,KAAK,0BAAA;YACL,KAAK,0BAAA;gBAA4B;oBAC/B,MAAA,IAAU,GAAA;oBACV;gBACF;YAEA,KAAK,gBAAA;gBAAkB;oBACrB,MAAM,cAAA,GAAiB,KAAA,CAAM,SAAA,CAAU,YAAA,EAAe,MAAM,MAAM,CAAA;oBAElE,IAAI,MAAA,CAAO,UAAA,CAAW,cAAc,CAAA,EAAG;wBACrC,MAAA,IAAU,MAAA,CAAO,KAAA,CAAM,cAAA,CAAe,MAAM,CAAA;oBAC9C,CAAA,MAAA,IAAW,OAAA,CAAQ,UAAA,CAAW,cAAc,CAAA,EAAG;wBAC7C,MAAA,IAAU,OAAA,CAAQ,KAAA,CAAM,cAAA,CAAe,MAAM,CAAA;oBAC/C,CAAA,MAAA,IAAW,MAAA,CAAO,UAAA,CAAW,cAAc,CAAA,EAAG;wBAC5C,MAAA,IAAU,MAAA,CAAO,KAAA,CAAM,cAAA,CAAe,MAAM,CAAA;oBAC9C;gBACF;QACF;IACF;IAEA,OAAO,MAAA;AACT;AC5YO,SAAS,iBAAiB,QAAA,EAO/B;IACA,IAAI,aAAa,KAAA,CAAA,EAAW;QAC1B,OAAO;YAAE,KAAA,EAAO,KAAA,CAAA;YAAW,KAAA,EAAO,iBAAA;QAAA,CAAA;IACpC;IAEA,IAAI,MAAA,GAAS,aAAA,CAAc;QAAE,IAAA,EAAM;IAAA,CAAU,CAAA;IAE7C,IAAI,OAAO,OAAA,EAAS;QAClB,OAAO;YAAE,KAAA,EAAO,MAAA,CAAO,KAAA;YAAO,OAAO,kBAAA;QAAA,CAAA;IACvC;IAEA,MAAA,GAAS,cAAc;QAAE,IAAA,EAAM,OAAA,CAAQ,QAAQ;IAAA,CAAG,CAAA;IAElD,IAAI,OAAO,OAAA,EAAS;QAClB,OAAO;YAAE,KAAA,EAAO,MAAA,CAAO,KAAA;YAAO,OAAO,gBAAA;QAAA,CAAA;IACvC;IAEA,OAAO;QAAE,KAAA,EAAO,KAAA,CAAA;QAAW,KAAA,EAAO,cAAA;IAAA,CAAA;AACpC;ACTA,IAAME,eAAAA,GAAsD;IAC1D,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,MAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,OAAO,UAAU,QAAA,EAAU;YAC7B,MAAM,IAAI,MAAM,qCAAqC,CAAA;QACvD;QACA,OAAO;YAAE,IAAA,EAAM,MAAA;YAAQ,KAAA;QAAA,CAAA;IACzB;AACF,CAAA;AAEA,IAAM,cAAA,GAAgE;IACpE,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,MAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;YACzB,MAAM,IAAI,MAAM,qCAAqC,CAAA;QACvD;QAEA,OAAO;YAAE,IAAA,EAAM,MAAA;YAAQ,KAAA;QAAA,CAAA;IACzB;AACF,CAAA;AAEA,IAAMC,gBAAAA,GAAwD;IAC5D,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,OAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,OAAO,UAAU,QAAA,EAAU;YAC7B,MAAM,IAAI,MAAM,sCAAsC,CAAA;QACxD;QACA,OAAO;YAAE,IAAA,EAAM,OAAA;YAAS,KAAA;QAAA,CAAA;IAC1B;AACF,CAAA;AAEA,IAAM,4BAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,qBAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;YACzB,MAAM,IAAI,MAAM,oDAAoD,CAAA;QACtE;QAEA,OAAO;YAAE,IAAA,EAAM,qBAAA;YAAuB,KAAA;QAAA,CAAA;IACxC;AACF,CAAA;AAEA,IAAM,kBAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,WAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,YAAA,IAAgB,KAAA,CAAA,IAClB,OAAO,KAAA,CAAM,UAAA,KAAe,QAAA,IAC5B,CAAA,CAAE,UAAA,IAAc,KAAA,CAAA,IAChB,OAAO,KAAA,CAAM,QAAA,KAAa,QAAA,IAC1B,CAAA,CAAE,MAAA,IAAU,KAAA,CAAA,IACZ,OAAO,KAAA,CAAM,IAAA,KAAS,QAAA,EACtB;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,OAAO;YACL,IAAA,EAAM,WAAA;YACN;QACF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,oBAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,aAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,YACjB,CAAA,CAAE,YAAA,IAAgB,KAAA,CAAA,IAClB,OAAO,KAAA,CAAM,UAAA,KAAe,QAAA,IAC5B,CAAA,CAAE,YAAY,KAAA,CAAA,EACd;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,OAAO;YACL,IAAA,EAAM,aAAA;YACN;QAIF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,gCAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,2BAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,SAAS,IAAA,IACT,OAAO,UAAU,QAAA,IACjB,CAAA,CAAE,gBAAgB,KAAA,CAAA,IAClB,OAAO,KAAA,CAAM,UAAA,KAAe,YAC5B,CAAA,CAAE,UAAA,IAAc,KAAA,KAChB,OAAO,KAAA,CAAM,QAAA,KAAa,QAAA,EAC1B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,OAAO;YACL,IAAA,EAAM,2BAAA;YACN;QACF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,uBAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,iBAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,SAAS,IAAA,IACT,OAAO,UAAU,QAAA,IACjB,CAAA,CAAE,gBAAgB,KAAA,CAAA,IAClB,OAAO,KAAA,CAAM,UAAA,KAAe,YAC5B,CAAA,CAAE,eAAA,IAAmB,KAAA,KACrB,OAAO,KAAA,CAAM,aAAA,KAAkB,QAAA,EAC/B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,OAAO;YACL,IAAA,EAAM,iBAAA;YACN;QAIF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,uBAAA,GAWF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,gBAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,cAAA,IAAkB,KAAA,CAAA,IACpB,OAAO,KAAA,CAAM,YAAA,KAAiB,QAAA,EAC9B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,MAAM,MAAA,GAMF;YACF,YAAA,EAAc,KAAA,CAAM,YAAA;QACtB,CAAA;QAEA,IACE,OAAA,IAAW,KAAA,IACX,KAAA,CAAM,KAAA,IAAS,QACf,OAAO,KAAA,CAAM,KAAA,KAAU,QAAA,IACvB,cAAA,IAAkB,KAAA,CAAM,KAAA,IACxB,kBAAA,IAAsB,MAAM,KAAA,EAC5B;YACA,MAAA,CAAO,KAAA,GAAQ;gBACb,YAAA,EACE,OAAO,MAAM,KAAA,CAAM,YAAA,KAAiB,WAChC,KAAA,CAAM,KAAA,CAAM,YAAA,GACZ,MAAA,CAAO,GAAA;gBACb,gBAAA,EACE,OAAO,MAAM,KAAA,CAAM,gBAAA,KAAqB,WACpC,KAAA,CAAM,KAAA,CAAM,gBAAA,GACZ,MAAA,CAAO,GAAA;YACf,CAAA;QACF;QAEA,OAAO;YACL,IAAA,EAAM,gBAAA;YACN,KAAA,EAAO;QACT,CAAA;IACF;AACF,CAAA;AAEA,IAAM,oBAAA,GAWF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,aAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,cAAA,IAAkB,KAAA,CAAA,IACpB,OAAO,KAAA,CAAM,YAAA,KAAiB,QAAA,EAC9B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,MAAM,MAAA,GAOF;YACF,YAAA,EAAc,KAAA,CAAM,YAAA;YACpB,WAAA,EAAa;QACf,CAAA;QAEA,IACE,OAAA,IAAW,KAAA,IACX,KAAA,CAAM,KAAA,IAAS,QACf,OAAO,KAAA,CAAM,KAAA,KAAU,QAAA,IACvB,cAAA,IAAkB,KAAA,CAAM,KAAA,IACxB,kBAAA,IAAsB,MAAM,KAAA,EAC5B;YACA,MAAA,CAAO,KAAA,GAAQ;gBACb,YAAA,EACE,OAAO,MAAM,KAAA,CAAM,YAAA,KAAiB,WAChC,KAAA,CAAM,KAAA,CAAM,YAAA,GACZ,MAAA,CAAO,GAAA;gBACb,gBAAA,EACE,OAAO,MAAM,KAAA,CAAM,gBAAA,KAAqB,WACpC,KAAA,CAAM,KAAA,CAAM,gBAAA,GACZ,MAAA,CAAO,GAAA;YACf,CAAA;QACF;QAEA,IAAI,aAAA,IAAiB,KAAA,IAAS,OAAO,KAAA,CAAM,WAAA,KAAgB,SAAA,EAAW;YACpE,MAAA,CAAO,WAAA,GAAc,KAAA,CAAM,WAAA;QAC7B;QAEA,OAAO;YACL,IAAA,EAAM,aAAA;YACN,KAAA,EAAO;QACT,CAAA;IACF;AACF,CAAA;AAEA,IAAM,mBAAA,GAMF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,YAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,WAAA,IAAe,KAAA,CAAA,IACjB,OAAO,KAAA,CAAM,SAAA,KAAc,QAAA,EAC3B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QAEA,OAAO;YACL,IAAA,EAAM,YAAA;YACN,KAAA,EAAO;gBACL,SAAA,EAAW,KAAA,CAAM,SAAA;YACnB;QACF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,mBAAA,GAAgE;IACpE,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,WAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,OAAO,UAAU,QAAA,EAAU;YAC7B,MAAM,IAAI,MAAM,0CAA0C,CAAA;QAC5D;QACA,OAAO;YAAE,IAAA,EAAM,WAAA;YAAa,KAAA;QAAA,CAAA;IAC9B;AACF,CAAA;AAEA,IAAM,UAAA,GAAmE;IACvE,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,QAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IAAI,KAAA,IAAS,IAAA,IAAQ,OAAO,KAAA,KAAU,QAAA,EAAU;YAC9C,MAAM,IAAI,MAAM,wCAAwC,CAAA;QAC1D;QAEA,OAAO;YACL,IAAA,EAAM,QAAA;YACN;QACF,CAAA;IACF;AACF,CAAA;AAEA,IAAM,2BAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,oBAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,MAAA,IAAU,KAAA,CAAA,IACZ,OAAO,KAAA,CAAM,IAAA,KAAS,QAAA,EACtB;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QACA,OAAO;YAAE,MAAM,oBAAA;YAAsB,KAAA,EAAO;gBAAE,IAAA,EAAM,KAAA,CAAM,IAAA;YAAA,CAAA;QAAA,CAAK;IACjE;AACF,CAAA;AAEA,IAAM,4BAAA,GAIF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,qBAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,KAAA,IAAS,IAAA,IACT,OAAO,KAAA,KAAU,QAAA,IACjB,CAAA,CAAE,WAAA,IAAe,KAAA,CAAA,IACjB,OAAO,KAAA,CAAM,SAAA,KAAc,QAAA,EAC3B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QACA,OAAO;YACL,IAAA,EAAM,qBAAA;YACN,KAAA,EAAO;gBAAE,SAAA,EAAW,KAAA,CAAM,SAAA;YAAA;QAC5B,CAAA;IACF;AACF,CAAA;AAEA,IAAM,cAAA,GAOF;IACF,IAAA,EAAM,GAAA;IACN,IAAA,EAAM,MAAA;IACN,KAAA,EAAO,CAAC,KAAA,KAAqB;QAC3B,IACE,SAAS,IAAA,IACT,OAAO,UAAU,QAAA,IACjB,CAAA,CAAE,UAAU,KAAA,CAAA,IACZ,OAAO,KAAA,CAAM,IAAA,KAAS,YACtB,CAAA,CAAE,UAAA,IAAc,KAAA,KAChB,OAAO,KAAA,CAAM,QAAA,KAAa,QAAA,EAC1B;YACA,MAAM,IAAI,KAAA,CACR;QAEJ;QACA,OAAO;YAAE,IAAA,EAAM,MAAA;YAAQ,KAAA;QAAA,CAAA;IACzB;AACF,CAAA;AAEA,IAAM,eAAA,GAAkB;IACtBD,eAAAA;IACA,cAAA;IACAC,gBAAAA;IACA,4BAAA;IACA,kBAAA;IACA,oBAAA;IACA,gCAAA;IACA,uBAAA;IACA,uBAAA;IACA,oBAAA;IACA,mBAAA;IACA,mBAAA;IACA,UAAA;IACA,2BAAA;IACA,4BAAA;IACA;CACF;AAEqC,MAAA,CAAO,WAAA,CAC1C,eAAA,CAAgB,GAAA,CAAI,CAAA,IAAA,GAAQ;QAAC,IAAA,CAAK,IAAA;QAAM,IAAI;KAAC;AAsCP,MAAA,CAAO,WAAA,CAC7C,eAAA,CAAgB,GAAA,CAAI,CAAA,IAAA,GAAQ;QAAC,KAAK,IAAA;QAAM,IAAA,CAAK,IAAI;KAAC;AAyC7C,SAAS,oBAAA,CACd,IAAA,EACA,KAAA,EACkB;IAClB,MAAM,aAAa,eAAA,CAAgB,IAAA,CAAK,CAAA,IAAA,GAAQ,IAAA,CAAK,IAAA,KAAS,IAAI,CAAA;IAElE,IAAI,CAAC,UAAA,EAAY;QACf,MAAM,IAAI,KAAA,CAAM,CAAA,0BAAA,EAA6B,IAAI,CAAA,CAAE,CAAA;IACrD;IAEA,OAAO,GAAG,UAAA,CAAW,IAAI,CAAA,CAAA,EAAI,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA;;AACpD;AC3iBO,SAAS,SAAA,CACdZ,UAAAA,EACA,OAAA,EASgB;IAhBlB,IAAAF,IAAAA;IAkBE,MAAM,aAAA,GAAA,CAAgBA,OAAA,KAAA,CAAS,KAAT,OAAAA,IAAAA,GAA0B,KAAA;IAEhD,OAAO,UAAA,CACL,WAAA,CAAgBE,UAAAA,EAAW;QACzB,YAAA,EAAc,gBAAgB,MAAA,GAAS,MAAA;QACvC,MAAA,EAAQ;IACT,CAAA,CAAA,EACD;QACE,QAAA,EAAU,CAAA,KAAA,KAAS;YACjB,MAAM,MAAA,GAASA,UAAAA,CAAU,SAAA,CAAU,KAAK,CAAA;YACxC,OAAO,MAAA,CAAO,OAAA,GACV;gBAAE,OAAA,EAAS;gBAAM,KAAA,EAAO,MAAA,CAAO,IAAA;YAAA,CAAA,GAC/B;gBAAE,OAAA,EAAS,KAAA;gBAAO,KAAA,EAAO,OAAO,KAAA;YAAA,CAAA;QACtC;IACF;AAEJ;AC1BA,IAAM,YAAA,GAAA,aAAA,GAAe,MAAA,CAAO,GAAA,CAAI,kBAAkB,CAAA;AAyB3C,SAAS,WACdQ,WAAAA,EACA,EACE,QAAA,EACF,GAII,CAAA,CAAA,EACY;IAChB,OAAO;QACL,CAAC,YAAY,CAAA,EAAG,IAAA;QAChB,KAAA,EAAO,KAAA,CAAA;;QACP,CAAC,eAAe,CAAA,EAAG,IAAA;QACnB,UAAA,EAAAA,WAAAA;QACA;IACF,CAAA;AACF;AAEA,SAAS,SAAS,KAAA,EAAiC;IACjD,OACE,OAAO,KAAA,KAAU,QAAA,IACjB,KAAA,KAAU,IAAA,IACV,YAAA,IAAgB,KAAA,IAChB,KAAA,CAAM,YAAY,CAAA,KAAM,IAAA,IACxB,YAAA,IAAgB,SAChB,UAAA,IAAc,KAAA;AAElB;AAEO,SAAS,SACd,MAAA,EACgB;IAChB,OAAO,QAAA,CAAS,MAAM,CAAA,GAAI,MAAA,GAAS,UAAU,MAAM,CAAA;AACrD;ACjDO,IAAM,WAAA,GAAc,OAAO,UAAA,KAAe,QAAA,GAAW,UAAA,GAAa,MAAA;ACDlE,IAAM,OAAA,GAAU,OAAA;ACCvB,IAAM,EAAA,GAAK,+BAAA;AAkBL,SAAU,wBACd,UAAA,EAAkB;IAElB,IAAM,gBAAA,GAAA,aAAA,GAAmB,IAAI,GAAA,CAAY;QAAC,UAAU;KAAC,CAAA;IACrD,IAAM,gBAAA,GAAA,aAAA,GAAA,IAAuB,GAAA,EAAA;IAE7B,IAAM,cAAA,GAAiB,UAAA,CAAW,KAAA,CAAM,EAAE,CAAA;IAC1C,IAAI,CAAC,cAAA,EAAgB;QAEnB,OAAO,WAAA;YAAM,OAAA,KAAA;QAAA,CAAA;;IAGf,IAAM,gBAAA,GAAmB;QACvB,KAAA,EAAO,CAAC,cAAA,CAAe,CAAC,CAAA;QACxB,KAAA,EAAO,CAAC,cAAA,CAAe,CAAC,CAAA;QACxB,KAAA,EAAO,CAAC,cAAA,CAAe,CAAC,CAAA;QACxB,UAAA,EAAY,cAAA,CAAe,CAAC,CAAA;;IAI9B,IAAI,gBAAA,CAAiB,UAAA,IAAc,IAAA,EAAM;QACvC,OAAO,SAAS,aAAa,aAAA,EAAqB;YAChD,OAAO,aAAA,KAAkB,UAAA;QAC3B,CAAA;;IAGF,SAAS,QAAQ,CAAA,EAAS;QACxB,gBAAA,CAAiB,GAAA,CAAI,CAAC,CAAA;QACtB,OAAO,KAAA;IACT;IAEA,SAAS,QAAQ,CAAA,EAAS;QACxB,gBAAA,CAAiB,GAAA,CAAI,CAAC,CAAA;QACtB,OAAO,IAAA;IACT;IAEA,OAAO,SAASK,cAAa,aAAA,EAAqB;QAChD,IAAI,gBAAA,CAAiB,GAAA,CAAI,aAAa,CAAA,EAAG;YACvC,OAAO,IAAA;;QAGT,IAAI,gBAAA,CAAiB,GAAA,CAAI,aAAa,CAAA,EAAG;YACvC,OAAO,KAAA;;QAGT,IAAM,kBAAA,GAAqB,aAAA,CAAc,KAAA,CAAM,EAAE,CAAA;QACjD,IAAI,CAAC,kBAAA,EAAoB;YAGvB,OAAO,QAAQ,aAAa,CAAA;;QAG9B,IAAM,mBAAA,GAAsB;YAC1B,KAAA,EAAO,CAAC,kBAAA,CAAmB,CAAC,CAAA;YAC5B,KAAA,EAAO,CAAC,kBAAA,CAAmB,CAAC,CAAA;YAC5B,KAAA,EAAO,CAAC,kBAAA,CAAmB,CAAC,CAAA;YAC5B,UAAA,EAAY,kBAAA,CAAmB,CAAC,CAAA;;QAIlC,IAAI,mBAAA,CAAoB,UAAA,IAAc,IAAA,EAAM;YAC1C,OAAO,QAAQ,aAAa,CAAA;;QAI9B,IAAI,gBAAA,CAAiB,KAAA,KAAU,mBAAA,CAAoB,KAAA,EAAO;YACxD,OAAO,QAAQ,aAAa,CAAA;;QAG9B,IAAI,gBAAA,CAAiB,KAAA,KAAU,CAAA,EAAG;YAChC,IACE,iBAAiB,KAAA,KAAU,mBAAA,CAAoB,KAAA,IAC/C,gBAAA,CAAiB,KAAA,IAAS,oBAAoB,KAAA,EAC9C;gBACA,OAAO,QAAQ,aAAa,CAAA;;YAG9B,OAAO,QAAQ,aAAa,CAAA;;QAG9B,IAAI,gBAAA,CAAiB,KAAA,IAAS,mBAAA,CAAoB,KAAA,EAAO;YACvD,OAAO,QAAQ,aAAa,CAAA;;QAG9B,OAAO,QAAQ,aAAa,CAAA;IAC9B,CAAA;AACF;AAiBO,IAAM,YAAA,GAAe,wBAAwB,OAAO,CAAA;AClH3D,IAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA;AAClC,IAAM,4BAAA,GAAA,aAAA,GAA+B,MAAA,CAAO,GAAA,CAC1C,uBAAA,GAAwB,KAAO,CAAA;AAGjC,IAAM,OAAA,GAAU,WAAA;AAEV,SAAU,cAAA,CACd,IAAA,EACA,QAAA,EACA,IAAA,EACA,aAAA,EAAqB;;IAArB,IAAA,kBAAA,KAAA,CAAA,EAAA;QAAA,aAAA,GAAA,KAAA;IAAqB;IAErB,IAAM,GAAA,GAAO,OAAA,CAAQ,4BAA4B,CAAA,GAAA,CAAIf,IAAAA,GAAA,OAAA,CACnD,4BAA4B,CAAA,MAC7B,IAAA,IAAAA,IAAAA,KAAA,KAAA,CAAA,GAAAA,IAAAA,GAAI;QACH,OAAA,EAAS;;IAGX,IAAI,CAAC,aAAA,IAAiB,GAAA,CAAI,IAAI,CAAA,EAAG;QAE/B,IAAM,GAAA,GAAM,IAAI,KAAA,CACd,+DAAA,GAAgE,IAAM,CAAA;QAExE,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,KAAA,IAAS,GAAA,CAAI,OAAO,CAAA;QACnC,OAAO,KAAA;;IAGT,IAAI,GAAA,CAAI,OAAA,KAAY,OAAA,EAAS;QAE3B,IAAM,GAAA,GAAM,IAAI,KAAA,CACd,+CAAA,GAAgD,IAAI,OAAA,GAAO,OAAA,GAAQ,IAAA,GAAI,6CAAA,GAA8C,OAAS,CAAA;QAEhI,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,KAAA,IAAS,GAAA,CAAI,OAAO,CAAA;QACnC,OAAO,KAAA;;IAGT,GAAA,CAAI,IAAI,CAAA,GAAI,QAAA;IACZ,IAAA,CAAK,KAAA,CACH,8CAAA,GAA+C,IAAA,GAAI,IAAA,GAAK,UAAO,GAAG,CAAA;IAGpE,OAAO,IAAA;AACT;AAEM,SAAU,UACd,IAAA,EAAU;;IAEV,IAAM,aAAA,GAAA,CAAgBA,OAAA,OAAA,CAAQ,4BAA4B,CAAA,MAAC,IAAA,IAAAA,IAAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAAA,IAAAA,CAAE,OAAA;IAC7D,IAAI,CAAC,aAAA,IAAiB,CAAC,YAAA,CAAa,aAAa,CAAA,EAAG;QAClD;;IAEF,OAAA,CAAO,EAAA,GAAA,OAAA,CAAQ,4BAA4B,CAAA,MAAC,QAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAG,IAAI,CAAA;AACrD;AAEM,SAAU,gBAAA,CAAiB,IAAA,EAA2B,IAAA,EAAgB;IAC1E,IAAA,CAAK,KAAA,CACH,iDAAA,GAAkD,IAAA,GAAI,IAAA,GAAK,UAAO,GAAG,CAAA;IAEvE,IAAM,GAAA,GAAM,OAAA,CAAQ,4BAA4B,CAAA;IAEhD,IAAI,GAAA,EAAK;QACP,OAAO,GAAA,CAAI,IAAI,CAAA;;AAEnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7DA,IAAA,mBAAA,iBAAA,WAAA;IAGE,SAAAgB,qBAAY,KAAA,EAA6B;QACvC,IAAA,CAAK,UAAA,GAAa,MAAM,SAAA,IAAa,qBAAA;IACvC;IAEOA,oBAAAA,CAAA,SAAA,CAAA,KAAA,GAAP,WAAA;QAAa,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAc;YAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACX,OAAO,QAAA,CAAS,OAAA,EAAS,IAAA,CAAK,UAAA,EAAY,IAAI,CAAA;IAChD,CAAA;IAEOA,oBAAAA,CAAA,SAAA,CAAA,KAAA,GAAP,WAAA;QAAa,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAc;YAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACX,OAAO,QAAA,CAAS,OAAA,EAAS,IAAA,CAAK,UAAA,EAAY,IAAI,CAAA;IAChD,CAAA;IAEOA,oBAAAA,CAAA,SAAA,CAAA,IAAA,GAAP,WAAA;QAAY,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAc;YAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACV,OAAO,QAAA,CAAS,MAAA,EAAQ,IAAA,CAAK,UAAA,EAAY,IAAI,CAAA;IAC/C,CAAA;IAEOA,oBAAAA,CAAA,SAAA,CAAA,IAAA,GAAP,WAAA;QAAY,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAc;YAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACV,OAAO,QAAA,CAAS,MAAA,EAAQ,IAAA,CAAK,UAAA,EAAY,IAAI,CAAA;IAC/C,CAAA;IAEOA,oBAAAA,CAAA,SAAA,CAAA,OAAA,GAAP,WAAA;QAAe,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAc;YAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACb,OAAO,QAAA,CAAS,SAAA,EAAW,IAAA,CAAK,UAAA,EAAY,IAAI,CAAA;IAClD,CAAA;IACF,OAAAA,oBAAAA;AAAA,CAAA;AAEA,SAAS,QAAA,CACP,QAAA,EACA,SAAA,EACA,IAAA,EAAS;IAET,IAAM,MAAA,GAAS,UAAU,MAAM,CAAA;IAE/B,IAAI,CAAC,MAAA,EAAQ;QACX;;IAGF,IAAA,CAAK,OAAA,CAAQ,SAAS,CAAA;IACtB,OAAO,MAAA,CAAO,QAAQ,CAAA,CAAC,KAAA,CAAhB,MAAA,EAAM,aAAA,CAAA,EAAA,EAAA,MAAA,CAAe,IAAoC,CAAA,EAAA,KAAA,CAAA,CAAA;AAClE;ACHA,IAAY,YAAA;AAAZ,CAAA,SAAYC,aAAAA,EAAY;IAEtBA,aAAAA,CAAAA,aAAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;IAGAA,aAAAA,CAAAA,aAAAA,CAAA,OAAA,CAAA,GAAA,EAAA,CAAA,GAAA,OAAA;IAGAA,aAAAA,CAAAA,aAAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;IAGAA,aAAAA,CAAAA,aAAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;IAGAA,aAAAA,CAAAA,aAAAA,CAAA,OAAA,CAAA,GAAA,EAAA,CAAA,GAAA,OAAA;IAMAA,aAAAA,CAAAA,aAAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;IAGAA,aAAAA,CAAAA,aAAAA,CAAA,KAAA,CAAA,GAAA,IAAA,CAAA,GAAA,KAAA;AACF,CAAA,EAxBY,YAAA,IAAA,CAAA,YAAA,GAAY,CAAA,CAAA,CAAA,CAAA;AChDlB,SAAU,wBAAA,CACd,QAAA,EACA,MAAA,EAAkB;IAElB,IAAI,QAAA,GAAW,aAAa,IAAA,EAAM;QAChC,QAAA,GAAW,YAAA,CAAa,IAAA;IACf,CAAA,MAAA,IAAA,QAAA,GAAW,aAAa,GAAA,EAAK;QACtC,QAAA,GAAW,YAAA,CAAa,GAAA;;IAI1B,MAAA,GAAS,UAAU,CAAA,CAAA;IAEnB,SAAS,WAAA,CACP,QAAA,EACA,QAAA,EAAsB;QAEtB,IAAM,OAAA,GAAU,MAAA,CAAO,QAAQ,CAAA;QAE/B,IAAI,OAAO,OAAA,KAAY,UAAA,IAAc,QAAA,IAAY,QAAA,EAAU;YACzD,OAAO,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA;;QAE5B,OAAO,WAAA,CAAa,CAAA;IACtB;IAEA,OAAO;QACL,KAAA,EAAO,WAAA,CAAY,OAAA,EAAS,YAAA,CAAa,KAAK,CAAA;QAC9C,IAAA,EAAM,WAAA,CAAY,MAAA,EAAQ,YAAA,CAAa,IAAI,CAAA;QAC3C,IAAA,EAAM,WAAA,CAAY,MAAA,EAAQ,YAAA,CAAa,IAAI,CAAA;QAC3C,KAAA,EAAO,WAAA,CAAY,OAAA,EAAS,YAAA,CAAa,KAAK,CAAA;QAC9C,OAAA,EAAS,WAAA,CAAY,SAAA,EAAW,YAAA,CAAa,OAAO;;AAExD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA,IAAM,QAAA,GAAW,MAAA;AAMjB,IAAA,OAAA,iBAAA,WAAA;IAgBE,SAAAC,QAAAA,GAAA;QACE,SAAS,UAAU,QAAA,EAA0B;YAC3C,OAAO,WAAA;gBAAU,IAAA,OAAA,EAAA;gBAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAO;oBAAP,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;gBACf,IAAM,MAAA,GAAS,UAAU,MAAM,CAAA;gBAE/B,IAAI,CAAC,MAAA,EAAQ;gBACb,OAAO,MAAA,CAAO,QAAQ,CAAA,CAAC,KAAA,CAAhB,MAAA,EAAMC,cAAAA,CAAA,EAAA,EAAAC,OAAAA,CAAc,IAAI,CAAA,EAAA,KAAA,CAAA,CAAA;YACjC,CAAA;QACF;QAGA,IAAM,IAAA,GAAO,IAAA;QAIb,IAAM,SAAA,GAAwC,SAC5C,MAAA,EACA,iBAAA,EAAmD;;YAAnD,IAAA,sBAAA,KAAA,CAAA,EAAA;gBAAA,iBAAA,GAAA;oBAAsB,QAAA,EAAU,YAAA,CAAa,IAAA;gBAAA,CAAA;YAAM;YAEnD,IAAI,WAAW,IAAA,EAAM;gBAInB,IAAM,GAAA,GAAM,IAAI,KAAA,CACd,oIAAoI,CAAA;gBAEtI,IAAA,CAAK,KAAA,CAAA,CAAMpB,OAAA,GAAA,CAAI,KAAA,MAAK,QAAAA,IAAAA,KAAA,KAAA,CAAA,GAAAA,IAAAA,GAAI,GAAA,CAAI,OAAO,CAAA;gBACnC,OAAO,KAAA;;YAGT,IAAI,OAAO,sBAAsB,QAAA,EAAU;gBACzC,iBAAA,GAAoB;oBAClB,QAAA,EAAU;;;YAId,IAAM,SAAA,GAAY,UAAU,MAAM,CAAA;YAClC,IAAM,SAAA,GAAY,wBAAA,CAAA,CAChB,EAAA,GAAA,iBAAA,CAAkB,QAAA,MAAQ,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,YAAA,CAAa,IAAA,EAC3C,MAAM,CAAA;YAGR,IAAI,SAAA,IAAa,CAAC,iBAAA,CAAkB,uBAAA,EAAyB;gBAC3D,IAAM,KAAA,GAAA,CAAQ,KAAA,IAAI,KAAA,GAAQ,KAAA,MAAK,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,iCAAA;gBACnC,SAAA,CAAU,IAAA,CAAK,6CAA2C,KAAO,CAAA;gBACjE,SAAA,CAAU,IAAA,CACR,+DAA6D,KAAO,CAAA;;YAIxE,OAAO,cAAA,CAAe,MAAA,EAAQ,SAAA,EAAW,IAAA,EAAM,IAAI,CAAA;QACrD,CAAA;QAEA,IAAA,CAAK,SAAA,GAAY,SAAA;QAEjB,IAAA,CAAK,OAAA,GAAU,WAAA;YACb,gBAAA,CAAiB,UAAU,IAAI,CAAA;QACjC,CAAA;QAEA,IAAA,CAAK,qBAAA,GAAwB,SAAC,OAAA,EAA+B;YAC3D,OAAO,IAAI,oBAAoB,OAAO,CAAA;QACxC,CAAA;QAEA,IAAA,CAAK,OAAA,GAAU,UAAU,SAAS,CAAA;QAClC,IAAA,CAAK,KAAA,GAAQ,UAAU,OAAO,CAAA;QAC9B,IAAA,CAAK,IAAA,GAAO,UAAU,MAAM,CAAA;QAC5B,IAAA,CAAK,IAAA,GAAO,UAAU,MAAM,CAAA;QAC5B,IAAA,CAAK,KAAA,GAAQ,UAAU,OAAO,CAAA;IAChC;IAhFckB,QAAAA,CAAA,QAAA,GAAd,WAAA;QACE,IAAI,CAAC,IAAA,CAAK,SAAA,EAAW;YACnB,IAAA,CAAK,SAAA,GAAY,IAAIA,QAAAA,EAAAA;;QAGvB,OAAO,IAAA,CAAK,SAAA;IACd,CAAA;IA+FF,OAAAA,QAAAA;AAAA,CAAA;AC3HM,SAAU,iBAAiB,WAAA,EAAmB;IAOlD,OAAO,MAAA,CAAO,GAAA,CAAI,WAAW,CAAA;AAC/B;AAEA,IAAA,WAAA,iCAAA,WAAA;IAQE,SAAAG,aAAY,aAAA,EAAoC;QAE9C,IAAM,IAAA,GAAO,IAAA;QAEb,IAAA,CAAK,eAAA,GAAkB,aAAA,GAAgB,IAAI,IAAI,aAAa,CAAA,GAAA,aAAA,GAAA,IAAQ,GAAA,EAAA;QAEpE,IAAA,CAAK,QAAA,GAAW,SAAC,GAAA,EAAW;YAAK,OAAA,IAAA,CAAK,eAAA,CAAgB,GAAA,CAAI,GAAG,CAAA;QAA5B,CAAA;QAEjC,IAAA,CAAK,QAAA,GAAW,SAAC,GAAA,EAAa,KAAA,EAAc;YAC1C,IAAM,OAAA,GAAU,IAAIA,YAAAA,CAAY,IAAA,CAAK,eAAe,CAAA;YACpD,OAAA,CAAQ,eAAA,CAAgB,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;YACtC,OAAO,OAAA;QACT,CAAA;QAEA,IAAA,CAAK,WAAA,GAAc,SAAC,GAAA,EAAW;YAC7B,IAAM,OAAA,GAAU,IAAIA,YAAAA,CAAY,IAAA,CAAK,eAAe,CAAA;YACpD,OAAA,CAAQ,eAAA,CAAgB,MAAA,CAAO,GAAG,CAAA;YAClC,OAAO,OAAA;QACT,CAAA;IACF;IAyBF,OAAAA,YAAAA;AAAA,CAAA;AAGO,IAAM,YAAA,GAAwB,IAAI,WAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEzC,IAAA,kBAAA,iBAAA,WAAA;IAAA,SAAAC,mBAAAA,GAAA,CAyBA;IAxBEA,mBAAAA,CAAA,SAAA,CAAA,MAAA,GAAA,WAAA;QACE,OAAO,YAAA;IACT,CAAA;IAEAA,mBAAAA,CAAA,SAAA,CAAA,IAAA,GAAA,SACE,QAAA,EACA,EAAA,EACA,OAAA,EAA8B;QAC9B,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAU;YAAV,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QAEA,OAAO,EAAA,CAAG,IAAA,CAAI,KAAA,CAAP,EAAA,EAAEH,cAAAA,CAAA;YAAM,OAAO;SAAA,EAAAC,OAAAA,CAAK,IAAI,CAAA,EAAA,KAAA,CAAA,CAAA;IACjC,CAAA;IAEAE,mBAAAA,CAAA,SAAA,CAAA,IAAA,GAAA,SAAQ,QAAA,EAAyB,MAAA,EAAS;QACxC,OAAO,MAAA;IACT,CAAA;IAEAA,mBAAAA,CAAA,SAAA,CAAA,MAAA,GAAA,WAAA;QACE,OAAO,IAAA;IACT,CAAA;IAEAA,mBAAAA,CAAA,SAAA,CAAA,OAAA,GAAA,WAAA;QACE,OAAO,IAAA;IACT,CAAA;IACF,OAAAA,mBAAAA;AAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA,IAAMC,SAAAA,GAAW,SAAA;AACjB,IAAM,oBAAA,GAAuB,IAAI,kBAAA,EAAA;AAKjC,IAAA,UAAA,iBAAA,WAAA;IAIE,SAAAC,WAAAA,GAAA,CAAuB;IAGTA,WAAAA,CAAA,WAAA,GAAd,WAAA;QACE,IAAI,CAAC,IAAA,CAAK,SAAA,EAAW;YACnB,IAAA,CAAK,SAAA,GAAY,IAAIA,WAAAA,EAAAA;;QAGvB,OAAO,IAAA,CAAK,SAAA;IACd,CAAA;IAOOA,WAAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,SAA+B,cAAA,EAA8B;QAC3D,OAAO,cAAA,CAAeD,SAAAA,EAAU,cAAA,EAAgB,OAAA,CAAQ,QAAA,EAAU,CAAA;IACpE,CAAA;IAKOC,WAAAA,CAAA,SAAA,CAAA,MAAA,GAAP,WAAA;QACE,OAAO,IAAA,CAAK,kBAAA,EAAA,CAAqB,MAAA,EAAA;IACnC,CAAA;IAUOA,WAAAA,CAAA,SAAA,CAAA,IAAA,GAAP,SACE,OAAA,EACA,EAAA,EACA,OAAA,EAA8B;;QAC9B,IAAA,OAAA,EAAA;QAAA,IAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,EAAA,CAAU;YAAV,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QAEA,OAAA,CAAOxB,OAAA,IAAA,CAAK,kBAAA,EAAA,EAAqB,IAAA,CAAI,KAAA,CAAAA,IAAAA,EAAAmB,cAAAA,CAAA;YAAC,OAAA;YAAS;YAAI,OAAO;SAAA,EAAAC,QAAK,IAAI,CAAA,EAAA,KAAA,CAAA,CAAA;IACrE,CAAA;IAQOI,WAAAA,CAAA,SAAA,CAAA,IAAA,GAAP,SAAe,OAAA,EAAkB,MAAA,EAAS;QACxC,OAAO,IAAA,CAAK,kBAAA,EAAA,CAAqB,IAAA,CAAK,SAAS,MAAM,CAAA;IACvD,CAAA;IAEQA,WAAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,WAAA;QACE,OAAO,SAAA,CAAUD,SAAQ,CAAA,IAAK,oBAAA;IAChC,CAAA;IAGOC,WAAAA,CAAA,SAAA,CAAA,OAAA,GAAP,WAAA;QACE,IAAA,CAAK,kBAAA,GAAqB,OAAA,EAAA;QAC1B,gBAAA,CAAiBD,SAAAA,EAAU,OAAA,CAAQ,QAAA,EAAU,CAAA;IAC/C,CAAA;IACF,OAAAC,WAAAA;AAAA,CAAA;ACnFA,IAAY,UAAA;AAAZ,CAAA,SAAYC,WAAAA,EAAU;IAEpBA,WAAAA,CAAAA,WAAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;IAEAA,WAAAA,CAAAA,WAAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACF,CAAA,EALY,UAAA,IAAA,CAAA,UAAA,GAAU,CAAA,CAAA,CAAA,CAAA;ACIf,IAAM,cAAA,GAAiB,kBAAA;AACvB,IAAM,eAAA,GAAkB,kCAAA;AACxB,IAAM,oBAAA,GAAoC;IAC/C,OAAA,EAAS,eAAA;IACT,MAAA,EAAQ,cAAA;IACR,UAAA,EAAY,UAAA,CAAW,IAAA;;ACMzB,IAAA,gBAAA,iBAAA,WAAA;IACE,SAAAC,kBACmB,YAAA,EAAgD;QAAhD,IAAA,iBAAA,KAAA,CAAA,EAAA;YAAA,YAAA,GAAA,oBAAA;QAAgD;QAAhD,IAAA,CAAA,YAAA,GAAA,YAAA;IAChB;IAGHA,iBAAAA,CAAA,SAAA,CAAA,WAAA,GAAA,WAAA;QACE,OAAO,IAAA,CAAK,YAAA;IACd,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,YAAA,GAAA,SAAa,IAAA,EAAc,MAAA,EAAe;QACxC,OAAO,IAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,aAAA,GAAA,SAAc,WAAA,EAA2B;QACvC,OAAO,IAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAS,KAAA,EAAe,WAAA,EAA4B;QAClD,OAAO,IAAA;IACT,CAAA;IAEAA,iBAAAA,CAAA,SAAA,CAAA,OAAA,GAAA,SAAQ,KAAA,EAAW;QACjB,OAAO,IAAA;IACT,CAAA;IAEAA,iBAAAA,CAAA,SAAA,CAAA,QAAA,GAAA,SAAS,MAAA,EAAc;QACrB,OAAO,IAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SAAU,OAAA,EAAmB;QAC3B,OAAO,IAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,UAAA,GAAA,SAAW,KAAA,EAAa;QACtB,OAAO,IAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,GAAA,GAAA,SAAI,QAAA,EAAoB,CAAS,CAAA;IAGjCA,iBAAAA,CAAA,SAAA,CAAA,WAAA,GAAA,WAAA;QACE,OAAO,KAAA;IACT,CAAA;IAGAA,iBAAAA,CAAA,SAAA,CAAA,eAAA,GAAA,SAAgB,UAAA,EAAuB,KAAA,EAAiB,CAAS,CAAA;IACnE,OAAAA,iBAAAA;AAAA,CAAA;ACzDA,IAAM,QAAA,GAAW,iBAAiB,gCAAgC,CAAA;AAO5D,SAAU,QAAQ,OAAA,EAAgB;IACtC,OAAQ,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA,IAAc,KAAA,CAAA;AACjD;AAKM,SAAU,aAAA,GAAa;IAC3B,OAAO,OAAA,CAAQ,UAAA,CAAW,WAAA,EAAA,CAAc,MAAA,EAAQ,CAAA;AAClD;AAQM,SAAU,OAAA,CAAQ,OAAA,EAAkB,IAAA,EAAU;IAClD,OAAO,OAAA,CAAQ,QAAA,CAAS,QAAA,EAAU,IAAI,CAAA;AACxC;AAOM,SAAU,WAAW,OAAA,EAAgB;IACzC,OAAO,OAAA,CAAQ,WAAA,CAAY,QAAQ,CAAA;AACrC;AASM,SAAU,cAAA,CACd,OAAA,EACA,WAAA,EAAwB;IAExB,OAAO,OAAA,CAAQ,OAAA,EAAS,IAAI,gBAAA,CAAiB,WAAW,CAAC,CAAA;AAC3D;AAOM,SAAU,eAAe,OAAA,EAAgB;;IAC7C,OAAA,CAAO1B,IAAAA,GAAA,QAAQ,OAAO,CAAA,MAAC,QAAAA,IAAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAAA,IAAAA,CAAE,WAAA,EAAA;AAC3B;AChEA,IAAM,mBAAA,GAAsB,mBAAA;AAC5B,IAAM,kBAAA,GAAqB,iBAAA;AAErB,SAAU,eAAe,OAAA,EAAe;IAC5C,OAAO,mBAAA,CAAoB,IAAA,CAAK,OAAO,CAAA,IAAK,OAAA,KAAY,eAAA;AAC1D;AAEM,SAAU,cAAc,MAAA,EAAc;IAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,MAAM,CAAA,IAAK,MAAA,KAAW,cAAA;AACvD;AAMM,SAAU,mBAAmB,WAAA,EAAwB;IACzD,OACE,eAAe,WAAA,CAAY,OAAO,CAAA,IAAK,aAAA,CAAc,YAAY,MAAM,CAAA;AAE3E;AAQM,SAAU,gBAAgB,WAAA,EAAwB;IACtD,OAAO,IAAI,iBAAiB,WAAW,CAAA;AACzC;ACvBA,IAAM,UAAA,GAAa,WAAW,WAAA,EAAA;AAK9B,IAAA,UAAA,iBAAA,WAAA;IAAA,SAAA2B,WAAAA,GAAA,CAoEA;IAlEEA,WAAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SACE9B,MAAAA,EACA,OAAA,EACA,OAAA,EAA6B;QAA7B,IAAA,YAAA,KAAA,CAAA,EAAA;YAAA,OAAA,GAAU,WAAW,MAAA,EAAA;QAAQ;QAE7B,IAAM,IAAA,GAAO,QAAQ,OAAA,KAAO,IAAA,IAAP,YAAO,KAAA,CAAA,GAAA,KAAA,CAAA,GAAP,QAAS,IAAI,CAAA;QAClC,IAAI,IAAA,EAAM;YACR,OAAO,IAAI,gBAAA,EAAA;;QAGb,IAAM,iBAAA,GAAoB,OAAA,IAAW,cAAA,CAAe,OAAO,CAAA;QAE3D,IACE,aAAA,CAAc,iBAAiB,CAAA,IAC/B,kBAAA,CAAmB,iBAAiB,CAAA,EACpC;YACA,OAAO,IAAI,iBAAiB,iBAAiB,CAAA;QACxC,CAAA,MAAA;YACL,OAAO,IAAI,gBAAA,EAAA;;IAEf,CAAA;IAiBA8B,WAAAA,CAAA,SAAA,CAAA,eAAA,GAAA,SACE9B,MAAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EAAQ;QAER,IAAI,IAAA;QACJ,IAAI,GAAA;QACJ,IAAI,EAAA;QAEJ,IAAI,SAAA,CAAU,MAAA,GAAS,CAAA,EAAG;YACxB;QACS,CAAA,MAAA,IAAA,SAAA,CAAU,MAAA,KAAW,CAAA,EAAG;YACjC,EAAA,GAAK,IAAA;QACI,CAAA,MAAA,IAAA,SAAA,CAAU,MAAA,KAAW,CAAA,EAAG;YACjC,IAAA,GAAO,IAAA;YACP,EAAA,GAAK,IAAA;QACA,CAAA,MAAA;YACL,IAAA,GAAO,IAAA;YACP,GAAA,GAAM,IAAA;YACN,EAAA,GAAK,IAAA;;QAGP,IAAM,gBAAgB,GAAA,KAAG,IAAA,IAAH,QAAG,KAAA,CAAA,GAAH,GAAA,GAAO,WAAW,MAAA,EAAA;QACxC,IAAM,IAAA,GAAO,IAAA,CAAK,SAAA,CAAUA,MAAAA,EAAM,MAAM,aAAa,CAAA;QACrD,IAAM,kBAAA,GAAqB,OAAA,CAAQ,aAAA,EAAe,IAAI,CAAA;QAEtD,OAAO,UAAA,CAAW,IAAA,CAAK,kBAAA,EAAoB,EAAA,EAAI,KAAA,GAAW,IAAI,CAAA;IAChE,CAAA;IACF,OAAA8B,WAAAA;AAAA,CAAA;AAEA,SAAS,cAAc,WAAA,EAAgB;IACrC,OACE,OAAO,WAAA,KAAgB,QAAA,IACvB,OAAO,WAAA,CAAY,QAAQ,CAAA,KAAM,QAAA,IACjC,OAAO,WAAA,CAAY,SAAS,CAAA,KAAM,QAAA,IAClC,OAAO,WAAA,CAAY,YAAY,CAAA,KAAM,QAAA;AAEzC;ACrFA,IAAM,WAAA,GAAc,IAAI,UAAA,EAAA;AAKxB,IAAA,WAAA,iBAAA,WAAA;IAIE,SAAAC,YAAAA,CACU,SAAA,EACQ/B,MAAAA,EACA,OAAA,EACA,OAAA,EAAuB;QAH/B,IAAA,CAAA,SAAA,GAAA,SAAA;QACQ,IAAA,CAAA,IAAA,GAAAA,MAAAA;QACA,IAAA,CAAA,OAAA,GAAA,OAAA;QACA,IAAA,CAAA,OAAA,GAAA,OAAA;IACf;IAEH+B,YAAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SAAU/B,MAAAA,EAAc,OAAA,EAAuB,OAAA,EAAiB;QAC9D,OAAO,IAAA,CAAK,UAAA,EAAA,CAAa,SAAA,CAAUA,MAAAA,EAAM,SAAS,OAAO,CAAA;IAC3D,CAAA;IAEA+B,YAAAA,CAAA,SAAA,CAAA,eAAA,GAAA,SACE,KAAA,EACA,QAAA,EACA,QAAA,EACA,GAAA,EAAO;QAEP,IAAM,MAAA,GAAS,IAAA,CAAK,UAAA,EAAA;QACpB,OAAO,OAAA,CAAQ,KAAA,CAAM,MAAA,CAAO,eAAA,EAAiB,QAAQ,SAAS,CAAA;IAChE,CAAA;IAMQA,YAAAA,CAAA,SAAA,CAAA,UAAA,GAAR,WAAA;QACE,IAAI,IAAA,CAAK,SAAA,EAAW;YAClB,OAAO,IAAA,CAAK,SAAA;;QAGd,IAAM,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,iBAAA,CAC5B,IAAA,CAAK,IAAA,EACL,IAAA,CAAK,OAAA,EACL,IAAA,CAAK,OAAO,CAAA;QAGd,IAAI,CAAC,MAAA,EAAQ;YACX,OAAO,WAAA;;QAGT,IAAA,CAAK,SAAA,GAAY,MAAA;QACjB,OAAO,IAAA,CAAK,SAAA;IACd,CAAA;IACF,OAAAA,YAAAA;AAAA,CAAA;AChDA,IAAA,kBAAA,iBAAA,WAAA;IAAA,SAAAC,mBAAAA,GAAA,CAQA;IAPEA,mBAAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SACE,KAAA,EACA,QAAA,EACA,QAAA,EAAwB;QAExB,OAAO,IAAI,UAAA,EAAA;IACb,CAAA;IACF,OAAAA,mBAAAA;AAAA,CAAA;ACbA,IAAM,oBAAA,GAAuB,IAAI,kBAAA,EAAA;AAUjC,IAAA,mBAAA,iBAAA,WAAA;IAAA,SAAAC,oBAAAA,GAAA,CA+BA;IAzBEA,oBAAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SAAUjC,MAAAA,EAAc,OAAA,EAAkB,OAAA,EAAuB;;QAC/D,OAAA,CACEG,OAAA,IAAA,CAAK,iBAAA,CAAkBH,MAAAA,EAAM,OAAA,EAAS,OAAO,CAAA,MAAC,IAAA,IAAAG,IAAAA,KAAA,KAAA,CAAA,GAAAA,OAC9C,IAAI,WAAA,CAAY,IAAA,EAAMH,MAAAA,EAAM,SAAS,OAAO,CAAA;IAEhD,CAAA;IAEAiC,oBAAAA,CAAA,SAAA,CAAA,WAAA,GAAA,WAAA;;QACE,OAAA,CAAO9B,OAAA,IAAA,CAAK,SAAA,MAAS,IAAA,IAAAA,IAAAA,KAAA,KAAA,IAAAA,IAAAA,GAAI,oBAAA;IAC3B,CAAA;IAKA8B,oBAAAA,CAAA,SAAA,CAAA,WAAA,GAAA,SAAY,QAAA,EAAwB;QAClC,IAAA,CAAK,SAAA,GAAY,QAAA;IACnB,CAAA;IAEAA,oBAAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,SACEjC,MAAAA,EACA,OAAA,EACA,OAAA,EAAuB;;QAEvB,OAAA,CAAOG,IAAAA,GAAA,IAAA,CAAK,SAAA,MAAS,IAAA,IAAAA,IAAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAAA,IAAAA,CAAE,SAAA,CAAUH,MAAAA,EAAM,OAAA,EAAS,OAAO,CAAA;IACzD,CAAA;IACF,OAAAiC,oBAAAA;AAAA,CAAA;ACtCA,IAAY,cAAA;AAAZ,CAAA,SAAYC,eAAAA,EAAc;IAIxBA,eAAAA,CAAAA,eAAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;IAKAA,eAAAA,CAAAA,eAAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA;IAIAA,eAAAA,CAAAA,eAAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACF,CAAA,EAdY,cAAA,IAAA,CAAA,cAAA,GAAc,CAAA,CAAA,CAAA,CAAA;ACa1B,IAAMR,SAAAA,GAAW,OAAA;AAKjB,IAAA,QAAA,iBAAA,WAAA;IAME,SAAAS,SAAAA,GAAA;QAHQ,IAAA,CAAA,oBAAA,GAAuB,IAAI,mBAAA,EAAA;QAmD5B,IAAA,CAAA,eAAA,GAAkB,eAAA;QAElB,IAAA,CAAA,kBAAA,GAAqB,kBAAA;QAErB,IAAA,CAAA,UAAA,GAAa,UAAA;QAEb,IAAA,CAAA,OAAA,GAAU,OAAA;QAEV,IAAA,CAAA,aAAA,GAAgB,aAAA;QAEhB,IAAA,CAAA,cAAA,GAAiB,cAAA;QAEjB,IAAA,CAAA,OAAA,GAAU,OAAA;QAEV,IAAA,CAAA,cAAA,GAAiB,cAAA;IA9DD;IAGTA,SAAAA,CAAA,WAAA,GAAd,WAAA;QACE,IAAI,CAAC,IAAA,CAAK,SAAA,EAAW;YACnB,IAAA,CAAK,SAAA,GAAY,IAAIA,SAAAA,EAAAA;;QAGvB,OAAO,IAAA,CAAK,SAAA;IACd,CAAA;IAOOA,SAAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,SAA+B,QAAA,EAAwB;QACrD,IAAM,UAAU,cAAA,CACdT,SAAAA,EACA,IAAA,CAAK,oBAAA,EACL,OAAA,CAAQ,QAAA,EAAU,CAAA;QAEpB,IAAI,OAAA,EAAS;YACX,IAAA,CAAK,oBAAA,CAAqB,WAAA,CAAY,QAAQ,CAAA;;QAEhD,OAAO,OAAA;IACT,CAAA;IAKOS,SAAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,WAAA;QACE,OAAO,SAAA,CAAUT,SAAQ,CAAA,IAAK,IAAA,CAAK,oBAAA;IACrC,CAAA;IAKOS,SAAAA,CAAA,SAAA,CAAA,SAAA,GAAP,SAAiBnC,MAAAA,EAAc,OAAA,EAAgB;QAC7C,OAAO,IAAA,CAAK,iBAAA,EAAA,CAAoB,SAAA,CAAUA,QAAM,OAAO,CAAA;IACzD,CAAA;IAGOmC,SAAAA,CAAA,SAAA,CAAA,OAAA,GAAP,WAAA;QACE,gBAAA,CAAiBT,SAAAA,EAAU,OAAA,CAAQ,QAAA,EAAU,CAAA;QAC7C,IAAA,CAAK,oBAAA,GAAuB,IAAI,mBAAA,EAAA;IAClC,CAAA;IAiBF,OAAAS,SAAAA;AAAA,CAAA;AC5FqB,SAAS,WAAA;;;;;;;;ACpBvB,SAAS,uBACd,OAAA,EACA,EACE,WAAA,EACA,iBAAA,EACF,EACA;IACA,MAAM,kBAAkB,IAAI,OAAA,CAAQ,WAAA,IAAA,GAAA,OAAA,GAAW,CAAA,CAAE,CAAA;IAEjD,IAAI,CAAC,eAAA,CAAgB,GAAA,CAAI,cAAc,CAAA,EAAG;QACxC,eAAA,CAAgB,GAAA,CAAI,gBAAgB,WAAW,CAAA;IACjD;IAEqC;QACnC,eAAA,CAAgB,GAAA,CAAI,2BAA2B,iBAAiB,CAAA;IAClE;IAEA,OAAO,eAAA;AACT;ACbA,IAAMnC,MAAAA,GAAO,2BAAA;AACb,IAAMC,QAAAA,GAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA,CAAA;AACtC,IAAME,QAAAA,GAAS,MAAA,CAAO,GAAA,CAAID,QAAM,CAAA;AAPhC,IAAAE,IAAAA;AAoBO,IAAM,sBAAA,GAAN,cAAqCiC,UAAAA,CAAW;IAuBrD,WAAA,CAAY,EACV,OAAA,GAAU,sBAAA,EACV,KAAA,EACA,IAAA,EAAAtC,KAAAA,EACA,QAAA,EACA,KAAA,EACA,YAAA,EAQC,CAAA;QACD,KAAA,CAAM;YAAE,IAAA,EAAAE,MAAAA;YAAM,OAAA;YAAS;QAAA,CAAO,CAAA;QArChC,IAAA,CAAkBG,IAAAA,CAAAA,GAAU,IAAA;QAuC1B,IAAA,CAAK,IAAA,GAAOL,KAAAA;QACZ,IAAA,CAAK,QAAA,GAAW,QAAA;QAChB,IAAA,CAAK,KAAA,GAAQ,KAAA;QACb,IAAA,CAAK,YAAA,GAAe,YAAA;IACtB;IAEA,OAAO,WAAW,KAAA,EAAiD;QACjE,OAAOsC,UAAAA,CAAW,SAAA,CAAU,KAAA,EAAOnC,QAAM,CAAA;IAC3C;AACF,CAAA;AAhDoBE,IAAAA,GAAAD,QAAAA;ACNb,IAAM,iBAAA,GAA4C,yKAAA,CAAE,KAAA,CAAM;IAC/D,yKAAA,CAAE,MAAA,EAAA;IACF,yKAAA,CAAE,UAAA,CAAW,UAAU,CAAA;IACvB,yKAAA,CAAE,UAAA,CAAW,WAAW,CAAA;IACxB,yKAAA,CAAE,MAAA;IAEA,CAAC,KAAA,KAAiC;QArBtC,IAAAC,IAAAA,EAAA,EAAA;QAsBM,OAAA,CAAA,EAAA,GAAA,CAAAA,IAAAA,GAAA,UAAA,CAAW,MAAA,KAAX,IAAA,GAAA,KAAA,CAAA,GAAAA,IAAAA,CAAmB,QAAA,CAAS,KAAA,CAAA,KAA5B,IAAA,GAAA,EAAA,GAAsC,KAAA;IAAA,CAAA,EACxC;QAAE,SAAS,kBAAA;IAAA;CAEd,CAAA;ACtBM,IAAM,kBAAwCkC,yKAAAA,CAAE,IAAA,CAAK,IAC1DA,yKAAAA,CAAE,KAAA,CAAM;QACNA,yKAAAA,CAAE,IAAA,EAAA;QACFA,yKAAAA,CAAE,MAAA,EAAA;QACFA,yKAAAA,CAAE,MAAA,EAAA;QACFA,yKAAAA,CAAE,OAAA,EAAA;QACFA,yKAAAA,CAAE,MAAA,CAAOA,yKAAAA,CAAE,MAAA,EAAA,EAAU,eAAe,CAAA;QACpCA,yKAAAA,CAAE,KAAA,CAAM,eAAe;KACxB;ACUI,IAAM,yBAAsDA,yKAAAA,CAAE,MAAA,CACnEA,yKAAAA,CAAE,MAAA,EAAA,EACFA,yKAAAA,CAAE,MAAA,CAAOA,yKAAAA,CAAE,MAAA,EAAA,EAAU,eAAe;ACT/B,IAAM,0BAAwDA,yKAAAA,CAAE,KAAA,CACrEA,yKAAAA,CAAE,KAAA,CAAM;IACNA,yKAAAA,CAAE,MAAA,CAAO;QAAE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;QAAG,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IAAA,CAAU,CAAA;IACtDA,yKAAAA,CAAE,MAAA,CAAO;QACP,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;QACvB,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;QACR,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,QAAA;IACtB,CAAA;CACF;ACiBI,IAAM,cAAA,GAAsCA,yKAAAA,CAAE,MAAA,CAAO;IAC1D,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;IACtB,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IACR,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAqCM,IAAM,eAAA,GAAwCA,yKAAAA,CAAE,MAAA,CAAO;IAC5D,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;IACvB,KAAA,EAAOA,yKAAAA,CAAE,KAAA,CAAM;QAAC,iBAAA;QAAmBA,yKAAAA,CAAE,UAAA,CAAW,GAAG,CAAC;KAAC,CAAA;IACrD,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,QAAA,EAAA;IACrB,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AA0CM,IAAM,cAAA,GAAsCA,yKAAAA,CAAE,MAAA,CAAO;IAC1D,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;IACtB,IAAA,EAAMA,yKAAAA,CAAE,KAAA,CAAM;QAAC,iBAAA;QAAmBA,yKAAAA,CAAE,UAAA,CAAW,GAAG,CAAC;KAAC,CAAA;IACpD,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,QAAA,EAAA;IACrB,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA;IACZ,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAkCM,IAAM,mBAAA,GAAgDA,yKAAAA,CAAE,MAAA,CAAO;IACpE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,WAAW,CAAA;IAC3B,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IACR,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AA6BM,IAAM,2BAAA,GACXA,yKAAAA,CAAE,MAAA,CAAO;IACP,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,oBAAoB,CAAA;IACpC,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IACR,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAuCI,IAAM,kBAAA,GAA8CA,yKAAAA,CAAE,MAAA,CAAO;IAClE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,WAAW,CAAA;IAC3B,UAAA,EAAYA,yKAAAA,CAAE,MAAA,EAAA;IACd,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA;IACZ,IAAA,EAAMA,yKAAAA,CAAE,OAAA,EAAA;IACR,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAiDM,IAAM,oBAAA,GAAkDA,yKAAAA,CAAE,MAAA,CAAO;IACtE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,aAAa,CAAA;IAC7B,UAAA,EAAYA,yKAAAA,CAAE,MAAA,EAAA;IACd,QAAA,EAAUA,yKAAAA,CAAE,MAAA,EAAA;IACZ,MAAA,EAAQA,yKAAAA,CAAE,OAAA,EAAA;IACV,OAAA,EAAS,wBAAwB,QAAA,EAAA;IACjC,OAAA,EAASA,yKAAAA,CAAE,OAAA,EAAA,CAAU,QAAA,EAAA;IACrB,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AC3QM,IAAM,uBAAA,GAAwDA,yKAAAA,CAAE,MAAA,CAAO;IAC5E,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,QAAQ,CAAA;IACxB,OAAA,EAASA,yKAAAA,CAAE,MAAA,EAAA;IACX,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAsBM,IAAM,qBAAA,GAAoDA,yKAAAA,CAAE,MAAA,CAAO;IACxE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;IACtB,OAAA,EAASA,yKAAAA,CAAE,KAAA,CAAM;QACfA,yKAAAA,CAAE,MAAA,EAAA;QACFA,yKAAAA,CAAE,KAAA,CAAMA,yKAAAA,CAAE,KAAA,CAAM;YAAC;YAAgB,eAAA;YAAiB,cAAc;SAAC,CAAC;KACnE,CAAA;IACD,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AA2BM,IAAM,0BAAA,GACXA,yKAAAA,CAAE,MAAA,CAAO;IACP,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,WAAW,CAAA;IAC3B,OAAA,EAASA,yKAAAA,CAAE,KAAA,CAAM;QACfA,yKAAAA,CAAE,MAAA,EAAA;QACFA,yKAAAA,CAAE,KAAA,CACAA,yKAAAA,CAAE,KAAA,CAAM;YACN,cAAA;YACA,cAAA;YACA,mBAAA;YACA,2BAAA;YACA;SACD;KAEJ,CAAA;IACD,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAgCI,IAAM,qBAAA,GAAoDA,yKAAAA,CAAE,MAAA,CAAO;IACxE,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;IACtB,OAAA,EAASA,yKAAAA,CAAE,KAAA,CAAM,oBAAoB,CAAA;IACrC,eAAA,EAAiB,uBAAuB,QAAA,EAAA;IACxC,6BAAA,EAA+B,uBAAuB,QAAA;AACxD,CAAC,CAAA;AAiBwDA,yKAAAA,CAAE,KAAA,CAAM;IAC/D,uBAAA;IACA,qBAAA;IACA,0BAAA;IACA;CACD;ACvLD,IAAM,qBAAA,GAAwB,cAAA;AAC9B,IAAM,qBAAA,GACJ,wEAAA;AACF,IAAM,sBAAA,GAAyB,4BAAA;AAExB,SAAS,qBAAA,CAAsB,EACpC,MAAA,EACA,MAAA,EACA,YAAA,GAAe,MAAA,IAAU,OAAO,qBAAA,GAAwB,KAAA,CAAA,EACxD,YAAA,GAAe,MAAA,IAAU,OACrB,qBAAA,GACA,sBAAA,EACN,EAKW;IACT,OAAO;QACL,MAAA,IAAU,IAAA,IAAQ,MAAA,CAAO,MAAA,GAAS,CAAA,GAAI,MAAA,GAAS,KAAA,CAAA;QAC/C,MAAA,IAAU,IAAA,IAAQ,MAAA,CAAO,MAAA,GAAS,CAAA,GAAI,EAAA,GAAK,KAAA,CAAA;;QAC3C,YAAA;QACA,MAAA,IAAU,IAAA,GAAO,IAAA,CAAK,SAAA,CAAU,MAAM,CAAA,GAAI,KAAA,CAAA;QAC1C;KACF,CACG,MAAA,CAAO,CAAA,IAAA,GAAQ,QAAQ,IAAI,CAAA,CAC3B,IAAA,CAAK,IAAI,CAAA;AACd;ACW2B,iBAAA,CAAkB;IAAE,QAAQ,OAAA;IAAS,IAAA,EAAM;AAAA,CAAI;ACkB/CC,iBAAAA,CAAkB;IAAE,QAAQ,OAAA;IAAS,IAAA,EAAM;AAAA,CAAI;ACjB/CA,iBAAAA,CAAkB;IAC3C,MAAA,EAAQ,OAAA;IACR,IAAA,EAAM;AACR,CAAC;AAEiCA,iBAAAA,CAAkB;IAClD,MAAA,EAAQ,KAAA;IACR,IAAA,EAAM;AACR,CAAC;ACjDD,IAAA,iBAAA,CAAA,CAAA;AAAA,QAAA,CAAA,cAAA,EAAA;IAAA,MAAA,EAAA,IAAA,MAAA;IAAA,IAAA,EAAA,IAAA;AAAA,CAAA,CAAA;AAyCO,IAAM,OAAO,IAAA,CAA+B;QACjD,IAAA,EAAM,MAAA;QAEN,cAAA,EAAgB,IAAA,CAAO;gBAAE,IAAA,EAAM,MAAA;YAAA,CAAA,CAAA;QAE/B,sBAAA,EAAuB,EAAE,MAAA,EAAA,EAA0C;YACjE,OAAO,MAAA;QACT,CAAA;QAEA,YAAA,EAAa,EAAE,IAAA,EAAAxC,KAAAA,EAAAA,EAA0B;YACvC,OAAO;gBAAE,SAASA,KAAAA;YAAAA,CAAAA;QACpB,CAAA;QAEA,WAAA,EAAY,EAAE,IAAA,EAAAA,KAAAA,EAAAA,EAA0B;YACtC,OAAOA,KAAAA;QACT;IACF,CAAA,CAAA;AAEO,IAAM,SAAS,CAAS,EAC7B,MAAA,EAAQ,WAAA,EACV,KAE2C;IACzC,MAAM,MAAA,GAASyC,SAAS,WAAW,CAAA;IAEnC,OAAO;QACL,IAAA,EAAM,QAAA;QAEN,cAAA,EAAgB,CAAC,EAAE,KAAA,EAAA,GAAA,CAAa;gBAC9B,IAAA,EAAM,MAAA;gBACN,MAAA,EAAQ,KAAA,CAAM,yBAAA,GAA4B,MAAA,CAAO,UAAA,GAAa,KAAA;YAChE,CAAA,CAAA;QAEA,sBAAA,EAAuB,EAAE,MAAA,EAAQ,KAAA,EAAA,EAAS;YAGxC,OAAO,KAAA,CAAM,yBAAA,GACT,MAAA,GACA,qBAAA,CAAsB;gBACpB,MAAA,EAAQ,MAAA;gBACR,MAAA,EAAQ,MAAA,CAAO,UAAA;YAChB,CAAA,CAAA;QACP,CAAA;QAEA,YAAA,EAAa,EAAE,IAAA,EAAAzC,KAAAA,EAAAA,EAA0B;YACvC,MAAM,MAAA,GAAS0C,iBAAiB1C,KAAI,CAAA;YAEpC,OAAQ,OAAO,KAAA;gBACb,KAAK,cAAA;gBACL,KAAK,iBAAA;oBACH,OAAO,KAAA,CAAA;gBAET,KAAK,gBAAA;gBACL,KAAK,kBAAA;oBACH,OAAO;;wBAEL,OAAA,EAAS,MAAA,CAAO,KAAA;oBAClB,CAAA;gBAEF;oBAAS;wBACP,MAAM,mBAA0B,MAAA,CAAO,KAAA;wBACvC,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAA4B,gBAAgB,CAAA,CAAE,CAAA;oBAChE;YACF;QACF,CAAA;QAEA,WAAA,EACE,EAAE,IAAA,EAAAA,KAAAA,EAAAA,EACF,OAAA,EAKA;YACA,MAAM,WAAA,GAAc2C,aAAAA,CAAc;gBAAE,IAAA,EAAA3C;YAAAA,CAAM,CAAA;YAE1C,IAAI,CAAC,YAAY,OAAA,EAAS;gBACxB,MAAM,IAAI,sBAAA,CAAuB;oBAC/B,OAAA,EAAS,oDAAA;oBACT,KAAA,EAAO,WAAA,CAAY,KAAA;oBACnB,IAAA,EAAAA,KAAAA;oBACA,QAAA,EAAU,OAAA,CAAQ,QAAA;oBAClB,KAAA,EAAO,OAAA,CAAQ,KAAA;oBACf,YAAA,EAAc,OAAA,CAAQ,YAAA;gBACvB,CAAA,CAAA;YACH;YAEA,MAAM,mBAAmB4C,iBAAAA,CAAkB;gBACzC,KAAA,EAAO,WAAA,CAAY,KAAA;gBACnB;YACD,CAAA,CAAA;YAED,IAAI,CAAC,iBAAiB,OAAA,EAAS;gBAC7B,MAAM,IAAI,sBAAA,CAAuB;oBAC/B,OAAA,EAAS,qDAAA;oBACT,KAAA,EAAO,gBAAA,CAAiB,KAAA;oBACxB,IAAA,EAAA5C,KAAAA;oBACA,QAAA,EAAU,OAAA,CAAQ,QAAA;oBAClB,KAAA,EAAO,OAAA,CAAQ,KAAA;oBACf,YAAA,EAAc,OAAA,CAAQ,YAAA;gBACvB,CAAA,CAAA;YACH;YAEA,OAAO,gBAAA,CAAiB,KAAA;QAC1B;IACF,CAAA;AACF,CAAA;ACtIO,SAAS,YAAA,CACd,OAAA,EACA,OAAA,EACiC;IACjC,MAAM,OAAA,GAAU,QAAQ,SAAA,EAAA;IACxB,MAAM,OAAA,GAAU,QAAQ,SAAA,EAAA;IAExB,IAAI,SAAA,GACF,KAAA,CAAA;IACF,IAAI,SAAA,GACF,KAAA,CAAA;IAEF,IAAI,WAAA,GAAc,KAAA;IAClB,IAAI,WAAA,GAAc,KAAA;IAGlB,eAAe,YACb,UAAA,EACA;QACA,IAAI;YACF,IAAI,aAAa,IAAA,EAAM;gBACrB,SAAA,GAAY,QAAQ,IAAA,EAAA;YACtB;YAEA,MAAM,SAAS,MAAM,SAAA;YACrB,SAAA,GAAY,KAAA,CAAA;YAEZ,IAAI,CAAC,OAAO,IAAA,EAAM;gBAChB,UAAA,CAAW,OAAA,CAAQ,OAAO,KAAK,CAAA;YACjC,CAAA,MAAO;gBACL,UAAA,CAAW,KAAA,EAAA;YACb;QACF,CAAA,CAAA,OAAS,KAAA,EAAO;YACd,UAAA,CAAW,KAAA,CAAM,KAAK,CAAA;QACxB;IACF;IAGA,eAAe,YACb,UAAA,EACA;QACA,IAAI;YACF,IAAI,aAAa,IAAA,EAAM;gBACrB,SAAA,GAAY,QAAQ,IAAA,EAAA;YACtB;YAEA,MAAM,SAAS,MAAM,SAAA;YACrB,SAAA,GAAY,KAAA,CAAA;YAEZ,IAAI,CAAC,OAAO,IAAA,EAAM;gBAChB,UAAA,CAAW,OAAA,CAAQ,OAAO,KAAK,CAAA;YACjC,CAAA,MAAO;gBACL,UAAA,CAAW,KAAA,EAAA;YACb;QACF,CAAA,CAAA,OAAS,KAAA,EAAO;YACd,UAAA,CAAW,KAAA,CAAM,KAAK,CAAA;QACxB;IACF;IAEA,OAAO,IAAI,cAAA,CAAgC;QACzC,MAAM,MAAK,UAAA,EAAY;YACrB,IAAI;gBAEF,IAAI,WAAA,EAAa;oBACf,MAAM,YAAY,UAAU,CAAA;oBAC5B;gBACF;gBAGA,IAAI,WAAA,EAAa;oBACf,MAAM,YAAY,UAAU,CAAA;oBAC5B;gBACF;gBAGA,IAAI,aAAa,IAAA,EAAM;oBACrB,SAAA,GAAY,QAAQ,IAAA,EAAA;gBACtB;gBACA,IAAI,aAAa,IAAA,EAAM;oBACrB,SAAA,GAAY,QAAQ,IAAA,EAAA;gBACtB;gBAKA,MAAM,EAAE,MAAA,EAAQ,MAAA,EAAA,GAAW,MAAM,QAAQ,IAAA,CAAK;oBAC5C,SAAA,CAAU,IAAA,CAAK,CAAA6C,OAAAA,GAAAA,CAAW;4BAAE,QAAAA,OAAAA;4BAAQ,MAAA,EAAQ;wBAAA,CAAA,CAAU,CAAA;oBACtD,SAAA,CAAU,IAAA,CAAK,CAAAA,OAAAA,GAAAA,CAAW;4BAAE,QAAAA,OAAAA;4BAAQ,MAAA,EAAQ;wBAAA,CAAA,CAAU;iBACvD,CAAA;gBAED,IAAI,CAAC,OAAO,IAAA,EAAM;oBAChB,UAAA,CAAW,OAAA,CAAQ,OAAO,KAAK,CAAA;gBACjC;gBAEA,IAAI,WAAW,OAAA,EAAS;oBACtB,SAAA,GAAY,KAAA,CAAA;oBACZ,IAAI,OAAO,IAAA,EAAM;wBAEf,MAAM,YAAY,UAAU,CAAA;wBAC5B,WAAA,GAAc,IAAA;oBAChB;gBACF,CAAA,MAAO;oBACL,SAAA,GAAY,KAAA,CAAA;oBAEZ,IAAI,OAAO,IAAA,EAAM;wBACf,WAAA,GAAc,IAAA;wBACd,MAAM,YAAY,UAAU,CAAA;oBAC9B;gBACF;YACF,CAAA,CAAA,OAAS,KAAA,EAAO;gBACd,UAAA,CAAW,KAAA,CAAM,KAAK,CAAA;YACxB;QACF,CAAA;QACA,MAAA,GAAS;YACP,OAAA,CAAQ,MAAA,EAAA;YACR,OAAA,CAAQ,MAAA,EAAA;QACV;IACD,CAAA,CAAA;AACH;AC9D2BL,iBAAAA,CAAkB;IAC3C,MAAA,EAAQ,OAAA;IACR,IAAA,EAAM;AACR,CAAC;AAEiCA,iBAAAA,CAAkB;IAClD,MAAA,EAAQ,KAAA;IACR,IAAA,EAAM;AACR,CAAC;ACpCD,IAAM,kCAAA,GAAqCD,yKAAAA,CACxC,MAAA,CAAO;IACN,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IACR,OAAA,EAASA,yKAAAA,CAAE,MAAA;AACb,CAAC,EACA,WAAA,EAAA;AAGI,IAAM,gBAAA,GAAmBA,yKAAAA,CAC7B,MAAA,CAAO;IACN,KAAA,EAAOA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,CAAO,CAAA,CAAE,CAAA,CAAE,WAAA,EAAa;AAC9C,CAAC,EACA,WAAA,EAAA;AAEI,IAAM,YAAA,GAAe,gBAAA;AAErB,IAAM,aAAA,GAAgBA,yKAAAA,CAAE,MAAA,CAAO;IACpC,MAAA,EAAQA,yKAAAA,CAAE,MAAA,EAAA;IACV,MAAA,EAAQA,yKAAAA,CAAE,QAAA,CAAS,gBAAgB;AACrC,CAAC,CAAA;AAUD,IAAM,wBAAA,GAA2BA,yKAAAA,CAC9B,MAAA,CAAO;IACN,YAAA,EAAcA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,CAAO,CAAA,CAAE,CAAA,CAAE,WAAA,EAAa,CAAA;IACnD,OAAA,EAASA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,CAAO,CAAA,CAAE,CAAA,CAAE,WAAA,EAAa,CAAA;IAC9C,OAAA,EAASA,yKAAAA,CAAE,QAAA,CACTA,yKAAAA,CACG,MAAA,CAAO;QACN,WAAA,EAAaA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,OAAA,EAAS;IACrC,CAAC,EACA,WAAA;IAEL,SAAA,EAAWA,yKAAAA,CAAE,QAAA,CACXA,yKAAAA,CACG,MAAA,CAAO;QACN,SAAA,EAAWA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,OAAA,EAAS,CAAA;QACjC,WAAA,EAAaA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,OAAA,EAAS;IACrC,CAAC,EACA,WAAA;IAEL,KAAA,EAAOA,yKAAAA,CAAE,QAAA,CACPA,yKAAAA,CACG,MAAA,CAAO;QACN,WAAA,EAAaA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,OAAA,EAAS;IACrC,CAAC,EACA,WAAA;AAEP,CAAC,EACA,WAAA,EAAA;AAGmC,aAAa,MAAA,CAAO;IACxD,eAAA,EAAiBA,yKAAAA,CAAE,MAAA,EAAA;IACnB,YAAA,EAAc,wBAAA;IACd,UAAA,EAAY,kCAAA;IACZ,YAAA,EAAcA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,EAAQ;AACrC,CAAC;AASD,IAAM,qBAAA,GAAwB,aAAa,MAAA,CAAO;IAChD,UAAA,EAAYA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,EAAQ;AACnC,CAAC,CAAA;AAED,IAAM,UAAA,GAAaA,yKAAAA,CAChB,MAAA,CAAO;IACN,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA;IACR,WAAA,EAAaA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,EAAQ,CAAA;IAClC,WAAA,EAAaA,yKAAAA,CACV,MAAA,CAAO;QACN,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,QAAQ,CAAA;QACxB,UAAA,EAAYA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,CAAO,CAAA,CAAE,CAAA,CAAE,WAAA,EAAa;IACnD,CAAC,EACA,WAAA;AACL,CAAC,EACA,WAAA,EAAA;AAEkC,sBAAsB,MAAA,CAAO;IAChE,KAAA,EAAOA,yKAAAA,CAAE,KAAA,CAAM,UAAU;AAC3B,CAAC;AAGD,IAAM,iBAAA,GAAoBA,yKAAAA,CACvB,MAAA,CAAO;IACN,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;IACtB,IAAA,EAAMA,yKAAAA,CAAE,MAAA;AACV,CAAC,EACA,WAAA,EAAA;AACH,IAAM,kBAAA,GAAqBA,yKAAAA,CACxB,MAAA,CAAO;IACN,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;IACvB,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA,CAAS,MAAA,EAAA;IACjB,QAAA,EAAUA,yKAAAA,CAAE,MAAA;AACd,CAAC,EACA,WAAA,EAAA;AACH,IAAM,sBAAA,GAAyBA,yKAAAA,CAC5B,MAAA,CAAO;;;MAIN,GAAA,EAAKA,yKAAAA,CAAE,MAAA,EAAA;;;MAIP,QAAA,EAAUA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,MAAA,EAAQ;AACjC,CAAC,EACA,WAAA,EAAA;AACH,IAAM,0BAAA,GAA6B,uBAAuB,MAAA,CAAO;IAC/D,IAAA,EAAMA,yKAAAA,CAAE,MAAA;AACV,CAAC,CAAA;AACD,IAAM,0BAAA,GAA6B,uBAAuB,MAAA,CAAO;IAC/D,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA,CAAS,MAAA;AACnB,CAAC,CAAA;AACD,IAAM,sBAAA,GAAyBA,yKAAAA,CAC5B,MAAA,CAAO;IACN,IAAA,EAAMA,yKAAAA,CAAE,OAAA,CAAQ,UAAU,CAAA;IAC1B,QAAA,EAAUA,yKAAAA,CAAE,KAAA,CAAM;QAAC,0BAAA;QAA4B,0BAA0B;KAAC;AAC5E,CAAC,EACA,WAAA,EAAA;AAEiC,aAAa,MAAA,CAAO;IACtD,OAAA,EAASA,yKAAAA,CAAE,KAAA,CACTA,yKAAAA,CAAE,KAAA,CAAM;QAAC,iBAAA;QAAmB,kBAAA;QAAoB,sBAAsB;KAAC;IAEzE,OAAA,EAASA,yKAAAA,CAAE,OAAA,EAAA,CAAU,OAAA,CAAQ,KAAK,EAAE,QAAA;AACtC,CAAC,CAAA,CAAE,EAAA,CACD,YAAA,CAAa,MAAA,CAAO;IAClB,UAAA,EAAYA,yKAAAA,CAAE,OAAA;AACf,CAAA;ACnLH,IAAM,eAAA,GAAkB,KAAA;AAExB,IAAM,oBAAA,GAAuBA,yKAAAA,CAC1B,MAAA,CAAO;IACN,OAAA,EAASA,yKAAAA,CAAE,OAAA,CAAQ,eAAe,CAAA;IAClC,EAAA,EAAIA,yKAAAA,CAAE,KAAA,CAAM;QAACA,yKAAAA,CAAE,MAAA,EAAA;QAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,GAAA,EAAK;KAAC;AAC5C,CAAC,CAAA,CACA,KAAA,CAAM,aAAa,CAAA,CACnB,MAAA,EAAA;AAIH,IAAM,qBAAA,GAAwBA,yKAAAA,CAC3B,MAAA,CAAO;IACN,OAAA,EAASA,yKAAAA,CAAE,OAAA,CAAQ,eAAe,CAAA;IAClC,EAAA,EAAIA,yKAAAA,CAAE,KAAA,CAAM;QAACA,yKAAAA,CAAE,MAAA,EAAA;QAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,GAAA,EAAK;KAAC,CAAA;IAC1C,MAAA,EAAQ;AACV,CAAC,EACA,MAAA,EAAA;AAIH,IAAM,kBAAA,GAAqBA,yKAAAA,CACxB,MAAA,CAAO;IACN,OAAA,EAASA,yKAAAA,CAAE,OAAA,CAAQ,eAAe,CAAA;IAClC,EAAA,EAAIA,yKAAAA,CAAE,KAAA,CAAM;QAACA,yKAAAA,CAAE,MAAA,EAAA;QAAUA,yKAAAA,CAAE,MAAA,EAAA,CAAS,GAAA,EAAK;KAAC,CAAA;IAC1C,KAAA,EAAOA,yKAAAA,CAAE,MAAA,CAAO;QACd,IAAA,EAAMA,yKAAAA,CAAE,MAAA,EAAA,CAAS,GAAA,EAAA;QACjB,OAAA,EAASA,yKAAAA,CAAE,MAAA,EAAA;QACX,IAAA,EAAMA,yKAAAA,CAAE,QAAA,CAASA,yKAAAA,CAAE,OAAA,EAAS;IAC7B,CAAA;AACH,CAAC,EACA,MAAA,EAAA;AAIH,IAAM,yBAAA,GAA4BA,yKAAAA,CAC/B,MAAA,CAAO;IACN,OAAA,EAASA,yKAAAA,CAAE,OAAA,CAAQ,eAAe;AACpC,CAAC,CAAA,CACA,KAAA,CACCA,yKAAAA,CAAE,MAAA,CAAO;IACP,MAAA,EAAQA,yKAAAA,CAAE,MAAA,EAAA;IACV,MAAA,EAAQA,yKAAAA,CAAE,QAAA,CAAS,gBAAgB;AACpC,CAAA,GAEF,MAAA,EAAA;AAIiCA,yKAAAA,CAAE,KAAA,CAAM;IAC1C,oBAAA;IACA,yBAAA;IACA,qBAAA;IACA;CACD;AC1DD,IAAA,4BAAA,CAAA,CAAA;AAAA,QAAA,CAAA,yBAAA,EAAA;IAAA,mBAAA,EAAA,IAAA,mBAAA;IAAA,YAAA,EAAA,IAAA,YAAA;IAAA,oBAAA,EAAA,IAAA;AAAA,CAAA,CAAA;AC8CO,SAAS,0BAAA,CACd,SAAA,GAAyC,CAAA,CAAA,EACJ;IACrC,MAAM,WAAA,GAAc,IAAI,WAAA,EAAA;IACxB,IAAI,kBAAA,GAAqB,EAAA;IAEzB,OAAO,IAAI,eAAA,CAAgB;QACzB,MAAM,KAAA,GAAuB;YAC3B,IAAI,SAAA,CAAU,OAAA,EAAS,MAAM,UAAU,OAAA,EAAA;QACzC,CAAA;QAEA,MAAM,SAAA,EAAU,OAAA,EAAS,UAAA,EAA2B;YAClD,UAAA,CAAW,OAAA,CAAQ,WAAA,CAAY,MAAA,CAAO,OAAO,CAAC,CAAA;YAE9C,kBAAA,IAAsB,OAAA;YAEtB,IAAI,SAAA,CAAU,OAAA,EAAS,MAAM,SAAA,CAAU,OAAA,CAAQ,OAAO,CAAA;YACtD,IAAI,SAAA,CAAU,MAAA,IAAU,OAAO,OAAA,KAAY,QAAA,EAAU;gBACnD,MAAM,SAAA,CAAU,MAAA,CAAO,OAAO,CAAA;YAChC;QACF,CAAA;QAEA,MAAM,KAAA,GAAuB;YAC3B,IAAI,UAAU,YAAA,EAAc;gBAC1B,MAAM,SAAA,CAAU,YAAA,CAAa,kBAAkB,CAAA;YACjD;YACA,IAAI,UAAU,OAAA,EAAS;gBACrB,MAAM,SAAA,CAAU,OAAA,CAAQ,kBAAkB,CAAA;YAC5C;QACF;IACD,CAAA,CAAA;AACH;AD5BA,SAAS,oBAAA,CACP,MAAA,EAIA,SAAA,EACA;IACA,OAAO,MAAA,CACJ,WAAA,CACC,IAAI,eAAA,CAEF;QACA,SAAA,EAAW,OAAO,OAAO,UAAA,KAAe;YA7DhD,IAAAlC,IAAAA;YA+DU,IAAI,OAAO,UAAU,QAAA,EAAU;gBAC7B,UAAA,CAAW,OAAA,CAAQ,KAAK,CAAA;gBACxB;YACF;YAGA,IAAI,WAAW,KAAA,EAAO;gBAEpB,IAAI,KAAA,CAAM,KAAA,KAAU,sBAAA,EAAwB;oBAC1C,qBAAA,CACEA,CAAAA,IAAAA,GAAA,KAAA,CAAM,IAAA,KAAN,IAAA,GAAA,KAAA,CAAA,GAAAA,IAAAA,CAAY,KAAA,EACZ;gBAEJ;gBACA;YACF;YAGA,qBAAA,CAAsB,OAAO,UAAU,CAAA;QACzC;IACD,CAAA,GAEF,WAAA,CAAY,0BAAA,CAA2B,SAAS,CAAC,CAAA,CACjD,WAAA,CAAY,IAAI,iBAAA,EAAmB,CAAA,CACnC,WAAA,CACC,IAAI,eAAA,CAAgB;QAClB,SAAA,EAAW,OAAO,OAAO,UAAA,KAAe;YACtC,UAAA,CAAW,OAAA,CAAQyC,oBAAAA,CAAqB,MAAA,EAAQ,KAAK,CAAC,CAAA;QACxD;IACD,CAAA;AAEP;AASO,SAAS,YAAA,CACd,MAAA,EAIA,SAAA,EACA;IACA,OAAO,oBAAA,CAAqB,MAAA,EAAQ,SAAS,CAAA,CAAE,WAAA,CAC7C,IAAI,iBAAA;AAER;AAEO,SAAS,oBAAA,CACd,MAAA,EAIA,OAAA,EAKA;IA7HF,IAAAzC,IAAAA;IA8HE,MAAM,UAAA,GAAa,oBAAA,CACjB,MAAA,EACA,OAAA,IAAA,IAAA,GAAA,KAAA,IAAA,OAAA,CAAS,SAAA,EACT,WAAA,CAAY,IAAI,mBAAmB,CAAA;IACrC,MAAM,IAAA,GAAO,OAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,OAAA,CAAS,IAAA;IACtB,MAAM,IAAA,GAAO,OAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,OAAA,CAAS,IAAA;IAEtB,MAAM,iBAAiB,IAAA,GACnB,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,UAAU,CAAA,GACpC,UAAA;IAEJ,OAAO,IAAI,SAAS,cAAA,EAAgB;QAClC,MAAA,EAAA,CAAQA,OAAA,IAAA,IAAA,IAAA,GAAA,KAAA,IAAA,IAAA,CAAM,MAAA,KAAN,OAAAA,IAAAA,GAAgB,GAAA;QACxB,UAAA,EAAY,IAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,IAAA,CAAM,UAAA;QAClB,OAAA,EAAS,sBAAA,CAAuB,IAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,KAAM,OAAA,EAAS;YAC7C,WAAA,EAAa,2BAAA;YACb,iBAAA,EAAmB;QACpB,CAAA;IACF,CAAA,CAAA;AACH;AAEO,SAAS,mBAAA,CACd,MAAA,EAIA,OAAA,EACA;IACA,OAAA,CAAQ,UAAA,CAAW,KAAA,CAAM,oBAAA,CAAqB,MAAA,EAAQ,OAAA,CAAQ,SAAS,CAAC,CAAA;AAC1E;AAEA,SAAS,qBAAA,CACP,KAAA,EACA,UAAA,EACA;IACA,IAAI,OAAO,KAAA,CAAM,OAAA,KAAY,QAAA,EAAU;QACrC,UAAA,CAAW,OAAA,CAAQ,MAAM,OAAO,CAAA;IAClC,CAAA,MAAO;QACL,MAAM,UAA4C,KAAA,CAAM,OAAA;QACxD,KAAA,MAAW,QAAQ,OAAA,CAAS;YAC1B,IAAI,IAAA,CAAK,IAAA,KAAS,MAAA,EAAQ;gBACxB,UAAA,CAAW,OAAA,CAAQ,KAAK,IAAI,CAAA;YAC9B;QACF;IACF;AACF;AE3KA,IAAA,6BAAA,CAAA,CAAA;AAAA,QAAA,CAAA,0BAAA,EAAA;IAAA,mBAAA,EAAA,IAAA0C,oBAAAA;IAAA,YAAA,EAAA,IAAAC,aAAAA;IAAA,oBAAA,EAAA,IAAAC;AAAA,CAAA,CAAA;AAeA,SAASC,qBAAAA,CACP,MAAA,EACA,SAAA,EACA;IACA,MAAM,YAAY,iBAAA,EAAA;IAElB,OAAO,qCAAqC,MAAA,CAAO,MAAA,CAAO,aAAa,CAAA,EAAG,CAAA,CACvE,WAAA,CACC,IAAI,eAAA,CAAgB;QAClB,MAAM,SAAA,EAAU,OAAA,EAAS,UAAA,EAA2B;YAClD,UAAA,CAAW,OAAA,CAAQ,SAAA,CAAU,OAAA,CAAQ,KAAK,CAAC,CAAA;QAC7C;IACD,CAAA,GAEF,WAAA,CAAY,0BAAA,CAA2B,SAAS,CAAC,CAAA,CACjD,WAAA,CAAY,IAAI,iBAAA,EAAmB,CAAA,CACnC,WAAA,CACC,IAAI,eAAA,CAAgB;QAClB,SAAA,EAAW,OAAO,OAAO,UAAA,KAAe;YACtC,UAAA,CAAW,OAAA,CAAQJ,oBAAAA,CAAqB,MAAA,EAAQ,KAAK,CAAC,CAAA;QACxD;IACD,CAAA;AAEP;AAEO,SAASE,aAAAA,CACd,MAAA,EACA,SAAA,EACA;IACA,OAAOE,qBAAAA,CAAqB,MAAA,EAAQ,SAAS,CAAA,CAAE,WAAA,CAC7C,IAAI,iBAAA;AAER;AAEO,SAASD,qBAAAA,CACd,MAAA,EACA,OAAA,GAII,CAAA,CAAA,EACJ;IAxDF,IAAA5C,IAAAA;IAyDE,MAAM,EAAE,IAAA,EAAM,IAAA,EAAM,SAAA,EAAA,GAAc,OAAA;IAClC,MAAM,UAAA,GAAa6C,qBAAAA,CAAqB,MAAA,EAAQ,SAAS,CAAA,CAAE,WAAA,CACzD,IAAI,iBAAA;IAEN,MAAM,iBAAiB,IAAA,GACnB,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,UAAU,CAAA,GACpC,UAAA;IAEJ,OAAO,IAAI,SAAS,cAAA,EAAgB;QAClC,MAAA,EAAA,CAAQ7C,OAAA,IAAA,IAAA,IAAA,GAAA,KAAA,IAAA,IAAA,CAAM,MAAA,KAAN,OAAAA,IAAAA,GAAgB,GAAA;QACxB,UAAA,EAAY,IAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,IAAA,CAAM,UAAA;QAClB,OAAA,EAAS,sBAAA,CAAuB,IAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,KAAM,OAAA,EAAS;YAC7C,WAAA,EAAa,2BAAA;YACb,iBAAA,EAAmB;QACpB,CAAA;IACF,CAAA,CAAA;AACH;AAEO,SAAS0C,oBAAAA,CACd,MAAA,EACA,OAAA,EAIA;IACA,OAAA,CAAQ,UAAA,CAAW,KAAA,CAAMG,qBAAAA,CAAqB,MAAA,EAAQ,OAAA,CAAQ,SAAS,CAAC,CAAA;AAC1E;AAEA,SAAS,iBAAA,GAA8C;IACrD,IAAI,aAAA,GAAgB,IAAA;IAEpB,OAAO,CAAClD,KAAAA,KAAyB;QAC/B,IAAI,aAAA,EAAe;YACjBA,KAAAA,GAAOA,MAAK,SAAA,EAAA;YACZ,IAAIA,KAAAA,EAAM,aAAA,GAAgB,KAAA;QAC5B;QACA,OAAOA,KAAAA;IACT,CAAA;AACF;;ACzDO,SAAS,6BAAA,CAA8BO,UAAAA,EAAsB,MAAA,GAAkB,aAAA,EAA4B;IAChH,MAAM,eAAA,OAAkB,8LAAA,EAAgBA,UAAAA,EAAW,MAAM,CAAA;IAEzD,OAAO,WAAW,eAAA,EAAiB;QACjC,UAAU,CAAA,KAAA,KAAS;YACjB,MAAM,MAAA,GAASA,UAAAA,CAAU,SAAA,CAAU,KAAK,CAAA;YACxC,OAAO,MAAA,CAAO,OAAA,GAAU;gBAAE,OAAA,EAAS;gBAAM,KAAA,EAAO,MAAA,CAAO,IAAA;YAAA,CAAK,GAAI;gBAAE,OAAA,EAAS,KAAA;gBAAO,KAAA,EAAO,OAAO,KAAA;YAAA,CAAM;QACxG;IAAA,CACD,CAAA;AACH;AASO,SAAS,UAAU,KAAA,EAAkC;IAG1D,OACE,OAAO,KAAA,KAAU,QAAA,IACjB,UAAU,IAAA,IAAA,CACT,MAAA,IAAU,SAAS,MAAA,IAAU,KAAA,CAAA,IAC9B,WAAW,KAAA,IACX,OAAQ,MAAc,KAAA,KAAU,UAAA,IAChC,eAAe,KAAA,IACf,OAAQ,MAAc,SAAA,KAAc,UAAA;AAExC;AA2BO,SAAS,mBAAmB,MAAA,EAAmD;IACpF,IAAI,SAAA,CAAU,MAAM,CAAA,EAAG;QACrB,OAAO,MAAA;IACT,CAAA,MAAO;QACL,MAAM,mBAAA,GAAsB,YAAA,IAAgB,MAAA,GAAS,MAAA,CAAO,UAAA,GAAa,MAAA;QACzE,IAAI;YACF,IAAI,kBAAkBgC,yKAAAA,EAAG;gBAEvB,WAAO,2LAAA,EAAuB,mBAAmB,CAAA;YACnD,CAAA,MAAO;gBAEL,WAAOY,iMAAAA,EAAyB,mBAAmB,CAAA;YACrD;QACF,EAAA,OAAS,CAAA,EAAY;YACnB,MAAM,YAAA,GAAe,CAAA,8EAAA,EAAiF,IAAA,CAAK,SAAA,CAAU,mBAAmB,CAAC,CAAA,CAAA;YACzI,OAAA,CAAQ,KAAA,CAAM,cAAc,CAAC,CAAA;YAC7B,MAAM,IAAI,KAAA,CAAM,YAAA,GAAA,CAAgB,CAAA,YAAa,KAAA,GAAQ,CAAA;AAAA,EAAK,CAAA,CAAE,KAAK,CAAA,CAAA,GAAK,wBAAA,CAAyB,CAAA;QACjG;IACF;AACF;AAmEO,SAAS,gBAAA,CAAiB,EAC/B,MAAA,EACA,YAAA,EACA,IAAA,EACF,EAIyB;IACvB,IAAI5C,UAAAA;IAEJ,IAAI,CAAC,SAAA,CAAU,MAAM,CAAA,EAAG;QAEtBA,UAAAA,GAAY,mBAAmB,MAAM,CAAA;IACvC,CAAA,MAAO;QACLA,UAAAA,GAAY,MAAA;IACd;IAEA,KAAA,MAAW,UAAU,YAAA,CAAc;QACjC,IAAI,MAAA,CAAO,WAAA,EAAY,EAAG;YACxB,OAAO,IAAA,KAAS,eAAe,MAAA,CAAO,mBAAA,CAAoBA,UAAS,CAAA,GAAI,MAAA,CAAO,oBAAA,CAAqBA,UAAS,CAAA;QAC9G;IACF;IAEA,IAAI,SAAS,YAAA,EAAc;QACzB,WAAO,8LAAA,EAAgBA,YAAW,aAAa,CAAA;IACjD,CAAA,MAAO;QACL,OAAO,8BAA8BA,UAAS,CAAA;IAChD;AACF;;AC1LO,IAAM,iBAAA,GAAoB;IAAC,OAAA;IAAS,OAAA;IAAS;IAAS,KAAA;IAAO,MAAA;IAAQ,MAAA;IAAQ,KAAA;IAAO,KAAK;CAAA;AAMzF,IAAM,iBAAA,GAAoB;IAC/B,KAAA;IAAA,iBAAA;IACA,KAAA;IAAA,iBAAA;IACA;CACF;AAMO,IAAM,gBAAA,GAAmB;IAAC,KAAA;IAAO,KAAA;IAAO,QAAQ;CAAA;AAEhD,IAAM,UAAA,GAAa,CAAC,CAAA,GAAyC,CAAA,YAAa,mJAAA;AAC1E,IAAM,KAAA,GAAQ,CAAC,CAAA,GAAiD,CAAA,YAAa,iJAAA;AAG7E,IAAM,KAAA,GAAQ,CAAC,CAAA,GAA2C,CAAA,YAAa,gJAAA;AACvE,IAAM,OAAA,GAAU,CAAC,CAAA,GAAgE,CAAA,YAAa,gJAAA;AAC9F,IAAM,QAAA,GAAW,CAAC,CAAA,GAAkC,CAAA,YAAa,iJAAA;AACjE,IAAM,QAAA,GAAW,CAAC,CAAA,GAAkC,CAAA,YAAa,iJAAA;AAQjE,IAAM,wBAAwB;IAAC,iBAAA;IAAmB,UAAA;IAAY,SAAA;IAAW;IAAY,cAAc;CAAA;AAMnG,IAAM,mBAAA,GAAsB;IACjC,WAAA;IACA,UAAA;IACA,UAAA;IACA,WAAA;IACA,WAAA;IACA,SAAA;IACA,QAAA;IACA,YAAA;IACA;CACF;AAMO,IAAM,aAAA,GAAgB,CAAC;OAAG,mBAAA,EAAqB;OAAG,qBAAqB;CAAA;AAyFvE,IAAM,oBAAN,MAAwB;IACrB,KAAA,CAAA;IACA,MAAA,CAAA;IAAA;;;;GAAA,GAOR,WAAA,CAAY,KAAA,EAAyB,MAAA,CAAiC;QACpE,IAAA,CAAK,KAAA,GAAQ,KAAA;QACb,IAAA,CAAK,MAAA,GAAS,MAAA;IAChB;IAAA;;;;GAAA,GAOA,QAAA,GAA6B;QAC3B,OAAO,IAAA,CAAK,KAAA;IACd;IAEA,sBAAA,GAA4C;QAC1C,OAAO,qBAAA;IACT;IAAA;;GAAA,GAKA,WAAW,CAAA,EAAsC;QAC/C,OAAO,CAAA,YAAa,mJAAA;IACtB;IAAA;;GAAA,GAKA,MAAM,CAAA,EAA8C;QAClD,OAAO,CAAA,YAAa,iJAAA;IACtB;IAAA;;GAAA,GAKA,OAAO,CAAA,EAA6B;QAClC,OAAO,CAAA,YAAa,+IAAA;IACtB;IAAA;;GAAA,GAKA,MAAM,CAAA,EAAwC;QAC5C,OAAO,CAAA,YAAa,gJAAA;IACtB;IAAA;;GAAA,GAKA,QAAQ,CAAA,EAA6D;QACnE,OAAO,CAAA,YAAa,gJAAA;IACtB;IAAA;;GAAA,GAKA,SAAS,CAAA,EAA+B;QACtC,OAAO,CAAA,YAAa,iJAAA;IACtB;IAAA;;GAAA,GAKA,SAAS,CAAA,EAA+B;QACtC,OAAO,CAAA,YAAa,iJAAA;IACtB;IAAA;;GAAA,GAKA,OAAO,CAAA,EAA6B;QAClC,OAAO,CAAA,YAAa,+IAAA;IACtB;IAAA;;GAAA,GAKA,UAAU,CAAA,EAAqC;QAC7C,OAAO,CAAA,YAAa,kJAAA;IACtB;IAAA;;;;;GAAA,GAQA,WAAA,GAAuB;QACrB,OAAO,IAAA,CAAK,MAAA,CAAO,WAAA,EAAY;IACjC;IAAA;;;;;GAAA,GAQA,eAAA,GAAuC;QACrC,OAAO,IAAA,CAAK,MAAA,CAAO,eAAA,EAAgB;IACrC;IAAA;;;;;;GAAA,GASA,eAAe,KAAA,EAA+B;QAC5C,OAAO,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,KAAK,CAAA;IACzC;IAAA;;;;;GAAA,GAQO,wBACL,KAAA,EACA,OAAA,GAAqC;QAAE,WAAA,EAAa;IAAA,CAAK,EAC/B;QAC1B,MAAM,cAAA,GAAiB,MAAA,CAAO,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA,CAAE,MAAA,CAAmC,CAAC,GAAA,EAAK,CAAC,GAAA,EAAK,SAAS,CAAA,KAAM;YAC/G,GAAA,CAAI,GAAG,CAAA,GAAI,IAAA,CAAK,cAAA,CAAe,SAAuB,CAAA;YACtD,OAAO,GAAA;QACT,CAAA,EAAG,CAAA,CAAE,CAAA;QAEL,IAAI,MAAA,GAAmCgC,yKAAAA,CAAE,MAAA,CAAO,cAAc,CAAA;QAE9D,IAAI,KAAA,CAAM,IAAA,CAAK,WAAA,KAAgB,QAAA,EAAU;YACvC,MAAA,GAAS,OAAO,MAAA,EAAO;QACzB;QACA,IAAI,KAAA,CAAM,IAAA,CAAK,QAAA,IAAY,CAAA,CAAE,MAAM,IAAA,CAAK,QAAA,YAAoBA,yKAAAA,CAAE,QAAA,CAAA,EAAW;YACvE,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,QAAQ,CAAA;QAC9C;QAEA,IAAI,MAAM,WAAA,EAAa;YACrB,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,WAAW,CAAA;QAC5C;QAEA,IAAI,OAAA,CAAQ,WAAA,IAAe,KAAA,CAAM,IAAA,CAAK,WAAA,KAAgB,aAAA,EAAe;YACnE,MAAA,GAAS,OAAO,WAAA,EAAY;QAC9B;QAEA,OAAO,MAAA;IACT;IAAA;;;;;;;;;GAAA,GAYO,yBAAA,CACL,WAAA,EACA,WAAA,EACoB;QACpB,IAAI,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG;YAC1B,OAAA,CAAQ,WAAA,GAAc,cAAc,IAAA,GAAO,EAAA,IAAM,CAAA,aAAA,EAAgB,WAAA,CAAY,IAAA,CAAK,CAAA,EAAA,CAAI,CAAC,CAAA,CAAA;QACzF,CAAA,MAAO;YACL,OAAO,WAAA;QACT;IACF;IAAA;;;;;;;GAAA,GAUO,gCAAA,CACL,KAAA,EACA,YAAA,GAA8C,qBAAA,EAC/B;QACf,IAAI,YAAA,CAAa,QAAA,CAAS,KAAA,CAAM,IAAA,EAAM,QAA8B,CAAA,EAAG;YACrE,MAAM,IAAI,KAAA,CAAM,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA,4BAAA,EAA+B,KAAA,CAAM,IAAA,EAAM,QAAQ,CAAA,CAAE,CAAA;QAC5F;QACA,OAAO,KAAA;IACT;IAAA;;;;;;GAAA,GASO,sBAAA,CACL,KAAA,EACA,YAAA,GAA0C,gBAAA,EACtB;QACpB,MAAM,cAAc,KAAA,CAAM,IAAA;QAC1B,MAAM,aAAA,GAAgB,IAAA,CAAK,cAAA,CAAe,WAAA,CAAY,IAAI,CAAA;QAE1D,IAAI,MAAA,GAASA,yKAAAA,CAAE,KAAA,CAAM,aAAa,CAAA;QAElC,MAAM,cAAoC,EAAC;QAE3C,IAAI,WAAA,CAAY,SAAA,EAAW,KAAA,KAAU,KAAA,CAAA,EAAW;YAC9C,IAAI,YAAA,CAAa,QAAA,CAAS,KAAK,CAAA,EAAG;gBAChC,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,WAAA,CAAY,SAAA,CAAU,KAAK,CAAA,CAAE,CAAA;YAClE,CAAA,MAAO;gBACL,MAAA,GAAS,MAAA,CAAO,GAAA,CAAI,WAAA,CAAY,SAAA,CAAU,KAAK,CAAA;YACjD;QACF;QAEA,IAAI,WAAA,CAAY,SAAA,EAAW,KAAA,KAAU,KAAA,CAAA,EAAW;YAC9C,IAAI,YAAA,CAAa,QAAA,CAAS,KAAK,CAAA,EAAG;gBAChC,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,WAAA,CAAY,SAAA,CAAU,KAAK,CAAA,CAAE,CAAA;YAClE,CAAA,MAAO;gBACL,MAAA,GAAS,MAAA,CAAO,GAAA,CAAI,WAAA,CAAY,SAAA,CAAU,KAAK,CAAA;YACjD;QACF;QAEA,IAAI,WAAA,CAAY,WAAA,EAAa,KAAA,KAAU,KAAA,CAAA,EAAW;YAChD,IAAI,YAAA,CAAa,QAAA,CAAS,QAAQ,CAAA,EAAG;gBACnC,WAAA,CAAY,IAAA,CAAK,CAAA,aAAA,EAAgB,WAAA,CAAY,WAAA,CAAY,KAAK,CAAA,CAAE,CAAA;YAClE,CAAA,MAAO;gBACL,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,WAAA,CAAY,WAAA,CAAY,KAAK,CAAA;YACtD;QACF;QAEA,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAuB,KAAA,EAA4D;QACxF,MAAM,gBAAA,GAAmB,KAAA,CAAM,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,CAAC,MAAA,GAAuB,IAAA,CAAK,cAAA,CAAe,MAAM,CAAC,CAAA;QACnG,IAAI,iBAAiB,MAAA,GAAS,CAAA,EAAG,MAAM,IAAI,MAAM,oCAAoC,CAAA;QACrF,IAAI,MAAA,GAASA,yKAAAA,CAAE,KAAA,CAAM,gBAA6D,CAAA;QAClF,IAAI,MAAM,WAAA,EAAa;YACrB,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,WAAW,CAAA;QAC5C;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2C,iBAAA,EAChC;QACX,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,MAAA,IAAU,EAAC;QAErC,MAAM,YAA8B,EAAC;QACrC,KAAA,MAAW,SAAS,MAAA,CAAQ;YAC1B,IAAI,UAAU,KAAA,EAAO;gBACnB,IAAI,YAAA,CAAa,QAAA,CAAS,KAAA,CAAM,IAAuB,CAAA,EAAG;oBACxD,OAAQ,MAAM,IAAA;wBACZ,KAAK,OAAA;4BAAS;gCACZ,WAAA,CAAY,IAAA,CAAK,CAAA,4BAAA,EAA+B,KAAA,CAAM,KAAA,CAAM,MAAM,CAAA,CAAE,CAAA;gCACpE;4BACF;wBACA,KAAK,OAAA;wBACL,KAAK,OAAA;wBACL,KAAK,KAAA;wBACL,KAAK,MAAA;wBACL,KAAK,MAAA;4BAAQ;gCACX,WAAA,CAAY,IAAA,CAAK,CAAA,QAAA,EAAW,KAAA,CAAM,IAAI,CAAA,CAAE,CAAA;gCACxC;4BACF;wBACA,KAAK,KAAA;wBACL,KAAK,KAAA;4BAAO;gCACV,WAAA,CAAY,IAAA,CAAK,CAAA,EAAG,KAAA,CAAM,IAAI,CAAA,YAAA,EAAe,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;gCAC1D;4BACF;oBAAA;gBAEJ,CAAA,MAAO;oBACL,SAAA,CAAU,IAAA,CAAK,KAAK,CAAA;gBACtB;YACF;QACF;QACA,IAAI,MAAA,GAASA,yKAAAA,CAAE,MAAA,EAAO;QACtB,KAAA,MAAW,SAAS,SAAA,CAAW;YAC7B,MAAA,GAAS,MAAA,CAAO,SAAA,CAAU,KAAK,CAAA;QACjC;QACA,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2C,iBAAA,EAChC;QACX,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,MAAA,IAAU,EAAC;QAErC,MAAM,YAA8B,EAAC;QACrC,KAAA,MAAW,SAAS,MAAA,CAAQ;YAC1B,IAAI,UAAU,KAAA,EAAO;gBACnB,IAAI,YAAA,CAAa,QAAA,CAAS,KAAA,CAAM,IAAuB,CAAA,EAAG;oBACxD,OAAQ,MAAM,IAAA;wBACZ,KAAK,KAAA;4BACH,IAAI,MAAM,SAAA,EAAW;gCACnB,WAAA,CAAY,IAAA,CAAK,CAAA,yBAAA,EAA4B,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;4BAC5D,CAAA,MAAO;gCACL,WAAA,CAAY,IAAA,CAAK,CAAA,aAAA,EAAgB,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;4BAChD;4BACA;wBACF,KAAK,KAAA;4BACH,IAAI,MAAM,SAAA,EAAW;gCACnB,WAAA,CAAY,IAAA,CAAK,CAAA,uBAAA,EAA0B,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;4BAC1D,CAAA,MAAO;gCACL,WAAA,CAAY,IAAA,CAAK,CAAA,WAAA,EAAc,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;4BAC9C;4BACA;wBACF,KAAK,YAAA;4BAAc;gCACjB,WAAA,CAAY,IAAA,CAAK,CAAA,YAAA,EAAe,KAAA,CAAM,KAAK,CAAA,CAAE,CAAA;gCAC7C;4BACF;oBAAA;gBAEJ,CAAA,MAAO;oBACL,SAAA,CAAU,IAAA,CAAK,KAAK,CAAA;gBACtB;YACF;QACF;QACA,IAAI,MAAA,GAASA,yKAAAA,CAAE,MAAA,EAAO;QACtB,KAAA,MAAW,SAAS,SAAA,CAAW;YAC7B,OAAQ,MAAM,IAAA;gBACZ,KAAK,KAAA;oBACH,MAAA,GAAS,OAAO,GAAA,EAAI;oBACpB;gBACF,KAAK,QAAA;oBACH,MAAA,GAAS,OAAO,MAAA,EAAO;oBACvB;gBACF;oBACE,MAAA,GAAS,MAAA,CAAO,SAAA,CAAU,KAAK,CAAA;YAAA;QAErC;QACA,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;GAAA,GAQO,sBAAsB,KAAA,EAA2B;QACtD,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,MAAA,IAAU,EAAC;QAGrC,KAAA,MAAW,SAAS,MAAA,CAAQ;YAC1B,IAAI,UAAU,KAAA,EAAO;gBACnB,OAAQ,MAAM,IAAA;oBACZ,KAAK,KAAA;wBACH,MAAM,OAAA,GAAU,IAAI,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;wBACpC,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,CAAA,EAAG;4BAC7B,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,EAA2B,OAAA,CAAQ,WAAA,EAAa,CAAA,MAAA,CAAQ,CAAA;wBAC3E;wBACA;oBACF,KAAK,KAAA;wBACH,MAAM,OAAA,GAAU,IAAI,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;wBACpC,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,CAAA,EAAG;4BAC7B,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,EAA2B,OAAA,CAAQ,WAAA,EAAa,CAAA,MAAA,CAAQ,CAAA;wBAC3E;wBACA;gBAEoB;YAE1B;QACF;QACA,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,CAA0B,CAAA;QAC3C,IAAI,MAAA,GAASA,yKAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,CAAS,WAAW,CAAA;QAC5C,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,yBAAA,CACL,KAAA,EACA,WAAA,GAAqC,mBAAA,EACzB;QACZ,IAAI,YAAY,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAsB,CAAA,EAAG;YAC1E,OAAO,IAAA,CAAK,cAAA,CAAe,KAAA,CAAM,IAAA,CAAK,SAAS,EAAE,QAAA,EAAS;QAC5D,CAAA,MAAO;YACL,OAAO,KAAA;QACT;IACF;IAAA;;;;;GAAA,GAQO,qBAAqBhC,UAAAA,EAAgC;QAC1D,MAAM,eAAA,GAAkB,IAAA,CAAK,cAAA,CAAeA,UAAS,CAAA;QAErD,OAAO,6BAAA,CAA8B,eAAA,EAAiB,IAAA,CAAK,eAAA,EAAiB,CAAA;IAC9E;IAAA;;;;;GAAA,GAQO,oBAAoBA,UAAAA,EAAqC;QAC9D,OAAO,IAAA,CAAK,oBAAA,CAAqBA,UAAS,CAAA,CAAE,UAAA;IAC9C;AACF;ACxlBO,IAAM6C,kBAAAA,GAAoB;IAC/B,OAAA;IACA,OAAA;IACA,OAAA;IACA,KAAA;IACA,MAAA;IACA,MAAA;IACA,YAAA;IACA,YAAA;IACA;CACF;AAMO,IAAMC,kBAAAA,GAAoB;IAAC,cAAA;IAAgB,WAAA;IAAa,aAAa;CAAA;AAMrE,IAAMC,iBAAAA,GAAmB;IAAC,KAAA;IAAO,KAAA;IAAO,QAAQ;CAAA;AAMhD,IAAMC,yBAAwB;IAAC,iBAAA;IAAmB,UAAA;IAAY,SAAA;IAAW;IAAY,cAAc;CAAA;AAMnG,IAAMC,oBAAAA,GAAsB;IACjC,WAAA;IACA,UAAA;IACA,UAAA;IACA,WAAA;IACA,WAAA;IACA,SAAA;IACA,QAAA;IACA,YAAA;IACA;CACF;AA6FO,IAAMC,qBAAN,MAAwB;IACrB,KAAA,CAAA;IACA,MAAA,CAAA;IAAA;;;;GAAA,GAOR,WAAA,CAAY,KAAA,EAAyB,MAAA,CAAiC;QACpE,IAAA,CAAK,KAAA,GAAQ,KAAA;QACb,IAAA,CAAK,MAAA,GAAS,MAAA;IAChB;IAAA;;;;GAAA,GAOA,QAAA,GAA6B;QAC3B,OAAO,IAAA,CAAK,KAAA;IACd;IAEA,sBAAA,GAA4C;QAC1C,OAAOF,sBAAAA;IACT;IAAA;;GAAA,GAKA,WAAW,CAAA,EAAqD;QAC9D,OAAO,CAAA,YAAaG,gKAAAA;IACtB;IAAA;;GAAA,GAKA,MAAM,CAAA,EAA2D;QAC/D,OAAO,CAAA,YAAaC,8JAAAA;IACtB;IAAA;;GAAA,GAKA,OAAO,CAAA,EAAmC;QACxC,OAAO,CAAA,YAAaC,4JAAAA;IACtB;IAAA;;GAAA,GAKA,WAAW,CAAA,EAAqD;QAC9D,OAAO,CAAA,YAAaC,gKAAAA;IACtB;IAAA;;GAAA,GAKA,MAAM,CAAA,EAA+C;QACnD,OAAO,CAAA,YAAaC,6JAAAA;IACtB;IAAA;;GAAA,GAKA,QAAQ,CAAA,EAAmF;QACzF,OAAO,CAAA,YAAaC,6JAAAA;IACtB;IAAA;;GAAA,GAKA,SAAS,CAAA,EAAuC;QAC9C,OAAO,CAAA,YAAaC,8JAAAA;IACtB;IAAA;;GAAA,GAKA,SAAS,CAAA,EAAuC;QAC9C,OAAO,CAAA,YAAaC,8JAAAA;IACtB;IAAA;;GAAA,GAKA,OAAO,CAAA,EAAmC;QACxC,OAAO,CAAA,YAAaC,4JAAAA;IACtB;IAAA;;GAAA,GAKA,UAAU,CAAA,EAAmD;QAC3D,OAAO,CAAA,YAAaC,+JAAAA;IACtB;IAAA;;;;;GAAA,GAQA,WAAA,GAAuB;QACrB,OAAO,IAAA,CAAK,MAAA,CAAO,WAAA,EAAY;IACjC;IAAA;;;;;GAAA,GAQA,eAAA,GAAuC;QACrC,OAAO,IAAA,CAAK,MAAA,CAAO,eAAA,EAAgB;IACrC;IAAA;;;;;;GAAA,GASA,eAAe,KAAA,EAAyB;QACtC,OAAO,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,KAAK,CAAA;IACzC;IAAA;;;;;GAAA,GAQO,wBACL,KAAA,EACA,OAAA,GAAqC;QAAE,WAAA,EAAa;IAAA,CAAK,EACpC;QACrB,MAAM,cAAA,GAAiB,MAAA,CAAO,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA,CAAE,MAAA,CAAgC,CAAC,GAAA,EAAK,CAAC,GAAA,EAAK,SAAS,CAAA,KAAM;YAC5G,GAAA,CAAI,GAAG,CAAA,GAAI,IAAA,CAAK,cAAA,CAAe,SAAmB,CAAA;YAClD,OAAO,GAAA;QACT,CAAA,EAAG,CAAA,CAAE,CAAA;QAEL,IAAI,MAAA,GAA8B5B,oLAAAA,CAAE,MAAA,CAAO,cAAc,CAAA;QAEzD,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,QAAA,YAAoBA,oLAAAA,CAAE,QAAA,EAAU;YACjD,MAAA,GAASA,oLAAAA,CAAE,YAAA,CAAa,cAAc,CAAA;QACxC;QACA,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,QAAA,IAAY,CAAA,CAAE,MAAM,IAAA,CAAK,GAAA,CAAI,QAAA,YAAoBA,oLAAAA,CAAE,QAAA,CAAA,EAAW;YAC/E,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,QAAQ,CAAA;QAClD;QAEA,IAAI,MAAM,WAAA,EAAa;YACrB,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,WAAW,CAAA;QAC5C;QAEA,IAAI,QAAQ,WAAA,IAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,QAAA,YAAoBA,oLAAAA,CAAE,UAAA,EAAY;YAC1E,MAAA,GAASA,oLAAAA,CAAE,WAAA,CAAY,cAAc,CAAA;QACvC;QAEA,OAAO,MAAA;IACT;IAAA;;;;;;;;;GAAA,GAYO,yBAAA,CACL,WAAA,EACA,WAAA,EACoB;QACpB,IAAI,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG;YAC1B,OAAA,CAAQ,WAAA,GAAc,cAAc,IAAA,GAAO,EAAA,IAAM,CAAA,aAAA,EAAgB,WAAA,CAAY,IAAA,CAAK,CAAA,EAAA,CAAI,CAAC,CAAA,CAAA;QACzF,CAAA,MAAO;YACL,OAAO,WAAA;QACT;IACF;IAAA;;;;;;;GAAA,GAUO,gCAAA,CACL,KAAA,EACA,YAAA,GAA8CgB,sBAAAA,EAC/B;QACf,IAAI,YAAA,CAAa,QAAA,CAAS,KAAA,CAAM,WAAA,CAAY,IAA0B,CAAA,EAAG;YACvE,MAAM,IAAI,KAAA,CAAM,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA,4BAAA,EAA+B,KAAA,CAAM,WAAA,CAAY,IAAI,CAAA,CAAE,CAAA;QAC9F;QACA,OAAO,KAAA;IACT;IAAA;;;;;;GAAA,GASO,sBAAA,CACL,KAAA,EACA,YAAA,GAA0CD,iBAAAA,EAC3B;QACf,MAAM,WAAA,GAAc,MAAM,IAAA,CAAK,GAAA;QAC/B,MAAM,aAAA,GAAgB,IAAA,CAAK,cAAA,CAAe,WAAA,CAAY,OAAO,CAAA;QAE7D,IAAI,MAAA,GAASf,oLAAAA,CAAE,KAAA,CAAM,aAAa,CAAA;QAElC,MAAM,cAAoC,EAAC;QAC3C,IAAI,YAAY,MAAA,EAAQ;YACtB,KAAA,MAAW,KAAA,IAAS,YAAY,MAAA,CAAQ;gBACtC,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA,KAAU,YAAA,EAAc;oBACzC,IAAI,YAAA,CAAa,QAAA,CAAS,KAAK,CAAA,EAAG;wBAEhC,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA,CAAE,CAAA;oBAC7D,CAAA,MAAO;wBAEL,MAAA,GAAS,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA;oBAC5C;gBACF;gBACA,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA,KAAU,YAAA,EAAc;oBACzC,IAAI,YAAA,CAAa,QAAA,CAAS,KAAK,CAAA,EAAG;wBAEhC,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA,CAAE,CAAA;oBAC7D,CAAA,MAAO;wBAEL,MAAA,GAAS,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA;oBAC5C;gBACF;gBACA,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA,KAAU,eAAA,EAAiB;oBAC5C,IAAI,YAAA,CAAa,QAAA,CAAS,QAAQ,CAAA,EAAG;wBAEnC,WAAA,CAAY,IAAA,CAAK,CAAA,aAAA,EAAgB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAM,CAAA,CAAE,CAAA;oBAC1D,CAAA,MAAO;wBAEL,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAM,CAAA;oBAC9C;gBACF;YACF;QACF;QAEA,MAAM,eAAA,GAAkB,KAAA,CAAM,IAAA,EAAK,EAAG,WAAA;QACtC,MAAM,oBAAoB,KAAA,CAAM,WAAA;QAEhC,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,eAAA,IAAmB,mBAAmB,WAAW,CAAA;QACpG,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAuB,KAAA,EAAgD;QAC5E,MAAM,gBAAA,GAAmB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,GAAA,CAAI,CAAC,MAAA,GAAmB,IAAA,CAAK,cAAA,CAAe,MAAM,CAAC,CAAA;QACnG,IAAI,iBAAiB,MAAA,GAAS,CAAA,EAAG,MAAM,IAAI,MAAM,oCAAoC,CAAA;QACrF,IAAI,MAAA,GAASA,oLAAAA,CAAE,KAAA,CAAM,gBAAiD,CAAA;QACtE,IAAI,MAAM,WAAA,EAAa;YACrB,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,KAAA,CAAM,WAAW,CAAA;QAC5C;QAEA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2Ca,kBAAAA,EAChC;QACX,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAA,IAAU,EAAC;QAEzC,MAAM,YAA8B,EAAC;QAErC,IAAI,MAAA,8BAAQ;YACV,KAAA,MAAW,SAAS,MAAA,CAAQ;gBAC1B,IAAI,aAAa,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAwB,CAAA,EAAG;oBAClE,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA;wBACrB,KAAK,YAAA;4BAEH,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA,CAAE,CAAA;4BAC3D;wBACF,KAAK,YAAA;4BAEH,WAAA,CAAY,IAAA,CAAK,CAAA,eAAA,EAAkB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA,CAAE,CAAA;4BAC3D;wBACF,KAAK,eAAA;4BACH;gCAEE,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAA;oCACrB,KAAK,OAAA;oCACL,KAAK,KAAA;oCACL,KAAK,OAAA;oCACL,KAAK,MAAA;oCACL,KAAK,MAAA;wCAEH,WAAA,CAAY,IAAA,CAAK,CAAA,QAAA,EAAW,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAM,CAAA,CAAE,CAAA;wCACnD;oCACF,KAAK,OAAA;wCAEH,WAAA,CAAY,IAAA,CAAK,CAAA,4BAAA,EAA+B,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA,CAAE,CAAA;wCACxE;gCAAA;4BAEN;4BACA;oBAAA;gBAEN,CAAA,MAAO;oBACL,SAAA,CAAU,IAAA,CAAK,KAAK,CAAA;gBACtB;YACF;QACF;QAEA,IAAI,MAAA,GAASb,oLAAAA,CAAE,MAAA,EAAO;QACtB,KAAA,MAAW,SAAS,SAAA,CAAW;YAC7B,MAAA,GAAS,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA;QAC7B;QAEA,MAAM,eAAA,GAAkB,KAAA,CAAM,IAAA,EAAK,EAAG,WAAA;QACtC,MAAM,oBAAoB,KAAA,CAAM,WAAA;QAEhC,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,eAAA,IAAmB,mBAAmB,WAAW,CAAA;QACpG,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2Cc,kBAAAA,EAChC;QACX,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAA,IAAU,EAAC;QAEzC,MAAM,YAA8B,EAAC;QAErC,IAAI,MAAA,8BAAQ;YACV,KAAA,MAAW,SAAS,MAAA,CAAQ;gBAC1B,IAAI,aAAa,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAwB,CAAA,EAAG;oBAClE,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA;wBACrB,KAAK,cAAA;4BAEH,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,SAAA,EAAW;gCAE5B,WAAA,CAAY,IAAA,CAAK,CAAA,yBAAA,EAA4B,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,CAAE,CAAA;4BACrE,CAAA,MAAO;gCAEL,WAAA,CAAY,IAAA,CAAK,CAAA,aAAA,EAAgB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,CAAE,CAAA;4BACzD;4BACA;wBACF,KAAK,WAAA;4BAEH,IAAI,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,SAAA,EAAW;gCAE5B,WAAA,CAAY,IAAA,CAAK,CAAA,uBAAA,EAA0B,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,CAAE,CAAA;4BACnE,CAAA,MAAO;gCAEL,WAAA,CAAY,IAAA,CAAK,CAAA,WAAA,EAAc,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,CAAE,CAAA;4BACvD;4BACA;wBACF,KAAK,aAAA;4BAAe;gCAElB,WAAA,CAAY,IAAA,CAAK,CAAA,YAAA,EAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA,CAAE,CAAA;gCACtD;4BACF;oBAAA;gBAEJ,CAAA,MAAO;oBACL,SAAA,CAAU,IAAA,CAAK,KAAK,CAAA;gBACtB;YACF;QACF;QACA,IAAI,MAAA,GAASd,oLAAAA,CAAE,MAAA,EAAO;QAEtB,KAAA,MAAW,SAAS,SAAA,CAAW;YAC7B,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA;gBACrB,KAAK,eAAA;oBAAiB;wBAEpB,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAA;4BACrB,KAAK,SAAA;gCACH,MAAA,GAAS,OAAO,GAAA,EAAI;gCACpB;wBAAA;wBAEJ;oBACF;gBACA;oBAEE,MAAA,GAAS,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA;YAAA;QAEjC;QACA,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;GAAA,GAQO,sBAAsB,KAAA,EAA2B;QACtD,MAAM,cAAoC,EAAC;QAC3C,MAAM,MAAA,GAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,MAAA,IAAU,EAAC;QAGzC,IAAI,MAAA,8BAAQ;YACV,KAAA,MAAW,SAAS,MAAA,CAAQ;gBAC1B,OAAQ,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAA;oBACrB,KAAK,WAAA;wBAEH,MAAM,UAAU,IAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA;wBAC7C,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,CAAA,EAAG;4BAC7B,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,EAA2B,OAAA,CAAQ,WAAA,EAAa,CAAA,MAAA,CAAQ,CAAA;wBAC3E;wBACA;oBACF,KAAK,cAAA;wBAEH,MAAM,UAAU,IAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA;wBAC7C,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,CAAA,EAAG;4BAC7B,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,EAA2B,OAAA,CAAQ,WAAA,EAAa,CAAA,MAAA,CAAQ,CAAA;wBAC3E;wBACA;gBAEoB;YAE1B;QACF;QACA,WAAA,CAAY,IAAA,CAAK,CAAA,wBAAA,CAA0B,CAAA;QAC3C,IAAI,MAAA,GAASA,oLAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,CAAS,WAAW,CAAA;QAC5C,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;QACjF,IAAI,WAAA,EAAa;YACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;QACtC;QACA,OAAO,MAAA;IACT;IAAA;;;;;;GAAA,GASO,yBAAA,CACL,KAAA,EACA,WAAA,GAAqCiB,oBAAAA,EAC5B;QACT,IAAI,WAAA,CAAY,QAAA,CAAS,KAAA,CAAM,WAAA,CAAY,IAAkB,CAAA,EAAG;YAC9D,OAAO,IAAA,CAAK,cAAA,CAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,SAAS,EAAE,QAAA,EAAS;QAChE,CAAA,MAAO;YACL,OAAO,KAAA;QACT;IACF;IAAA;;;;;GAAA,GAQO,qBAAqBjD,UAAAA,EAA4B;QACtD,MAAM,eAAA,GAAkB,IAAA,CAAK,cAAA,CAAeA,UAAS,CAAA;QAErD,OAAO,6BAAA,CAA8B,eAAA,EAAiB,IAAA,CAAK,eAAA,EAAiB,CAAA;IAC9E;IAAA;;;;;GAAA,GAQO,oBAAoBA,UAAAA,EAAiC;QAC1D,OAAO,IAAA,CAAK,oBAAA,CAAqBA,UAAS,CAAA,CAAE,UAAA;IAC9C;AACF;;ACtnBO,IAAekD,qBAAf,MAAiC;IAC9B,KAAA,CAAA;IACA,OAAA,CAAA;IACA,OAAA,CAAA;IAAA;;;;GAAA,GAOR,YAAY,KAAA,CAAyB;QACnC,IAAA,CAAK,KAAA,GAAQ,KAAA;QACb,IAAA,CAAK,OAAA,GAAU,IAAI,iBAAA,CAAoB,KAAA,EAAO,IAAI,CAAA;QAClD,IAAA,CAAK,OAAA,GAAU,IAAIA,kBAAAA,CAAoB,KAAA,EAAO,IAAI,CAAA;IACpD;IAAA;;;;GAAA,GAOA,QAAA,GAA6B;QAC3B,OAAO,IAAA,CAAK,KAAA;IACd;IAEA,uBAAuB,CAAA,EAA+B;QACpD,IAAI,UAAU,CAAA,EAAG;YACf,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,EAAuB;QAC7C,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,EAAuB;QAC7C;IACF;IAOA,WAAW,CAAA,EAA8B;QACvC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA;QAClC,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA;QAClC;IACF;IAOA,MAAM,CAAA,EAA8B;QAClC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAC7B,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAC7B;IACF;IAOA,OAAO,CAAA,EAA8B;QACnC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;QAC9B,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;QAC9B;IACF;IAOA,MAAM,CAAA,EAA8B;QAClC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAC7B,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAC7B;IACF;IAOA,QAAQ,CAAA,EAA8B;QACpC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,CAAC,CAAA;QAC/B,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,CAAC,CAAA;QAC/B;IACF;IAOA,SAAS,CAAA,EAA8B;QACrC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;QAChC,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;QAChC;IACF;IAOA,SAAS,CAAA,EAA8B;QACrC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;QAChC,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA;QAChC;IACF;IAOA,OAAO,CAAA,EAA8B;QACnC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;QAC9B,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;QAC9B;IACF;IAOA,UAAU,CAAA,EAA8B;QACtC,IAAI,UAAU,CAAA,EAAG;YAEf,OAAO,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,CAAC,CAAA;QACjC,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,CAAC,CAAA;QACjC;IACF;IA2CO,wBACL,KAAA,EACA,OAAA,GAAqC;QAAE,WAAA,EAAa;IAAA,CAAK,EACS;QAClE,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAA,EAAO,OAAO,CAAA;QAC5D,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAA,EAAO,OAAO,CAAA;QAC5D;IACF;IAAA;;;;;;;;;GAAA,GAYO,yBAAA,CACL,WAAA,EACA,WAAA,EACoB;QAEpB,OAAO,IAAA,CAAK,OAAA,CAAQ,yBAAA,CAA0B,WAAA,EAAa,WAAW,CAAA;IACxE;IAAA;;;;;;;GAAA,GAUO,gCAAA,CACL,KAAA,EACA,YAAA,EAKkG;QAClG,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,gCAAA,CAAA,+BAAA;YAElB,KAAA,EACC,YAAA,IAAgBF;QAErB,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,gCAAA,CAClB,KAAA,EACC,YAAA,IAAgB;QAErB;IACF;IAcO,sBAAA,CACL,KAAA,EACA,YAAA,GAA0C,gBAAA,EACE;QAC5C,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,CAAuB,KAAA,EAAO,YAAY,CAAA;QAChE,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,CAAuB,KAAA,EAAO,YAAY,CAAA;QAChE;IACF;IAWO,uBACL,KAAA,EAC2B;QAC3B,IAAI,UAAU,KAAA,EAAO;YAEnB,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,CAAuB,KAAK,CAAA;QAClD,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,sBAAA,CAAuB,KAAK,CAAA;QAClD;IACF;IAWO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2C,iBAAA,EACZ;QAC/B,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAK,CAAA;QACnD,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAA,EAAO,YAAY,CAAA;QACjE;IACF;IAWO,uBAAA,CACL,KAAA,EACA,YAAA,GAA2C,iBAAA,EACZ;QAC/B,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAK,CAAA;QACnD,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,uBAAA,CAAwB,KAAA,EAAO,YAAY,CAAA;QACjE;IACF;IAUO,sBAAsB,KAAA,EAAiE;QAC5F,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,qBAAA,CAAsB,KAAK,CAAA;QACjD,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,qBAAA,CAAsB,KAAK,CAAA;QACjD;IACF;IAWO,yBAAA,CACL,KAAA,EACA,WAAA,EAC2B;QAC3B,IAAI,UAAU,KAAA,EAAO;YACnB,OAAO,IAAA,CAAK,OAAA,CAAQ,yBAAA,CAA0B,KAAA,EAAO,eAAeC,oBAAsB,CAAA;QAC5F,CAAA,MAAO;YACL,OAAO,IAAA,CAAK,OAAA,CAAQ,yBAAA,CAA0B,KAAA,EAAO,eAAe,mBAAsB,CAAA;QAC5F;IACF;IAAA;;;;;GAAA,GAQO,qBAAqBjD,UAAAA,EAAgD;QAC1E,MAAM,eAAA,GAAkB,IAAA,CAAK,cAAA,CAAeA,UAAS,CAAA;QAErD,OAAO,6BAAA,CAA8B,eAAA,EAAiB,IAAA,CAAK,eAAA,EAAiB,CAAA;IAC9E;IAAA;;;;;GAAA,GAQO,oBAAoBA,UAAAA,EAAqD;QAC9E,OAAO,IAAA,CAAK,oBAAA,CAAqBA,UAAS,CAAA,CAAE,UAAA;IAC9C;AACF;;AC9aO,SAAS6D,YAA8C7B,GAAAA,EAAM;IAClE,OAAO,CAAC,CAAA,GAAkC,CAAA,YAAaA,GAAAA,CAAE,aAAa,CAAA;AACxE;AAIO,SAAS8B,OAAyC9B,GAAAA,EAAM;IAC7D,OAAO,CAAC,CAAA,GAAgC,CAAA,YAAaA,GAAAA,CAAE,WAAW,CAAA;AACpE;AAIO,SAAS,OAA0CA,GAAAA,EAAM;IAC9D,OAAO,CAAC,CAAA,GAA8B,CAAA,YAAaA,GAAAA,CAAE,SAAS,CAAA;AAChE;AAIO,SAAS+B,OAAyC/B,GAAAA,EAAM;IAC7D,OAAO,CAAC,CAAA,GAA+B,CAAA,YAAaA,GAAAA,CAAE,UAAU,CAAA;AAClE;AAIO,SAASgC,SAA2ChC,GAAAA,EAAM;IAC/D,OAAO,CAAC,CAAA,GAA+B,CAAA,YAAaA,GAAAA,CAAE,UAAU,CAAA;AAClE;AAIO,SAASiC,UAA4CjC,GAAAA,EAAM;IAChE,OAAO,CAAC,CAAA,GAAgC,CAAA,YAAaA,GAAAA,CAAE,WAAW,CAAA;AACpE;AAIO,SAASkC,UAA4ClC,GAAAA,EAAM;IAChE,OAAO,CAAC,CAAA,GAAgC,CAAA,YAAaA,GAAAA,CAAE,WAAW,CAAA;AACpE;AAIO,SAAS,OAA0CA,GAAAA,EAAM;IAC9D,OAAO,CAAC,CAAA,GAA8B,CAAA,YAAaA,GAAAA,CAAE,SAAS,CAAA;AAChE;AAIO,SAAS,UAA6CA,GAAAA,EAAM;IACjE,OAAO,CAAC,CAAA,GAAiC,CAAA,YAAaA,GAAAA,CAAE,YAAY,CAAA;AACtE;AAIO,SAAS,WAA8CA,GAAAA,EAAM;IAClE,OAAO,CAAC,CAAA,GAAkC,CAAA,YAAaA,GAAAA,CAAE,aAAa,CAAA;AACxE;;ACnDO,IAAM,0BAAA,GAAN,cAAyCkB,kBAAAA,CAAkB;IAChE,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,aAAA;IACT;IAEA,WAAA,GAAuB;QACrB,OAAO,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA;IAClD;IAIA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YACxB,MAAM,WAAA,GAA6C;gBACjD,WAAA;gBACA,UAAA;gBACA,UAAA;gBACA,UAAA;gBACA,cAAA;gBACA;aACF;YACA,IAAI,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,kBAAkB,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,WAAW,CAAA;YACtF,OAAO,IAAA,CAAK,yBAAA,CAA0B,KAAA,EAAO,WAAW,CAAA;QAC1D,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAA,EAAO,EAAE,CAAA;QAC9C,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAI7B,IAAI,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,kBAAkB,CAAA,EAAG;gBACxD,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAA,EAAO;oBAAC,KAAA;oBAAO,KAAK;iBAAC,CAAA;YAC3D,CAAA,MAAO;gBACL,OAAO,KAAA;YACT;QACF;QAEA,OAAO,IAAA,CAAK,gCAAA,CAAiC,KAAA,EAA8C;YACzF,UAAA;YACA,UAAA;YACA;SACD,CAAA;IACH;AACF;ACpDO,IAAM,yBAAA,GAAN,cAAwCkB,kBAAAA,CAAkB;IAC/D,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,aAAA;IACT;IAEA,WAAA,GAAuB;QAErB,OAAO,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,UAAU,CAAA,IAAK,CAAC,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,IAAI,CAAA;IAC/F;IAIA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YACxB,OAAO,IAAA,CAAK,yBAAA,CAA0B,KAAA,EAAO;gBAAC;gBAAa,UAAA;gBAAY,UAAA;gBAAY,WAAA;gBAAa,WAAW;aAAC,CAAA;QAC9G,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAA,EAAO;gBAAC,KAAA;gBAAO,KAAK;aAAC,CAAA;QAC1D,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C;QAEA,OAAO,KAAA;IACT;AACF;AC/BO,IAAM,uBAAA,GAAN,cAAsCkB,kBAAAA,CAAkB;IAC7D,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,aAAA;IACT;IAEA,WAAA,GAAuB;QACrB,OAAO,IAAA,CAAK,QAAA,EAAS,CAAE,QAAA,CAAS,QAAA,CAAS,QAAQ,CAAA,IAAK,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA;IACjG;IAGA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YACxB,OAAO,IAAA,CAAK,yBAAA,CAA0B,KAAA,EAAO;gBAAC;gBAAa,UAAA;gBAAY,UAAA;gBAAY,WAAA;gBAAa,WAAW;aAAC,CAAA;QAC9G,CAAA,MAAA,IAAW,MAAA,CAAOA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAE3B,OAAOA,yKAAAA,CACJ,GAAA,EAAI,CACJ,MAAA,CAAO,CAAA,IAAK,CAAA,KAAM,IAAA,EAAM;gBAAE,OAAA,EAAS;YAAA,CAAgB,CAAA,CACnD,QAAA,CAAS,KAAA,CAAM,WAAA,IAAe,cAAc,CAAA;QACjD,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAA,EAAO,EAAE,CAAA;QAC9C,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAG7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAWkC,SAAAA,CAASlC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAG7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C;QACA,OAAO,IAAA,CAAK,gCAAA,CAAiC,KAA4C,CAAA;IAC3F;AACF;ACxCO,IAAM,qBAAA,GAAN,cAAoCkB,kBAAAA,CAAkB;IAC3D,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,aAAA;IACT;IAEA,WAAA,GAAuB;QACrB,OAAO,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,MAAM,CAAA;IAChD;IAIA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YACxB,OAAO,IAAA,CAAK,yBAAA,CAA0B,KAAA,EAAO;gBAAC;gBAAa,UAAA;gBAAY,UAAA;gBAAY,WAAA;gBAAa,WAAW;aAAC,CAAA;QAC9G,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAA,EAAO;gBAAC,KAAA;gBAAO,KAAK;aAAC,CAAA;QAC1D,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWkC,SAAAA,CAASlC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C;QAEA,OAAO,KAAA;IACT;AACF;AChCO,IAAM,uBAAA,GAAN,cAAsCkB,kBAAAA,CAAkB;IAC7D,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,CAAA,WAAA,CAAA;IACT;IAEA,WAAA,GAAuB;QACrB,IACE,CAAC,IAAA,CAAK,QAAA,GAAW,yBAAA,IAAA,CAChB,IAAA,CAAK,QAAA,EAAS,CAAE,QAAA,CAAS,QAAA,CAAS,CAAA,MAAA,CAAQ,KAAK,IAAA,CAAK,QAAA,GAAW,OAAA,CAAQ,QAAA,CAAS,CAAA,MAAA,CAAQ,CAAA,CAAA,EACzF;YACA,OAAO,IAAA;QACT;QAEA,OAAO,KAAA;IACT;IAIA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAIxB,MAAM,SAAA,GAAY,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,SAAA,GAAa,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,SAAA;YAErF,IAAI,SAAA,EAAW;gBAGb,IAAI,UAAA,CAAWA,yKAAC,CAAA,CAAE,SAAS,CAAA,EAAG;oBAC5B,MAAM,SAAA,GAAY,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;oBAC/C,OAAO,UAAU,SAAA,CAAU,CAAC,MAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,IAAY,GAAI,CAAA;gBAC3E;gBAIA,MAAM,cAAA,GAAiB,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;gBACpD,OAAO,cAAA,CAAe,QAAA,EAAS,CAAE,SAAA,CAAU,CAAC,GAAA,GAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,CAAA,GAAY,GAAI,CAAA;YAC3F;YAEA,OAAO,KAAA;QACT,CAAA,MAAA,IAAW,UAAA,CAAWA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAE/B,MAAM,SAAA,GAAY,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,SAAA,GAAa,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,SAAA;YACrF,IAAI,SAAA,EAAW;gBAGb,IAAI6B,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,SAAS,CAAA,EAAG;oBAC5B,MAAM,cAAA,GACJ,UAAU,SAAA,GAAY,SAAA,CAAU,IAAA,CAAK,SAAA,GAAa,SAAA,CAAkB,IAAA,EAAM,GAAA,EAAK,SAAA;oBACjF,IAAI,cAAA,EAAgB;wBAClB,MAAM,mBAAA,GAAsB,IAAA,CAAK,cAAA,CAAe,cAAc,CAAA;wBAC9D,OAAO,mBAAA,CAAoB,QAAA,EAAS,CAAE,SAAA,CAAU,CAAC,GAAA,GAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,CAAA,GAAY,GAAI,CAAA;oBAChG;gBACF;gBAEA,MAAM,cAAA,GAAiB,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;gBACpD,OAAO,eAAe,QAAA,EAAS;YACjC;YACA,OAAO,KAAA;QACT,CAAA,MAAA,IAAW,SAAA,CAAUA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAI9B,MAAM,SAAA,GAAY,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,SAAA,GAAa,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,SAAA;YACrF,MAAM,YAAA,GAAe,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,YAAA,GAAgB,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,YAAA;YAE3F,IAAI,SAAA,EAAW;gBACb,MAAM,cAAA,GAAiB,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;gBAEpD,OAAO,cAAA,CAAe,QAAA,EAAS,CAAE,SAAA,CAAU,CAAC,GAAA,KAAa;oBACvD,IAAI,QAAQ,IAAA,EAAM;wBAChB,OAAO,OAAO,YAAA,KAAiB,UAAA,GAAa,YAAA,EAAa,GAAI,YAAA;oBAC/D;oBACA,OAAO,GAAA;gBACT,CAAC,CAAA;YACH;YAEA,OAAO,KAAA;QACT,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,EAAS;YAC5B,MAAM,MAAA,GAAS;gBAAC,OAAO;aAAA;YAEvB,IAAI,KAAA,CAAM,OAAA,CAAQ,QAAA,CAAS,aAAa,CAAA,EAAG;gBACzC,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAA,EAAO;oBAAC,OAAA;oBAAS,OAAO;iBAAC,CAAA;YAC/D;YAEA,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAA,EAAO,MAAM,CAAA;QACnD;QAEA,OAAO,IAAA,CAAK,gCAAA,CAAiC,KAAA,EAA8C;YACzF,UAAA;YACA,cAAA;YACA;SACD,CAAA;IACH;AACF;ACzGO,IAAM,gCAAA,GAAN,cAA+CkB,kBAAAA,CAAkB;IACtE,YAAY,KAAA,CAAyB;QACnC,KAAA,CAAM,KAAK,CAAA;IACb;IAEA,eAAA,GAAuC;QACrC,OAAO,CAAA,QAAA,CAAA;IACT;IAEA,gBAAA,GAA4B;QAG1B,OACE,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,CAAA,EAAA,CAAI,KACrC,IAAA,CAAK,QAAA,GAAW,OAAA,CAAQ,QAAA,CAAS,CAAA,EAAA,CAAI,CAAA,IACrC,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,CAAA,EAAA,CAAI,CAAA;IAEzC;IAEA,WAAA,GAAuB;QACrB,IACE,IAAA,CAAK,gBAAA,EAAiB,IAAA,CACrB,IAAA,CAAK,QAAA,GAAW,QAAA,CAAS,QAAA,CAAS,CAAA,MAAA,CAAQ,CAAA,IAAK,IAAA,CAAK,QAAA,EAAS,CAAE,OAAA,CAAQ,QAAA,CAAS,CAAA,MAAA,CAAQ,CAAA,CAAA,EACzF;YACA,OAAO,IAAA;QACT;QAEA,OAAO,KAAA;IACT;IAIA,eAAe,KAAA,EAAqD;QAClE,IAAIW,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAGxB,MAAM,SAAA,GAAY,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,SAAA,GAAa,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,SAAA;YAErF,IAAI,SAAA,EAAW;gBAEb,IAAI,UAAA,CAAWA,yKAAC,CAAA,CAAE,SAAS,CAAA,EAAG;oBAC5B,MAAM,SAAA,GAAY,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;oBAC/C,OAAO,UAAU,SAAA,CAAU,CAAC,MAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,IAAY,GAAI,CAAA;gBAC3E;gBAGA,MAAM,cAAA,GAAiB,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;gBACpD,OAAO,cAAA,CAAe,QAAA,EAAS,CAAE,SAAA,CAAU,CAAC,GAAA,GAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,CAAA,GAAY,GAAI,CAAA;YAC3F;YAEA,OAAO,KAAA;QACT,CAAA,MAAA,IAAW,UAAA,CAAWA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAG/B,MAAM,SAAA,GAAY,UAAU,KAAA,GAAQ,KAAA,CAAM,IAAA,CAAK,SAAA,GAAa,KAAA,CAAc,IAAA,EAAM,GAAA,EAAK,SAAA;YACrF,IAAI,SAAA,IAAa6B,WAAAA,CAAW7B,yKAAC,CAAA,CAAE,SAAS,CAAA,EAAG;gBACzC,MAAM,cAAA,GAAiB,UAAU,SAAA,GAAY,SAAA,CAAU,IAAA,CAAK,SAAA,GAAa,SAAA,CAAkB,IAAA,EAAM,GAAA,EAAK,SAAA;gBACtG,IAAI,cAAA,EAAgB;oBAClB,MAAM,mBAAA,GAAsB,IAAA,CAAK,cAAA,CAAe,cAAc,CAAA;oBAC9D,OAAO,mBAAA,CAAoB,QAAA,EAAS,CAAE,SAAA,CAAU,CAAC,GAAA,GAAc,GAAA,KAAQ,IAAA,GAAO,KAAA,CAAA,GAAY,GAAI,CAAA;gBAChG;YACF;YAEA,IAAI,SAAA,EAAW;gBACb,MAAM,cAAA,GAAiB,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;gBACpD,OAAO,eAAe,QAAA,EAAS;YACjC;YACA,OAAO,KAAA;QACT,CAAA,MAAA,IAAW8B,MAAAA,CAAM9B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAA,EAAO;gBAAE,WAAA,EAAa;YAAA,CAAO,CAAA;QACnE,CAAA,MAAA,IAAW+B,MAAAA,CAAM/B,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC1B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAWgC,QAAAA,CAAQhC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC5B,OAAO,IAAA,CAAK,sBAAA,CAAuB,KAAK,CAAA;QAC1C,CAAA,MAAA,IAAW,SAAA,CAAUA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC9B,MAAM,aAAa,KAAA,CAAM,IAAA;YACzB,MAAM,YAAY,UAAA,CAAW,SAAA;YAE7B,MAAM,YAAA,GACJ,OAAO,UAAA,CAAW,YAAA,KAAiB,aAAa,UAAA,CAAW,YAAA,KAAiB,UAAA,CAAW,YAAA;YACzF,MAAM,cAAwB,EAAC;YAC/B,IAAI,iBAAiB,KAAA,CAAA,EAAW;gBAC9B,WAAA,CAAY,IAAA,CAAK,CAAA,qBAAA,EAAwB,YAAY,CAAA,CAAE,CAAA;YACzD;YAEA,MAAM,WAAA,GAAc,IAAA,CAAK,yBAAA,CAA0B,KAAA,CAAM,WAAA,EAAa,WAAW,CAAA;YACjF,IAAI,MAAA,GAAS,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;YAC1C,IAAI,WAAA,EAAa;gBACf,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;YACtC;YACA,OAAO,MAAA;QACT,CAAA,MAAA,IAAWkC,SAAAA,CAASlC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAWiC,SAAAA,CAASjC,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC7B,OAAO,IAAA,CAAK,uBAAA,CAAwB,KAAK,CAAA;QAC3C,CAAA,MAAA,IAAW,MAAA,CAAOA,yKAAC,CAAA,CAAE,KAAK,CAAA,EAAG;YAC3B,OAAO,IAAA,CAAK,qBAAA,CAAsB,KAAK,CAAA;QACzC,CAAA,MAAA,IAAW,KAAA,CAAM,WAAA,CAAY,IAAA,KAAS,QAAA,EAAU;YAG9C,OAAOA,yKAAAA,CACJ,MAAA,EAAO,CACP,QAAA,CAAA,CACE,KAAA,CAAM,WAAA,IAAe,EAAA,IACpB,CAAA;qGAAA,CAAA;QAER;QAEA,OAAO,IAAA,CAAK,gCAAA,CAAiC,KAA4C,CAAA;IAC3F;AACF"}},
    {"offset": {"line": 5664, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@mastra/schema-compat/dist/zod-to-json.js","sources":[],"sourcesContent":[],"names":[],"mappings":""}}]
}