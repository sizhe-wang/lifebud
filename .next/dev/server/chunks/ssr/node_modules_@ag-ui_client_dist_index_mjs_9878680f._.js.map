{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/apply/default.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/utils.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/agent/subscriber.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/verify/verify.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/transform/http.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/run/http-request.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/transform/sse.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/transform/proto.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/legacy/convert.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/legacy/types.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/agent/agent.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/chunks/transform.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/middleware/middleware.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/middleware/filter-tool-calls.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/middleware/backward-compatibility-0-0-39.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/package.json","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/agent/http.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/compact/compact.ts","file:///Users/wsz/lifebud/version2/lifebud/node_modules/%40ag-ui/client/src/index.ts"],"sourcesContent":["import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  DeveloperMessage,\n  SystemMessage,\n  AssistantMessage,\n  UserMessage,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(agent.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role = \"assistant\" } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            // Text messages can be developer, system, assistant, or user (not tool)\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const { messageId, delta } = event as TextMessageContentEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append content to the correct message by ID\n            const existingContent =\n              typeof targetMessage.content === \"string\" ? targetMessage.content : \"\";\n            targetMessage.content = `${existingContent}${delta}`;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const { messageId } = event as TextMessageEndEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_END: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: targetMessage,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const { toolCallId, delta } = event as ToolCallArgsEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_ARGS: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallBuffer = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append the arguments to the correct tool call by ID\n            targetToolCall.function.arguments += delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const { toolCallId } = event as ToolCallEndEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_END: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_END: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallArgsString = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: targetToolCall,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_SNAPSHOT: {\n          const activityEvent = event as ActivitySnapshotEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          const existingMessage = existingIndex >= 0 ? messages[existingIndex] : undefined;\n          const existingActivityMessage =\n            existingMessage?.role === \"activity\" ? (existingMessage as ActivityMessage) : undefined;\n          const replace = activityEvent.replace ?? true;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivitySnapshotEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n                existingMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const activityMessage: ActivityMessage = {\n              id: activityEvent.messageId,\n              role: \"activity\",\n              activityType: activityEvent.activityType,\n              content: structuredClone_(activityEvent.content),\n            };\n\n            let createdMessage: ActivityMessage | undefined;\n\n            if (existingIndex === -1) {\n              messages.push(activityMessage);\n              createdMessage = activityMessage;\n            } else if (existingActivityMessage) {\n              if (replace) {\n                messages[existingIndex] = {\n                  ...existingActivityMessage,\n                  activityType: activityEvent.activityType,\n                  content: structuredClone_(activityEvent.content),\n                };\n              }\n            } else if (replace) {\n              messages[existingIndex] = activityMessage;\n              createdMessage = activityMessage;\n            }\n\n            applyMutation({ messages });\n\n            if (createdMessage) {\n              await Promise.all(\n                subscribers.map((subscriber) =>\n                  subscriber.onNewMessage?.({\n                    message: createdMessage,\n                    messages,\n                    state,\n                    agent,\n                    input,\n                  }),\n                ),\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_DELTA: {\n          const activityEvent = event as ActivityDeltaEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          if (existingIndex === -1) {\n            console.warn(\n              `ACTIVITY_DELTA: No message found with ID '${activityEvent.messageId}' to apply patch`,\n            );\n            return emitUpdates();\n          }\n\n          const existingMessage = messages[existingIndex];\n          if (existingMessage.role !== \"activity\") {\n            console.warn(\n              `ACTIVITY_DELTA: Message '${activityEvent.messageId}' is not an activity message`,\n            );\n            return emitUpdates();\n          }\n\n          const existingActivityMessage = existingMessage as ActivityMessage;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivityDeltaEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            try {\n              const baseContent = structuredClone_(existingActivityMessage.content ?? {});\n\n              const result = applyPatch(\n                baseContent,\n                activityEvent.patch ?? [],\n                true,\n                false,\n              );\n              const updatedContent = result.newDocument as ActivityMessage[\"content\"];\n\n              messages[existingIndex] = {\n                ...existingActivityMessage,\n                content: structuredClone_(updatedContent),\n                activityType: activityEvent.activityType,\n              };\n\n              applyMutation({ messages });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply activity patch for '${activityEvent.messageId}': ${errorMessage}`,\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          // Handle input.messages if present and stopPropagation is not set\n          if (mutation.stopPropagation !== true) {\n            const runStartedEvent = event as RunStartedEvent;\n\n            // Check if the event contains input with messages\n            if (runStartedEvent.input?.messages) {\n              // Add messages that aren't already present (checked by ID)\n              for (const message of runStartedEvent.input.messages) {\n                const existingMessage = messages.find((m) => m.id === message.id);\n                if (!existingMessage) {\n                  messages.push(message);\n                }\n              }\n\n              // Apply mutation to emit the updated messages\n              applyMutation({ messages });\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n","import { v4 as uuidv4 } from \"uuid\";\n\nexport const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n\n/**\n * Generate a random UUID v4\n * Cross-platform compatible (Node.js, browsers, React Native)\n */\nexport function randomUUID(): string {\n  return uuidv4();\n}\n\n// Note: semver helpers were removed in favor of using\n// the external `compare-versions` library directly at call sites.\n\n\n/**\n * Parses a semantic version string into its numeric components.\n * Supports incomplete versions (e.g. \"1\", \"1.2\") by defaulting missing segments to zero.\n *\n * @throws If the version string is not a valid semantic version.\n */\n// (Intentionally left minimal.)\n","import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivitySnapshotEvent?(\n    params: {\n      event: ActivitySnapshotEvent;\n      activityMessage?: ActivityMessage;\n      existingMessage?: Message;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivityDeltaEvent?(\n    params: {\n      event: ActivityDeltaEvent;\n      activityMessage?: ActivityMessage;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned â€“ keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n","import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessages = new Map<string, boolean>(); // Map of message ID -> active status\n    let activeToolCalls = new Map<string, boolean>(); // Map of tool call ID -> active status\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n    let runStarted = false; // Track if a run has started\n\n    // Function to reset state for a new run\n    const resetRunState = () => {\n      activeMessages.clear();\n      activeToolCalls.clear();\n      activeSteps.clear();\n      activeThinkingStep = false;\n      activeThinkingStepMessage = false;\n      runFinished = false;\n      runError = false;\n      runStarted = true;\n    };\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished (but allow new RUN_STARTED to start a new run)\n        if (runFinished && eventType !== EventType.RUN_ERROR && eventType !== EventType.RUN_STARTED) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Handle first event requirement and sequential RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Allow RUN_STARTED after RUN_FINISHED (new run), but not during an active run\n          if (runStarted && !runFinished) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run.`,\n                ),\n            );\n          }\n          // If we're here, it's either the first RUN_STARTED or a new run after RUN_FINISHED\n          if (runFinished) {\n            // This is a new run after the previous one finished, reset state\n            resetRunState();\n          }\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            const messageId = (event as any).messageId;\n\n            // Check if this message is already in progress\n            if (activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${messageId}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessages.set(messageId, true);\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${messageId}'. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${messageId}'. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove message from active set\n            activeMessages.delete(messageId);\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Check if this tool call is already in progress\n            if (activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call with ID '${toolCallId}' is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCalls.set(toolCallId, true);\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${toolCallId}'. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${toolCallId}'. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove tool call from active set\n            activeToolCalls.delete(toolCallId);\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            runStarted = true;\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            // Check that all messages are finished before run ends\n            if (activeMessages.size > 0) {\n              const unfinishedMessages = Array.from(activeMessages.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while text messages are still active: ${unfinishedMessages}`,\n                  ),\n              );\n            }\n\n            // Check that all tool calls are finished before run ends\n            if (activeToolCalls.size > 0) {\n              const unfinishedToolCalls = Array.from(activeToolCalls.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while tool calls are still active: ${unfinishedToolCalls}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n","import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\nimport { EventType } from \"@ag-ui/core\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => {\n              if ((err as DOMException)?.name === \"AbortError\") {\n                eventSubject.next({\n                  type: EventType.RUN_ERROR,\n                  rawEvent: err,\n                });\n                eventSubject.complete();\n                return;\n              }\n              return eventSubject.error(err)\n            },\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n","import { Observable, from, defer, throwError } from \"rxjs\";\nimport { mergeMap, switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        // Read the (small) error body once, then error the stream\n        return from(response.text()).pipe(\n          mergeMap((text) => {\n            let payload: unknown = text;\n            if (contentType.includes(\"application/json\")) {\n              try { payload = JSON.parse(text); } catch {/* keep raw text */}\n            }\n            const err: any = new Error(\n              `HTTP ${response.status}: ${typeof payload === \"string\" ? payload : JSON.stringify(payload)}`\n            );\n            err.status = response.status;\n            err.payload = payload;\n            return throwError(() => err);\n          })\n        );\n      }\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel().catch((error) => {\n            if ((error as DOMException)?.name === \"AbortError\") {\n              return;\n            }\n\n            throw error;\n          });\n        };\n      });\n    }),\n  );\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * Follows the SSE spec by only processing 'data:' prefixed lines.\n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        // Extract data content (remove 'data: ' prefix)\n        dataLines.push(line.slice(6));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n","import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n  RunErrorEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n  LegacyRunError\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\nconst flattenMessageContentToText = (content: Message[\"content\"]) => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return undefined;\n  }\n\n  const textParts = content\n    .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\n    .map((part) => part.text)\n    .filter((text) => text.length > 0);\n\n  if (textParts.length === 0) {\n    return undefined;\n  }\n\n  return textParts.join(\"\\n\");\n};\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n                role: startEvent.role,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            // Find the tool call by ID instead of using the last one\n            const currentToolCall = currentToolCalls.find((tc) => tc.id === argsEvent.toolCallId);\n            if (!currentToolCall) {\n              console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${argsEvent.toolCallId}'`);\n              return [];\n            }\n\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            // Only do an update if state is not empty\n            if (Object.keys(currentState).length === 0) {\n              return [];\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            const errorEvent = event as RunErrorEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.RunError,\n                message: errorEvent.message,\n                code: errorEvent.code,\n              } as LegacyRunError,\n            ];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      const textContent = flattenMessageContentToText(message.content);\n      if (textContent) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: textContent,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n","import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n  role: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\n\nexport const LegacyRunError = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.RunError),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n  LegacyRunError,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\nexport type LegacyRunError = z.infer<typeof LegacyRunError>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n","import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { compareVersions } from \"compare-versions\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { takeUntil } from \"rxjs/operators\";\nimport { pipe, Observable, from, of, EMPTY, Subject } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\nimport { AGUIConnectNotImplementedError } from \"@ag-ui/core\";\nimport {\n  Middleware,\n  MiddlewareFunction,\n  FunctionMiddleware,\n  BackwardCompatibility_0_0_39,\n} from \"@/middleware\";\nimport packageJson from \"../../package.json\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n  public isRunning: boolean = false;\n  private middlewares: Middleware[] = [];\n  // Emits to immediately detach from the active run (stop processing its stream)\n  private activeRunDetach$?: Subject<void>;\n  private activeRunCompletionPromise?: Promise<void>;\n\n  get maxVersion() {\n    return packageJson.version;\n  }\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n\n    if (compareVersions(this.maxVersion, \"0.0.39\") <= 0) {\n      this.middlewares.unshift(new BackwardCompatibility_0_0_39());\n    }\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public use(...middlewares: (Middleware | MiddlewareFunction)[]): this {\n    const normalizedMiddlewares = middlewares.map((middleware) =>\n      typeof middleware === \"function\" ? new FunctionMiddleware(middleware) : middleware,\n    );\n    this.middlewares.push(...normalizedMiddlewares);\n    return this;\n  }\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => {\n          // Build middleware chain using reduceRight so middlewares can intercept runs.\n          if (this.middlewares.length === 0) {\n            return this.run(input);\n          }\n\n          const chainedAgent = this.middlewares.reduceRight(\n            (nextAgent: AbstractAgent, middleware) =>\n              ({\n                run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n              }) as AbstractAgent,\n            this, // Original agent is the final 'next'\n          );\n\n          return chainedAgent.run(input);\n        },\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          return this.onError(input, error, subscribers);\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null)));\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  protected connect(input: RunAgentInput): Observable<BaseEvent> {\n    throw new AGUIConnectNotImplementedError();\n  }\n  public async connectAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => this.connect(input),\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          if (!(error instanceof AGUIConnectNotImplementedError)) {\n            return this.onError(input, error, subscribers);\n          }\n          return EMPTY;\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null))); // wait for stream completion before toggling isRunning\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  public abortRun() {}\n\n  public async detachActiveRun(): Promise<void> {\n    if (!this.activeRunDetach$) {\n      return;\n    }\n    const completion = this.activeRunCompletionPromise ?? Promise.resolve();\n    this.activeRunDetach$.next();\n    this.activeRunDetach$?.complete();\n    await completion;\n  }\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    const clonedMessages = structuredClone_(this.messages) as Message[];\n    const messagesWithoutActivity = clonedMessages.filter((message) => message.role !== \"activity\");\n\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: messagesWithoutActivity,\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    cloned.agentId = this.agentId;\n    cloned.description = this.description;\n    cloned.threadId = this.threadId;\n    cloned.messages = structuredClone_(this.messages);\n    cloned.state = structuredClone_(this.state);\n    cloned.debug = this.debug;\n    cloned.isRunning = this.isRunning;\n    cloned.subscribers = [...this.subscribers];\n    cloned.middlewares = [...this.middlewares];\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    // Build middleware chain for legacy bridge\n    const runObservable = (() => {\n      if (this.middlewares.length === 0) {\n        return this.run(input);\n      }\n\n      const chainedAgent = this.middlewares.reduceRight(\n        (nextAgent: AbstractAgent, middleware) =>\n          ({\n            run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n          }) as AbstractAgent,\n        this,\n      );\n\n      return chainedAgent.run(input);\n    })();\n\n    return runObservable.pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n","import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n          case EventType.ACTIVITY_SNAPSHOT:\n          case EventType.ACTIVITY_DELTA:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: messageChunkEvent.role || \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n        return [];\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        closePendingEvent();\n      }),\n    );\n  };\n","import { AbstractAgent } from \"@/agent\";\nimport { RunAgentInput, BaseEvent, Message } from \"@ag-ui/core\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport { concatMap } from \"rxjs/operators\";\nimport { transformChunks } from \"@/chunks\";\nimport { defaultApplyEvents } from \"@/apply\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport type MiddlewareFunction = (\n  input: RunAgentInput,\n  next: AbstractAgent,\n) => Observable<BaseEvent>;\n\nexport interface EventWithState {\n  event: BaseEvent;\n  messages: Message[];\n  state: any;\n}\n\nexport abstract class Middleware {\n  abstract run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent>;\n\n  /**\n   * Runs the next agent in the chain with automatic chunk transformation.\n   */\n  protected runNext(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return next.run(input).pipe(\n      transformChunks(false), // Always transform chunks to full events\n    );\n  }\n\n  /**\n   * Runs the next agent and tracks state, providing current messages and state with each event.\n   * The messages and state represent the state AFTER the event has been applied.\n   */\n  protected runNextWithState(\n    input: RunAgentInput,\n    next: AbstractAgent,\n  ): Observable<EventWithState> {\n    let currentMessages = structuredClone_(input.messages || []);\n    let currentState = structuredClone_(input.state || {});\n\n    // Use a ReplaySubject to feed events one by one\n    const eventSubject = new ReplaySubject<BaseEvent>();\n\n    // Set up defaultApplyEvents to process events\n    const mutations$ = defaultApplyEvents(input, eventSubject, next, []);\n\n    // Subscribe to track state changes\n    mutations$.subscribe((mutation) => {\n      if (mutation.messages !== undefined) {\n        currentMessages = mutation.messages;\n      }\n      if (mutation.state !== undefined) {\n        currentState = mutation.state;\n      }\n    });\n\n    return this.runNext(input, next).pipe(\n      concatMap(async (event) => {\n        // Feed the event to defaultApplyEvents and wait for it to process\n        eventSubject.next(event);\n\n        // Give defaultApplyEvents a chance to process\n        await new Promise((resolve) => setTimeout(resolve, 0));\n\n        // Return event with current state\n        return {\n          event,\n          messages: structuredClone_(currentMessages),\n          state: structuredClone_(currentState),\n        };\n      }),\n    );\n  }\n}\n\n// Wrapper class to convert a function into a Middleware instance\nexport class FunctionMiddleware extends Middleware {\n  constructor(private fn: MiddlewareFunction) {\n    super();\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return this.fn(input, next);\n  }\n}\n","import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport {\n  RunAgentInput,\n  BaseEvent,\n  EventType,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport { filter } from \"rxjs/operators\";\n\ntype FilterToolCallsConfig =\n  | { allowedToolCalls: string[]; disallowedToolCalls?: never }\n  | { disallowedToolCalls: string[]; allowedToolCalls?: never };\n\nexport class FilterToolCallsMiddleware extends Middleware {\n  private blockedToolCallIds = new Set<string>();\n  private readonly allowedTools?: Set<string>;\n  private readonly disallowedTools?: Set<string>;\n\n  constructor(config: FilterToolCallsConfig) {\n    super();\n\n    // Runtime validation (belt and suspenders approach)\n    if (config.allowedToolCalls && config.disallowedToolCalls) {\n      throw new Error(\"Cannot specify both allowedToolCalls and disallowedToolCalls\");\n    }\n\n    if (!config.allowedToolCalls && !config.disallowedToolCalls) {\n      throw new Error(\"Must specify either allowedToolCalls or disallowedToolCalls\");\n    }\n\n    if (config.allowedToolCalls) {\n      this.allowedTools = new Set(config.allowedToolCalls);\n    } else if (config.disallowedToolCalls) {\n      this.disallowedTools = new Set(config.disallowedToolCalls);\n    }\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    // Use runNext which already includes transformChunks\n    return this.runNext(input, next).pipe(\n      filter((event) => {\n        // Handle TOOL_CALL_START events\n        if (event.type === EventType.TOOL_CALL_START) {\n          const toolCallStartEvent = event as ToolCallStartEvent;\n          const shouldFilter = this.shouldFilterTool(toolCallStartEvent.toolCallName);\n\n          if (shouldFilter) {\n            // Track this tool call ID as blocked\n            this.blockedToolCallIds.add(toolCallStartEvent.toolCallId);\n            return false; // Filter out this event\n          }\n\n          return true; // Allow this event\n        }\n\n        // Handle TOOL_CALL_ARGS events\n        if (event.type === EventType.TOOL_CALL_ARGS) {\n          const toolCallArgsEvent = event as ToolCallArgsEvent;\n          return !this.blockedToolCallIds.has(toolCallArgsEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_END events\n        if (event.type === EventType.TOOL_CALL_END) {\n          const toolCallEndEvent = event as ToolCallEndEvent;\n          return !this.blockedToolCallIds.has(toolCallEndEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_RESULT events\n        if (event.type === EventType.TOOL_CALL_RESULT) {\n          const toolCallResultEvent = event as ToolCallResultEvent;\n          const isBlocked = this.blockedToolCallIds.has(toolCallResultEvent.toolCallId);\n\n          if (isBlocked) {\n            // Clean up the blocked ID after the last event\n            this.blockedToolCallIds.delete(toolCallResultEvent.toolCallId);\n            return false;\n          }\n\n          return true;\n        }\n\n        // Allow all other events through\n        return true;\n      }),\n    );\n  }\n\n  private shouldFilterTool(toolName: string): boolean {\n    if (this.allowedTools) {\n      // If using allowed list, filter out tools NOT in the list\n      return !this.allowedTools.has(toolName);\n    } else if (this.disallowedTools) {\n      // If using disallowed list, filter out tools IN the list\n      return this.disallowedTools.has(toolName);\n    }\n\n    return false;\n  }\n}\n","import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport type { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport type { Observable } from \"rxjs\";\n\ntype InputMessage = RunAgentInput[\"messages\"][number];\n\nfunction sanitizeMessageContent(message: InputMessage): InputMessage {\n  const rawContent = (message as { content?: unknown }).content;\n\n  if (Array.isArray(rawContent)) {\n    const concatenatedContent = rawContent\n      .filter(\n        (part): part is { type: \"text\"; text: string } =>\n          typeof part === \"object\" &&\n          part !== null &&\n          \"type\" in part &&\n          (part as { type: unknown }).type === \"text\" &&\n          typeof (part as { text?: unknown }).text === \"string\",\n      )\n      .map((part) => part.text)\n      .join(\"\");\n\n    return {\n      ...message,\n      content: concatenatedContent,\n    } as InputMessage;\n  }\n\n  if (typeof rawContent === \"string\") {\n    return message;\n  }\n\n  return {\n    ...message,\n    content: \"\",\n  } as InputMessage;\n}\n\n/**\n * Middleware placeholder that maintains compatibility with AG-UI 0.0.39 flows.\n * Currently it simply forwards all events to the next middleware/agent.\n */\nexport class BackwardCompatibility_0_0_39 extends Middleware {\n  override run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    const { parentRunId: _parentRunId, ...rest } = input;\n    const sanitizedInput: RunAgentInput = {\n      ...rest,\n      messages: rest.messages.map(sanitizeMessageContent),\n    } as RunAgentInput;\n\n    return this.runNext(sanitizedInput, next);\n  }\n}\n","{\n  \"name\": \"@ag-ui/client\",\n  \"author\": \"Markus Ecker <markus.ecker@gmail.com>\",\n  \"version\": \"0.0.42\",\n  \"private\": false,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"files\": [\n    \"dist/**\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"clean\": \"rm -rf dist .turbo node_modules\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\",\n    \"link:global\": \"pnpm link --global\",\n    \"unlink:global\": \"pnpm unlink --global\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/core\": \"workspace:*\",\n    \"@ag-ui/encoder\": \"workspace:*\",\n    \"@ag-ui/proto\": \"workspace:*\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"compare-versions\": \"^6.1.1\",\n    \"fast-json-patch\": \"^3.1.1\",\n    \"rxjs\": \"7.8.1\",\n    \"untruncate-json\": \"^0.0.1\",\n    \"uuid\": \"^11.1.0\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^20.11.19\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.2\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n","import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public clone(): HttpAgent {\n    const cloned = super.clone() as HttpAgent;\n    cloned.url = this.url;\n    cloned.headers = structuredClone_(this.headers ?? {});\n\n    const newController = new AbortController();\n    const originalSignal = this.abortController.signal as AbortSignal & { reason?: unknown };\n    if (originalSignal.aborted) {\n      newController.abort(originalSignal.reason);\n    }\n    cloned.abortController = newController;\n\n    return cloned;\n  }\n}\n","import {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n} from \"@ag-ui/core\";\n\n/**\n * Compacts streaming events by consolidating multiple deltas into single events.\n * For text messages: multiple content deltas become one concatenated delta.\n * For tool calls: multiple args deltas become one concatenated delta.\n * Events between related streaming events are reordered to keep streaming events together.\n *\n * @param events - Array of events to compact\n * @returns Compacted array of events\n */\nexport function compactEvents(events: BaseEvent[]): BaseEvent[] {\n  const compacted: BaseEvent[] = [];\n  const pendingTextMessages = new Map<\n    string,\n    {\n      start?: TextMessageStartEvent;\n      contents: TextMessageContentEvent[];\n      end?: TextMessageEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n  const pendingToolCalls = new Map<\n    string,\n    {\n      start?: ToolCallStartEvent;\n      args: ToolCallArgsEvent[];\n      end?: ToolCallEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n\n  for (const event of events) {\n    // Handle text message streaming events\n    if (event.type === EventType.TEXT_MESSAGE_START) {\n      const startEvent = event as TextMessageStartEvent;\n      const messageId = startEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TEXT_MESSAGE_CONTENT) {\n      const contentEvent = event as TextMessageContentEvent;\n      const messageId = contentEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.contents.push(contentEvent);\n    } else if (event.type === EventType.TEXT_MESSAGE_END) {\n      const endEvent = event as TextMessageEndEvent;\n      const messageId = endEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.end = endEvent;\n\n      // Flush this message's events\n      flushTextMessage(messageId, pending, compacted);\n      pendingTextMessages.delete(messageId);\n    } else if (event.type === EventType.TOOL_CALL_START) {\n      const startEvent = event as ToolCallStartEvent;\n      const toolCallId = startEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TOOL_CALL_ARGS) {\n      const argsEvent = event as ToolCallArgsEvent;\n      const toolCallId = argsEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.args.push(argsEvent);\n    } else if (event.type === EventType.TOOL_CALL_END) {\n      const endEvent = event as ToolCallEndEvent;\n      const toolCallId = endEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.end = endEvent;\n\n      // Flush this tool call's events\n      flushToolCall(toolCallId, pending, compacted);\n      pendingToolCalls.delete(toolCallId);\n    } else {\n      // For non-streaming events, check if we're in the middle of any streaming sequences\n      let addedToBuffer = false;\n\n      // Check text messages\n      for (const [messageId, pending] of pendingTextMessages) {\n        // If we have a start but no end yet, this event is \"in between\"\n        if (pending.start && !pending.end) {\n          pending.otherEvents.push(event);\n          addedToBuffer = true;\n          break;\n        }\n      }\n\n      // Check tool calls if not already buffered\n      if (!addedToBuffer) {\n        for (const [toolCallId, pending] of pendingToolCalls) {\n          // If we have a start but no end yet, this event is \"in between\"\n          if (pending.start && !pending.end) {\n            pending.otherEvents.push(event);\n            addedToBuffer = true;\n            break;\n          }\n        }\n      }\n\n      // If not in the middle of any streaming sequence, add directly to compacted\n      if (!addedToBuffer) {\n        compacted.push(event);\n      }\n    }\n  }\n\n  // Flush any remaining incomplete messages\n  for (const [messageId, pending] of pendingTextMessages) {\n    flushTextMessage(messageId, pending, compacted);\n  }\n\n  // Flush any remaining incomplete tool calls\n  for (const [toolCallId, pending] of pendingToolCalls) {\n    flushToolCall(toolCallId, pending, compacted);\n  }\n\n  return compacted;\n}\n\nfunction flushTextMessage(\n  messageId: string,\n  pending: {\n    start?: TextMessageStartEvent;\n    contents: TextMessageContentEvent[];\n    end?: TextMessageEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all content events into one\n  if (pending.contents.length > 0) {\n    const concatenatedDelta = pending.contents.map((c) => c.delta).join(\"\");\n\n    const compactedContent: TextMessageContentEvent = {\n      type: EventType.TEXT_MESSAGE_CONTENT,\n      messageId: messageId,\n      delta: concatenatedDelta,\n    };\n\n    compacted.push(compactedContent);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n\nfunction flushToolCall(\n  toolCallId: string,\n  pending: {\n    start?: ToolCallStartEvent;\n    args: ToolCallArgsEvent[];\n    end?: ToolCallEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all args events into one\n  if (pending.args.length > 0) {\n    const concatenatedArgs = pending.args.map((a) => a.delta).join(\"\");\n\n    const compactedArgs: ToolCallArgsEvent = {\n      type: EventType.TOOL_CALL_ARGS,\n      toolCallId: toolCallId,\n      delta: concatenatedArgs,\n    };\n\n    compacted.push(compactedArgs);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n","export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"./utils\";\nexport * from \"./compact\";\nexport * from \"@ag-ui/core\";\nexport * from \"./chunks\";\nexport * from \"./middleware\";\n\nexport { Middleware, FilterToolCallsMiddleware } from \"./middleware\";\nexport type { MiddlewareFunction } from \"./middleware\";\n"],"names":["EventType","mergeAll","defaultIfEmpty","concatMap","of","EMPTY","uuidv4","structuredClone_","obj","err","__spreadValues","randomUUID","uuidv4","applyPatch","runSubscribersWithMutation","subscribers","initialMessages","initialState","executor","messages","state","stopPropagation","subscriber","mutation","structuredClone_","error","__spreadValues","untruncateJson","defaultApplyEvents","input","events$","agent","subscribers","messages","structuredClone_","state","currentMutation","applyMutation","mutation","emitUpdates","result","of","EMPTY","concatMap","event","_a","_b","_c","_d","_e","runSubscribersWithMutation","subscriber","EventType","messageId","role","newMessage","delta","targetMessage","m","existingContent","toolCallId","toolCallName","parentMessageId","tc","targetToolCall","toolCallBuffer","partialToolCallArgs","untruncateJson","error","toolCallArgsString","toolCallArgs","content","toolMessage","snapshot","applyPatch","errorMessage","newMessages","activityEvent","existingIndex","existingMessage","existingActivityMessage","replace","activityMessage","createdMessage","__spreadProps","__spreadValues","baseContent","updatedContent","runStartedEvent","message","_exhaustiveCheck","mergeAll","defaultIfEmpty","stream","EventType","AGUIError","throwError","of","mergeMap","verifyEvents","debug","source$","activeMessages","activeToolCalls","runFinished","runError","firstEventReceived","activeSteps","activeThinkingStep","activeThinkingStepMessage","runStarted","resetRunState","event","eventType","messageId","toolCallId","stepName","unfinishedSteps","unfinishedMessages","unfinishedToolCalls","EventSchemas","Subject","ReplaySubject","Observable","from","defer","throwError","mergeMap","switchMap","runHttpRequest","url","requestInit","defer","from","switchMap","response","_a","contentType","mergeMap","text","payload","e","err","throwError","headersEvent","reader","Observable","subscriber","done","value","dataEvent","error","Subject","parseSSEStream","source$","jsonSubject","Subject","decoder","buffer","event","text","events","processSSEEvent","err","eventText","lines","dataLines","line","jsonStr","json","Subject","proto","parseProtoStream","source$","eventSubject","Subject","buffer","event","newBuffer","processBuffer","err","error","totalLength","message","errorMessage","proto","EventType","transformHttpEventStream","source$","eventSubject","Subject","bufferSubject","ReplaySubject","parserInitialized","event","parseProtoStream","err","parseSSEStream","json","parsedEvent","EventSchemas","mergeMap","applyPatch","EventType","z","LegacyRuntimeEventTypes","LegacyRuntimeMetaEventName","LegacyTextMessageStart","LegacyTextMessageContent","LegacyTextMessageEnd","LegacyActionExecutionStart","LegacyActionExecutionArgs","LegacyActionExecutionEnd","LegacyActionExecutionResult","LegacyAgentStateMessage","LegacyMetaEvent","LegacyRunError","LegacyRuntimeProtocolEvent","LegacyTextMessageSchema","LegacyActionExecutionMessageSchema","LegacyResultMessageSchema","untruncateJson","flattenMessageContentToText","content","textParts","part","text","convertToLegacyEvents","threadId","runId","agentName","events$","currentState","running","active","nodeName","syncedMessages","predictState","currentToolCalls","toolCallNames","updateCurrentState","newState","mergeMap","event","EventType","startEvent","LegacyRuntimeEventTypes","contentEvent","endEvent","argsEvent","currentToolCall","tc","didUpdateState","currentPredictState","s","currentArgs","untruncateJson","__spreadProps","__spreadValues","e","resultEvent","customEvent","result","applyPatch","convertMessagesToLegacyFormat","errorEvent","messages","_a","message","textContent","textMessage","toolCall","actionExecutionMessage","actionName","m","toolMessage","uuidv4","compareVersions","catchError","map","tap","finalize","takeUntil","pipe","from","of","EMPTY","Subject","lastValueFrom","mergeMap","finalize","EventType","transformChunks","debug","events$","textMessageFields","toolCallFields","mode","closeTextMessage","event","closeToolCall","closePendingEvent","messageChunkEvent","textMessageResult","textMessageStartEvent","textMessageContentEvent","toolCallChunkEvent","toolMessageResult","toolCallStartEvent","toolCallArgsEvent","_exhaustiveCheck","AGUIConnectNotImplementedError","ReplaySubject","concatMap","Middleware","input","next","transformChunks","currentMessages","structuredClone_","currentState","eventSubject","ReplaySubject","defaultApplyEvents","mutation","concatMap","event","resolve","FunctionMiddleware","fn","EventType","filter","FilterToolCallsMiddleware","Middleware","config","input","next","event","toolCallStartEvent","toolCallArgsEvent","toolCallEndEvent","toolCallResultEvent","toolName","sanitizeMessageContent","message","rawContent","concatenatedContent","part","__spreadProps","__spreadValues","BackwardCompatibility_0_0_39","Middleware","input","next","_a","_parentRunId","rest","__objRest","sanitizedInput","package_default","AbstractAgent","agentId","description","threadId","initialMessages","initialState","debug","uuidv4","structuredClone_","compareVersions","BackwardCompatibility_0_0_39","package_default","subscriber","s","middlewares","normalizedMiddlewares","middleware","FunctionMiddleware","parameters","_a","input","result","currentMessageIds","message","subscribers","params","Subject","resolveActiveRunCompletion","resolve","pipeline","pipe","nextAgent","i","transformChunks","verifyEvents","source$","takeUntil","catchError","error","finalize","lastValueFrom","of","newMessages","AGUIConnectNotImplementedError","EMPTY","_b","completion","events$","defaultApplyEvents","tap","event","_c","messagesWithoutActivity","onRunInitializedMutation","runSubscribersWithMutation","messages","state","from","map","onRunFailedMutation","mutation","onRunFinalizedMutation","cloned","toolCall","config","convertToLegacyEvents","HttpAgent","AbstractAgent","config","_a","structuredClone_","input","__spreadProps","__spreadValues","parameters","subscriber","httpEvents","runHttpRequest","transformHttpEventStream","cloned","newController","originalSignal","EventType","compactEvents","events","compacted","pendingTextMessages","pendingToolCalls","event","startEvent","messageId","pending","contentEvent","endEvent","flushTextMessage","toolCallId","argsEvent","flushToolCall","addedToBuffer","concatenatedDelta","c","compactedContent","otherEvent","concatenatedArgs","a","compactedArgs"],"mappings":"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"}}]
}