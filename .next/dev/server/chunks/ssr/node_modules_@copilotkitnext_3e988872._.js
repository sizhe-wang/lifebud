module.exports = [
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasA11yProp",
    ()=>hasA11yProp,
    "mergeClasses",
    ()=>mergeClasses,
    "toCamelCase",
    ()=>toCamelCase,
    "toKebabCase",
    ()=>toKebabCase,
    "toPascalCase",
    ()=>toPascalCase
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string)=>string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());
const toPascalCase = (string)=>{
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes)=>classes.filter((className, index, array)=>{
        return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
const hasA11yProp = (props)=>{
    for(const prop in props){
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
            return true;
        }
    }
};
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>defaultAttributes
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
;
 //# sourceMappingURL=defaultAttributes.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Icon
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
;
;
;
const Icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("svg", {
        ref,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])("lucide", className),
        ...!children && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasA11yProp"])(rest) && {
            "aria-hidden": "true"
        },
        ...rest
    }, [
        ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
        ...Array.isArray(children) ? children : [
            children
        ]
    ]));
;
 //# sourceMappingURL=Icon.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>createLucideIcon
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)");
;
;
;
const createLucideIcon = (iconName, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ className, ...props }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], {
            ref,
            iconNode,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toKebabCase"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName))}`, `lucide-${iconName}`, className),
            ...props
        }));
    Component.displayName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName);
    return Component;
};
;
 //# sourceMappingURL=createLucideIcon.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Plus
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M5 12h14",
            key: "1ays0h"
        }
    ],
    [
        "path",
        {
            d: "M12 5v14",
            key: "s699le"
        }
    ]
];
const Plus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("plus", __iconNode);
;
 //# sourceMappingURL=plus.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript) <export default as Plus>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Plus",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$plus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$plus$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/plus.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/mic.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Mic
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M12 19v3",
            key: "npa21l"
        }
    ],
    [
        "path",
        {
            d: "M19 10v2a7 7 0 0 1-14 0v-2",
            key: "1vc78b"
        }
    ],
    [
        "rect",
        {
            x: "9",
            y: "2",
            width: "6",
            height: "13",
            rx: "3",
            key: "s6n7sd"
        }
    ]
];
const Mic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("mic", __iconNode);
;
 //# sourceMappingURL=mic.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/mic.js [app-ssr] (ecmascript) <export default as Mic>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Mic",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$mic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$mic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/mic.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/arrow-up.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ArrowUp
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m5 12 7-7 7 7",
            key: "hav0vg"
        }
    ],
    [
        "path",
        {
            d: "M12 19V5",
            key: "x0mq9r"
        }
    ]
];
const ArrowUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("arrow-up", __iconNode);
;
 //# sourceMappingURL=arrow-up.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/arrow-up.js [app-ssr] (ecmascript) <export default as ArrowUp>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ArrowUp",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/arrow-up.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/x.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>X
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M18 6 6 18",
            key: "1bl5f8"
        }
    ],
    [
        "path",
        {
            d: "m6 6 12 12",
            key: "d8bk6v"
        }
    ]
];
const X = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("x", __iconNode);
;
 //# sourceMappingURL=x.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/x.js [app-ssr] (ecmascript) <export default as X>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "X",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$x$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$x$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/x.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Check
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M20 6 9 17l-5-5",
            key: "1gmf2c"
        }
    ]
];
const Check = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("check", __iconNode);
;
 //# sourceMappingURL=check.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript) <export default as Check>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Check",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/check.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Square
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2",
            key: "afitv7"
        }
    ]
];
const Square = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("square", __iconNode);
;
 //# sourceMappingURL=square.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square.js [app-ssr] (ecmascript) <export default as Square>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Square",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$square$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$square$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ChevronRight
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m9 18 6-6-6-6",
            key: "mthhwq"
        }
    ]
];
const ChevronRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("chevron-right", __iconNode);
;
 //# sourceMappingURL=chevron-right.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-ssr] (ecmascript) <export default as ChevronRightIcon>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronRightIcon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Copy
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "rect",
        {
            width: "14",
            height: "14",
            x: "8",
            y: "8",
            rx: "2",
            ry: "2",
            key: "17jyea"
        }
    ],
    [
        "path",
        {
            d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
            key: "zix9uf"
        }
    ]
];
const Copy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("copy", __iconNode);
;
 //# sourceMappingURL=copy.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript) <export default as Copy>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Copy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$copy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$copy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/copy.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-up.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ThumbsUp
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M7 10v12",
            key: "1qc93n"
        }
    ],
    [
        "path",
        {
            d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z",
            key: "emmmcr"
        }
    ]
];
const ThumbsUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("thumbs-up", __iconNode);
;
 //# sourceMappingURL=thumbs-up.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-up.js [app-ssr] (ecmascript) <export default as ThumbsUp>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ThumbsUp",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$thumbs$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$thumbs$2d$up$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-up.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-down.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ThumbsDown
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M17 14V2",
            key: "8ymqnk"
        }
    ],
    [
        "path",
        {
            d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z",
            key: "m61m77"
        }
    ]
];
const ThumbsDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("thumbs-down", __iconNode);
;
 //# sourceMappingURL=thumbs-down.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-down.js [app-ssr] (ecmascript) <export default as ThumbsDown>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ThumbsDown",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$thumbs$2d$down$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$thumbs$2d$down$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/thumbs-down.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/volume-2.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Volume2
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
            key: "uqj9uw"
        }
    ],
    [
        "path",
        {
            d: "M16 9a5 5 0 0 1 0 6",
            key: "1q6k2b"
        }
    ],
    [
        "path",
        {
            d: "M19.364 18.364a9 9 0 0 0 0-12.728",
            key: "ijwkga"
        }
    ]
];
const Volume2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("volume-2", __iconNode);
;
 //# sourceMappingURL=volume-2.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/volume-2.js [app-ssr] (ecmascript) <export default as Volume2>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Volume2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$volume$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$volume$2d$2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/volume-2.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/refresh-cw.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>RefreshCw
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
            key: "v9h5vc"
        }
    ],
    [
        "path",
        {
            d: "M21 3v5h-5",
            key: "1q7to0"
        }
    ],
    [
        "path",
        {
            d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
            key: "3uifl3"
        }
    ],
    [
        "path",
        {
            d: "M8 16H3v5",
            key: "1cv678"
        }
    ]
];
const RefreshCw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("refresh-cw", __iconNode);
;
 //# sourceMappingURL=refresh-cw.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/refresh-cw.js [app-ssr] (ecmascript) <export default as RefreshCw>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RefreshCw",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$refresh$2d$cw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$refresh$2d$cw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/refresh-cw.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square-pen.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>SquarePen
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
            key: "1m0v6g"
        }
    ],
    [
        "path",
        {
            d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
            key: "ohrbg2"
        }
    ]
];
const SquarePen = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("square-pen", __iconNode);
;
 //# sourceMappingURL=square-pen.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square-pen.js [app-ssr] (ecmascript) <export default as Edit>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Edit",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$square$2d$pen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$square$2d$pen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/square-pen.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-left.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ChevronLeft
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m15 18-6-6 6-6",
            key: "1wnfg3"
        }
    ]
];
const ChevronLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("chevron-left", __iconNode);
;
 //# sourceMappingURL=chevron-left.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-left.js [app-ssr] (ecmascript) <export default as ChevronLeft>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronLeft",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-left.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-ssr] (ecmascript) <export default as ChevronRight>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronRight",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>LoaderCircle
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M21 12a9 9 0 1 1-6.219-8.56",
            key: "13zald"
        }
    ]
];
const LoaderCircle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("loader-circle", __iconNode);
;
 //# sourceMappingURL=loader-circle.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-ssr] (ecmascript) <export default as Loader2>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Loader2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>ChevronDown
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m6 9 6 6 6-6",
            key: "qrunsl"
        }
    ]
];
const ChevronDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("chevron-down", __iconNode);
;
 //# sourceMappingURL=chevron-down.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-ssr] (ecmascript) <export default as ChevronDown>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronDown",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/message-circle.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>MessageCircle
]);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
            key: "vv11sd"
        }
    ]
];
const MessageCircle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("message-circle", __iconNode);
;
 //# sourceMappingURL=message-circle.js.map
}),
"[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/message-circle.js [app-ssr] (ecmascript) <export default as MessageCircle>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MessageCircle",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$message$2d$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$react$2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$message$2d$circle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/react/node_modules/lucide-react/dist/esm/icons/message-circle.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@copilotkitnext/shared/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_AGENT_ID",
    ()=>DEFAULT_AGENT_ID,
    "finalizeRunEvents",
    ()=>finalizeRunEvents,
    "logger",
    ()=>logger,
    "partialJSONParse",
    ()=>partialJSONParse,
    "randomUUID",
    ()=>randomUUID
]);
// src/utils.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/v4.js [app-ssr] (ecmascript) <export default as v4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$partial$2d$json$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/partial-json/dist/index.js [app-ssr] (ecmascript)");
// src/finalize-events.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ag-ui/core/dist/index.mjs [app-ssr] (ecmascript)");
;
;
function randomUUID() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
}
function partialJSONParse(json) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$partial$2d$json$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"](json);
    } catch (error) {
        return {};
    }
}
// src/logger.ts
var logger = console;
// src/constants.ts
var DEFAULT_AGENT_ID = "default";
;
var defaultStopMessage = "Run stopped by user";
var defaultAbruptEndMessage = "Run ended without emitting a terminal event";
function finalizeRunEvents(events, options = {}) {
    const { stopRequested = false, interruptionMessage } = options;
    const resolvedStopMessage = interruptionMessage ?? defaultStopMessage;
    const resolvedAbruptMessage = interruptionMessage && interruptionMessage !== defaultStopMessage ? interruptionMessage : defaultAbruptEndMessage;
    const appended = [];
    const openMessageIds = /* @__PURE__ */ new Set();
    const openToolCalls = /* @__PURE__ */ new Map();
    for (const event of events){
        switch(event.type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TEXT_MESSAGE_START:
                {
                    const messageId = event.messageId;
                    if (typeof messageId === "string") {
                        openMessageIds.add(messageId);
                    }
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TEXT_MESSAGE_END:
                {
                    const messageId = event.messageId;
                    if (typeof messageId === "string") {
                        openMessageIds.delete(messageId);
                    }
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TOOL_CALL_START:
                {
                    const toolCallId = event.toolCallId;
                    if (typeof toolCallId === "string") {
                        openToolCalls.set(toolCallId, {
                            hasEnd: false,
                            hasResult: false
                        });
                    }
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TOOL_CALL_END:
                {
                    const toolCallId = event.toolCallId;
                    const info = toolCallId ? openToolCalls.get(toolCallId) : void 0;
                    if (info) {
                        info.hasEnd = true;
                    }
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TOOL_CALL_RESULT:
                {
                    const toolCallId = event.toolCallId;
                    const info = toolCallId ? openToolCalls.get(toolCallId) : void 0;
                    if (info) {
                        info.hasResult = true;
                    }
                    break;
                }
            default:
                break;
        }
    }
    const hasRunFinished = events.some((event)=>event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].RUN_FINISHED);
    const hasRunError = events.some((event)=>event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].RUN_ERROR);
    const hasTerminalEvent = hasRunFinished || hasRunError;
    const terminalEventMissing = !hasTerminalEvent;
    for (const messageId of openMessageIds){
        const endEvent = {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TEXT_MESSAGE_END,
            messageId
        };
        events.push(endEvent);
        appended.push(endEvent);
    }
    for (const [toolCallId, info] of openToolCalls){
        if (!info.hasEnd) {
            const endEvent = {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TOOL_CALL_END,
                toolCallId
            };
            events.push(endEvent);
            appended.push(endEvent);
        }
        if (terminalEventMissing && !info.hasResult) {
            const resultEvent = {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].TOOL_CALL_RESULT,
                toolCallId,
                messageId: `${toolCallId ?? randomUUID()}-result`,
                role: "tool",
                content: JSON.stringify(stopRequested ? {
                    status: "stopped",
                    reason: "stop_requested",
                    message: resolvedStopMessage
                } : {
                    status: "error",
                    reason: "missing_terminal_event",
                    message: resolvedAbruptMessage
                })
            };
            events.push(resultEvent);
            appended.push(resultEvent);
        }
    }
    if (terminalEventMissing) {
        if (stopRequested) {
            const finishedEvent = {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].RUN_FINISHED
            };
            events.push(finishedEvent);
            appended.push(finishedEvent);
        } else {
            const errorEvent = {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventType"].RUN_ERROR,
                message: resolvedAbruptMessage,
                code: "INCOMPLETE_STREAM"
            };
            events.push(errorEvent);
            appended.push(errorEvent);
        }
    }
    return appended;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@copilotkitnext/core/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AgentRegistry",
    ()=>AgentRegistry,
    "ContextStore",
    ()=>ContextStore,
    "CopilotKitCore",
    ()=>CopilotKitCore,
    "CopilotKitCoreErrorCode",
    ()=>CopilotKitCoreErrorCode,
    "CopilotKitCoreRuntimeConnectionStatus",
    ()=>CopilotKitCoreRuntimeConnectionStatus,
    "ProxiedCopilotRuntimeAgent",
    ()=>ProxiedCopilotRuntimeAgent,
    "RunHandler",
    ()=>RunHandler,
    "StateManager",
    ()=>StateManager,
    "SuggestionEngine",
    ()=>SuggestionEngine,
    "ToolCallStatus",
    ()=>ToolCallStatus,
    "completePartialMarkdown",
    ()=>completePartialMarkdown
]);
// src/core/agent-registry.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ag-ui/client/dist/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@copilotkitnext/shared/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js [app-ssr] (ecmascript)");
;
;
;
var ProxiedCopilotRuntimeAgent = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HttpAgent"] {
    runtimeUrl;
    transport;
    singleEndpointUrl;
    constructor(config){
        const normalizedRuntimeUrl = config.runtimeUrl ? config.runtimeUrl.replace(/\/$/, "") : void 0;
        const transport = config.transport ?? "rest";
        const runUrl = transport === "single" ? normalizedRuntimeUrl ?? config.runtimeUrl ?? "" : `${normalizedRuntimeUrl ?? config.runtimeUrl}/agent/${encodeURIComponent(config.agentId ?? "")}/run`;
        if (!runUrl) {
            throw new Error("ProxiedCopilotRuntimeAgent requires a runtimeUrl when transport is set to 'single'.");
        }
        super({
            ...config,
            url: runUrl
        });
        this.runtimeUrl = normalizedRuntimeUrl ?? config.runtimeUrl;
        this.transport = transport;
        if (this.transport === "single") {
            this.singleEndpointUrl = this.runtimeUrl;
        }
    }
    abortRun() {
        if (!this.agentId || !this.threadId) {
            return;
        }
        if (typeof fetch === "undefined") {
            return;
        }
        if (this.transport === "single") {
            if (!this.singleEndpointUrl) {
                return;
            }
            const headers = new Headers({
                ...this.headers,
                "Content-Type": "application/json"
            });
            void fetch(this.singleEndpointUrl, {
                method: "POST",
                headers,
                body: JSON.stringify({
                    method: "agent/stop",
                    params: {
                        agentId: this.agentId,
                        threadId: this.threadId
                    }
                })
            }).catch((error)=>{
                console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
            });
            return;
        }
        if (!this.runtimeUrl) {
            return;
        }
        const stopPath = `${this.runtimeUrl}/agent/${encodeURIComponent(this.agentId)}/stop/${encodeURIComponent(this.threadId)}`;
        const origin = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "http://localhost";
        const base = new URL(this.runtimeUrl, origin);
        const stopUrl = new URL(stopPath, base);
        void fetch(stopUrl.toString(), {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                ...this.headers
            }
        }).catch((error)=>{
            console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
        });
    }
    connect(input) {
        if (this.transport === "single") {
            if (!this.singleEndpointUrl) {
                throw new Error("Single endpoint transport requires a runtimeUrl");
            }
            const requestInit = this.createSingleRouteRequestInit(input, "agent/connect", {
                agentId: this.agentId
            });
            const httpEvents2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["runHttpRequest"])(this.singleEndpointUrl, requestInit);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transformHttpEventStream"])(httpEvents2);
        }
        const httpEvents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["runHttpRequest"])(`${this.runtimeUrl}/agent/${this.agentId}/connect`, this.requestInit(input));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transformHttpEventStream"])(httpEvents);
    }
    run(input) {
        if (this.transport === "single") {
            if (!this.singleEndpointUrl) {
                throw new Error("Single endpoint transport requires a runtimeUrl");
            }
            const requestInit = this.createSingleRouteRequestInit(input, "agent/run", {
                agentId: this.agentId
            });
            const httpEvents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["runHttpRequest"])(this.singleEndpointUrl, requestInit);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transformHttpEventStream"])(httpEvents);
        }
        return super.run(input);
    }
    clone() {
        const cloned = super.clone();
        cloned.runtimeUrl = this.runtimeUrl;
        cloned.transport = this.transport;
        cloned.singleEndpointUrl = this.singleEndpointUrl;
        return cloned;
    }
    createSingleRouteRequestInit(input, method, params) {
        if (!this.agentId) {
            throw new Error("ProxiedCopilotRuntimeAgent requires agentId to make runtime requests");
        }
        const baseInit = super.requestInit(input);
        const headers = new Headers(baseInit.headers ?? {});
        headers.set("Content-Type", "application/json");
        headers.set("Accept", headers.get("Accept") ?? "text/event-stream");
        let originalBody = void 0;
        if (typeof baseInit.body === "string") {
            try {
                originalBody = JSON.parse(baseInit.body);
            } catch (error) {
                console.warn("ProxiedCopilotRuntimeAgent: failed to parse request body for single route transport", error);
                originalBody = void 0;
            }
        }
        const envelope = {
            method
        };
        if (params && Object.keys(params).length > 0) {
            envelope.params = params;
        }
        if (originalBody !== void 0) {
            envelope.body = originalBody;
        }
        return {
            ...baseInit,
            headers,
            body: JSON.stringify(envelope)
        };
    }
};
// src/core/agent-registry.ts
var AgentRegistry = class {
    constructor(core){
        this.core = core;
    }
    _agents = {};
    localAgents = {};
    remoteAgents = {};
    _runtimeUrl;
    _runtimeVersion;
    _runtimeConnectionStatus = "disconnected" /* Disconnected */ ;
    _runtimeTransport = "rest";
    /**
   * Get all agents as a readonly record
   */ get agents() {
        return this._agents;
    }
    get runtimeUrl() {
        return this._runtimeUrl;
    }
    get runtimeVersion() {
        return this._runtimeVersion;
    }
    get runtimeConnectionStatus() {
        return this._runtimeConnectionStatus;
    }
    get runtimeTransport() {
        return this._runtimeTransport;
    }
    /**
   * Initialize agents from configuration
   */ initialize(agents) {
        this.localAgents = this.assignAgentIds(agents);
        this.applyHeadersToAgents(this.localAgents);
        this._agents = this.localAgents;
    }
    /**
   * Set the runtime URL and update connection
   */ setRuntimeUrl(runtimeUrl) {
        const normalizedRuntimeUrl = runtimeUrl ? runtimeUrl.replace(/\/$/, "") : void 0;
        if (this._runtimeUrl === normalizedRuntimeUrl) {
            return;
        }
        this._runtimeUrl = normalizedRuntimeUrl;
        void this.updateRuntimeConnection();
    }
    setRuntimeTransport(runtimeTransport) {
        if (this._runtimeTransport === runtimeTransport) {
            return;
        }
        this._runtimeTransport = runtimeTransport;
        void this.updateRuntimeConnection();
    }
    /**
   * Set all agents at once (for development use)
   */ setAgents__unsafe_dev_only(agents) {
        Object.entries(agents).forEach(([id, agent])=>{
            if (agent) {
                this.validateAndAssignAgentId(id, agent);
            }
        });
        this.localAgents = agents;
        this._agents = {
            ...this.localAgents,
            ...this.remoteAgents
        };
        this.applyHeadersToAgents(this._agents);
        void this.notifyAgentsChanged();
    }
    /**
   * Add a single agent (for development use)
   */ addAgent__unsafe_dev_only({ id, agent }) {
        this.validateAndAssignAgentId(id, agent);
        this.localAgents[id] = agent;
        this.applyHeadersToAgent(agent);
        this._agents = {
            ...this.localAgents,
            ...this.remoteAgents
        };
        void this.notifyAgentsChanged();
    }
    /**
   * Remove an agent by ID (for development use)
   */ removeAgent__unsafe_dev_only(id) {
        delete this.localAgents[id];
        this._agents = {
            ...this.localAgents,
            ...this.remoteAgents
        };
        void this.notifyAgentsChanged();
    }
    /**
   * Get an agent by ID
   */ getAgent(id) {
        if (id in this._agents) {
            return this._agents[id];
        }
        if (this.runtimeUrl !== void 0 && (this.runtimeConnectionStatus === "disconnected" /* Disconnected */  || this.runtimeConnectionStatus === "connecting" /* Connecting */ )) {
            return void 0;
        }
        console.warn(`Agent ${id} not found`);
        return void 0;
    }
    /**
   * Apply current headers to an agent
   */ applyHeadersToAgent(agent) {
        if (agent instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HttpAgent"]) {
            agent.headers = {
                ...this.core.headers
            };
        }
    }
    /**
   * Apply current headers to all agents
   */ applyHeadersToAgents(agents) {
        Object.values(agents).forEach((agent)=>{
            this.applyHeadersToAgent(agent);
        });
    }
    /**
   * Update runtime connection and fetch remote agents
   */ async updateRuntimeConnection() {
        if ("TURBOPACK compile-time truthy", 1) {
            return;
        }
        //TURBOPACK unreachable
        ;
    }
    async fetchRuntimeInfo() {
        if (!this.runtimeUrl) {
            throw new Error("Runtime URL is not set");
        }
        const baseHeaders = this.core.headers;
        const headers = {
            ...baseHeaders
        };
        if (this._runtimeTransport === "single") {
            if (!headers["Content-Type"]) {
                headers["Content-Type"] = "application/json";
            }
            const response2 = await fetch(this.runtimeUrl, {
                method: "POST",
                headers,
                body: JSON.stringify({
                    method: "info"
                })
            });
            if ("ok" in response2 && !response2.ok) {
                throw new Error(`Runtime info request failed with status ${response2.status}`);
            }
            return await response2.json();
        }
        const response = await fetch(`${this.runtimeUrl}/info`, {
            headers
        });
        if ("ok" in response && !response.ok) {
            throw new Error(`Runtime info request failed with status ${response.status}`);
        }
        return await response.json();
    }
    /**
   * Assign agent IDs to a record of agents
   */ assignAgentIds(agents) {
        Object.entries(agents).forEach(([id, agent])=>{
            if (agent) {
                this.validateAndAssignAgentId(id, agent);
            }
        });
        return agents;
    }
    /**
   * Validate and assign an agent ID
   */ validateAndAssignAgentId(registrationId, agent) {
        if (agent.agentId && agent.agentId !== registrationId) {
            throw new Error(`Agent registration mismatch: Agent with ID "${agent.agentId}" cannot be registered under key "${registrationId}". The agent ID must match the registration key or be undefined.`);
        }
        if (!agent.agentId) {
            agent.agentId = registrationId;
        }
    }
    /**
   * Notify subscribers of runtime status changes
   */ async notifyRuntimeStatusChanged(status) {
        await this.core.notifySubscribers((subscriber)=>subscriber.onRuntimeConnectionStatusChanged?.({
                copilotkit: this.core,
                status
            }), "Error in CopilotKitCore subscriber (onRuntimeConnectionStatusChanged):");
    }
    /**
   * Notify subscribers of agent changes
   */ async notifyAgentsChanged() {
        await this.core.notifySubscribers((subscriber)=>subscriber.onAgentsChanged?.({
                copilotkit: this.core,
                agents: this._agents
            }), "Subscriber onAgentsChanged error:");
    }
};
;
var ContextStore = class {
    constructor(core){
        this.core = core;
    }
    _context = {};
    /**
   * Get all context entries as a readonly record
   */ get context() {
        return this._context;
    }
    /**
   * Add a new context entry
   * @returns The ID of the created context entry
   */ addContext({ description, value }) {
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])();
        this._context[id] = {
            description,
            value
        };
        void this.notifySubscribers();
        return id;
    }
    /**
   * Remove a context entry by ID
   */ removeContext(id) {
        delete this._context[id];
        void this.notifySubscribers();
    }
    /**
   * Notify all subscribers of context changes
   */ async notifySubscribers() {
        await this.core.notifySubscribers((subscriber)=>subscriber.onContextChanged?.({
                copilotkit: this.core,
                context: this._context
            }), "Subscriber onContextChanged error:");
    }
};
;
var SuggestionEngine = class {
    constructor(core){
        this.core = core;
    }
    _suggestionsConfig = {};
    _suggestions = {};
    _runningSuggestions = {};
    /**
   * Initialize with suggestion configs
   */ initialize(suggestionsConfig) {
        for (const config of suggestionsConfig){
            this._suggestionsConfig[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])()] = config;
        }
    }
    /**
   * Add a suggestion configuration
   * @returns The ID of the created config
   */ addSuggestionsConfig(config) {
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])();
        this._suggestionsConfig[id] = config;
        void this.notifySuggestionsConfigChanged();
        return id;
    }
    /**
   * Remove a suggestion configuration by ID
   */ removeSuggestionsConfig(id) {
        delete this._suggestionsConfig[id];
        void this.notifySuggestionsConfigChanged();
    }
    /**
   * Reload suggestions for a specific agent
   * This triggers generation of new suggestions based on current configs
   */ reloadSuggestions(agentId) {
        this.clearSuggestions(agentId);
        const agent = this.core.getAgent(agentId);
        if (!agent) {
            return;
        }
        const messageCount = agent.messages?.length ?? 0;
        let hasAnySuggestions = false;
        for (const config of Object.values(this._suggestionsConfig)){
            if (config.consumerAgentId !== void 0 && config.consumerAgentId !== "*" && config.consumerAgentId !== agentId) {
                continue;
            }
            if (!this.shouldShowSuggestions(config, messageCount)) {
                continue;
            }
            const suggestionId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])();
            if (isDynamicSuggestionsConfig(config)) {
                if (!hasAnySuggestions) {
                    hasAnySuggestions = true;
                    void this.notifySuggestionsStartedLoading(agentId);
                }
                void this.generateSuggestions(suggestionId, config, agentId);
            } else if (isStaticSuggestionsConfig(config)) {
                this.addStaticSuggestions(suggestionId, config, agentId);
            }
        }
    }
    /**
   * Clear all suggestions for a specific agent
   */ clearSuggestions(agentId) {
        const runningAgents = this._runningSuggestions[agentId];
        if (runningAgents) {
            for (const agent of runningAgents){
                agent.abortRun();
            }
            delete this._runningSuggestions[agentId];
        }
        this._suggestions[agentId] = {};
        void this.notifySuggestionsChanged(agentId, []);
    }
    /**
   * Get current suggestions for an agent
   */ getSuggestions(agentId) {
        const suggestions = Object.values(this._suggestions[agentId] ?? {}).flat();
        const isLoading = (this._runningSuggestions[agentId]?.length ?? 0) > 0;
        return {
            suggestions,
            isLoading
        };
    }
    /**
   * Generate suggestions using a provider agent
   */ async generateSuggestions(suggestionId, config, consumerAgentId) {
        let agent = void 0;
        try {
            const suggestionsProviderAgent = this.core.getAgent(config.providerAgentId ?? "default");
            if (!suggestionsProviderAgent) {
                throw new Error(`Suggestions provider agent not found: ${config.providerAgentId}`);
            }
            const suggestionsConsumerAgent = this.core.getAgent(consumerAgentId);
            if (!suggestionsConsumerAgent) {
                throw new Error(`Suggestions consumer agent not found: ${consumerAgentId}`);
            }
            const clonedAgent = suggestionsProviderAgent.clone();
            agent = clonedAgent;
            agent.threadId = suggestionId;
            agent.messages = JSON.parse(JSON.stringify(suggestionsConsumerAgent.messages));
            agent.state = JSON.parse(JSON.stringify(suggestionsConsumerAgent.state));
            this._suggestions[consumerAgentId] = {
                ...this._suggestions[consumerAgentId] ?? {},
                [suggestionId]: []
            };
            this._runningSuggestions[consumerAgentId] = [
                ...this._runningSuggestions[consumerAgentId] ?? [],
                agent
            ];
            agent.addMessage({
                id: suggestionId,
                role: "user",
                content: [
                    `Suggest what the user could say next. Provide clear, highly relevant suggestions by calling the \`copilotkitSuggest\` tool.`,
                    `Provide at least ${config.minSuggestions ?? 1} and at most ${config.maxSuggestions ?? 3} suggestions.`,
                    `The user has the following tools available: ${JSON.stringify(this.core.buildFrontendTools(consumerAgentId))}.`,
                    ` ${config.instructions}`
                ].join("\n")
            });
            await agent.runAgent({
                context: Object.values(this.core.context),
                forwardedProps: {
                    ...this.core.properties,
                    toolChoice: {
                        type: "function",
                        function: {
                            name: "copilotkitSuggest"
                        }
                    }
                },
                tools: [
                    SUGGEST_TOOL
                ]
            }, {
                onMessagesChanged: ({ messages })=>{
                    this.extractSuggestions(messages, suggestionId, consumerAgentId, true);
                }
            });
        } catch (error) {
            console.warn("Error generating suggestions:", error);
        } finally{
            this.finalizeSuggestions(suggestionId, consumerAgentId);
            const runningAgents = this._runningSuggestions[consumerAgentId];
            if (agent && runningAgents) {
                const filteredAgents = runningAgents.filter((a)=>a !== agent);
                this._runningSuggestions[consumerAgentId] = filteredAgents;
                if (filteredAgents.length === 0) {
                    delete this._runningSuggestions[consumerAgentId];
                    await this.notifySuggestionsFinishedLoading(consumerAgentId);
                }
            }
        }
    }
    /**
   * Finalize suggestions by marking them as no longer loading
   */ finalizeSuggestions(suggestionId, consumerAgentId) {
        const agentSuggestions = this._suggestions[consumerAgentId];
        const currentSuggestions = agentSuggestions?.[suggestionId];
        if (agentSuggestions && currentSuggestions && currentSuggestions.length > 0) {
            const finalizedSuggestions = currentSuggestions.filter((suggestion)=>suggestion.title !== "" || suggestion.message !== "").map((suggestion)=>({
                    ...suggestion,
                    isLoading: false
                }));
            if (finalizedSuggestions.length > 0) {
                agentSuggestions[suggestionId] = finalizedSuggestions;
            } else {
                delete agentSuggestions[suggestionId];
            }
            const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
            void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "finalized");
        }
    }
    /**
   * Extract suggestions from messages (called during streaming)
   */ extractSuggestions(messages, suggestionId, consumerAgentId, isRunning) {
        const idx = messages.findIndex((message)=>message.id === suggestionId);
        if (idx == -1) {
            return;
        }
        const suggestions = [];
        const newMessages = messages.slice(idx + 1);
        for (const message of newMessages){
            if (message.role === "assistant" && message.toolCalls) {
                for (const toolCall of message.toolCalls){
                    if (toolCall.function.name === "copilotkitSuggest") {
                        const fullArgs = Array.isArray(toolCall.function.arguments) ? toolCall.function.arguments.join("") : toolCall.function.arguments;
                        const parsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["partialJSONParse"])(fullArgs);
                        if (parsed && typeof parsed === "object" && "suggestions" in parsed) {
                            const parsedSuggestions = parsed.suggestions;
                            if (Array.isArray(parsedSuggestions)) {
                                for (const item of parsedSuggestions){
                                    if (item && typeof item === "object" && "title" in item) {
                                        suggestions.push({
                                            title: item.title ?? "",
                                            message: item.message ?? "",
                                            isLoading: false
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (isRunning && suggestions.length > 0) {
            suggestions[suggestions.length - 1].isLoading = true;
        }
        const agentSuggestions = this._suggestions[consumerAgentId];
        if (agentSuggestions) {
            agentSuggestions[suggestionId] = suggestions;
            const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
            void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "suggestions changed");
        }
    }
    /**
   * Notify subscribers of suggestions config changes
   */ async notifySuggestionsConfigChanged() {
        await this.core.notifySubscribers((subscriber)=>subscriber.onSuggestionsConfigChanged?.({
                copilotkit: this.core,
                suggestionsConfig: this._suggestionsConfig
            }), "Subscriber onSuggestionsConfigChanged error:");
    }
    /**
   * Notify subscribers of suggestions changes
   */ async notifySuggestionsChanged(agentId, suggestions, context = "") {
        await this.core.notifySubscribers((subscriber)=>subscriber.onSuggestionsChanged?.({
                copilotkit: this.core,
                agentId,
                suggestions
            }), `Subscriber onSuggestionsChanged error: ${context}`);
    }
    /**
   * Notify subscribers that suggestions started loading
   */ async notifySuggestionsStartedLoading(agentId) {
        await this.core.notifySubscribers((subscriber)=>subscriber.onSuggestionsStartedLoading?.({
                copilotkit: this.core,
                agentId
            }), "Subscriber onSuggestionsStartedLoading error:");
    }
    /**
   * Notify subscribers that suggestions finished loading
   */ async notifySuggestionsFinishedLoading(agentId) {
        await this.core.notifySubscribers((subscriber)=>subscriber.onSuggestionsFinishedLoading?.({
                copilotkit: this.core,
                agentId
            }), "Subscriber onSuggestionsFinishedLoading error:");
    }
    /**
   * Check if suggestions should be shown based on availability and message count
   */ shouldShowSuggestions(config, messageCount) {
        const availability = config.available;
        if (!availability) {
            if (isDynamicSuggestionsConfig(config)) {
                return messageCount > 0;
            } else {
                return messageCount === 0;
            }
        }
        switch(availability){
            case "disabled":
                return false;
            case "before-first-message":
                return messageCount === 0;
            case "after-first-message":
                return messageCount > 0;
            case "always":
                return true;
            default:
                return false;
        }
    }
    /**
   * Add static suggestions directly without AI generation
   */ addStaticSuggestions(suggestionId, config, consumerAgentId) {
        const suggestions = config.suggestions.map((s)=>({
                ...s,
                isLoading: false
            }));
        this._suggestions[consumerAgentId] = {
            ...this._suggestions[consumerAgentId] ?? {},
            [suggestionId]: suggestions
        };
        const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
        void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "static suggestions added");
    }
};
function isDynamicSuggestionsConfig(config) {
    return "instructions" in config;
}
function isStaticSuggestionsConfig(config) {
    return "suggestions" in config;
}
var SUGGEST_TOOL = {
    name: "copilotkitSuggest",
    description: "Suggest what the user could say next",
    parameters: {
        type: "object",
        properties: {
            suggestions: {
                type: "array",
                description: "List of suggestions shown to the user as buttons.",
                items: {
                    type: "object",
                    properties: {
                        title: {
                            type: "string",
                            description: "The title of the suggestion. This is shown as a button and should be short."
                        },
                        message: {
                            type: "string",
                            description: "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI."
                        }
                    },
                    required: [
                        "title",
                        "message"
                    ]
                }
            }
        },
        required: [
            "suggestions"
        ]
    }
};
;
;
;
var RunHandler = class {
    constructor(core){
        this.core = core;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _tools = [];
    /**
   * Get all tools as a readonly array
   */ get tools() {
        return this._tools;
    }
    /**
   * Initialize with tools
   */ initialize(tools) {
        this._tools = tools;
    }
    /**
   * Add a tool to the registry
   */ addTool(tool) {
        const existingToolIndex = this._tools.findIndex((t)=>t.name === tool.name && t.agentId === tool.agentId);
        if (existingToolIndex !== -1) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logger"].warn(`Tool already exists: '${tool.name}' for agent '${tool.agentId || "global"}', skipping.`);
            return;
        }
        this._tools.push(tool);
    }
    /**
   * Remove a tool by name and optionally by agentId
   */ removeTool(id, agentId) {
        this._tools = this._tools.filter((tool)=>{
            if (agentId !== void 0) {
                return !(tool.name === id && tool.agentId === agentId);
            }
            return !(tool.name === id && !tool.agentId);
        });
    }
    /**
   * Get a tool by name and optionally by agentId.
   * If agentId is provided, it will first look for an agent-specific tool,
   * then fall back to a global tool with the same name.
   */ getTool(params) {
        const { toolName, agentId } = params;
        if (agentId) {
            const agentTool = this._tools.find((tool)=>tool.name === toolName && tool.agentId === agentId);
            if (agentTool) {
                return agentTool;
            }
        }
        return this._tools.find((tool)=>tool.name === toolName && !tool.agentId);
    }
    /**
   * Set all tools at once. Replaces existing tools.
   */ setTools(tools) {
        this._tools = [
            ...tools
        ];
    }
    /**
   * Connect an agent (establish initial connection)
   */ async connectAgent({ agent }) {
        try {
            await agent.detachActiveRun();
            agent.setMessages([]);
            agent.setState({});
            if (agent instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HttpAgent"]) {
                agent.headers = {
                    ...this.core.headers
                };
            }
            const runAgentResult = await agent.connectAgent({
                forwardedProps: this.core.properties,
                tools: this.buildFrontendTools(agent.agentId)
            }, this.createAgentErrorSubscriber(agent));
            return this.processAgentResult({
                runAgentResult,
                agent
            });
        } catch (error) {
            const connectError = error instanceof Error ? error : new Error(String(error));
            const context = {};
            if (agent.agentId) {
                context.agentId = agent.agentId;
            }
            await this.core.emitError({
                error: connectError,
                code: "agent_connect_failed" /* AGENT_CONNECT_FAILED */ ,
                context
            });
            throw error;
        }
    }
    /**
   * Run an agent
   */ async runAgent({ agent }) {
        if (agent.agentId) {
            void this.core.suggestionEngine.clearSuggestions(agent.agentId);
        }
        if (agent instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ag$2d$ui$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HttpAgent"]) {
            agent.headers = {
                ...this.core.headers
            };
        }
        try {
            const runAgentResult = await agent.runAgent({
                forwardedProps: this.core.properties,
                tools: this.buildFrontendTools(agent.agentId),
                context: Object.values(this.core.context)
            }, this.createAgentErrorSubscriber(agent));
            return this.processAgentResult({
                runAgentResult,
                agent
            });
        } catch (error) {
            const runError = error instanceof Error ? error : new Error(String(error));
            const context = {};
            if (agent.agentId) {
                context.agentId = agent.agentId;
            }
            await this.core.emitError({
                error: runError,
                code: "agent_run_failed" /* AGENT_RUN_FAILED */ ,
                context
            });
            throw error;
        }
    }
    /**
   * Process agent result and execute tools
   */ async processAgentResult({ runAgentResult, agent }) {
        const { newMessages } = runAgentResult;
        const agentId = agent.agentId;
        let needsFollowUp = false;
        for (const message of newMessages){
            if (message.role === "assistant") {
                for (const toolCall of message.toolCalls || []){
                    if (newMessages.findIndex((m)=>m.role === "tool" && m.toolCallId === toolCall.id) === -1) {
                        const tool = this.getTool({
                            toolName: toolCall.function.name,
                            agentId: agent.agentId
                        });
                        if (tool) {
                            const followUp = await this.executeSpecificTool(tool, toolCall, message, agent, agentId);
                            if (followUp) {
                                needsFollowUp = true;
                            }
                        } else {
                            const wildcardTool = this.getTool({
                                toolName: "*",
                                agentId: agent.agentId
                            });
                            if (wildcardTool) {
                                const followUp = await this.executeWildcardTool(wildcardTool, toolCall, message, agent, agentId);
                                if (followUp) {
                                    needsFollowUp = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (needsFollowUp) {
            return await this.runAgent({
                agent
            });
        }
        void this.core.suggestionEngine.reloadSuggestions(agentId);
        return runAgentResult;
    }
    /**
   * Execute a specific tool
   */ async executeSpecificTool(tool, toolCall, message, agent, agentId) {
        if (tool?.agentId && tool.agentId !== agent.agentId) {
            return false;
        }
        let toolCallResult = "";
        let errorMessage;
        let isArgumentError = false;
        if (tool?.handler) {
            let parsedArgs;
            try {
                parsedArgs = JSON.parse(toolCall.function.arguments);
            } catch (error) {
                const parseError = error instanceof Error ? error : new Error(String(error));
                errorMessage = parseError.message;
                isArgumentError = true;
                await this.core.emitError({
                    error: parseError,
                    code: "tool_argument_parse_failed" /* TOOL_ARGUMENT_PARSE_FAILED */ ,
                    context: {
                        agentId,
                        toolCallId: toolCall.id,
                        toolName: toolCall.function.name,
                        rawArguments: toolCall.function.arguments,
                        toolType: "specific",
                        messageId: message.id
                    }
                });
            }
            await this.core.notifySubscribers((subscriber)=>subscriber.onToolExecutionStart?.({
                    copilotkit: this.core,
                    toolCallId: toolCall.id,
                    agentId,
                    toolName: toolCall.function.name,
                    args: parsedArgs
                }), "Subscriber onToolExecutionStart error:");
            if (!errorMessage) {
                try {
                    const result = await tool.handler(parsedArgs, toolCall);
                    if (result === void 0 || result === null) {
                        toolCallResult = "";
                    } else if (typeof result === "string") {
                        toolCallResult = result;
                    } else {
                        toolCallResult = JSON.stringify(result);
                    }
                } catch (error) {
                    const handlerError = error instanceof Error ? error : new Error(String(error));
                    errorMessage = handlerError.message;
                    await this.core.emitError({
                        error: handlerError,
                        code: "tool_handler_failed" /* TOOL_HANDLER_FAILED */ ,
                        context: {
                            agentId,
                            toolCallId: toolCall.id,
                            toolName: toolCall.function.name,
                            parsedArgs,
                            toolType: "specific",
                            messageId: message.id
                        }
                    });
                }
            }
            if (errorMessage) {
                toolCallResult = `Error: ${errorMessage}`;
            }
            await this.core.notifySubscribers((subscriber)=>subscriber.onToolExecutionEnd?.({
                    copilotkit: this.core,
                    toolCallId: toolCall.id,
                    agentId,
                    toolName: toolCall.function.name,
                    result: errorMessage ? "" : toolCallResult,
                    error: errorMessage
                }), "Subscriber onToolExecutionEnd error:");
            if (isArgumentError) {
                throw new Error(errorMessage ?? "Tool execution failed");
            }
        }
        if (!errorMessage || !isArgumentError) {
            const messageIndex = agent.messages.findIndex((m)=>m.id === message.id);
            const toolMessage = {
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])(),
                role: "tool",
                toolCallId: toolCall.id,
                content: toolCallResult
            };
            agent.messages.splice(messageIndex + 1, 0, toolMessage);
            if (!errorMessage && tool?.followUp !== false) {
                return true;
            }
        }
        return false;
    }
    /**
   * Execute a wildcard tool
   */ async executeWildcardTool(wildcardTool, toolCall, message, agent, agentId) {
        if (wildcardTool?.agentId && wildcardTool.agentId !== agent.agentId) {
            return false;
        }
        let toolCallResult = "";
        let errorMessage;
        let isArgumentError = false;
        if (wildcardTool?.handler) {
            let parsedArgs;
            try {
                parsedArgs = JSON.parse(toolCall.function.arguments);
            } catch (error) {
                const parseError = error instanceof Error ? error : new Error(String(error));
                errorMessage = parseError.message;
                isArgumentError = true;
                await this.core.emitError({
                    error: parseError,
                    code: "tool_argument_parse_failed" /* TOOL_ARGUMENT_PARSE_FAILED */ ,
                    context: {
                        agentId,
                        toolCallId: toolCall.id,
                        toolName: toolCall.function.name,
                        rawArguments: toolCall.function.arguments,
                        toolType: "wildcard",
                        messageId: message.id
                    }
                });
            }
            const wildcardArgs = {
                toolName: toolCall.function.name,
                args: parsedArgs
            };
            await this.core.notifySubscribers((subscriber)=>subscriber.onToolExecutionStart?.({
                    copilotkit: this.core,
                    toolCallId: toolCall.id,
                    agentId,
                    toolName: toolCall.function.name,
                    args: wildcardArgs
                }), "Subscriber onToolExecutionStart error:");
            if (!errorMessage) {
                try {
                    const result = await wildcardTool.handler(wildcardArgs, toolCall);
                    if (result === void 0 || result === null) {
                        toolCallResult = "";
                    } else if (typeof result === "string") {
                        toolCallResult = result;
                    } else {
                        toolCallResult = JSON.stringify(result);
                    }
                } catch (error) {
                    const handlerError = error instanceof Error ? error : new Error(String(error));
                    errorMessage = handlerError.message;
                    await this.core.emitError({
                        error: handlerError,
                        code: "tool_handler_failed" /* TOOL_HANDLER_FAILED */ ,
                        context: {
                            agentId,
                            toolCallId: toolCall.id,
                            toolName: toolCall.function.name,
                            parsedArgs: wildcardArgs,
                            toolType: "wildcard",
                            messageId: message.id
                        }
                    });
                }
            }
            if (errorMessage) {
                toolCallResult = `Error: ${errorMessage}`;
            }
            await this.core.notifySubscribers((subscriber)=>subscriber.onToolExecutionEnd?.({
                    copilotkit: this.core,
                    toolCallId: toolCall.id,
                    agentId,
                    toolName: toolCall.function.name,
                    result: errorMessage ? "" : toolCallResult,
                    error: errorMessage
                }), "Subscriber onToolExecutionEnd error:");
            if (isArgumentError) {
                throw new Error(errorMessage ?? "Tool execution failed");
            }
        }
        if (!errorMessage || !isArgumentError) {
            const messageIndex = agent.messages.findIndex((m)=>m.id === message.id);
            const toolMessage = {
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$copilotkitnext$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomUUID"])(),
                role: "tool",
                toolCallId: toolCall.id,
                content: toolCallResult
            };
            agent.messages.splice(messageIndex + 1, 0, toolMessage);
            if (!errorMessage && wildcardTool?.followUp !== false) {
                return true;
            }
        }
        return false;
    }
    /**
   * Build frontend tools for an agent
   */ buildFrontendTools(agentId) {
        return this._tools.filter((tool)=>!tool.agentId || tool.agentId === agentId).map((tool)=>({
                name: tool.name,
                description: tool.description ?? "",
                parameters: createToolSchema(tool)
            }));
    }
    /**
   * Create an agent error subscriber
   */ createAgentErrorSubscriber(agent) {
        const emitAgentError = async (error, code, extraContext = {})=>{
            const context = {
                ...extraContext
            };
            if (agent.agentId) {
                context.agentId = agent.agentId;
            }
            await this.core.emitError({
                error,
                code,
                context
            });
        };
        return {
            onRunFailed: async ({ error })=>{
                await emitAgentError(error, "agent_run_failed_event" /* AGENT_RUN_FAILED_EVENT */ , {
                    source: "onRunFailed"
                });
            },
            onRunErrorEvent: async ({ event })=>{
                const eventError = event?.rawEvent instanceof Error ? event.rawEvent : event?.rawEvent?.error instanceof Error ? event.rawEvent.error : void 0;
                const errorMessage = typeof event?.rawEvent?.error === "string" ? event.rawEvent.error : event?.message ?? "Agent run error";
                const rawError = eventError ?? new Error(errorMessage);
                if (event?.code && !rawError.code) {
                    rawError.code = event.code;
                }
                await emitAgentError(rawError, "agent_run_error_event" /* AGENT_RUN_ERROR_EVENT */ , {
                    source: "onRunErrorEvent",
                    event,
                    runtimeErrorCode: event?.code
                });
            }
        };
    }
};
var EMPTY_TOOL_SCHEMA = {
    type: "object",
    properties: {}
};
function createToolSchema(tool) {
    if (!tool.parameters) {
        return {
            ...EMPTY_TOOL_SCHEMA
        };
    }
    const rawSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2d$to$2d$json$2d$schema$2f$dist$2f$esm$2f$zodToJsonSchema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["zodToJsonSchema"])(tool.parameters, {
        $refStrategy: "none"
    });
    if (!rawSchema || typeof rawSchema !== "object") {
        return {
            ...EMPTY_TOOL_SCHEMA
        };
    }
    const { $schema, ...schema } = rawSchema;
    if (typeof schema.type !== "string") {
        schema.type = "object";
    }
    if (typeof schema.properties !== "object" || schema.properties === null) {
        schema.properties = {};
    }
    stripAdditionalProperties(schema);
    return schema;
}
function stripAdditionalProperties(schema) {
    if (!schema || typeof schema !== "object") {
        return;
    }
    if (Array.isArray(schema)) {
        schema.forEach(stripAdditionalProperties);
        return;
    }
    const record = schema;
    if (record.additionalProperties !== void 0) {
        delete record.additionalProperties;
    }
    for (const value of Object.values(record)){
        stripAdditionalProperties(value);
    }
}
// src/core/state-manager.ts
var StateManager = class {
    constructor(core){
        this.core = core;
    }
    // State tracking: agentId -> threadId -> runId -> state
    stateByRun = /* @__PURE__ */ new Map();
    // Message tracking: agentId -> threadId -> messageId -> runId
    messageToRun = /* @__PURE__ */ new Map();
    // Agent subscriptions for cleanup
    agentSubscriptions = /* @__PURE__ */ new Map();
    /**
   * Initialize state tracking for an agent
   */ initialize() {}
    /**
   * Subscribe to an agent's events to track state and messages
   */ subscribeToAgent(agent) {
        if (!agent.agentId) {
            return;
        }
        const agentId = agent.agentId;
        this.unsubscribeFromAgent(agentId);
        const { unsubscribe } = agent.subscribe({
            onRunStartedEvent: ({ event, state })=>{
                this.handleRunStarted(agent, event, state);
            },
            onRunFinishedEvent: ({ event, state })=>{
                this.handleRunFinished(agent, event, state);
            },
            onStateSnapshotEvent: ({ event, input, state })=>{
                this.handleStateSnapshot(agent, event, input, state);
            },
            onStateDeltaEvent: ({ event, input, state })=>{
                this.handleStateDelta(agent, event, input, state);
            },
            onMessagesSnapshotEvent: ({ event, input, messages })=>{
                this.handleMessagesSnapshot(agent, event, input, messages);
            },
            onNewMessage: ({ message, input })=>{
                this.handleNewMessage(agent, message, input);
            }
        });
        this.agentSubscriptions.set(agentId, unsubscribe);
    }
    /**
   * Unsubscribe from an agent's events
   */ unsubscribeFromAgent(agentId) {
        const unsubscribe = this.agentSubscriptions.get(agentId);
        if (unsubscribe) {
            unsubscribe();
            this.agentSubscriptions.delete(agentId);
        }
    }
    /**
   * Get state for a specific run
   * Returns a deep copy to prevent external mutations
   */ getStateByRun(agentId, threadId, runId) {
        const state = this.stateByRun.get(agentId)?.get(threadId)?.get(runId);
        if (!state) return void 0;
        return JSON.parse(JSON.stringify(state));
    }
    /**
   * Get runId associated with a message
   */ getRunIdForMessage(agentId, threadId, messageId) {
        return this.messageToRun.get(agentId)?.get(threadId)?.get(messageId);
    }
    /**
   * Get all states for an agent's thread
   */ getStatesForThread(agentId, threadId) {
        return this.stateByRun.get(agentId)?.get(threadId) ?? /* @__PURE__ */ new Map();
    }
    /**
   * Get all run IDs for an agent's thread
   */ getRunIdsForThread(agentId, threadId) {
        const threadStates = this.stateByRun.get(agentId)?.get(threadId);
        return threadStates ? Array.from(threadStates.keys()) : [];
    }
    /**
   * Handle run started event
   */ handleRunStarted(agent, event, state) {
        if (!agent.agentId) return;
        const { threadId, runId } = event;
        this.saveState(agent.agentId, threadId, runId, state);
    }
    /**
   * Handle run finished event
   */ handleRunFinished(agent, event, state) {
        if (!agent.agentId) return;
        const { threadId, runId } = event;
        this.saveState(agent.agentId, threadId, runId, state);
    }
    /**
   * Handle state snapshot event
   */ handleStateSnapshot(agent, event, input, state) {
        if (!agent.agentId) return;
        const { threadId, runId } = input;
        const mergedState = {
            ...state,
            ...event.snapshot
        };
        this.saveState(agent.agentId, threadId, runId, mergedState);
    }
    /**
   * Handle state delta event
   */ handleStateDelta(agent, event, input, state) {
        if (!agent.agentId) return;
        const { threadId, runId } = input;
        this.saveState(agent.agentId, threadId, runId, state);
    }
    /**
   * Handle messages snapshot event
   */ handleMessagesSnapshot(agent, event, input, messages) {
        if (!agent.agentId) return;
        const { threadId, runId } = input;
        for (const message of event.messages){
            this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
        }
    }
    /**
   * Handle new message event
   */ handleNewMessage(agent, message, input) {
        if (!agent.agentId || !input) return;
        const { threadId, runId } = input;
        this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
    }
    /**
   * Save state for a specific run
   */ saveState(agentId, threadId, runId, state) {
        if (!this.stateByRun.has(agentId)) {
            this.stateByRun.set(agentId, /* @__PURE__ */ new Map());
        }
        const agentStates = this.stateByRun.get(agentId);
        if (!agentStates.has(threadId)) {
            agentStates.set(threadId, /* @__PURE__ */ new Map());
        }
        const threadStates = agentStates.get(threadId);
        threadStates.set(runId, JSON.parse(JSON.stringify(state)));
    }
    /**
   * Associate a message with a run
   */ associateMessageWithRun(agentId, threadId, messageId, runId) {
        if (!this.messageToRun.has(agentId)) {
            this.messageToRun.set(agentId, /* @__PURE__ */ new Map());
        }
        const agentMessages = this.messageToRun.get(agentId);
        if (!agentMessages.has(threadId)) {
            agentMessages.set(threadId, /* @__PURE__ */ new Map());
        }
        const threadMessages = agentMessages.get(threadId);
        threadMessages.set(messageId, runId);
    }
    /**
   * Clear all state for an agent
   */ clearAgentState(agentId) {
        this.stateByRun.delete(agentId);
        this.messageToRun.delete(agentId);
    }
    /**
   * Clear all state for a thread
   */ clearThreadState(agentId, threadId) {
        this.stateByRun.get(agentId)?.delete(threadId);
        this.messageToRun.get(agentId)?.delete(threadId);
    }
};
// src/core/core.ts
var CopilotKitCoreErrorCode = /* @__PURE__ */ ((CopilotKitCoreErrorCode2)=>{
    CopilotKitCoreErrorCode2["RUNTIME_INFO_FETCH_FAILED"] = "runtime_info_fetch_failed";
    CopilotKitCoreErrorCode2["AGENT_CONNECT_FAILED"] = "agent_connect_failed";
    CopilotKitCoreErrorCode2["AGENT_RUN_FAILED"] = "agent_run_failed";
    CopilotKitCoreErrorCode2["AGENT_RUN_FAILED_EVENT"] = "agent_run_failed_event";
    CopilotKitCoreErrorCode2["AGENT_RUN_ERROR_EVENT"] = "agent_run_error_event";
    CopilotKitCoreErrorCode2["TOOL_ARGUMENT_PARSE_FAILED"] = "tool_argument_parse_failed";
    CopilotKitCoreErrorCode2["TOOL_HANDLER_FAILED"] = "tool_handler_failed";
    return CopilotKitCoreErrorCode2;
})(CopilotKitCoreErrorCode || {});
var CopilotKitCoreRuntimeConnectionStatus = /* @__PURE__ */ ((CopilotKitCoreRuntimeConnectionStatus2)=>{
    CopilotKitCoreRuntimeConnectionStatus2["Disconnected"] = "disconnected";
    CopilotKitCoreRuntimeConnectionStatus2["Connected"] = "connected";
    CopilotKitCoreRuntimeConnectionStatus2["Connecting"] = "connecting";
    CopilotKitCoreRuntimeConnectionStatus2["Error"] = "error";
    return CopilotKitCoreRuntimeConnectionStatus2;
})(CopilotKitCoreRuntimeConnectionStatus || {});
var CopilotKitCore = class {
    _headers;
    _properties;
    subscribers = /* @__PURE__ */ new Set();
    // Delegate classes
    agentRegistry;
    contextStore;
    suggestionEngine;
    runHandler;
    stateManager;
    constructor({ runtimeUrl, runtimeTransport = "rest", headers = {}, properties = {}, agents__unsafe_dev_only = {}, tools = [], suggestionsConfig = [] }){
        this._headers = headers;
        this._properties = properties;
        this.agentRegistry = new AgentRegistry(this);
        this.contextStore = new ContextStore(this);
        this.suggestionEngine = new SuggestionEngine(this);
        this.runHandler = new RunHandler(this);
        this.stateManager = new StateManager(this);
        this.agentRegistry.initialize(agents__unsafe_dev_only);
        this.runHandler.initialize(tools);
        this.suggestionEngine.initialize(suggestionsConfig);
        this.stateManager.initialize();
        this.agentRegistry.setRuntimeTransport(runtimeTransport);
        this.agentRegistry.setRuntimeUrl(runtimeUrl);
        this.subscribe({
            onAgentsChanged: ({ agents })=>{
                Object.values(agents).forEach((agent)=>{
                    if (agent.agentId) {
                        this.stateManager.subscribeToAgent(agent);
                    }
                });
            }
        });
    }
    /**
   * Internal method used by delegate classes and subclasses to notify subscribers
   */ async notifySubscribers(handler, errorMessage) {
        await Promise.all(Array.from(this.subscribers).map(async (subscriber)=>{
            try {
                await handler(subscriber);
            } catch (error) {
                console.error(errorMessage, error);
            }
        }));
    }
    /**
   * Internal method used by delegate classes to emit errors
   */ async emitError({ error, code, context = {} }) {
        await this.notifySubscribers((subscriber)=>subscriber.onError?.({
                copilotkit: this,
                error,
                code,
                context
            }), "Subscriber onError error:");
    }
    /**
   * Snapshot accessors
   */ get context() {
        return this.contextStore.context;
    }
    get agents() {
        return this.agentRegistry.agents;
    }
    get tools() {
        return this.runHandler.tools;
    }
    get runtimeUrl() {
        return this.agentRegistry.runtimeUrl;
    }
    setRuntimeUrl(runtimeUrl) {
        this.agentRegistry.setRuntimeUrl(runtimeUrl);
    }
    get runtimeTransport() {
        return this.agentRegistry.runtimeTransport;
    }
    setRuntimeTransport(runtimeTransport) {
        this.agentRegistry.setRuntimeTransport(runtimeTransport);
    }
    get runtimeVersion() {
        return this.agentRegistry.runtimeVersion;
    }
    get headers() {
        return this._headers;
    }
    get properties() {
        return this._properties;
    }
    get runtimeConnectionStatus() {
        return this.agentRegistry.runtimeConnectionStatus;
    }
    /**
   * Configuration updates
   */ setHeaders(headers) {
        this._headers = headers;
        this.agentRegistry.applyHeadersToAgents(this.agentRegistry.agents);
        void this.notifySubscribers((subscriber)=>subscriber.onHeadersChanged?.({
                copilotkit: this,
                headers: this.headers
            }), "Subscriber onHeadersChanged error:");
    }
    setProperties(properties) {
        this._properties = properties;
        void this.notifySubscribers((subscriber)=>subscriber.onPropertiesChanged?.({
                copilotkit: this,
                properties: this.properties
            }), "Subscriber onPropertiesChanged error:");
    }
    /**
   * Agent management (delegated to AgentRegistry)
   */ setAgents__unsafe_dev_only(agents) {
        this.agentRegistry.setAgents__unsafe_dev_only(agents);
    }
    addAgent__unsafe_dev_only(params) {
        this.agentRegistry.addAgent__unsafe_dev_only(params);
    }
    removeAgent__unsafe_dev_only(id) {
        this.agentRegistry.removeAgent__unsafe_dev_only(id);
    }
    getAgent(id) {
        return this.agentRegistry.getAgent(id);
    }
    /**
   * Context management (delegated to ContextStore)
   */ addContext(context) {
        return this.contextStore.addContext(context);
    }
    removeContext(id) {
        this.contextStore.removeContext(id);
    }
    /**
   * Suggestions management (delegated to SuggestionEngine)
   */ addSuggestionsConfig(config) {
        return this.suggestionEngine.addSuggestionsConfig(config);
    }
    removeSuggestionsConfig(id) {
        this.suggestionEngine.removeSuggestionsConfig(id);
    }
    reloadSuggestions(agentId) {
        this.suggestionEngine.reloadSuggestions(agentId);
    }
    clearSuggestions(agentId) {
        this.suggestionEngine.clearSuggestions(agentId);
    }
    getSuggestions(agentId) {
        return this.suggestionEngine.getSuggestions(agentId);
    }
    /**
   * Tool management (delegated to RunHandler)
   */ addTool(tool) {
        this.runHandler.addTool(tool);
    }
    removeTool(id, agentId) {
        this.runHandler.removeTool(id, agentId);
    }
    getTool(params) {
        return this.runHandler.getTool(params);
    }
    setTools(tools) {
        this.runHandler.setTools(tools);
    }
    /**
   * Subscription lifecycle
   */ subscribe(subscriber) {
        this.subscribers.add(subscriber);
        return {
            unsubscribe: ()=>{
                this.subscribers.delete(subscriber);
            }
        };
    }
    /**
   * Agent connectivity (delegated to RunHandler)
   */ async connectAgent(params) {
        return this.runHandler.connectAgent(params);
    }
    stopAgent(params) {
        params.agent.abortRun();
    }
    async runAgent(params) {
        return this.runHandler.runAgent(params);
    }
    /**
   * State management (delegated to StateManager)
   */ getStateByRun(agentId, threadId, runId) {
        return this.stateManager.getStateByRun(agentId, threadId, runId);
    }
    getRunIdForMessage(agentId, threadId, messageId) {
        return this.stateManager.getRunIdForMessage(agentId, threadId, messageId);
    }
    getRunIdsForThread(agentId, threadId) {
        return this.stateManager.getRunIdsForThread(agentId, threadId);
    }
    /**
   * Internal method used by RunHandler to build frontend tools
   */ buildFrontendTools(agentId) {
        return this.runHandler.buildFrontendTools(agentId);
    }
};
// src/types.ts
var ToolCallStatus = /* @__PURE__ */ ((ToolCallStatus2)=>{
    ToolCallStatus2["InProgress"] = "inProgress";
    ToolCallStatus2["Executing"] = "executing";
    ToolCallStatus2["Complete"] = "complete";
    return ToolCallStatus2;
})(ToolCallStatus || {});
// src/utils/markdown.ts
function completePartialMarkdown(input) {
    let s = input;
    const fenceMatches = Array.from(s.matchAll(/^(\s*)(`{3,}|~{3,})/gm));
    if (fenceMatches.length % 2 === 1) {
        const [, indent, fence] = fenceMatches[0];
        s += `
${indent}${fence}`;
    }
    const incompleteLinkMatch = s.match(/\[([^\]]*)\]\(([^)]*)$/);
    if (incompleteLinkMatch) {
        s += ")";
    }
    const openElements = [];
    const chars = Array.from(s);
    const codeBlockRanges = [];
    const inlineCodeRanges = [];
    let tempCodeFenceCount = 0;
    let currentCodeBlockStart = -1;
    for(let i = 0; i < chars.length; i++){
        if (i === 0 || chars[i - 1] === "\n") {
            const lineMatch = s.substring(i).match(/^(\s*)(`{3,}|~{3,})/);
            if (lineMatch) {
                tempCodeFenceCount++;
                if (tempCodeFenceCount % 2 === 1) {
                    currentCodeBlockStart = i;
                } else if (currentCodeBlockStart !== -1) {
                    codeBlockRanges.push({
                        start: currentCodeBlockStart,
                        end: i + lineMatch[0].length
                    });
                    currentCodeBlockStart = -1;
                }
                i += lineMatch[0].length - 1;
            }
        }
    }
    for(let i = 0; i < chars.length; i++){
        if (chars[i] === "`") {
            let backslashCount = 0;
            for(let j = i - 1; j >= 0 && chars[j] === "\\"; j--){
                backslashCount++;
            }
            if (backslashCount % 2 === 0) {
                for(let j = i + 1; j < chars.length; j++){
                    if (chars[j] === "`") {
                        let closingBackslashCount = 0;
                        for(let k = j - 1; k >= 0 && chars[k] === "\\"; k--){
                            closingBackslashCount++;
                        }
                        if (closingBackslashCount % 2 === 0) {
                            inlineCodeRanges.push({
                                start: i,
                                end: j + 1
                            });
                            i = j;
                            break;
                        }
                    }
                }
            }
        }
    }
    const isInCode = (pos)=>{
        return codeBlockRanges.some((range)=>pos >= range.start && pos < range.end) || inlineCodeRanges.some((range)=>pos >= range.start && pos < range.end);
    };
    for(let i = 0; i < chars.length; i++){
        const char = chars[i];
        const nextChar = chars[i + 1];
        const prevChar = chars[i - 1];
        if (isInCode(i)) {
            continue;
        }
        if (char === "[") {
            let isCompleteLink = false;
            let bracketDepth = 1;
            let j = i + 1;
            while(j < chars.length && bracketDepth > 0){
                if (chars[j] === "[" && !isInCode(j)) bracketDepth++;
                if (chars[j] === "]" && !isInCode(j)) bracketDepth--;
                j++;
            }
            if (bracketDepth === 0 && chars[j] === "(") {
                let parenDepth = 1;
                j++;
                while(j < chars.length && parenDepth > 0){
                    if (chars[j] === "(" && !isInCode(j)) parenDepth++;
                    if (chars[j] === ")" && !isInCode(j)) parenDepth--;
                    j++;
                }
                if (parenDepth === 0) {
                    isCompleteLink = true;
                    i = j - 1;
                    continue;
                }
            }
            if (!isCompleteLink) {
                const existingIndex = openElements.findIndex((el)=>el.type === "bracket");
                if (existingIndex !== -1) {
                    openElements.splice(existingIndex, 1);
                } else {
                    openElements.push({
                        type: "bracket",
                        marker: "[",
                        position: i
                    });
                }
            }
        } else if (char === "*" && nextChar === "*") {
            const existingIndex = openElements.findIndex((el)=>el.type === "bold_star");
            if (existingIndex !== -1) {
                openElements.splice(existingIndex, 1);
            } else {
                openElements.push({
                    type: "bold_star",
                    marker: "**",
                    position: i
                });
            }
            i++;
        } else if (char === "_" && nextChar === "_") {
            const existingIndex = openElements.findIndex((el)=>el.type === "bold_underscore");
            if (existingIndex !== -1) {
                openElements.splice(existingIndex, 1);
            } else {
                openElements.push({
                    type: "bold_underscore",
                    marker: "__",
                    position: i
                });
            }
            i++;
        } else if (char === "~" && nextChar === "~") {
            const existingIndex = openElements.findIndex((el)=>el.type === "strike");
            if (existingIndex !== -1) {
                openElements.splice(existingIndex, 1);
            } else {
                openElements.push({
                    type: "strike",
                    marker: "~~",
                    position: i
                });
            }
            i++;
        } else if (char === "*" && prevChar !== "*" && nextChar !== "*") {
            const existingIndex = openElements.findIndex((el)=>el.type === "italic_star");
            if (existingIndex !== -1) {
                openElements.splice(existingIndex, 1);
            } else {
                openElements.push({
                    type: "italic_star",
                    marker: "*",
                    position: i
                });
            }
        } else if (char === "_" && prevChar !== "_" && nextChar !== "_") {
            const existingIndex = openElements.findIndex((el)=>el.type === "italic_underscore");
            if (existingIndex !== -1) {
                openElements.splice(existingIndex, 1);
            } else {
                openElements.push({
                    type: "italic_underscore",
                    marker: "_",
                    position: i
                });
            }
        }
    }
    let backtickCount = 0;
    for(let i = 0; i < chars.length; i++){
        if (chars[i] === "`" && !isInCode(i)) {
            backtickCount++;
        }
    }
    if (backtickCount % 2 === 1) {
        s += "`";
    }
    openElements.sort((a, b)=>b.position - a.position);
    const closers = openElements.map((el)=>{
        switch(el.type){
            case "bracket":
                return "]";
            case "bold_star":
                return "**";
            case "bold_underscore":
                return "__";
            case "strike":
                return "~~";
            case "italic_star":
                return "*";
            case "italic_underscore":
                return "_";
            default:
                return "";
        }
    });
    let result = s + closers.join("");
    const finalFenceMatches = Array.from(result.matchAll(/^(\s*)(`{3,}|~{3,})/gm));
    const hasUnclosedBacktick = (result.match(/`/g) || []).length % 2 === 1;
    const hasUnclosedCodeFence = finalFenceMatches.length % 2 === 1;
    let shouldCloseParens = !hasUnclosedBacktick && !hasUnclosedCodeFence;
    if (shouldCloseParens) {
        const lastOpenParen = result.lastIndexOf("(");
        if (lastOpenParen !== -1) {
            const beforeParen = result.substring(0, lastOpenParen);
            const backticksBeforeParen = (beforeParen.match(/`/g) || []).length;
            if (backticksBeforeParen % 2 === 1) {
                shouldCloseParens = false;
            }
        }
    }
    if (shouldCloseParens) {
        const openParens = (result.match(/\(/g) || []).length;
        const closeParens = (result.match(/\)/g) || []).length;
        if (openParens > closeParens) {
            result += ")".repeat(openParens - closeParens);
        }
    }
    return result;
}
;
 //# sourceMappingURL=index.mjs.map
}),
];

//# sourceMappingURL=node_modules_%40copilotkitnext_3e988872._.js.map