{"version":3,"sources":["../src/mastra.ts","../src/utils.ts"],"sourcesContent":["import type {\n  AgentConfig,\n  BaseEvent,\n  RunAgentInput,\n  RunFinishedEvent,\n  RunStartedEvent,\n  StateSnapshotEvent,\n  TextMessageChunkEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/client\";\nimport { AbstractAgent, EventType } from \"@ag-ui/client\";\nimport type { StorageThreadType } from \"@mastra/core/memory\";\nimport type { Agent as LocalMastraAgent } from \"@mastra/core/agent\";\nimport { RequestContext } from \"@mastra/core/request-context\";\nimport { randomUUID } from \"@ag-ui/client\";\nimport { Observable } from \"rxjs\";\nimport type { MastraClient } from \"@mastra/client-js\";\nimport {\n  convertAGUIMessagesToMastra,\n  GetLocalAgentsOptions,\n  getLocalAgents,\n  getRemoteAgents,\n  GetRemoteAgentsOptions,\n  GetLocalAgentOptions,\n  getLocalAgent,\n  GetNetworkOptions,\n  getNetwork,\n} from \"./utils\";\n\ntype RemoteMastraAgent = ReturnType<MastraClient[\"getAgent\"]>;\n\nexport interface MastraAgentConfig extends AgentConfig {\n  agent: LocalMastraAgent | RemoteMastraAgent;\n  resourceId: string;\n  requestContext?: RequestContext;\n}\n\ninterface MastraAgentStreamOptions {\n  onTextPart?: (text: string) => void;\n  onFinishMessagePart?: () => void;\n  onToolCallPart?: (streamPart: {\n    toolCallId: string;\n    toolName: string;\n    args: any;\n  }) => void;\n  onToolResultPart?: (streamPart: { toolCallId: string; result: any }) => void;\n  onError?: (error: Error) => void;\n  onRunFinished?: () => Promise<void>;\n}\n\nexport class MastraAgent extends AbstractAgent {\n  agent: LocalMastraAgent | RemoteMastraAgent;\n  resourceId: string;\n  requestContext?: RequestContext;\n\n  constructor(private config: MastraAgentConfig) {\n    const { agent, resourceId, requestContext, ...rest } = config;\n    super(rest);\n    this.agent = agent;\n    this.resourceId = resourceId;\n    this.requestContext = requestContext ?? new RequestContext();\n  }\n\n  public clone() {\n    return new MastraAgent(this.config);\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    let messageId = randomUUID();\n\n    return new Observable<BaseEvent>((subscriber) => {\n      const run = async () => {\n        const runStartedEvent: RunStartedEvent = {\n          type: EventType.RUN_STARTED,\n          threadId: input.threadId,\n          runId: input.runId,\n        };\n\n        subscriber.next(runStartedEvent);\n\n        // Handle local agent memory management (from Mastra implementation)\n        if (this.isLocalMastraAgent(this.agent)) {\n          const memory = await this.agent.getMemory({\n            requestContext: this.requestContext,\n          });\n\n          if (\n            memory &&\n            input.state &&\n            Object.keys(input.state || {}).length > 0\n          ) {\n            let thread: StorageThreadType | null = await memory.getThreadById({\n              threadId: input.threadId,\n            });\n\n            if (!thread) {\n              thread = {\n                id: input.threadId,\n                title: \"\",\n                metadata: {},\n                resourceId: this.resourceId ?? input.threadId,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n              };\n            }\n\n            const existingMemory = JSON.parse(\n              (thread.metadata?.workingMemory as string) ?? \"{}\",\n            );\n            const { messages, ...rest } = input.state;\n            const workingMemory = JSON.stringify({\n              ...existingMemory,\n              ...rest,\n            });\n\n            // Update thread metadata with new working memory\n            await memory.saveThread({\n              thread: {\n                ...thread,\n                metadata: {\n                  ...thread.metadata,\n                  workingMemory,\n                },\n              },\n            });\n          }\n        }\n\n        try {\n          await this.streamMastraAgent(input, {\n            onTextPart: (text) => {\n              const event: TextMessageChunkEvent = {\n                type: EventType.TEXT_MESSAGE_CHUNK,\n                role: \"assistant\",\n                messageId,\n                delta: text,\n              };\n              subscriber.next(event);\n            },\n            onToolCallPart: (streamPart) => {\n              const startEvent: ToolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                parentMessageId: messageId,\n                toolCallId: streamPart.toolCallId,\n                toolCallName: streamPart.toolName,\n              };\n              subscriber.next(startEvent);\n\n              const argsEvent: ToolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: streamPart.toolCallId,\n                delta: JSON.stringify(streamPart.args),\n              };\n              subscriber.next(argsEvent);\n\n              const endEvent: ToolCallEndEvent = {\n                type: EventType.TOOL_CALL_END,\n                toolCallId: streamPart.toolCallId,\n              };\n              subscriber.next(endEvent);\n            },\n            onToolResultPart(streamPart) {\n              const toolCallResultEvent: ToolCallResultEvent = {\n                type: EventType.TOOL_CALL_RESULT,\n                toolCallId: streamPart.toolCallId,\n                content: JSON.stringify(streamPart.result),\n                messageId: randomUUID(),\n                role: \"tool\",\n              };\n\n              subscriber.next(toolCallResultEvent);\n            },\n            onFinishMessagePart: async () => {\n              messageId = randomUUID();\n            },\n            onError: (error) => {\n              console.error(\"error\", error);\n              // Handle error\n              subscriber.error(error);\n            },\n            onRunFinished: async () => {\n              if (this.isLocalMastraAgent(this.agent)) {\n                try {\n                  const memory = await this.agent.getMemory({\n                    requestContext: this.requestContext,\n                  });\n                  if (memory) {\n                    const workingMemory = await memory.getWorkingMemory({\n                      resourceId: this.resourceId,\n                      threadId: input.threadId,\n                      memoryConfig: {\n                        workingMemory: {\n                          enabled: true,\n                        },\n                      },\n                    });\n\n                    if (typeof workingMemory === \"string\") {\n                      const snapshot = JSON.parse(workingMemory);\n\n                      if (snapshot && !(\"$schema\" in snapshot)) {\n                        const stateSnapshotEvent: StateSnapshotEvent = {\n                          type: EventType.STATE_SNAPSHOT,\n                          snapshot,\n                        };\n\n                        subscriber.next(stateSnapshotEvent);\n                      }\n                    }\n                  }\n                } catch (error) {\n                  console.error(\"Error sending state snapshot\", error);\n                }\n              }\n\n              // Emit run finished event\n              subscriber.next({\n                type: EventType.RUN_FINISHED,\n                threadId: input.threadId,\n                runId: input.runId,\n              } as RunFinishedEvent);\n\n              // Complete the observable\n              subscriber.complete();\n            },\n          });\n        } catch (error) {\n          console.error(\"Stream error:\", error);\n          subscriber.error(error);\n        }\n      };\n\n      run();\n\n      return () => {};\n    });\n  }\n\n  isLocalMastraAgent(\n    agent: LocalMastraAgent | RemoteMastraAgent,\n  ): agent is LocalMastraAgent {\n    return \"getMemory\" in agent;\n  }\n\n  /**\n   * Streams in process or remote mastra agent.\n   * @param input - The input for the mastra agent.\n   * @param options - The options for the mastra agent.\n   * @returns The stream of the mastra agent.\n   */\n  private async streamMastraAgent(\n    { threadId, runId, messages, tools, context: inputContext }: RunAgentInput,\n    {\n      onTextPart,\n      onFinishMessagePart,\n      onToolCallPart,\n      onToolResultPart,\n      onError,\n      onRunFinished,\n    }: MastraAgentStreamOptions,\n  ): Promise<void> {\n    const clientTools = tools.reduce(\n      (acc, tool) => {\n        acc[tool.name as string] = {\n          id: tool.name,\n          description: tool.description,\n          inputSchema: tool.parameters,\n        };\n        return acc;\n      },\n      {} as Record<string, any>,\n    );\n    const resourceId = this.resourceId ?? threadId;\n\n    const convertedMessages = convertAGUIMessagesToMastra(messages);\n    this.requestContext?.set(\"ag-ui\", { context: inputContext });\n    const requestContext = this.requestContext;\n\n    if (this.isLocalMastraAgent(this.agent)) {\n      // Local agent - use the agent's stream method directly\n      try {\n        const response = await this.agent.stream(convertedMessages, {\n          memory: {\n            thread: threadId,\n            resource: resourceId,\n          },\n          runId,\n          clientTools,\n          requestContext,\n        });\n\n        // For local agents, the response should already be a stream\n        // Process it using the agent's built-in streaming mechanism\n        if (response && typeof response === \"object\") {\n          for await (const chunk of response.fullStream) {\n            switch (chunk.type) {\n              case \"text-delta\": {\n                onTextPart?.(chunk.payload.text);\n                break;\n              }\n              case \"tool-call\": {\n                onToolCallPart?.({\n                  toolCallId: chunk.payload.toolCallId,\n                  toolName: chunk.payload.toolName,\n                  args: chunk.payload.args,\n                });\n                break;\n              }\n              case \"tool-result\": {\n                onToolResultPart?.({\n                  toolCallId: chunk.payload.toolCallId,\n                  result: chunk.payload.result,\n                });\n                break;\n              }\n\n              case \"error\": {\n                onError?.(new Error(chunk.payload.error as string));\n                break;\n              }\n\n              case \"finish\": {\n                onFinishMessagePart?.();\n                break;\n              }\n            }\n          }\n\n          await onRunFinished?.();\n        } else {\n          throw new Error(\"Invalid response from local agent\");\n        }\n      } catch (error) {\n        onError?.(error as Error);\n      }\n    } else {\n      // Remote agent - use the remote agent's stream method\n      try {\n        const response = await this.agent.stream({\n          memory: {\n            thread: threadId,\n            resource: resourceId,\n          },\n          runId,\n          messages: convertedMessages,\n          clientTools,\n          requestContext,\n        });\n\n        // Remote agents should have a processDataStream method\n        if (response && typeof response.processDataStream === \"function\") {\n          await response.processDataStream({\n            onChunk: async (chunk) => {\n              switch (chunk.type) {\n                case \"text-delta\": {\n                  onTextPart?.(chunk.payload.text);\n                  break;\n                }\n                case \"tool-call\": {\n                  onToolCallPart?.({\n                    toolCallId: chunk.payload.toolCallId,\n                    toolName: chunk.payload.toolName,\n                    args: chunk.payload.args,\n                  });\n                  break;\n                }\n                case \"tool-result\": {\n                  onToolResultPart?.({\n                    toolCallId: chunk.payload.toolCallId,\n                    result: chunk.payload.result,\n                  });\n                  break;\n                }\n\n                case \"finish\": {\n                  onFinishMessagePart?.();\n                  break;\n                }\n              }\n            },\n          });\n          await onRunFinished?.();\n        } else {\n          throw new Error(\"Invalid response from remote agent\");\n        }\n      } catch (error) {\n        onError?.(error as Error);\n      }\n    }\n  }\n\n  static async getRemoteAgents(\n    options: GetRemoteAgentsOptions,\n  ): Promise<Record<string, AbstractAgent>> {\n    return getRemoteAgents(options);\n  }\n\n  static getLocalAgents(\n    options: GetLocalAgentsOptions,\n  ): Record<string, AbstractAgent> {\n    return getLocalAgents(options);\n  }\n\n  static getLocalAgent(options: GetLocalAgentOptions) {\n    return getLocalAgent(options);\n  }\n\n  static getNetwork(options: GetNetworkOptions) {\n    return getNetwork(options);\n  }\n}\n","import type { InputContent, Message } from \"@ag-ui/client\";\nimport { AbstractAgent } from \"@ag-ui/client\";\nimport { MastraClient } from \"@mastra/client-js\";\nimport type { Mastra } from \"@mastra/core\";\nimport type { CoreMessage } from \"@mastra/core/llm\";\nimport { Agent as LocalMastraAgent } from \"@mastra/core/agent\";\nimport { RequestContext } from \"@mastra/core/request-context\";\nimport { MastraAgent } from \"./mastra\";\n\nconst toMastraTextContent = (content: Message[\"content\"]): string => {\n  if (!content) {\n    return \"\";\n  }\n\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return \"\";\n  }\n\n  type TextInput = Extract<InputContent, { type: \"text\" }>;\n\n  const textParts = content\n    .filter((part): part is TextInput => part.type === \"text\")\n    .map((part: TextInput) => part.text.trim())\n    .filter(Boolean);\n\n  return textParts.join(\"\\n\");\n};\n\nexport function convertAGUIMessagesToMastra(messages: Message[]): CoreMessage[] {\n  const result: CoreMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\") {\n      const assistantContent = toMastraTextContent(message.content);\n      const parts: any[] = [];\n      if (assistantContent) {\n        parts.push({ type: \"text\", text: assistantContent });\n      }\n      for (const toolCall of message.toolCalls ?? []) {\n        parts.push({\n          type: \"tool-call\",\n          toolCallId: toolCall.id,\n          toolName: toolCall.function.name,\n          args: JSON.parse(toolCall.function.arguments),\n        });\n      }\n      result.push({\n        role: \"assistant\",\n        content: parts,\n      });\n    } else if (message.role === \"user\") {\n      const userContent = toMastraTextContent(message.content);\n      result.push({\n        role: \"user\",\n        content: userContent,\n      });\n    } else if (message.role === \"tool\") {\n      let toolName = \"unknown\";\n      for (const msg of messages) {\n        if (msg.role === \"assistant\") {\n          for (const toolCall of msg.toolCalls ?? []) {\n            if (toolCall.id === message.toolCallId) {\n              toolName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      result.push({\n        role: \"tool\",\n        content: [\n          {\n            type: \"tool-result\",\n            toolCallId: message.toolCallId,\n            toolName: toolName,\n            result: message.content,\n          },\n        ],\n      });\n    }\n  }\n\n  return result;\n}\n\nexport interface GetRemoteAgentsOptions {\n  mastraClient: MastraClient;\n  resourceId: string;\n}\n\nexport async function getRemoteAgents({\n  mastraClient,\n  resourceId,\n}: GetRemoteAgentsOptions): Promise<Record<string, AbstractAgent>> {\n  const agents = await mastraClient.listAgents();\n\n  return Object.entries(agents).reduce(\n    (acc, [agentId]) => {\n      const agent = mastraClient.getAgent(agentId);\n\n      acc[agentId] = new MastraAgent({\n        agentId,\n        agent,\n        resourceId,\n      });\n\n      return acc;\n    },\n    {} as Record<string, AbstractAgent>,\n  );\n}\n\nexport interface GetLocalAgentsOptions {\n  mastra: Mastra;\n  resourceId: string;\n  requestContext?: RequestContext;\n}\n\nexport function getLocalAgents({\n  mastra,\n  resourceId,\n  requestContext,\n}: GetLocalAgentsOptions): Record<string, AbstractAgent> {\n  const agents = mastra.listAgents() || {};\n\n  const agentAGUI = Object.entries(agents).reduce(\n    (acc, [agentId, agent]) => {\n      acc[agentId] = new MastraAgent({\n        agentId,\n        agent,\n        resourceId,\n        requestContext,\n      });\n      return acc;\n    },\n    {} as Record<string, AbstractAgent>,\n  );\n\n  return agentAGUI;\n}\n\nexport interface GetLocalAgentOptions {\n  mastra: Mastra;\n  agentId: string;\n  resourceId: string;\n  requestContext?: RequestContext;\n}\n\nexport function getLocalAgent({\n  mastra,\n  agentId,\n  resourceId,\n  requestContext,\n}: GetLocalAgentOptions) {\n  const agent = mastra.getAgent(agentId);\n  if (!agent) {\n    throw new Error(`Agent ${agentId} not found`);\n  }\n  return new MastraAgent({\n    agentId,\n    agent,\n    resourceId,\n    requestContext,\n  }) as AbstractAgent;\n}\n\nexport interface GetNetworkOptions {\n  mastra: Mastra;\n  networkId: string;\n  resourceId: string;\n  requestContext?: RequestContext;\n}\n\nexport function getNetwork({ mastra, networkId, resourceId, requestContext }: GetNetworkOptions) {\n  const network = mastra.getAgent(networkId);\n  if (!network) {\n    throw new Error(`Network ${networkId} not found`);\n  }\n  return new MastraAgent({\n    agentId: network.name!,\n    agent: network as unknown as LocalMastraAgent,\n    resourceId,\n    requestContext,\n  }) as AbstractAgent;\n}\n"],"mappings":"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","names":["AbstractAgent","EventType","RequestContext","randomUUID","Observable","toMastraTextContent","content","part","convertAGUIMessagesToMastra","messages","_a","_b","result","message","assistantContent","parts","toolCall","userContent","toolName","msg","getRemoteAgents","mastraClient","resourceId","agents","acc","agentId","agent","MastraAgent","getLocalAgents","mastra","requestContext","getLocalAgent","getNetwork","networkId","network","MastraAgent","_MastraAgent","AbstractAgent","config","_a","agent","resourceId","requestContext","rest","__objRest","RequestContext","input","messageId","randomUUID","Observable","subscriber","_b","_c","runStartedEvent","EventType","memory","thread","existingMemory","_d","messages","workingMemory","__spreadValues","__spreadProps","text","event","streamPart","startEvent","argsEvent","endEvent","toolCallResultEvent","error","snapshot","stateSnapshotEvent","threadId","runId","tools","inputContext","onTextPart","onFinishMessagePart","onToolCallPart","onToolResultPart","onError","onRunFinished","clientTools","acc","tool","convertedMessages","convertAGUIMessagesToMastra","response","iter","__forAwait","more","temp","chunk","options","getRemoteAgents","getLocalAgents","getLocalAgent","getNetwork"]}