import {
  useCoAgentStateRenders
} from "./chunk-FDOMAPJY.mjs";
import {
  __objRest
} from "./chunk-SKC7AJIV.mjs";

// src/hooks/use-coagent-state-render-bridge.tsx
import { useAgent } from "@copilotkitnext/react";
import { useCallback, useEffect, useMemo, useState } from "react";
import { dataToUUID, parseJson } from "@copilotkit/shared";
function getStateWithoutConstantKeys(state) {
  if (!state)
    return {};
  const _a = state, { messages, tools, copilotkit } = _a, stateWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  return stateWithoutConstantKeys;
}
function areStatesEquals(a, b) {
  if (a && !b || !a && b)
    return false;
  const _a = a, { messages, tools, copilotkit } = _a, aWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  const _b = b, {
    messages: bMessages,
    tools: bTools,
    copilotkit: bCopilotkit
  } = _b, bWithoutConstantKeys = __objRest(_b, [
    "messages",
    "tools",
    "copilotkit"
  ]);
  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);
}
function useCoagentStateRenderBridge(agentId, props) {
  var _a;
  const { stateSnapshot, messageIndexInRun, message } = props;
  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();
  const { agent } = useAgent({ agentId });
  const [nodeName, setNodeName] = useState(void 0);
  const runId = (_a = props.runId) != null ? _a : message.runId;
  const effectiveRunId = runId || "pending";
  useEffect(() => {
    if (!agent)
      return;
    const subscriber = {
      onStepStartedEvent: ({ event }) => {
        if (event.stepName !== nodeName) {
          setNodeName(event.stepName);
        }
      },
      onStepFinishedEvent: ({ event }) => {
        if (event.stepName === nodeName) {
          setNodeName(void 0);
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agentId, nodeName]);
  const getStateRender = useCallback(
    (messageId) => {
      return Object.entries(coAgentStateRenders).find(([stateRenderId, stateRender]) => {
        if (claimsRef.current[messageId]) {
          return stateRenderId === claimsRef.current[messageId].stateRenderId;
        }
        const matchingAgentName = stateRender.name === agentId;
        const matchesNodeContext = stateRender.nodeName ? stateRender.nodeName === nodeName : true;
        return matchingAgentName && matchesNodeContext;
      });
    },
    [coAgentStateRenders, nodeName, agentId]
  );
  const handleRenderRequest = ({
    stateRenderId,
    messageId,
    runId: runId2,
    stateSnapshot: renderSnapshot
  }) => {
    if (claimsRef.current[messageId]) {
      const canRender = claimsRef.current[messageId].stateRenderId === stateRenderId;
      if (canRender && runId2 && (!claimsRef.current[messageId].runId || claimsRef.current[messageId].runId === "pending")) {
        claimsRef.current[messageId].runId = runId2;
      }
      return canRender;
    }
    const renderClaimedByOtherMessage = Object.values(claimsRef.current).find(
      (c) => c.stateRenderId === stateRenderId && dataToUUID(getStateWithoutConstantKeys(c.stateSnapshot)) === dataToUUID(getStateWithoutConstantKeys(renderSnapshot))
    );
    if (renderClaimedByOtherMessage) {
      if (renderSnapshot && renderClaimedByOtherMessage.stateSnapshot && !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, renderSnapshot)) {
        claimsRef.current[messageId] = { stateRenderId, runId: runId2 };
        return true;
      }
      return false;
    }
    if (!runId2) {
      return false;
    }
    claimsRef.current[messageId] = { stateRenderId, runId: runId2 };
    return true;
  };
  return useMemo(() => {
    var _a2, _b, _c;
    if (messageIndexInRun !== 0) {
      return null;
    }
    const [stateRenderId, stateRender] = (_a2 = getStateRender(message.id)) != null ? _a2 : [];
    if (!stateRender || !stateRenderId) {
      return null;
    }
    const snapshot = stateSnapshot ? parseJson(stateSnapshot, stateSnapshot) : agent == null ? void 0 : agent.state;
    const canRender = handleRenderRequest({
      stateRenderId,
      messageId: message.id,
      runId: effectiveRunId,
      stateSnapshot: snapshot
    });
    if (!canRender) {
      return null;
    }
    if (snapshot && !claimsRef.current[message.id].locked) {
      if (stateSnapshot) {
        claimsRef.current[message.id].stateSnapshot = snapshot;
        claimsRef.current[message.id].locked = true;
      } else {
        claimsRef.current[message.id].stateSnapshot = snapshot;
      }
    }
    if (stateRender.handler) {
      stateRender.handler({
        state: stateSnapshot ? parseJson(stateSnapshot, stateSnapshot) : (_b = agent == null ? void 0 : agent.state) != null ? _b : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
    if (stateRender.render) {
      const status = (agent == null ? void 0 : agent.isRunning) ? "inProgress" : "complete";
      if (typeof stateRender.render === "string")
        return stateRender.render;
      return stateRender.render({
        status,
        // Always use state from claim, to make sure the state does not seem "wiped" for a fraction of a second
        state: (_c = claimsRef.current[message.id].stateSnapshot) != null ? _c : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
  }, [
    getStateRender,
    stateSnapshot,
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.isRunning,
    nodeName,
    effectiveRunId,
    message.id,
    messageIndexInRun
  ]);
}
function CoAgentStateRenderBridge(props) {
  return useCoagentStateRenderBridge(props.agentId, props);
}

export {
  useCoagentStateRenderBridge,
  CoAgentStateRenderBridge
};
//# sourceMappingURL=chunk-QNUAXSDP.mjs.map