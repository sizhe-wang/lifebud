"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hooks/use-coagent-state-render-bridge.tsx
var use_coagent_state_render_bridge_exports = {};
__export(use_coagent_state_render_bridge_exports, {
  CoAgentStateRenderBridge: () => CoAgentStateRenderBridge,
  useCoagentStateRenderBridge: () => useCoagentStateRenderBridge
});
module.exports = __toCommonJS(use_coagent_state_render_bridge_exports);
var import_react2 = require("@copilotkitnext/react");
var import_react3 = require("react");

// src/context/coagent-state-renders-context.tsx
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var CoAgentStateRendersContext = (0, import_react.createContext)(
  void 0
);
function useCoAgentStateRenders() {
  const context = (0, import_react.useContext)(CoAgentStateRendersContext);
  if (!context) {
    throw new Error("useCoAgentStateRenders must be used within CoAgentStateRendersProvider");
  }
  return context;
}

// src/hooks/use-coagent-state-render-bridge.tsx
var import_shared = require("@copilotkit/shared");
function getStateWithoutConstantKeys(state) {
  if (!state)
    return {};
  const _a = state, { messages, tools, copilotkit } = _a, stateWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  return stateWithoutConstantKeys;
}
function areStatesEquals(a, b) {
  if (a && !b || !a && b)
    return false;
  const _a = a, { messages, tools, copilotkit } = _a, aWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  const _b = b, {
    messages: bMessages,
    tools: bTools,
    copilotkit: bCopilotkit
  } = _b, bWithoutConstantKeys = __objRest(_b, [
    "messages",
    "tools",
    "copilotkit"
  ]);
  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);
}
function useCoagentStateRenderBridge(agentId, props) {
  var _a;
  const { stateSnapshot, messageIndexInRun, message } = props;
  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();
  const { agent } = (0, import_react2.useAgent)({ agentId });
  const [nodeName, setNodeName] = (0, import_react3.useState)(void 0);
  const runId = (_a = props.runId) != null ? _a : message.runId;
  const effectiveRunId = runId || "pending";
  (0, import_react3.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStepStartedEvent: ({ event }) => {
        if (event.stepName !== nodeName) {
          setNodeName(event.stepName);
        }
      },
      onStepFinishedEvent: ({ event }) => {
        if (event.stepName === nodeName) {
          setNodeName(void 0);
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agentId, nodeName]);
  const getStateRender = (0, import_react3.useCallback)(
    (messageId) => {
      return Object.entries(coAgentStateRenders).find(([stateRenderId, stateRender]) => {
        if (claimsRef.current[messageId]) {
          return stateRenderId === claimsRef.current[messageId].stateRenderId;
        }
        const matchingAgentName = stateRender.name === agentId;
        const matchesNodeContext = stateRender.nodeName ? stateRender.nodeName === nodeName : true;
        return matchingAgentName && matchesNodeContext;
      });
    },
    [coAgentStateRenders, nodeName, agentId]
  );
  const handleRenderRequest = ({
    stateRenderId,
    messageId,
    runId: runId2,
    stateSnapshot: renderSnapshot
  }) => {
    if (claimsRef.current[messageId]) {
      const canRender = claimsRef.current[messageId].stateRenderId === stateRenderId;
      if (canRender && runId2 && (!claimsRef.current[messageId].runId || claimsRef.current[messageId].runId === "pending")) {
        claimsRef.current[messageId].runId = runId2;
      }
      return canRender;
    }
    const renderClaimedByOtherMessage = Object.values(claimsRef.current).find(
      (c) => c.stateRenderId === stateRenderId && (0, import_shared.dataToUUID)(getStateWithoutConstantKeys(c.stateSnapshot)) === (0, import_shared.dataToUUID)(getStateWithoutConstantKeys(renderSnapshot))
    );
    if (renderClaimedByOtherMessage) {
      if (renderSnapshot && renderClaimedByOtherMessage.stateSnapshot && !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, renderSnapshot)) {
        claimsRef.current[messageId] = { stateRenderId, runId: runId2 };
        return true;
      }
      return false;
    }
    if (!runId2) {
      return false;
    }
    claimsRef.current[messageId] = { stateRenderId, runId: runId2 };
    return true;
  };
  return (0, import_react3.useMemo)(() => {
    var _a2, _b, _c;
    if (messageIndexInRun !== 0) {
      return null;
    }
    const [stateRenderId, stateRender] = (_a2 = getStateRender(message.id)) != null ? _a2 : [];
    if (!stateRender || !stateRenderId) {
      return null;
    }
    const snapshot = stateSnapshot ? (0, import_shared.parseJson)(stateSnapshot, stateSnapshot) : agent == null ? void 0 : agent.state;
    const canRender = handleRenderRequest({
      stateRenderId,
      messageId: message.id,
      runId: effectiveRunId,
      stateSnapshot: snapshot
    });
    if (!canRender) {
      return null;
    }
    if (snapshot && !claimsRef.current[message.id].locked) {
      if (stateSnapshot) {
        claimsRef.current[message.id].stateSnapshot = snapshot;
        claimsRef.current[message.id].locked = true;
      } else {
        claimsRef.current[message.id].stateSnapshot = snapshot;
      }
    }
    if (stateRender.handler) {
      stateRender.handler({
        state: stateSnapshot ? (0, import_shared.parseJson)(stateSnapshot, stateSnapshot) : (_b = agent == null ? void 0 : agent.state) != null ? _b : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
    if (stateRender.render) {
      const status = (agent == null ? void 0 : agent.isRunning) ? "inProgress" : "complete";
      if (typeof stateRender.render === "string")
        return stateRender.render;
      return stateRender.render({
        status,
        // Always use state from claim, to make sure the state does not seem "wiped" for a fraction of a second
        state: (_c = claimsRef.current[message.id].stateSnapshot) != null ? _c : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
  }, [
    getStateRender,
    stateSnapshot,
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.isRunning,
    nodeName,
    effectiveRunId,
    message.id,
    messageIndexInRun
  ]);
}
function CoAgentStateRenderBridge(props) {
  return useCoagentStateRenderBridge(props.agentId, props);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CoAgentStateRenderBridge,
  useCoagentStateRenderBridge
});
//# sourceMappingURL=use-coagent-state-render-bridge.js.map