'use strict';

var uuid = require('@lukeed/uuid');
var error = require('@mastra/core/error');
var requestContext = require('@mastra/core/request-context');
var isVercelTool = require('@mastra/core/tools/is-vercel-tool');
var zodToJson = require('@mastra/schema-compat/zod-to-json');

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));

// ../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter;
  }
});

// ../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;

// ../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};

// ../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse = __toESM(require_secure_json_parse());
var createIdGenerator = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
createIdGenerator();
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema) {
  return validator((value) => {
    const result = zodSchema.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes({
  value,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value };
    }
    const result = validator2.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON({
  text,
  schema
}) {
  try {
    const value = import_secure_json_parse.default.parse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error })
    };
  }
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
var dataStreamPartsByCode = Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
var validCodes2 = dataStreamParts.map((part) => part.code);
var parseDataStreamPart = (line) => {
  const firstSeparatorIndex = line.indexOf(":");
  if (firstSeparatorIndex === -1) {
    throw new Error("Failed to parse stream string. No separator found.");
  }
  const prefix = line.slice(0, firstSeparatorIndex);
  if (!validCodes2.includes(prefix)) {
    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);
  }
  const code = prefix;
  const textValue = line.slice(firstSeparatorIndex + 1);
  const jsonValue = JSON.parse(textValue);
  return dataStreamPartsByCode[code].parse(jsonValue);
};
var NEWLINE = "\n".charCodeAt(0);
function concatChunks(chunks, totalLength) {
  const concatenatedChunks = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    concatenatedChunks.set(chunk, offset);
    offset += chunk.length;
  }
  chunks.length = 0;
  return concatenatedChunks;
}
async function processDataStream({
  stream,
  onTextPart,
  onReasoningPart,
  onReasoningSignaturePart,
  onRedactedReasoningPart,
  onSourcePart,
  onFilePart,
  onDataPart,
  onErrorPart,
  onToolCallStreamingStartPart,
  onToolCallDeltaPart,
  onToolCallPart,
  onToolResultPart,
  onMessageAnnotationsPart,
  onFinishMessagePart,
  onFinishStepPart,
  onStartStepPart
}) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  const chunks = [];
  let totalLength = 0;
  while (true) {
    const { value } = await reader.read();
    if (value) {
      chunks.push(value);
      totalLength += value.length;
      if (value[value.length - 1] !== NEWLINE) {
        continue;
      }
    }
    if (chunks.length === 0) {
      break;
    }
    const concatenatedChunks = concatChunks(chunks, totalLength);
    totalLength = 0;
    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split("\n").filter((line) => line !== "").map(parseDataStreamPart);
    for (const { type, value: value2 } of streamParts) {
      switch (type) {
        case "text":
          await (onTextPart == null ? void 0 : onTextPart(value2));
          break;
        case "reasoning":
          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));
          break;
        case "reasoning_signature":
          await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));
          break;
        case "redacted_reasoning":
          await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));
          break;
        case "file":
          await (onFilePart == null ? void 0 : onFilePart(value2));
          break;
        case "source":
          await (onSourcePart == null ? void 0 : onSourcePart(value2));
          break;
        case "data":
          await (onDataPart == null ? void 0 : onDataPart(value2));
          break;
        case "error":
          await (onErrorPart == null ? void 0 : onErrorPart(value2));
          break;
        case "message_annotations":
          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));
          break;
        case "tool_call_streaming_start":
          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));
          break;
        case "tool_call_delta":
          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));
          break;
        case "tool_call":
          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));
          break;
        case "tool_result":
          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));
          break;
        case "finish_message":
          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));
          break;
        case "finish_step":
          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));
          break;
        case "start_step":
          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));
          break;
        default: {
          const exhaustiveCheck = type;
          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);
        }
      }
    }
  }
}
function isComplexValue(value) {
  if (value === null || value === void 0) return false;
  if (value instanceof Date) return false;
  return typeof value === "object";
}
function serializeQueryValue(value) {
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (isComplexValue(value)) {
    return JSON.stringify(value, (_key, val) => {
      if (val instanceof Date) {
        return val.toISOString();
      }
      return val;
    });
  }
  return String(value);
}
function toQueryParams(params, flattenKeys = []) {
  const searchParams = new URLSearchParams();
  const keysToFlatten = flattenKeys;
  function addParams(obj) {
    for (const [key, value] of Object.entries(obj)) {
      if (value === void 0 || value === null) continue;
      if (keysToFlatten.includes(key) && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date)) {
        addParams(value);
      } else {
        searchParams.set(key, serializeQueryValue(value));
      }
    }
  }
  addParams(params);
  return searchParams.toString();
}
function parseClientRequestContext(requestContext$1) {
  if (requestContext$1) {
    if (requestContext$1 instanceof requestContext.RequestContext) {
      return Object.fromEntries(requestContext$1.entries());
    }
    return requestContext$1;
  }
  return void 0;
}
function base64RequestContext(requestContext) {
  if (requestContext) {
    return btoa(JSON.stringify(requestContext));
  }
  return void 0;
}
function requestContextQueryString(requestContext, delimiter = "?") {
  const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));
  if (!requestContextParam) return "";
  const searchParams = new URLSearchParams();
  searchParams.set("requestContext", requestContextParam);
  const queryString = searchParams.toString();
  return queryString ? `${delimiter}${queryString}` : "";
}
function isZodType(value) {
  return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function zodToJsonSchema2(zodSchema) {
  if (!isZodType(zodSchema)) {
    return zodSchema;
  }
  return zodToJson.zodToJsonSchema(zodSchema);
}

// src/utils/process-client-tools.ts
function processClientTools(clientTools) {
  if (!clientTools) {
    return void 0;
  }
  return Object.fromEntries(
    Object.entries(clientTools).map(([key, value]) => {
      if (isVercelTool.isVercelTool(value)) {
        return [
          key,
          {
            ...value,
            parameters: value.parameters ? zodToJsonSchema2(value.parameters) : void 0
          }
        ];
      } else {
        return [
          key,
          {
            ...value,
            inputSchema: value.inputSchema ? zodToJsonSchema2(value.inputSchema) : void 0,
            outputSchema: value.outputSchema ? zodToJsonSchema2(value.outputSchema) : void 0
          }
        ];
      }
    })
  );
}

// src/utils/process-mastra-stream.ts
async function sharedProcessMastraStream({
  stream,
  onChunk
}) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        if (line.startsWith("data: ")) {
          const data = line.slice(6);
          if (data === "[DONE]") {
            return;
          }
          let json;
          try {
            json = JSON.parse(data);
          } catch (error) {
            console.error("\u274C JSON parse error:", error, "Data:", data);
            continue;
          }
          if (json) {
            await onChunk(json);
          }
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function processMastraNetworkStream({
  stream,
  onChunk
}) {
  return sharedProcessMastraStream({
    stream,
    onChunk
  });
}
async function processMastraStream({
  stream,
  onChunk
}) {
  return sharedProcessMastraStream({
    stream,
    onChunk
  });
}

// src/resources/base.ts
var BaseResource = class {
  options;
  constructor(options) {
    this.options = options;
  }
  /**
   * Makes an HTTP request to the API with retries and exponential backoff
   * @param path - The API endpoint path
   * @param options - Optional request configuration
   * @returns Promise containing the response data
   */
  async request(path, options = {}) {
    let lastError = null;
    const {
      baseUrl,
      retries = 3,
      backoffMs = 100,
      maxBackoffMs = 1e3,
      headers = {},
      credentials,
      fetch: customFetch
    } = this.options;
    const fetchFn = customFetch || fetch;
    let delay = backoffMs;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const response = await fetchFn(`${baseUrl.replace(/\/$/, "")}${path}`, {
          ...options,
          headers: {
            ...options.body && !(options.body instanceof FormData) && (options.method === "POST" || options.method === "PUT") ? { "content-type": "application/json" } : {},
            ...headers,
            ...options.headers
            // TODO: Bring this back once we figure out what we/users need to do to make this work with cross-origin requests
            // 'x-mastra-client-type': 'js',
          },
          signal: this.options.abortSignal,
          credentials: options.credentials ?? credentials,
          body: options.body instanceof FormData ? options.body : options.body ? JSON.stringify(options.body) : void 0
        });
        if (!response.ok) {
          const errorBody = await response.text();
          let errorMessage = `HTTP error! status: ${response.status}`;
          try {
            const errorJson = JSON.parse(errorBody);
            errorMessage += ` - ${JSON.stringify(errorJson)}`;
          } catch {
            if (errorBody) {
              errorMessage += ` - ${errorBody}`;
            }
          }
          throw new Error(errorMessage);
        }
        if (options.stream) {
          return response;
        }
        const data = await response.json();
        return data;
      } catch (error) {
        lastError = error;
        if (attempt === retries) {
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay = Math.min(delay * 2, maxBackoffMs);
      }
    }
    throw lastError || new Error("Request failed");
  }
};

// src/resources/agent.ts
async function executeToolCallAndRespond({
  response,
  params,
  resourceId,
  threadId,
  requestContext,
  respondFn
}) {
  if (response.finishReason === "tool-calls") {
    const toolCalls = response.toolCalls;
    if (!toolCalls || !Array.isArray(toolCalls)) {
      return response;
    }
    for (const toolCall of toolCalls) {
      const clientTool = params.clientTools?.[toolCall.payload.toolName];
      if (clientTool && clientTool.execute) {
        const result = await clientTool.execute(toolCall?.payload.args, {
          requestContext,
          tracingContext: { currentSpan: void 0 },
          agent: {
            messages: response.messages,
            toolCallId: toolCall?.payload.toolCallId,
            suspend: async () => {
            },
            threadId,
            resourceId
          }
        });
        const updatedMessages = [
          ...response.response.messages || [],
          {
            role: "tool",
            content: [
              {
                type: "tool-result",
                toolCallId: toolCall.payload.toolCallId,
                toolName: toolCall.payload.toolName,
                result
              }
            ]
          }
        ];
        return respondFn(updatedMessages, params);
      }
    }
  }
  return response;
}
var AgentVoice = class extends BaseResource {
  constructor(options, agentId) {
    super(options);
    this.agentId = agentId;
    this.agentId = agentId;
  }
  /**
   * Convert text to speech using the agent's voice provider
   * @param text - Text to convert to speech
   * @param options - Optional provider-specific options for speech generation
   * @returns Promise containing the audio data
   */
  async speak(text, options) {
    return this.request(`/api/agents/${this.agentId}/voice/speak`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: { input: text, options },
      stream: true
    });
  }
  /**
   * Convert speech to text using the agent's voice provider
   * @param audio - Audio data to transcribe
   * @param options - Optional provider-specific options
   * @returns Promise containing the transcribed text
   */
  listen(audio, options) {
    const formData = new FormData();
    formData.append("audio", audio);
    if (options) {
      formData.append("options", JSON.stringify(options));
    }
    return this.request(`/api/agents/${this.agentId}/voice/listen`, {
      method: "POST",
      body: formData
    });
  }
  /**
   * Get available speakers for the agent's voice provider
   * @param requestContext - Optional request context to pass as query parameter
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing list of available speakers
   */
  getSpeakers(requestContext) {
    return this.request(`/api/agents/${this.agentId}/voice/speakers${requestContextQueryString(requestContext)}`);
  }
  /**
   * Get the listener configuration for the agent's voice provider
   * @param requestContext - Optional request context to pass as query parameter
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing a check if the agent has listening capabilities
   */
  getListener(requestContext) {
    return this.request(`/api/agents/${this.agentId}/voice/listener${requestContextQueryString(requestContext)}`);
  }
};
var Agent = class extends BaseResource {
  constructor(options, agentId) {
    super(options);
    this.agentId = agentId;
    this.voice = new AgentVoice(options, this.agentId);
  }
  voice;
  /**
   * Retrieves details about the agent
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing agent details including model and instructions
   */
  details(requestContext) {
    return this.request(`/api/agents/${this.agentId}${requestContextQueryString(requestContext)}`);
  }
  enhanceInstructions(instructions, comment) {
    return this.request(`/api/agents/${this.agentId}/instructions/enhance`, {
      method: "POST",
      body: { instructions, comment }
    });
  }
  async generateLegacy(params) {
    const processedParams = {
      ...params,
      output: params.output ? zodToJsonSchema2(params.output) : void 0,
      experimental_output: params.experimental_output ? zodToJsonSchema2(params.experimental_output) : void 0,
      requestContext: parseClientRequestContext(params.requestContext),
      clientTools: processClientTools(params.clientTools)
    };
    const { resourceId, threadId, requestContext } = processedParams;
    const response = await this.request(
      `/api/agents/${this.agentId}/generate-legacy`,
      {
        method: "POST",
        body: processedParams
      }
    );
    if (response.finishReason === "tool-calls") {
      const toolCalls = response.toolCalls;
      if (!toolCalls || !Array.isArray(toolCalls)) {
        return response;
      }
      for (const toolCall of toolCalls) {
        const clientTool = params.clientTools?.[toolCall.toolName];
        if (clientTool && clientTool.execute) {
          const result = await clientTool.execute(toolCall?.args, {
            requestContext,
            tracingContext: { currentSpan: void 0 },
            agent: {
              messages: response.messages,
              toolCallId: toolCall?.toolCallId,
              suspend: async () => {
              },
              threadId,
              resourceId
            }
          });
          const updatedMessages = [
            ...response.response.messages,
            {
              role: "tool",
              content: [
                {
                  type: "tool-result",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  result
                }
              ]
            }
          ];
          return this.generate({
            ...params,
            messages: updatedMessages
          });
        }
      }
    }
    return response;
  }
  async generate(messages, options) {
    const params = {
      ...options,
      messages
    };
    const processedParams = {
      ...params,
      requestContext: parseClientRequestContext(params.requestContext),
      clientTools: processClientTools(params.clientTools),
      structuredOutput: params.structuredOutput ? {
        ...params.structuredOutput,
        schema: zodToJsonSchema2(params.structuredOutput.schema)
      } : void 0
    };
    const { memory, requestContext } = processedParams;
    const { resource, thread } = memory ?? {};
    const resourceId = resource;
    const threadId = typeof thread === "string" ? thread : thread?.id;
    const response = await this.request(
      `/api/agents/${this.agentId}/generate`,
      {
        method: "POST",
        body: processedParams
      }
    );
    if (response.finishReason === "tool-calls") {
      return executeToolCallAndRespond({
        response,
        params,
        resourceId,
        threadId,
        requestContext,
        respondFn: this.generate.bind(this)
      });
    }
    return response;
  }
  async processChatResponse({
    stream,
    update,
    onToolCall,
    onFinish,
    getCurrentDate = () => /* @__PURE__ */ new Date(),
    lastMessage
  }) {
    const replaceLastMessage = lastMessage?.role === "assistant";
    let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:
    (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {
      return Math.max(max, toolInvocation.step ?? 0);
    }, 0) ?? 0) : 0;
    const message = replaceLastMessage ? structuredClone(lastMessage) : {
      id: uuid.v4(),
      createdAt: getCurrentDate(),
      role: "assistant",
      content: "",
      parts: []
    };
    let currentTextPart = void 0;
    let currentReasoningPart = void 0;
    let currentReasoningTextDetail = void 0;
    function updateToolInvocationPart(toolCallId, invocation) {
      const part = message.parts.find(
        (part2) => part2.type === "tool-invocation" && part2.toolInvocation.toolCallId === toolCallId
      );
      if (part != null) {
        part.toolInvocation = invocation;
      } else {
        message.parts.push({
          type: "tool-invocation",
          toolInvocation: invocation
        });
      }
    }
    const data = [];
    let messageAnnotations = replaceLastMessage ? lastMessage?.annotations : void 0;
    const partialToolCalls = {};
    let usage = {
      completionTokens: NaN,
      promptTokens: NaN,
      totalTokens: NaN
    };
    let finishReason = "unknown";
    function execUpdate() {
      const copiedData = [...data];
      if (messageAnnotations?.length) {
        message.annotations = messageAnnotations;
      }
      const copiedMessage = {
        // deep copy the message to ensure that deep changes (msg attachments) are updated
        // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.
        ...structuredClone(message),
        // add a revision id to ensure that the message is updated with SWR. SWR uses a
        // hashing approach by default to detect changes, but it only works for shallow
        // changes. This is why we need to add a revision id to ensure that the message
        // is updated with SWR (without it, the changes get stuck in SWR and are not
        // forwarded to rendering):
        revisionId: uuid.v4()
      };
      update({
        message: copiedMessage,
        data: copiedData,
        replaceLastMessage
      });
    }
    await processDataStream({
      stream,
      onTextPart(value) {
        if (currentTextPart == null) {
          currentTextPart = {
            type: "text",
            text: value
          };
          message.parts.push(currentTextPart);
        } else {
          currentTextPart.text += value;
        }
        message.content += value;
        execUpdate();
      },
      onReasoningPart(value) {
        if (currentReasoningTextDetail == null) {
          currentReasoningTextDetail = { type: "text", text: value };
          if (currentReasoningPart != null) {
            currentReasoningPart.details.push(currentReasoningTextDetail);
          }
        } else {
          currentReasoningTextDetail.text += value;
        }
        if (currentReasoningPart == null) {
          currentReasoningPart = {
            type: "reasoning",
            reasoning: value,
            details: [currentReasoningTextDetail]
          };
          message.parts.push(currentReasoningPart);
        } else {
          currentReasoningPart.reasoning += value;
        }
        message.reasoning = (message.reasoning ?? "") + value;
        execUpdate();
      },
      onReasoningSignaturePart(value) {
        if (currentReasoningTextDetail != null) {
          currentReasoningTextDetail.signature = value.signature;
        }
      },
      onRedactedReasoningPart(value) {
        if (currentReasoningPart == null) {
          currentReasoningPart = {
            type: "reasoning",
            reasoning: "",
            details: []
          };
          message.parts.push(currentReasoningPart);
        }
        currentReasoningPart.details.push({
          type: "redacted",
          data: value.data
        });
        currentReasoningTextDetail = void 0;
        execUpdate();
      },
      onFilePart(value) {
        message.parts.push({
          type: "file",
          mimeType: value.mimeType,
          data: value.data
        });
        execUpdate();
      },
      onSourcePart(value) {
        message.parts.push({
          type: "source",
          source: value
        });
        execUpdate();
      },
      onToolCallStreamingStartPart(value) {
        if (message.toolInvocations == null) {
          message.toolInvocations = [];
        }
        partialToolCalls[value.toolCallId] = {
          text: "",
          step,
          toolName: value.toolName,
          index: message.toolInvocations.length
        };
        const invocation = {
          state: "partial-call",
          step,
          toolCallId: value.toolCallId,
          toolName: value.toolName,
          args: void 0
        };
        message.toolInvocations.push(invocation);
        updateToolInvocationPart(value.toolCallId, invocation);
        execUpdate();
      },
      onToolCallDeltaPart(value) {
        const partialToolCall = partialToolCalls[value.toolCallId];
        partialToolCall.text += value.argsTextDelta;
        const { value: partialArgs } = parsePartialJson(partialToolCall.text);
        const invocation = {
          state: "partial-call",
          step: partialToolCall.step,
          toolCallId: value.toolCallId,
          toolName: partialToolCall.toolName,
          args: partialArgs
        };
        message.toolInvocations[partialToolCall.index] = invocation;
        updateToolInvocationPart(value.toolCallId, invocation);
        execUpdate();
      },
      async onToolCallPart(value) {
        const invocation = {
          state: "call",
          step,
          ...value
        };
        if (partialToolCalls[value.toolCallId] != null) {
          message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;
        } else {
          if (message.toolInvocations == null) {
            message.toolInvocations = [];
          }
          message.toolInvocations.push(invocation);
        }
        updateToolInvocationPart(value.toolCallId, invocation);
        execUpdate();
        if (onToolCall) {
          const result = await onToolCall({ toolCall: value });
          if (result != null) {
            const invocation2 = {
              state: "result",
              step,
              ...value,
              result
            };
            message.toolInvocations[message.toolInvocations.length - 1] = invocation2;
            updateToolInvocationPart(value.toolCallId, invocation2);
            execUpdate();
          }
        }
      },
      onToolResultPart(value) {
        const toolInvocations = message.toolInvocations;
        if (toolInvocations == null) {
          throw new Error("tool_result must be preceded by a tool_call");
        }
        const toolInvocationIndex = toolInvocations.findIndex((invocation2) => invocation2.toolCallId === value.toolCallId);
        if (toolInvocationIndex === -1) {
          throw new Error("tool_result must be preceded by a tool_call with the same toolCallId");
        }
        const invocation = {
          ...toolInvocations[toolInvocationIndex],
          state: "result",
          ...value
        };
        toolInvocations[toolInvocationIndex] = invocation;
        updateToolInvocationPart(value.toolCallId, invocation);
        execUpdate();
      },
      onDataPart(value) {
        data.push(...value);
        execUpdate();
      },
      onMessageAnnotationsPart(value) {
        if (messageAnnotations == null) {
          messageAnnotations = [...value];
        } else {
          messageAnnotations.push(...value);
        }
        execUpdate();
      },
      onFinishStepPart(value) {
        step += 1;
        currentTextPart = value.isContinued ? currentTextPart : void 0;
        currentReasoningPart = void 0;
        currentReasoningTextDetail = void 0;
      },
      onStartStepPart(value) {
        if (!replaceLastMessage) {
          message.id = value.messageId;
        }
        message.parts.push({ type: "step-start" });
        execUpdate();
      },
      onFinishMessagePart(value) {
        finishReason = value.finishReason;
        if (value.usage != null) {
          usage = value.usage;
        }
      },
      onErrorPart(error) {
        throw new Error(error);
      }
    });
    onFinish?.({ message, finishReason, usage });
  }
  /**
   * Streams a response from the agent
   * @param params - Stream parameters including prompt
   * @returns Promise containing the enhanced Response object with processDataStream method
   */
  async streamLegacy(params) {
    const processedParams = {
      ...params,
      output: params.output ? zodToJsonSchema2(params.output) : void 0,
      experimental_output: params.experimental_output ? zodToJsonSchema2(params.experimental_output) : void 0,
      requestContext: parseClientRequestContext(params.requestContext),
      clientTools: processClientTools(params.clientTools)
    };
    const { readable, writable } = new TransformStream();
    const response = await this.processStreamResponseLegacy(processedParams, writable);
    const streamResponse = new Response(readable, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async (options = {}) => {
      await processDataStream({
        stream: streamResponse.body,
        ...options
      });
    };
    return streamResponse;
  }
  async processChatResponse_vNext({
    stream,
    update,
    onToolCall,
    onFinish,
    getCurrentDate = () => /* @__PURE__ */ new Date(),
    lastMessage
  }) {
    const replaceLastMessage = lastMessage?.role === "assistant";
    let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:
    (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {
      return Math.max(max, toolInvocation.step ?? 0);
    }, 0) ?? 0) : 0;
    const message = replaceLastMessage ? structuredClone(lastMessage) : {
      id: uuid.v4(),
      createdAt: getCurrentDate(),
      role: "assistant",
      content: "",
      parts: []
    };
    let currentTextPart = void 0;
    let currentReasoningPart = void 0;
    let currentReasoningTextDetail = void 0;
    function updateToolInvocationPart(toolCallId, invocation) {
      const part = message.parts.find(
        (part2) => part2.type === "tool-invocation" && part2.toolInvocation.toolCallId === toolCallId
      );
      if (part != null) {
        part.toolInvocation = invocation;
      } else {
        message.parts.push({
          type: "tool-invocation",
          toolInvocation: invocation
        });
      }
    }
    const data = [];
    let messageAnnotations = replaceLastMessage ? lastMessage?.annotations : void 0;
    const partialToolCalls = {};
    let usage = {
      completionTokens: NaN,
      promptTokens: NaN,
      totalTokens: NaN
    };
    let finishReason = "unknown";
    function execUpdate() {
      const copiedData = [...data];
      if (messageAnnotations?.length) {
        message.annotations = messageAnnotations;
      }
      const copiedMessage = {
        // deep copy the message to ensure that deep changes (msg attachments) are updated
        // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.
        ...structuredClone(message),
        // add a revision id to ensure that the message is updated with SWR. SWR uses a
        // hashing approach by default to detect changes, but it only works for shallow
        // changes. This is why we need to add a revision id to ensure that the message
        // is updated with SWR (without it, the changes get stuck in SWR and are not
        // forwarded to rendering):
        revisionId: uuid.v4()
      };
      update({
        message: copiedMessage,
        data: copiedData,
        replaceLastMessage
      });
    }
    await processMastraStream({
      stream,
      // TODO: casting as any here because the stream types were all typed as any before in core.
      // but this is completely wrong and this fn is probably broken. Remove ":any" and you'll see a bunch of type errors
      onChunk: async (chunk) => {
        switch (chunk.type) {
          case "tripwire": {
            message.parts.push({
              type: "text",
              text: chunk.payload.reason
            });
            execUpdate();
            break;
          }
          case "step-start": {
            if (!replaceLastMessage) {
              message.id = chunk.payload.messageId;
            }
            message.parts.push({ type: "step-start" });
            execUpdate();
            break;
          }
          case "text-delta": {
            if (currentTextPart == null) {
              currentTextPart = {
                type: "text",
                text: chunk.payload.text
              };
              message.parts.push(currentTextPart);
            } else {
              currentTextPart.text += chunk.payload.text;
            }
            message.content += chunk.payload.text;
            execUpdate();
            break;
          }
          case "reasoning-delta": {
            if (currentReasoningTextDetail == null) {
              currentReasoningTextDetail = { type: "text", text: chunk.payload.text };
              if (currentReasoningPart != null) {
                currentReasoningPart.details.push(currentReasoningTextDetail);
              }
            } else {
              currentReasoningTextDetail.text += chunk.payload.text;
            }
            if (currentReasoningPart == null) {
              currentReasoningPart = {
                type: "reasoning",
                reasoning: chunk.payload.text,
                details: [currentReasoningTextDetail]
              };
              message.parts.push(currentReasoningPart);
            } else {
              currentReasoningPart.reasoning += chunk.payload.text;
            }
            message.reasoning = (message.reasoning ?? "") + chunk.payload.text;
            execUpdate();
            break;
          }
          case "file": {
            message.parts.push({
              type: "file",
              mimeType: chunk.payload.mimeType,
              data: chunk.payload.data
            });
            execUpdate();
            break;
          }
          case "source": {
            message.parts.push({
              type: "source",
              source: chunk.payload.source
            });
            execUpdate();
            break;
          }
          case "tool-call": {
            const invocation = {
              state: "call",
              step,
              ...chunk.payload
            };
            if (partialToolCalls[chunk.payload.toolCallId] != null) {
              message.toolInvocations[partialToolCalls[chunk.payload.toolCallId].index] = invocation;
            } else {
              if (message.toolInvocations == null) {
                message.toolInvocations = [];
              }
              message.toolInvocations.push(invocation);
            }
            updateToolInvocationPart(chunk.payload.toolCallId, invocation);
            execUpdate();
            if (onToolCall) {
              const result = await onToolCall({ toolCall: chunk.payload });
              if (result != null) {
                const invocation2 = {
                  state: "result",
                  step,
                  ...chunk.payload,
                  result
                };
                message.toolInvocations[message.toolInvocations.length - 1] = invocation2;
                updateToolInvocationPart(chunk.payload.toolCallId, invocation2);
                execUpdate();
              }
            }
          }
          case "tool-call-input-streaming-start": {
            if (message.toolInvocations == null) {
              message.toolInvocations = [];
            }
            partialToolCalls[chunk.payload.toolCallId] = {
              text: "",
              step,
              toolName: chunk.payload.toolName,
              index: message.toolInvocations.length
            };
            const invocation = {
              state: "partial-call",
              step,
              toolCallId: chunk.payload.toolCallId,
              toolName: chunk.payload.toolName,
              args: chunk.payload.args
            };
            message.toolInvocations.push(invocation);
            updateToolInvocationPart(chunk.payload.toolCallId, invocation);
            execUpdate();
            break;
          }
          case "tool-call-delta": {
            const partialToolCall = partialToolCalls[chunk.payload.toolCallId];
            partialToolCall.text += chunk.payload.argsTextDelta;
            const { value: partialArgs } = parsePartialJson(partialToolCall.text);
            const invocation = {
              state: "partial-call",
              step: partialToolCall.step,
              toolCallId: chunk.payload.toolCallId,
              toolName: partialToolCall.toolName,
              args: partialArgs
            };
            message.toolInvocations[partialToolCall.index] = invocation;
            updateToolInvocationPart(chunk.payload.toolCallId, invocation);
            execUpdate();
            break;
          }
          case "tool-result": {
            const toolInvocations = message.toolInvocations;
            if (toolInvocations == null) {
              throw new Error("tool_result must be preceded by a tool_call");
            }
            const toolInvocationIndex = toolInvocations.findIndex(
              (invocation2) => invocation2.toolCallId === chunk.payload.toolCallId
            );
            if (toolInvocationIndex === -1) {
              throw new Error("tool_result must be preceded by a tool_call with the same toolCallId");
            }
            const invocation = {
              ...toolInvocations[toolInvocationIndex],
              state: "result",
              ...chunk.payload
            };
            toolInvocations[toolInvocationIndex] = invocation;
            updateToolInvocationPart(chunk.payload.toolCallId, invocation);
            execUpdate();
            break;
          }
          case "error": {
            throw error.getErrorFromUnknown(chunk.payload.error, {
              fallbackMessage: "Unknown error in stream",
              supportSerialization: false
            });
          }
          case "data": {
            data.push(...chunk.payload.data);
            execUpdate();
            break;
          }
          case "step-finish": {
            step += 1;
            currentTextPart = chunk.payload.stepResult.isContinued ? currentTextPart : void 0;
            currentReasoningPart = void 0;
            currentReasoningTextDetail = void 0;
            execUpdate();
            break;
          }
          case "finish": {
            finishReason = chunk.payload.stepResult.reason;
            if (chunk.payload.usage != null) {
              usage = chunk.payload.usage;
            }
            break;
          }
        }
      }
    });
    onFinish?.({ message, finishReason, usage });
  }
  async processStreamResponse(processedParams, controller, route = "stream") {
    const response = await this.request(`/api/agents/${this.agentId}/${route}`, {
      method: "POST",
      body: processedParams,
      stream: true
    });
    if (!response.body) {
      throw new Error("No response body");
    }
    try {
      let toolCalls = [];
      let messages = [];
      const [streamForController, streamForProcessing] = response.body.tee();
      const pipePromise = streamForController.pipeTo(
        new WritableStream({
          async write(chunk) {
            try {
              const text = new TextDecoder().decode(chunk);
              const lines = text.split("\n\n");
              const readableLines = lines.filter((line) => line.trim() !== "[DONE]" && line.trim() !== "data: [DONE]").join("\n\n");
              if (readableLines) {
                const encoded = new TextEncoder().encode(readableLines);
                controller.enqueue(encoded);
              }
            } catch (error) {
              console.error("Error enqueueing to controller:", error);
              controller.enqueue(chunk);
            }
          }
        })
      ).catch((error) => {
        console.error("Error piping to controller:", error);
        try {
          controller.close();
        } catch {
        }
      });
      this.processChatResponse_vNext({
        stream: streamForProcessing,
        update: ({ message }) => {
          const existingIndex = messages.findIndex((m) => m.id === message.id);
          if (existingIndex !== -1) {
            messages[existingIndex] = message;
          } else {
            messages.push(message);
          }
        },
        onFinish: async ({ finishReason, message }) => {
          if (finishReason === "tool-calls") {
            const toolCall = [...message?.parts ?? []].reverse().find((part) => part.type === "tool-invocation")?.toolInvocation;
            if (toolCall) {
              toolCalls.push(toolCall);
            }
            let shouldExecuteClientTool = false;
            for (const toolCall2 of toolCalls) {
              const clientTool = processedParams.clientTools?.[toolCall2.toolName];
              if (clientTool && clientTool.execute) {
                shouldExecuteClientTool = true;
                const result = await clientTool.execute(toolCall2?.args, {
                  requestContext: processedParams.requestContext,
                  // TODO: Pass proper tracing context when client-js supports tracing
                  tracingContext: { currentSpan: void 0 },
                  agent: {
                    messages: response.messages,
                    toolCallId: toolCall2?.toolCallId,
                    suspend: async () => {
                    },
                    threadId: processedParams.threadId,
                    resourceId: processedParams.resourceId
                  }
                });
                const lastMessageRaw = messages[messages.length - 1];
                const lastMessage = lastMessageRaw != null ? JSON.parse(JSON.stringify(lastMessageRaw)) : void 0;
                const toolInvocationPart = lastMessage?.parts?.find(
                  (part) => part.type === "tool-invocation" && part.toolInvocation?.toolCallId === toolCall2.toolCallId
                );
                if (toolInvocationPart) {
                  toolInvocationPart.toolInvocation = {
                    ...toolInvocationPart.toolInvocation,
                    state: "result",
                    result
                  };
                }
                const toolInvocation = lastMessage?.toolInvocations?.find(
                  (toolInvocation2) => toolInvocation2.toolCallId === toolCall2.toolCallId
                );
                if (toolInvocation) {
                  toolInvocation.state = "result";
                  toolInvocation.result = result;
                }
                const updatedMessages = lastMessage != null ? [...messages.filter((m) => m.id !== lastMessage.id), lastMessage] : [...messages];
                try {
                  await this.processStreamResponse(
                    {
                      ...processedParams,
                      messages: updatedMessages
                    },
                    controller
                  );
                } catch (error) {
                  console.error("Error processing recursive stream response:", error);
                }
              }
            }
            if (!shouldExecuteClientTool) {
              await pipePromise;
              controller.close();
            }
          } else {
            await pipePromise;
            controller.close();
          }
        },
        lastMessage: void 0
      }).catch(async (error) => {
        console.error("Error processing stream response:", error);
        try {
          await pipePromise;
          controller.close();
        } catch {
        }
      });
    } catch (error) {
      console.error("Error processing stream response:", error);
    }
    return response;
  }
  async network(params) {
    const response = await this.request(`/api/agents/${this.agentId}/network`, {
      method: "POST",
      body: params,
      stream: true
    });
    if (!response.body) {
      throw new Error("No response body");
    }
    const streamResponse = new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraNetworkStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  async approveNetworkToolCall(params) {
    const response = await this.request(`/api/agents/${this.agentId}/approve-network-tool-call`, {
      method: "POST",
      body: params,
      stream: true
    });
    if (!response.body) {
      throw new Error("No response body");
    }
    const streamResponse = new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraNetworkStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  async declineNetworkToolCall(params) {
    const response = await this.request(`/api/agents/${this.agentId}/decline-network-tool-call`, {
      method: "POST",
      body: params,
      stream: true
    });
    if (!response.body) {
      throw new Error("No response body");
    }
    const streamResponse = new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraNetworkStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  async stream(messagesOrParams, options) {
    let params = {
      messages: messagesOrParams,
      ...options
    };
    const processedParams = {
      ...params,
      requestContext: parseClientRequestContext(params.requestContext),
      clientTools: processClientTools(params.clientTools),
      structuredOutput: params.structuredOutput ? {
        ...params.structuredOutput,
        schema: zodToJsonSchema2(params.structuredOutput.schema)
      } : void 0
    };
    let readableController;
    const readable = new ReadableStream({
      start(controller) {
        readableController = controller;
      }
    });
    const response = await this.processStreamResponse(processedParams, readableController);
    const streamResponse = new Response(readable, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  async approveToolCall(params) {
    let readableController;
    const readable = new ReadableStream({
      start(controller) {
        readableController = controller;
      }
    });
    const response = await this.processStreamResponse(params, readableController, "approve-tool-call");
    const streamResponse = new Response(readable, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  async declineToolCall(params) {
    let readableController;
    const readable = new ReadableStream({
      start(controller) {
        readableController = controller;
      }
    });
    const response = await this.processStreamResponse(params, readableController, "decline-tool-call");
    const streamResponse = new Response(readable, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
    streamResponse.processDataStream = async ({
      onChunk
    }) => {
      await processMastraStream({
        stream: streamResponse.body,
        onChunk
      });
    };
    return streamResponse;
  }
  /**
   * Processes the stream response and handles tool calls
   */
  async processStreamResponseLegacy(processedParams, writable) {
    const response = await this.request(`/api/agents/${this.agentId}/stream-legacy`, {
      method: "POST",
      body: processedParams,
      stream: true
    });
    if (!response.body) {
      throw new Error("No response body");
    }
    try {
      let toolCalls = [];
      let messages = [];
      const [streamForWritable, streamForProcessing] = response.body.tee();
      streamForWritable.pipeTo(writable, {
        preventClose: true
      }).catch((error) => {
        console.error("Error piping to writable stream:", error);
      });
      this.processChatResponse({
        stream: streamForProcessing,
        update: ({ message }) => {
          const existingIndex = messages.findIndex((m) => m.id === message.id);
          if (existingIndex !== -1) {
            messages[existingIndex] = message;
          } else {
            messages.push(message);
          }
        },
        onFinish: async ({ finishReason, message }) => {
          if (finishReason === "tool-calls") {
            const toolCall = [...message?.parts ?? []].reverse().find((part) => part.type === "tool-invocation")?.toolInvocation;
            if (toolCall) {
              toolCalls.push(toolCall);
            }
            for (const toolCall2 of toolCalls) {
              const clientTool = processedParams.clientTools?.[toolCall2.toolName];
              if (clientTool && clientTool.execute) {
                const result = await clientTool.execute(toolCall2?.args, {
                  requestContext: processedParams.requestContext,
                  // TODO: Pass proper tracing context when client-js supports tracing
                  tracingContext: { currentSpan: void 0 },
                  agent: {
                    messages: response.messages,
                    toolCallId: toolCall2?.toolCallId,
                    suspend: async () => {
                    },
                    threadId: processedParams.threadId,
                    resourceId: processedParams.resourceId
                  }
                });
                const lastMessage = JSON.parse(JSON.stringify(messages[messages.length - 1]));
                const toolInvocationPart = lastMessage?.parts?.find(
                  (part) => part.type === "tool-invocation" && part.toolInvocation?.toolCallId === toolCall2.toolCallId
                );
                if (toolInvocationPart) {
                  toolInvocationPart.toolInvocation = {
                    ...toolInvocationPart.toolInvocation,
                    state: "result",
                    result
                  };
                }
                const toolInvocation = lastMessage?.toolInvocations?.find(
                  (toolInvocation2) => toolInvocation2.toolCallId === toolCall2.toolCallId
                );
                if (toolInvocation) {
                  toolInvocation.state = "result";
                  toolInvocation.result = result;
                }
                const writer = writable.getWriter();
                try {
                  await writer.write(
                    new TextEncoder().encode(
                      "a:" + JSON.stringify({
                        toolCallId: toolCall2.toolCallId,
                        result
                      }) + "\n"
                    )
                  );
                } finally {
                  writer.releaseLock();
                }
                this.processStreamResponseLegacy(
                  {
                    ...processedParams,
                    messages: [...messages.filter((m) => m.id !== lastMessage.id), lastMessage]
                  },
                  writable
                ).catch((error) => {
                  console.error("Error processing stream response:", error);
                });
              }
            }
          } else {
            setTimeout(() => {
              writable.close();
            }, 0);
          }
        },
        lastMessage: void 0
      }).catch((error) => {
        console.error("Error processing stream response:", error);
      });
    } catch (error) {
      console.error("Error processing stream response:", error);
    }
    return response;
  }
  /**
   * Gets details about a specific tool available to the agent
   * @param toolId - ID of the tool to retrieve
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing tool details
   */
  getTool(toolId, requestContext) {
    return this.request(`/api/agents/${this.agentId}/tools/${toolId}${requestContextQueryString(requestContext)}`);
  }
  /**
   * Executes a tool for the agent
   * @param toolId - ID of the tool to execute
   * @param params - Parameters required for tool execution
   * @returns Promise containing the tool execution results
   */
  executeTool(toolId, params) {
    const body = {
      data: params.data,
      requestContext: parseClientRequestContext(params.requestContext)
    };
    return this.request(`/api/agents/${this.agentId}/tools/${toolId}/execute`, {
      method: "POST",
      body
    });
  }
  /**
   * Updates the model for the agent
   * @param params - Parameters for updating the model
   * @returns Promise containing the updated model
   */
  updateModel(params) {
    return this.request(`/api/agents/${this.agentId}/model`, {
      method: "POST",
      body: params
    });
  }
  /**
   * Resets the agent's model to the original model that was set during construction
   * @returns Promise containing a success message
   */
  resetModel() {
    return this.request(`/api/agents/${this.agentId}/model/reset`, {
      method: "POST",
      body: {}
    });
  }
  /**
   * Updates the model for the agent in the model list
   * @param params - Parameters for updating the model
   * @returns Promise containing the updated model
   */
  updateModelInModelList({ modelConfigId, ...params }) {
    return this.request(`/api/agents/${this.agentId}/models/${modelConfigId}`, {
      method: "POST",
      body: params
    });
  }
  /**
   * Reorders the models for the agent
   * @param params - Parameters for reordering the model list
   * @returns Promise containing the updated model list
   */
  reorderModelList(params) {
    return this.request(`/api/agents/${this.agentId}/models/reorder`, {
      method: "POST",
      body: params
    });
  }
};

// src/resources/memory-thread.ts
var MemoryThread = class extends BaseResource {
  constructor(options, threadId, agentId) {
    super(options);
    this.threadId = threadId;
    this.agentId = agentId;
  }
  /**
   * Builds the query string for agentId (if provided)
   */
  getAgentIdQueryParam(prefix = "?") {
    return this.agentId ? `${prefix}agentId=${this.agentId}` : "";
  }
  /**
   * Retrieves the memory thread details
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing thread details including title and metadata
   */
  get(requestContext) {
    const agentIdParam = this.getAgentIdQueryParam("?");
    const contextParam = requestContextQueryString(requestContext, agentIdParam ? "&" : "?");
    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`);
  }
  /**
   * Updates the memory thread properties
   * @param params - Update parameters including title, metadata, and optional request context
   * @returns Promise containing updated thread details
   */
  update(params) {
    const agentIdParam = this.getAgentIdQueryParam("?");
    const contextParam = requestContextQueryString(params.requestContext, agentIdParam ? "&" : "?");
    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`, {
      method: "PATCH",
      body: params
    });
  }
  /**
   * Deletes the memory thread
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing deletion result
   */
  delete(requestContext) {
    const agentIdParam = this.getAgentIdQueryParam("?");
    const contextParam = requestContextQueryString(requestContext, agentIdParam ? "&" : "?");
    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`, {
      method: "DELETE"
    });
  }
  /**
   * Retrieves paginated messages associated with the thread with filtering and ordering options
   * @param params - Pagination parameters including page, perPage, orderBy, filter, include options, and request context
   * @returns Promise containing paginated thread messages with pagination metadata (total, page, perPage, hasMore)
   */
  listMessages(params = {}) {
    const { page, perPage, orderBy, filter, include, resourceId, requestContext } = params;
    const queryParams = {};
    if (this.agentId) queryParams.agentId = this.agentId;
    if (resourceId) queryParams.resourceId = resourceId;
    if (page !== void 0) queryParams.page = String(page);
    if (perPage !== void 0) queryParams.perPage = String(perPage);
    if (orderBy) queryParams.orderBy = JSON.stringify(orderBy);
    if (filter) queryParams.filter = JSON.stringify(filter);
    if (include) queryParams.include = JSON.stringify(include);
    const query = new URLSearchParams(queryParams);
    const queryString = query.toString();
    const url = `/api/memory/threads/${this.threadId}/messages${queryString ? `?${queryString}` : ""}${requestContextQueryString(requestContext, queryString ? "&" : "?")}`;
    return this.request(url);
  }
  /**
   * Deletes one or more messages from the thread
   * @param messageIds - Can be a single message ID (string), array of message IDs,
   *                     message object with id property, or array of message objects
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing deletion result
   */
  deleteMessages(messageIds, requestContext) {
    const queryParams = {};
    if (this.agentId) queryParams.agentId = this.agentId;
    const query = new URLSearchParams(queryParams);
    const queryString = query.toString();
    return this.request(
      `/api/memory/messages/delete${queryString ? `?${queryString}` : ""}${requestContextQueryString(requestContext, queryString ? "&" : "?")}`,
      {
        method: "POST",
        body: { messageIds }
      }
    );
  }
  /**
   * Clones the thread with all its messages to a new thread
   * @param params - Clone parameters including optional new thread ID, title, metadata, and message filters
   * @returns Promise containing the cloned thread and copied messages
   */
  clone(params = {}) {
    const { requestContext, ...body } = params;
    const agentIdParam = this.getAgentIdQueryParam("?");
    const contextParam = requestContextQueryString(requestContext, agentIdParam ? "&" : "?");
    return this.request(`/api/memory/threads/${this.threadId}/clone${agentIdParam}${contextParam}`, {
      method: "POST",
      body
    });
  }
};

// src/resources/vector.ts
var Vector = class extends BaseResource {
  constructor(options, vectorName) {
    super(options);
    this.vectorName = vectorName;
  }
  /**
   * Retrieves details about a specific vector index
   * @param indexName - Name of the index to get details for
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing vector index details
   */
  details(indexName, requestContext) {
    return this.request(
      `/api/vector/${this.vectorName}/indexes/${indexName}${requestContextQueryString(requestContext)}`
    );
  }
  /**
   * Deletes a vector index
   * @param indexName - Name of the index to delete
   * @returns Promise indicating deletion success
   */
  delete(indexName) {
    return this.request(`/api/vector/${this.vectorName}/indexes/${indexName}`, {
      method: "DELETE"
    });
  }
  /**
   * Retrieves a list of all available indexes
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing array of index names
   */
  getIndexes(requestContext) {
    return this.request(`/api/vector/${this.vectorName}/indexes${requestContextQueryString(requestContext)}`);
  }
  /**
   * Creates a new vector index
   * @param params - Parameters for index creation including dimension and metric
   * @returns Promise indicating creation success
   */
  createIndex(params) {
    return this.request(`/api/vector/${this.vectorName}/create-index`, {
      method: "POST",
      body: params
    });
  }
  /**
   * Upserts vectors into an index
   * @param params - Parameters containing vectors, metadata, and optional IDs
   * @returns Promise containing array of vector IDs
   */
  upsert(params) {
    return this.request(`/api/vector/${this.vectorName}/upsert`, {
      method: "POST",
      body: params
    });
  }
  /**
   * Queries vectors in an index
   * @param params - Query parameters including query vector and search options
   * @returns Promise containing query results
   */
  query(params) {
    return this.request(`/api/vector/${this.vectorName}/query`, {
      method: "POST",
      body: params
    });
  }
};

// src/resources/tool.ts
var Tool = class extends BaseResource {
  constructor(options, toolId) {
    super(options);
    this.toolId = toolId;
  }
  /**
   * Retrieves details about the tool
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing tool details including description and schemas
   */
  details(requestContext) {
    return this.request(`/api/tools/${this.toolId}${requestContextQueryString(requestContext)}`);
  }
  /**
   * Executes the tool with the provided parameters
   * @param params - Parameters required for tool execution
   * @returns Promise containing the tool execution results
   */
  execute(params) {
    const url = new URLSearchParams();
    if (params.runId) {
      url.set("runId", params.runId);
    }
    const body = {
      data: params.data,
      requestContext: parseClientRequestContext(params.requestContext)
    };
    return this.request(`/api/tools/${this.toolId}/execute?${url.toString()}`, {
      method: "POST",
      body
    });
  }
};
function deserializeWorkflowError(result) {
  if (result.status === "failed" && result.error) {
    result.error = error.getErrorFromUnknown(result.error, {
      fallbackMessage: "Unknown workflow error",
      supportSerialization: false
    });
  }
  return result;
}
var RECORD_SEPARATOR = "";
var Run = class extends BaseResource {
  constructor(options, workflowId, runId) {
    super(options);
    this.workflowId = workflowId;
    this.runId = runId;
  }
  /**
   * Creates a transform stream that parses RECORD_SEPARATOR-delimited JSON chunks
   */
  createChunkTransformStream() {
    let failedChunk = void 0;
    return new TransformStream({
      start() {
      },
      async transform(chunk, controller) {
        try {
          const decoded = new TextDecoder().decode(chunk);
          const chunks = decoded.split(RECORD_SEPARATOR);
          for (const chunk2 of chunks) {
            if (chunk2) {
              const newChunk = failedChunk ? failedChunk + chunk2 : chunk2;
              try {
                const parsedChunk = JSON.parse(newChunk);
                controller.enqueue(parsedChunk);
                failedChunk = void 0;
              } catch {
                failedChunk = newChunk;
              }
            }
          }
        } catch {
        }
      }
    });
  }
  /**
   * Cancels a specific workflow run by its ID
   * @returns Promise containing a success message
   * @deprecated Use `cancel()` instead
   */
  cancelRun() {
    return this.request(`/api/workflows/${this.workflowId}/runs/${this.runId}/cancel`, {
      method: "POST"
    });
  }
  /**
   * Cancels a workflow run.
   *
   * This method aborts any running steps and updates the workflow status to 'canceled' .
   * It works for both actively running workflows and suspended/waiting workflows.
   *
   * ## How cancellation works
   *
   * When called, the workflow will:
   * 1. **Trigger the abort signal** - Uses the standard Web API AbortSignal to notify running steps
   * 2. **Prevent subsequent steps** - No further steps will be executed
   *
   * ## Abort signal behavior
   *
   * Steps that check the `abortSignal` parameter can respond to cancellation:
   * - Steps can listen to the 'abort' event: `abortSignal.addEventListener('abort', callback)`
   * - Steps can check if already aborted: `if (abortSignal.aborted) { ... }`
   * - Useful for canceling timeouts, network requests, or long-running operations
   *
   * **Note:** Steps must actively check the abort signal to be canceled mid-execution.
   * Steps that don't check the signal will run to completion, but subsequent steps won't execute.
   *
   * @returns Promise that resolves with `{ message: 'Workflow run canceled' }` when cancellation succeeds
   * @throws {HTTPException} 400 - If workflow ID or run ID is missing
   * @throws {HTTPException} 404 - If workflow or workflow run is not found
   *
   * @example
   * ```typescript
   * const run = await workflow.createRun({ runId: 'run-123' });
   * await run.cancel();
   * // Returns: { message: 'Workflow run canceled' }
   * ```
   *
   * @example
   * ```typescript
   * // Example of a step that responds to cancellation
   * const step = createStep({
   *   id: 'long-running-step',
   *   execute: async ({ inputData, abortSignal, abort }) => {
   *     const timeout = new Promise((resolve) => {
   *       const timer = setTimeout(() => resolve('done'), 10000);
   *
   *       // Clean up if canceled
   *       abortSignal.addEventListener('abort', () => {
   *         clearTimeout(timer);
   *         resolve('canceled');
   *       });
   *     });
   *
   *     const result = await timeout;
   *
   *     // Check if aborted after async operation
   *     if (abortSignal.aborted) {
   *       return abort(); // Stop execution
   *     }
   *
   *     return { result };
   *   }
   * });
   * ```
   */
  cancel() {
    return this.request(`/api/workflows/${this.workflowId}/runs/${this.runId}/cancel`, {
      method: "POST"
    });
  }
  /**
   * Starts a workflow run synchronously without waiting for the workflow to complete
   * @param params - Object containing the inputData, initialState and requestContext
   * @returns Promise containing success message
   */
  start(params) {
    const requestContext = parseClientRequestContext(params.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/start?runId=${this.runId}`, {
      method: "POST",
      body: {
        inputData: params?.inputData,
        initialState: params?.initialState,
        requestContext,
        tracingOptions: params.tracingOptions,
        perStep: params.perStep
      }
    });
  }
  /**
   * Resumes a suspended workflow step synchronously without waiting for the workflow to complete
   * @param params - Object containing the step, resumeData and requestContext
   * @returns Promise containing success message
   */
  resume({
    step,
    resumeData,
    tracingOptions,
    perStep,
    ...rest
  }) {
    const requestContext = parseClientRequestContext(rest.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/resume?runId=${this.runId}`, {
      method: "POST",
      body: {
        step,
        resumeData,
        requestContext,
        tracingOptions,
        perStep
      }
    });
  }
  /**
   * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete
   * @param params - Object containing the inputData, initialState and requestContext
   * @returns Promise containing the workflow execution results
   */
  startAsync(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", this.runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/start-async?${searchParams.toString()}`, {
      method: "POST",
      body: {
        inputData: params.inputData,
        initialState: params.initialState,
        requestContext,
        tracingOptions: params.tracingOptions,
        resourceId: params.resourceId,
        perStep: params.perStep
      }
    }).then(deserializeWorkflowError);
  }
  /**
   * Starts a workflow run and returns a stream
   * @param params - Object containing the inputData, initialState and requestContext
   * @returns Promise containing the workflow execution results
   */
  async stream(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", this.runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const response = await this.request(
      `/api/workflows/${this.workflowId}/stream?${searchParams.toString()}`,
      {
        method: "POST",
        body: {
          inputData: params.inputData,
          initialState: params.initialState,
          requestContext,
          tracingOptions: params.tracingOptions,
          resourceId: params.resourceId,
          perStep: params.perStep,
          closeOnSuspend: params.closeOnSuspend
        },
        stream: true
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to stream workflow: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createChunkTransformStream());
  }
  /**
   * Observes workflow stream for a workflow run
   * @returns Promise containing the workflow execution results
   */
  async observeStream() {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", this.runId);
    const response = await this.request(
      `/api/workflows/${this.workflowId}/observe-stream?${searchParams.toString()}`,
      {
        method: "POST",
        stream: true
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to observe workflow stream: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createChunkTransformStream());
  }
  /**
   * Resumes a suspended workflow step asynchronously and returns a promise that resolves when the workflow is complete
   * @param params - Object containing the step, resumeData and requestContext
   * @returns Promise containing the workflow resume results
   */
  resumeAsync(params) {
    const requestContext = parseClientRequestContext(params.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/resume-async?runId=${this.runId}`, {
      method: "POST",
      body: {
        step: params.step,
        resumeData: params.resumeData,
        requestContext,
        tracingOptions: params.tracingOptions,
        perStep: params.perStep
      }
    }).then(deserializeWorkflowError);
  }
  /**
   * Resumes a suspended workflow step that uses stream asynchronously and returns a promise that resolves when the workflow is complete
   * @param params - Object containing the step, resumeData and requestContext
   * @returns Promise containing the workflow resume results
   */
  async resumeStream(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", this.runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const response = await this.request(
      `/api/workflows/${this.workflowId}/resume-stream?${searchParams.toString()}`,
      {
        method: "POST",
        body: {
          step: params.step,
          resumeData: params.resumeData,
          requestContext,
          tracingOptions: params.tracingOptions,
          perStep: params.perStep
        },
        stream: true
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to stream vNext workflow: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createChunkTransformStream());
  }
  /**
   * Restarts an active workflow run synchronously without waiting for the workflow to complete
   * @param params - Object containing the requestContext
   * @returns Promise containing success message
   */
  restart(params) {
    const requestContext = parseClientRequestContext(params.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/restart?runId=${this.runId}`, {
      method: "POST",
      body: {
        requestContext,
        tracingOptions: params.tracingOptions
      }
    });
  }
  /**
   * Restarts an active workflow run asynchronously
   * @param params - optional object containing the requestContext
   * @returns Promise containing the workflow restart results
   */
  restartAsync(params) {
    const requestContext = parseClientRequestContext(params?.requestContext);
    return this.request(`/api/workflows/${this.workflowId}/restart-async?runId=${this.runId}`, {
      method: "POST",
      body: {
        requestContext,
        tracingOptions: params?.tracingOptions
      }
    }).then(deserializeWorkflowError);
  }
  /**
   * Time travels a workflow run synchronously without waiting for the workflow to complete
   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
   * @returns Promise containing success message
   */
  timeTravel({ requestContext: paramsRequestContext, ...params }) {
    const requestContext = parseClientRequestContext(paramsRequestContext);
    return this.request(`/api/workflows/${this.workflowId}/time-travel?runId=${this.runId}`, {
      method: "POST",
      body: {
        ...params,
        requestContext
      }
    });
  }
  /**
   * Time travels a workflow run asynchronously
   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
   * @returns Promise containing the workflow time travel results
   */
  timeTravelAsync({ requestContext: paramsRequestContext, ...params }) {
    const requestContext = parseClientRequestContext(paramsRequestContext);
    return this.request(`/api/workflows/${this.workflowId}/time-travel-async?runId=${this.runId}`, {
      method: "POST",
      body: {
        ...params,
        requestContext
      }
    }).then(deserializeWorkflowError);
  }
  /**
   * Time travels a workflow run and returns a stream
   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
   * @returns Promise containing the workflow execution results
   */
  async timeTravelStream({ requestContext: paramsRequestContext, ...params }) {
    const requestContext = parseClientRequestContext(paramsRequestContext);
    const response = await this.request(
      `/api/workflows/${this.workflowId}/time-travel-stream?runId=${this.runId}`,
      {
        method: "POST",
        body: {
          ...params,
          requestContext
        },
        stream: true
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to time travel workflow: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createChunkTransformStream());
  }
};

// src/resources/workflow.ts
var RECORD_SEPARATOR2 = "";
var Workflow = class extends BaseResource {
  constructor(options, workflowId) {
    super(options);
    this.workflowId = workflowId;
  }
  /**
   * Retrieves details about the workflow
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing workflow details including steps and graphs
   */
  details(requestContext) {
    return this.request(`/api/workflows/${this.workflowId}${requestContextQueryString(requestContext)}`);
  }
  /**
   * Retrieves all runs for a workflow
   * @param params - Parameters for filtering runs
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing workflow runs array
   */
  runs(params, requestContext) {
    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));
    const searchParams = new URLSearchParams();
    if (params?.fromDate) {
      searchParams.set("fromDate", params.fromDate.toISOString());
    }
    if (params?.toDate) {
      searchParams.set("toDate", params.toDate.toISOString());
    }
    if (params?.page !== void 0) {
      searchParams.set("page", String(params.page));
    }
    if (params?.perPage !== void 0) {
      searchParams.set("perPage", String(params.perPage));
    }
    if (params?.limit !== null && params?.limit !== void 0) {
      if (params.limit === false) {
        searchParams.set("limit", "false");
      } else if (typeof params.limit === "number" && params.limit > 0 && Number.isInteger(params.limit)) {
        searchParams.set("limit", String(params.limit));
      }
    }
    if (params?.offset !== null && params?.offset !== void 0 && !isNaN(Number(params?.offset))) {
      searchParams.set("offset", String(params.offset));
    }
    if (params?.resourceId) {
      searchParams.set("resourceId", params.resourceId);
    }
    if (params?.status) {
      searchParams.set("status", params.status);
    }
    if (requestContextParam) {
      searchParams.set("requestContext", requestContextParam);
    }
    if (searchParams.size) {
      return this.request(`/api/workflows/${this.workflowId}/runs?${searchParams}`);
    } else {
      return this.request(`/api/workflows/${this.workflowId}/runs`);
    }
  }
  /**
   * Retrieves a specific workflow run by its ID
   * @param runId - The ID of the workflow run to retrieve
   * @param options - Optional configuration
   * @param options.requestContext - Optional request context to pass as query parameter
   * @param options.fields - Optional array of fields to return (e.g., ['result', 'steps']). Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph. Metadata fields (runId, workflowName, resourceId, createdAt, updatedAt) and status are always included.
   * @param options.withNestedWorkflows - Whether to include nested workflow data in steps. Defaults to true. Set to false for better performance when you don't need nested workflow details.
   * @returns Promise containing the workflow run details with metadata and processed execution state
   */
  runById(runId, options) {
    const searchParams = new URLSearchParams();
    if (options?.fields && options.fields.length > 0) {
      searchParams.set("fields", options.fields.join(","));
    }
    if (options?.withNestedWorkflows !== void 0) {
      searchParams.set("withNestedWorkflows", String(options.withNestedWorkflows));
    }
    const requestContextParam = base64RequestContext(parseClientRequestContext(options?.requestContext));
    if (requestContextParam) {
      searchParams.set("requestContext", requestContextParam);
    }
    const queryString = searchParams.size > 0 ? `?${searchParams.toString()}` : "";
    return this.request(`/api/workflows/${this.workflowId}/runs/${runId}${queryString}`);
  }
  /**
   * Deletes a specific workflow run by its ID
   * @param runId - The ID of the workflow run to delete
   * @returns Promise containing a success message
   */
  deleteRunById(runId) {
    return this.request(`/api/workflows/${this.workflowId}/runs/${runId}`, {
      method: "DELETE"
    });
  }
  /**
   * Creates a new workflow run
   * @param params - Optional object containing the optional runId
   * @returns Promise containing the Run instance
   */
  async createRun(params) {
    const searchParams = new URLSearchParams();
    if (!!params?.runId) {
      searchParams.set("runId", params.runId);
    }
    const res = await this.request(
      `/api/workflows/${this.workflowId}/create-run?${searchParams.toString()}`,
      {
        method: "POST",
        body: {
          resourceId: params?.resourceId,
          disableScorers: params?.disableScorers
        }
      }
    );
    const run = new Run(this.options, this.workflowId, res.runId);
    return run;
  }
  /**
   * Creates a new ReadableStream from an iterable or async iterable of objects,
   * serializing each as JSON and separating them with the record separator (\x1E).
   *
   * @param records - An iterable or async iterable of objects to stream
   * @returns A ReadableStream emitting the records as JSON strings separated by the record separator
   */
  static createRecordStream(records) {
    const encoder = new TextEncoder();
    return new ReadableStream({
      async start(controller) {
        try {
          for await (const record of records) {
            const json = JSON.stringify(record) + RECORD_SEPARATOR2;
            controller.enqueue(encoder.encode(json));
          }
          controller.close();
        } catch (err) {
          controller.error(err);
        }
      }
    });
  }
};

// src/resources/a2a.ts
var A2A = class extends BaseResource {
  constructor(options, agentId) {
    super(options);
    this.agentId = agentId;
  }
  /**
   * Get the agent card with metadata about the agent
   * @returns Promise containing the agent card information
   */
  async getCard() {
    return this.request(`/.well-known/${this.agentId}/agent-card.json`);
  }
  /**
   * Send a message to the agent and gets a message or task response
   * @param params - Parameters for the task
   * @returns Promise containing the response
   */
  async sendMessage(params) {
    const response = await this.request(`/a2a/${this.agentId}`, {
      method: "POST",
      body: {
        method: "message/send",
        params
      }
    });
    return response;
  }
  /**
   * Sends a message to an agent to initiate/continue a task and subscribes
   * the client to real-time updates for that task via Server-Sent Events (SSE).
   * @param params - Parameters for the task
   * @returns A stream of Server-Sent Events. Each SSE `data` field contains a `SendStreamingMessageResponse`
   */
  async sendStreamingMessage(params) {
    const response = await this.request(`/a2a/${this.agentId}`, {
      method: "POST",
      body: {
        method: "message/stream",
        params
      },
      stream: true
    });
    return response;
  }
  /**
   * Get the status and result of a task
   * @param params - Parameters for querying the task
   * @returns Promise containing the task response
   */
  async getTask(params) {
    const response = await this.request(`/a2a/${this.agentId}`, {
      method: "POST",
      body: {
        method: "tasks/get",
        params
      }
    });
    return response;
  }
  /**
   * Cancel a running task
   * @param params - Parameters identifying the task to cancel
   * @returns Promise containing the task response
   */
  async cancelTask(params) {
    return this.request(`/a2a/${this.agentId}`, {
      method: "POST",
      body: {
        method: "tasks/cancel",
        params
      }
    });
  }
};

// src/resources/mcp-tool.ts
var MCPTool = class extends BaseResource {
  serverId;
  toolId;
  constructor(options, serverId, toolId) {
    super(options);
    this.serverId = serverId;
    this.toolId = toolId;
  }
  /**
   * Retrieves details about this specific tool from the MCP server.
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing the tool's information (name, description, schema).
   */
  details(requestContext) {
    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}${requestContextQueryString(requestContext)}`);
  }
  /**
   * Executes this specific tool on the MCP server.
   * @param params - Parameters for tool execution, including data/args and optional requestContext.
   * @returns Promise containing the result of the tool execution.
   */
  execute(params) {
    const body = {};
    if (params.data !== void 0) body.data = params.data;
    if (params.requestContext !== void 0) {
      body.requestContext = params.requestContext;
    }
    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}/execute`, {
      method: "POST",
      body: Object.keys(body).length > 0 ? body : void 0
    });
  }
};

// src/resources/agent-builder.ts
var RECORD_SEPARATOR3 = "";
var AgentBuilder = class extends BaseResource {
  constructor(options, actionId) {
    super(options);
    this.actionId = actionId;
  }
  // Helper function to transform workflow result to action result
  transformWorkflowResult(result) {
    if (result.status === "success") {
      return {
        success: result.result.success || false,
        applied: result.result.applied || false,
        branchName: result.result.branchName,
        message: result.result.message || "Agent builder action completed",
        validationResults: result.result.validationResults,
        error: result.result.error,
        errors: result.result.errors,
        stepResults: result.result.stepResults
      };
    } else if (result.status === "failed") {
      return {
        success: false,
        applied: false,
        message: `Agent builder action failed: ${result.error.message}`,
        error: result.error.message
      };
    } else {
      return {
        success: false,
        applied: false,
        message: "Agent builder action was suspended",
        error: "Workflow suspended - manual intervention required"
      };
    }
  }
  /**
   * Creates a transform stream that parses binary chunks into JSON records.
   */
  createRecordParserTransform() {
    let failedChunk = void 0;
    return new TransformStream({
      start() {
      },
      async transform(chunk, controller) {
        try {
          const decoded = new TextDecoder().decode(chunk);
          const chunks = decoded.split(RECORD_SEPARATOR3);
          for (const chunk2 of chunks) {
            if (chunk2) {
              const newChunk = failedChunk ? failedChunk + chunk2 : chunk2;
              try {
                const parsedChunk = JSON.parse(newChunk);
                controller.enqueue(parsedChunk);
                failedChunk = void 0;
              } catch {
                failedChunk = newChunk;
              }
            }
          }
        } catch {
        }
      }
    });
  }
  /**
   * Creates a new agent builder action run and returns the runId.
   * This calls `/api/agent-builder/:actionId/create-run`.
   */
  async createRun(params) {
    const searchParams = new URLSearchParams();
    if (!!params?.runId) {
      searchParams.set("runId", params.runId);
    }
    const url = `/api/agent-builder/${this.actionId}/create-run${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
    return this.request(url, {
      method: "POST"
    });
  }
  /**
   * Starts agent builder action asynchronously and waits for completion.
   * This calls `/api/agent-builder/:actionId/start-async`.
   */
  async startAsync(params, runId) {
    const searchParams = new URLSearchParams();
    if (runId) {
      searchParams.set("runId", runId);
    }
    const requestContext = parseClientRequestContext(params.requestContext);
    const { requestContext: _, ...actionParams } = params;
    const url = `/api/agent-builder/${this.actionId}/start-async${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
    const result = await this.request(url, {
      method: "POST",
      body: { ...actionParams, requestContext }
    });
    return this.transformWorkflowResult(result);
  }
  /**
   * Starts an existing agent builder action run.
   * This calls `/api/agent-builder/:actionId/start`.
   */
  async startActionRun(params, runId) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const { requestContext: _, ...actionParams } = params;
    const url = `/api/agent-builder/${this.actionId}/start?${searchParams.toString()}`;
    return this.request(url, {
      method: "POST",
      body: { ...actionParams, requestContext }
    });
  }
  /**
   * Resumes a suspended agent builder action step.
   * This calls `/api/agent-builder/:actionId/resume`.
   */
  async resume(params, runId) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const { requestContext: _, ...resumeParams } = params;
    const url = `/api/agent-builder/${this.actionId}/resume?${searchParams.toString()}`;
    return this.request(url, {
      method: "POST",
      body: { ...resumeParams, requestContext }
    });
  }
  /**
   * Resumes a suspended agent builder action step asynchronously.
   * This calls `/api/agent-builder/:actionId/resume-async`.
   */
  async resumeAsync(params, runId) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const { requestContext: _, ...resumeParams } = params;
    const url = `/api/agent-builder/${this.actionId}/resume-async?${searchParams.toString()}`;
    const result = await this.request(url, {
      method: "POST",
      body: { ...resumeParams, requestContext }
    });
    return this.transformWorkflowResult(result);
  }
  /**
   * Creates an async generator that processes a readable stream and yields action records
   * separated by the Record Separator character (\x1E)
   *
   * @param stream - The readable stream to process
   * @returns An async generator that yields parsed records
   */
  async *streamProcessor(stream) {
    const reader = stream.getReader();
    let doneReading = false;
    let buffer = "";
    try {
      while (!doneReading) {
        const { done, value } = await reader.read();
        doneReading = done;
        if (done && !value) continue;
        try {
          const decoded = value ? new TextDecoder().decode(value) : "";
          const chunks = (buffer + decoded).split(RECORD_SEPARATOR3);
          buffer = chunks.pop() || "";
          for (const chunk of chunks) {
            if (chunk) {
              if (typeof chunk === "string") {
                try {
                  const parsedChunk = JSON.parse(chunk);
                  yield parsedChunk;
                } catch {
                }
              }
            }
          }
        } catch {
        }
      }
      if (buffer) {
        try {
          yield JSON.parse(buffer);
        } catch {
        }
      }
    } finally {
      reader.cancel().catch(() => {
      });
    }
  }
  /**
   * Streams agent builder action progress in real-time.
   * This calls `/api/agent-builder/:actionId/stream`.
   */
  async stream(params, runId) {
    const searchParams = new URLSearchParams();
    if (runId) {
      searchParams.set("runId", runId);
    }
    const requestContext = parseClientRequestContext(params.requestContext);
    const { requestContext: _, ...actionParams } = params;
    const url = `/api/agent-builder/${this.actionId}/stream${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
    const response = await this.request(url, {
      method: "POST",
      body: { ...actionParams, requestContext },
      stream: true
    });
    if (!response.ok) {
      throw new Error(`Failed to stream agent builder action: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createRecordParserTransform());
  }
  /**
   * Observes an existing agent builder action run stream.
   * Replays cached execution from the beginning, then continues with live stream.
   * This is the recommended method for recovery after page refresh/hot reload.
   * This calls `/api/agent-builder/:actionId/observe`
   */
  async observeStream(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", params.runId);
    const url = `/api/agent-builder/${this.actionId}/observe?${searchParams.toString()}`;
    const response = await this.request(url, {
      method: "POST",
      stream: true
    });
    if (!response.ok) {
      throw new Error(`Failed to observe agent builder action stream: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createRecordParserTransform());
  }
  /**
   * Observes an existing agent builder action run stream using legacy streaming API.
   * Replays cached execution from the beginning, then continues with live stream.
   * This calls `/api/agent-builder/:actionId/observe-stream-legacy`.
   */
  async observeStreamLegacy(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", params.runId);
    const url = `/api/agent-builder/${this.actionId}/observe-stream-legacy?${searchParams.toString()}`;
    const response = await this.request(url, {
      method: "POST",
      stream: true
    });
    if (!response.ok) {
      throw new Error(`Failed to observe agent builder action stream legacy: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createRecordParserTransform());
  }
  /**
   * Resumes a suspended agent builder action and streams the results.
   * This calls `/api/agent-builder/:actionId/resume-stream`.
   */
  async resumeStream(params) {
    const searchParams = new URLSearchParams();
    searchParams.set("runId", params.runId);
    const requestContext = parseClientRequestContext(params.requestContext);
    const { runId: _, requestContext: __, ...resumeParams } = params;
    const url = `/api/agent-builder/${this.actionId}/resume-stream?${searchParams.toString()}`;
    const response = await this.request(url, {
      method: "POST",
      body: { ...resumeParams, requestContext },
      stream: true
    });
    if (!response.ok) {
      throw new Error(`Failed to resume agent builder action stream: ${response.statusText}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    return response.body.pipeThrough(this.createRecordParserTransform());
  }
  /**
   * Gets a specific action run by its ID.
   * This calls `/api/agent-builder/:actionId/runs/:runId`.
   * @param runId - The ID of the action run to retrieve
   * @param options - Optional configuration
   * @param options.fields - Optional array of fields to return (e.g., ['result', 'steps']). Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph. Metadata fields (runId, workflowName, resourceId, createdAt, updatedAt) and status are always included.
   * @param options.withNestedWorkflows - Whether to include nested workflow data in steps. Defaults to true. Set to false for better performance when you don't need nested workflow details.
   * @returns Promise containing the action run details with metadata and processed execution state
   */
  async runById(runId, options) {
    const searchParams = new URLSearchParams();
    if (options?.fields && options.fields.length > 0) {
      searchParams.set("fields", options.fields.join(","));
    }
    if (options?.withNestedWorkflows !== void 0) {
      searchParams.set("withNestedWorkflows", String(options.withNestedWorkflows));
    }
    const queryString = searchParams.size > 0 ? `?${searchParams.toString()}` : "";
    const url = `/api/agent-builder/${this.actionId}/runs/${runId}${queryString}`;
    return this.request(url, {
      method: "GET"
    });
  }
  /**
   * Gets details about this agent builder action.
   * This calls `/api/agent-builder/:actionId`.
   */
  async details() {
    const result = await this.request(`/api/agent-builder/${this.actionId}`);
    return result;
  }
  /**
   * Gets all runs for this agent builder action.
   * This calls `/api/agent-builder/:actionId/runs`.
   */
  async runs(params) {
    const searchParams = new URLSearchParams();
    if (params?.fromDate) {
      searchParams.set("fromDate", params.fromDate.toISOString());
    }
    if (params?.toDate) {
      searchParams.set("toDate", params.toDate.toISOString());
    }
    if (params?.perPage !== void 0) {
      searchParams.set("perPage", String(params.perPage));
    }
    if (params?.page !== void 0) {
      searchParams.set("page", String(params.page));
    }
    if (params?.limit !== null && params?.limit !== void 0) {
      if (params.limit === false) {
        searchParams.set("limit", "false");
      } else if (typeof params.limit === "number" && params.limit > 0 && Number.isInteger(params.limit)) {
        searchParams.set("limit", String(params.limit));
      }
    }
    if (params?.offset !== null && params?.offset !== void 0 && !isNaN(Number(params?.offset))) {
      searchParams.set("offset", String(params.offset));
    }
    if (params?.resourceId) {
      searchParams.set("resourceId", params.resourceId);
    }
    const url = `/api/agent-builder/${this.actionId}/runs${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
    return this.request(url, {
      method: "GET"
    });
  }
  /**
   * Cancels an agent builder action run.
   * This calls `/api/agent-builder/:actionId/runs/:runId/cancel`.
   */
  async cancelRun(runId) {
    const url = `/api/agent-builder/${this.actionId}/runs/${runId}/cancel`;
    return this.request(url, {
      method: "POST"
    });
  }
};

// src/resources/observability.ts
var Observability = class extends BaseResource {
  constructor(options) {
    super(options);
  }
  /**
   * Retrieves a specific trace by ID
   * @param traceId - ID of the trace to retrieve
   * @returns Promise containing the trace with all its spans
   */
  getTrace(traceId) {
    return this.request(`/api/observability/traces/${traceId}`);
  }
  /**
   * Retrieves paginated list of traces with optional filtering.
   * This is the legacy API preserved for backward compatibility.
   *
   * @param params - Parameters for pagination and filtering (legacy format)
   * @returns Promise containing paginated traces and pagination info
   * @deprecated Use {@link listTraces} instead for new features like ordering and more filters.
   */
  getTraces(params) {
    const { pagination, filters } = params;
    const { page, perPage, dateRange } = pagination || {};
    const { name: name14, spanType, entityId, entityType } = filters || {};
    const searchParams = new URLSearchParams();
    if (page !== void 0) {
      searchParams.set("page", String(page));
    }
    if (perPage !== void 0) {
      searchParams.set("perPage", String(perPage));
    }
    if (name14) {
      searchParams.set("name", name14);
    }
    if (spanType !== void 0) {
      searchParams.set("spanType", String(spanType));
    }
    if (entityId && entityType) {
      searchParams.set("entityId", entityId);
      searchParams.set("entityType", entityType);
    }
    if (dateRange) {
      const dateRangeStr = JSON.stringify({
        start: dateRange.start instanceof Date ? dateRange.start.toISOString() : dateRange.start,
        end: dateRange.end instanceof Date ? dateRange.end.toISOString() : dateRange.end
      });
      searchParams.set("dateRange", dateRangeStr);
    }
    const queryString = searchParams.toString();
    return this.request(`/api/observability/traces${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves paginated list of traces with optional filtering and sorting.
   * This is the new API with improved filtering options.
   *
   * @param params - Parameters for pagination, filtering, and ordering
   * @returns Promise containing paginated traces and pagination info
   */
  listTraces(params = {}) {
    const queryString = toQueryParams(params, ["filters", "pagination", "orderBy"]);
    return this.request(`/api/observability/traces${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves scores by trace ID and span ID
   * @param params - Parameters containing trace ID, span ID, and pagination options
   * @returns Promise containing scores and pagination info
   */
  listScoresBySpan(params) {
    const { traceId, spanId, ...pagination } = params;
    const queryString = toQueryParams(pagination);
    return this.request(
      `/api/observability/traces/${encodeURIComponent(traceId)}/${encodeURIComponent(spanId)}/scores${queryString ? `?${queryString}` : ""}`
    );
  }
  /**
   * Scores one or more traces using a specified scorer.
   * @param params - Scorer name and targets to score
   * @returns Promise containing the scoring status
   */
  score(params) {
    return this.request(`/api/observability/traces/score`, {
      method: "POST",
      body: { ...params }
    });
  }
};

// src/resources/stored-agent.ts
var StoredAgent = class extends BaseResource {
  constructor(options, storedAgentId) {
    super(options);
    this.storedAgentId = storedAgentId;
  }
  /**
   * Retrieves details about the stored agent
   * @returns Promise containing stored agent details
   */
  details() {
    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`);
  }
  /**
   * Updates the stored agent with the provided fields
   * @param params - Fields to update
   * @returns Promise containing the updated stored agent
   */
  update(params) {
    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`, {
      method: "PATCH",
      body: params
    });
  }
  /**
   * Deletes the stored agent
   * @returns Promise containing deletion confirmation
   */
  delete() {
    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`, {
      method: "DELETE"
    });
  }
};

// src/client.ts
var MastraClient = class extends BaseResource {
  observability;
  constructor(options) {
    super(options);
    this.observability = new Observability(options);
  }
  /**
   * Retrieves all available agents
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing map of agent IDs to agent details
   */
  listAgents(requestContext, partial) {
    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));
    const searchParams = new URLSearchParams();
    if (requestContextParam) {
      searchParams.set("requestContext", requestContextParam);
    }
    if (partial) {
      searchParams.set("partial", "true");
    }
    const queryString = searchParams.toString();
    return this.request(`/api/agents${queryString ? `?${queryString}` : ""}`);
  }
  listAgentsModelProviders() {
    return this.request(`/api/agents/providers`);
  }
  /**
   * Gets an agent instance by ID
   * @param agentId - ID of the agent to retrieve
   * @returns Agent instance
   */
  getAgent(agentId) {
    return new Agent(this.options, agentId);
  }
  /**
   * Lists memory threads for a resource with pagination support
   * @param params - Parameters containing resource ID, pagination options, and optional request context
   * @returns Promise containing paginated array of memory threads with metadata
   */
  async listMemoryThreads(params) {
    const queryParams = new URLSearchParams({
      resourceId: params.resourceId,
      resourceid: params.resourceId,
      ...params.agentId && { agentId: params.agentId },
      ...params.page !== void 0 && { page: params.page.toString() },
      ...params.perPage !== void 0 && { perPage: params.perPage.toString() },
      ...params.orderBy && { orderBy: params.orderBy },
      ...params.sortDirection && { sortDirection: params.sortDirection }
    });
    const response = await this.request(
      `/api/memory/threads?${queryParams.toString()}${requestContextQueryString(params.requestContext, "&")}`
    );
    const actualResponse = "threads" in response ? response : {
      threads: response,
      total: response.length,
      page: params.page ?? 0,
      perPage: params.perPage ?? 100,
      hasMore: false
    };
    return actualResponse;
  }
  /**
   * Retrieves memory config for a resource
   * @param params - Parameters containing the resource ID and optional request context
   * @returns Promise containing memory configuration
   */
  getMemoryConfig(params) {
    return this.request(
      `/api/memory/config?agentId=${params.agentId}${requestContextQueryString(params.requestContext, "&")}`
    );
  }
  /**
   * Creates a new memory thread
   * @param params - Parameters for creating the memory thread including optional request context
   * @returns Promise containing the created memory thread
   */
  createMemoryThread(params) {
    return this.request(
      `/api/memory/threads?agentId=${params.agentId}${requestContextQueryString(params.requestContext, "&")}`,
      { method: "POST", body: params }
    );
  }
  /**
   * Gets a memory thread instance by ID
   * @param threadId - ID of the memory thread to retrieve
   * @param agentId - Optional agent ID. When not provided, uses storage directly
   * @returns MemoryThread instance
   */
  getMemoryThread({ threadId, agentId }) {
    return new MemoryThread(this.options, threadId, agentId);
  }
  /**
   * Lists messages for a thread.
   * @param threadId - ID of the thread
   * @param opts - Optional parameters including agentId, networkId, and requestContext
   *   - When agentId is provided, uses the agent's memory
   *   - When networkId is provided, uses the network endpoint
   *   - When neither is provided, uses storage directly
   * @returns Promise containing the thread messages
   */
  listThreadMessages(threadId, opts = {}) {
    let url = "";
    if (opts.networkId) {
      url = `/api/memory/network/threads/${threadId}/messages?networkId=${opts.networkId}${requestContextQueryString(opts.requestContext, "&")}`;
    } else if (opts.agentId) {
      url = `/api/memory/threads/${threadId}/messages?agentId=${opts.agentId}${requestContextQueryString(opts.requestContext, "&")}`;
    } else {
      url = `/api/memory/threads/${threadId}/messages${requestContextQueryString(opts.requestContext, "?")}`;
    }
    return this.request(url);
  }
  deleteThread(threadId, opts = {}) {
    let url = "";
    if (opts.agentId) {
      url = `/api/memory/threads/${threadId}?agentId=${opts.agentId}${requestContextQueryString(opts.requestContext, "&")}`;
    } else if (opts.networkId) {
      url = `/api/memory/network/threads/${threadId}?networkId=${opts.networkId}${requestContextQueryString(opts.requestContext, "&")}`;
    }
    return this.request(url, { method: "DELETE" });
  }
  /**
   * Saves messages to memory
   * @param params - Parameters containing messages to save and optional request context
   * @returns Promise containing the saved messages
   */
  saveMessageToMemory(params) {
    return this.request(
      `/api/memory/save-messages?agentId=${params.agentId}${requestContextQueryString(params.requestContext, "&")}`,
      {
        method: "POST",
        body: params
      }
    );
  }
  /**
   * Gets the status of the memory system
   * @param agentId - The agent ID
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing memory system status
   */
  getMemoryStatus(agentId, requestContext) {
    return this.request(`/api/memory/status?agentId=${agentId}${requestContextQueryString(requestContext, "&")}`);
  }
  /**
   * Retrieves all available tools
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing map of tool IDs to tool details
   */
  listTools(requestContext) {
    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));
    const searchParams = new URLSearchParams();
    if (requestContextParam) {
      searchParams.set("requestContext", requestContextParam);
    }
    const queryString = searchParams.toString();
    return this.request(`/api/tools${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Gets a tool instance by ID
   * @param toolId - ID of the tool to retrieve
   * @returns Tool instance
   */
  getTool(toolId) {
    return new Tool(this.options, toolId);
  }
  /**
   * Retrieves all available workflows
   * @param requestContext - Optional request context to pass as query parameter
   * @returns Promise containing map of workflow IDs to workflow details
   */
  listWorkflows(requestContext, partial) {
    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));
    const searchParams = new URLSearchParams();
    if (requestContextParam) {
      searchParams.set("requestContext", requestContextParam);
    }
    if (partial) {
      searchParams.set("partial", "true");
    }
    const queryString = searchParams.toString();
    return this.request(`/api/workflows${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Gets a workflow instance by ID
   * @param workflowId - ID of the workflow to retrieve
   * @returns Workflow instance
   */
  getWorkflow(workflowId) {
    return new Workflow(this.options, workflowId);
  }
  /**
   * Gets all available agent builder actions
   * @returns Promise containing map of action IDs to action details
   */
  getAgentBuilderActions() {
    return this.request("/api/agent-builder/");
  }
  /**
   * Gets an agent builder instance for executing agent-builder workflows
   * @returns AgentBuilder instance
   */
  getAgentBuilderAction(actionId) {
    return new AgentBuilder(this.options, actionId);
  }
  /**
   * Gets a vector instance by name
   * @param vectorName - Name of the vector to retrieve
   * @returns Vector instance
   */
  getVector(vectorName) {
    return new Vector(this.options, vectorName);
  }
  /**
   * Retrieves logs
   * @param params - Parameters for filtering logs
   * @returns Promise containing array of log messages
   */
  listLogs(params) {
    const { transportId, fromDate, toDate, logLevel, filters, page, perPage } = params;
    const _filters = filters ? Object.entries(filters).map(([key, value]) => `${key}:${value}`) : [];
    const searchParams = new URLSearchParams();
    if (transportId) {
      searchParams.set("transportId", transportId);
    }
    if (fromDate) {
      searchParams.set("fromDate", fromDate.toISOString());
    }
    if (toDate) {
      searchParams.set("toDate", toDate.toISOString());
    }
    if (logLevel) {
      searchParams.set("logLevel", logLevel);
    }
    if (page) {
      searchParams.set("page", String(page));
    }
    if (perPage) {
      searchParams.set("perPage", String(perPage));
    }
    if (_filters) {
      if (Array.isArray(_filters)) {
        for (const filter of _filters) {
          searchParams.append("filters", filter);
        }
      } else {
        searchParams.set("filters", _filters);
      }
    }
    if (searchParams.size) {
      return this.request(`/api/logs?${searchParams}`);
    } else {
      return this.request(`/api/logs`);
    }
  }
  /**
   * Gets logs for a specific run
   * @param params - Parameters containing run ID to retrieve
   * @returns Promise containing array of log messages
   */
  getLogForRun(params) {
    const { runId, transportId, fromDate, toDate, logLevel, filters, page, perPage } = params;
    const _filters = filters ? Object.entries(filters).map(([key, value]) => `${key}:${value}`) : [];
    const searchParams = new URLSearchParams();
    if (runId) {
      searchParams.set("runId", runId);
    }
    if (transportId) {
      searchParams.set("transportId", transportId);
    }
    if (fromDate) {
      searchParams.set("fromDate", fromDate.toISOString());
    }
    if (toDate) {
      searchParams.set("toDate", toDate.toISOString());
    }
    if (logLevel) {
      searchParams.set("logLevel", logLevel);
    }
    if (page) {
      searchParams.set("page", String(page));
    }
    if (perPage) {
      searchParams.set("perPage", String(perPage));
    }
    if (_filters) {
      if (Array.isArray(_filters)) {
        for (const filter of _filters) {
          searchParams.append("filters", filter);
        }
      } else {
        searchParams.set("filters", _filters);
      }
    }
    if (searchParams.size) {
      return this.request(`/api/logs/${runId}?${searchParams}`);
    } else {
      return this.request(`/api/logs/${runId}`);
    }
  }
  /**
   * List of all log transports
   * @returns Promise containing list of log transports
   */
  listLogTransports() {
    return this.request("/api/logs/transports");
  }
  /**
   * Retrieves a list of available MCP servers.
   * @param params - Optional parameters for pagination (page, perPage, or deprecated offset, limit).
   * @returns Promise containing the list of MCP servers and pagination info.
   */
  getMcpServers(params) {
    const searchParams = new URLSearchParams();
    if (params?.page !== void 0) {
      searchParams.set("page", String(params.page));
    }
    if (params?.perPage !== void 0) {
      searchParams.set("perPage", String(params.perPage));
    }
    if (params?.limit !== void 0) {
      searchParams.set("limit", String(params.limit));
    }
    if (params?.offset !== void 0) {
      searchParams.set("offset", String(params.offset));
    }
    const queryString = searchParams.toString();
    return this.request(`/api/mcp/v0/servers${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves detailed information for a specific MCP server.
   * @param serverId - The ID of the MCP server to retrieve.
   * @param params - Optional parameters, e.g., specific version.
   * @returns Promise containing the detailed MCP server information.
   */
  getMcpServerDetails(serverId, params) {
    const searchParams = new URLSearchParams();
    if (params?.version) {
      searchParams.set("version", params.version);
    }
    const queryString = searchParams.toString();
    return this.request(`/api/mcp/v0/servers/${serverId}${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves a list of tools for a specific MCP server.
   * @param serverId - The ID of the MCP server.
   * @returns Promise containing the list of tools.
   */
  getMcpServerTools(serverId) {
    return this.request(`/api/mcp/${serverId}/tools`);
  }
  /**
   * Gets an MCPTool resource instance for a specific tool on an MCP server.
   * This instance can then be used to fetch details or execute the tool.
   * @param serverId - The ID of the MCP server.
   * @param toolId - The ID of the tool.
   * @returns MCPTool instance.
   */
  getMcpServerTool(serverId, toolId) {
    return new MCPTool(this.options, serverId, toolId);
  }
  /**
   * Gets an A2A client for interacting with an agent via the A2A protocol
   * @param agentId - ID of the agent to interact with
   * @returns A2A client instance
   */
  getA2A(agentId) {
    return new A2A(this.options, agentId);
  }
  /**
   * Retrieves the working memory for a specific thread (optionally resource-scoped).
   * @param agentId - ID of the agent.
   * @param threadId - ID of the thread.
   * @param resourceId - Optional ID of the resource.
   * @returns Working memory for the specified thread or resource.
   */
  getWorkingMemory({
    agentId,
    threadId,
    resourceId,
    requestContext
  }) {
    return this.request(
      `/api/memory/threads/${threadId}/working-memory?agentId=${agentId}&resourceId=${resourceId}${requestContextQueryString(requestContext, "&")}`
    );
  }
  searchMemory({
    agentId,
    resourceId,
    threadId,
    searchQuery,
    memoryConfig,
    requestContext
  }) {
    const params = new URLSearchParams({
      searchQuery,
      resourceId,
      agentId
    });
    if (threadId) {
      params.append("threadId", threadId);
    }
    if (memoryConfig) {
      params.append("memoryConfig", JSON.stringify(memoryConfig));
    }
    return this.request(`/api/memory/search?${params}${requestContextQueryString(requestContext, "&")}`);
  }
  /**
   * Updates the working memory for a specific thread (optionally resource-scoped).
   * @param agentId - ID of the agent.
   * @param threadId - ID of the thread.
   * @param workingMemory - The new working memory content.
   * @param resourceId - Optional ID of the resource.
   */
  updateWorkingMemory({
    agentId,
    threadId,
    workingMemory,
    resourceId,
    requestContext
  }) {
    return this.request(
      `/api/memory/threads/${threadId}/working-memory?agentId=${agentId}${requestContextQueryString(requestContext, "&")}`,
      {
        method: "POST",
        body: {
          workingMemory,
          resourceId
        }
      }
    );
  }
  /**
   * Retrieves all available scorers
   * @returns Promise containing list of available scorers
   */
  listScorers() {
    return this.request("/api/scores/scorers");
  }
  /**
   * Retrieves a scorer by ID
   * @param scorerId - ID of the scorer to retrieve
   * @returns Promise containing the scorer
   */
  getScorer(scorerId) {
    return this.request(`/api/scores/scorers/${encodeURIComponent(scorerId)}`);
  }
  listScoresByScorerId(params) {
    const { page, perPage, scorerId, entityId, entityType } = params;
    const searchParams = new URLSearchParams();
    if (entityId) {
      searchParams.set("entityId", entityId);
    }
    if (entityType) {
      searchParams.set("entityType", entityType);
    }
    if (page !== void 0) {
      searchParams.set("page", String(page));
    }
    if (perPage !== void 0) {
      searchParams.set("perPage", String(perPage));
    }
    const queryString = searchParams.toString();
    return this.request(`/api/scores/scorer/${encodeURIComponent(scorerId)}${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves scores by run ID
   * @param params - Parameters containing run ID and pagination options
   * @returns Promise containing scores and pagination info
   */
  listScoresByRunId(params) {
    const { runId, page, perPage } = params;
    const searchParams = new URLSearchParams();
    if (page !== void 0) {
      searchParams.set("page", String(page));
    }
    if (perPage !== void 0) {
      searchParams.set("perPage", String(perPage));
    }
    const queryString = searchParams.toString();
    return this.request(`/api/scores/run/${encodeURIComponent(runId)}${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Retrieves scores by entity ID and type
   * @param params - Parameters containing entity ID, type, and pagination options
   * @returns Promise containing scores and pagination info
   */
  listScoresByEntityId(params) {
    const { entityId, entityType, page, perPage } = params;
    const searchParams = new URLSearchParams();
    if (page !== void 0) {
      searchParams.set("page", String(page));
    }
    if (perPage !== void 0) {
      searchParams.set("perPage", String(perPage));
    }
    const queryString = searchParams.toString();
    return this.request(
      `/api/scores/entity/${encodeURIComponent(entityType)}/${encodeURIComponent(entityId)}${queryString ? `?${queryString}` : ""}`
    );
  }
  /**
   * Saves a score
   * @param params - Parameters containing the score data to save
   * @returns Promise containing the saved score
   */
  saveScore(params) {
    return this.request("/api/scores", {
      method: "POST",
      body: params
    });
  }
  getTrace(traceId) {
    return this.observability.getTrace(traceId);
  }
  /**
   * Retrieves paginated list of traces with optional filtering.
   * This is the legacy API preserved for backward compatibility.
   *
   * @param params - Parameters for pagination and filtering (legacy format)
   * @returns Promise containing paginated traces and pagination info
   * @deprecated Use {@link listTraces} instead for new features like ordering and more filters.
   */
  getTraces(params) {
    return this.observability.getTraces(params);
  }
  /**
   * Retrieves paginated list of traces with optional filtering and sorting.
   * This is the new API with improved filtering options.
   *
   * @param params - Parameters for pagination, filtering, and ordering
   * @returns Promise containing paginated traces and pagination info
   */
  listTraces(params = {}) {
    return this.observability.listTraces(params);
  }
  listScoresBySpan(params) {
    return this.observability.listScoresBySpan(params);
  }
  score(params) {
    return this.observability.score(params);
  }
  // ============================================================================
  // Stored Agents
  // ============================================================================
  /**
   * Lists all stored agents with optional pagination
   * @param params - Optional pagination and ordering parameters
   * @returns Promise containing paginated list of stored agents
   */
  listStoredAgents(params) {
    const searchParams = new URLSearchParams();
    if (params?.page !== void 0) {
      searchParams.set("page", String(params.page));
    }
    if (params?.perPage !== void 0) {
      searchParams.set("perPage", String(params.perPage));
    }
    if (params?.orderBy) {
      if (params.orderBy.field) {
        searchParams.set("orderBy[field]", params.orderBy.field);
      }
      if (params.orderBy.direction) {
        searchParams.set("orderBy[direction]", params.orderBy.direction);
      }
    }
    const queryString = searchParams.toString();
    return this.request(`/api/stored/agents${queryString ? `?${queryString}` : ""}`);
  }
  /**
   * Creates a new stored agent
   * @param params - Agent configuration including id, name, instructions, model, etc.
   * @returns Promise containing the created stored agent
   */
  createStoredAgent(params) {
    return this.request("/api/stored/agents", {
      method: "POST",
      body: params
    });
  }
  /**
   * Gets a stored agent instance by ID for further operations (details, update, delete)
   * @param storedAgentId - ID of the stored agent to retrieve
   * @returns StoredAgent instance
   */
  getStoredAgent(storedAgentId) {
    return new StoredAgent(this.options, storedAgentId);
  }
  // ============================================================================
  // System
  // ============================================================================
  /**
   * Retrieves installed Mastra packages and their versions
   * @returns Promise containing the list of installed Mastra packages
   */
  getSystemPackages() {
    return this.request("/api/system/packages");
  }
};

// src/tools.ts
var ClientTool = class {
  id;
  description;
  inputSchema;
  outputSchema;
  execute;
  constructor(opts) {
    this.id = opts.id;
    this.description = opts.description;
    this.inputSchema = opts.inputSchema;
    this.outputSchema = opts.outputSchema;
    this.execute = opts.execute;
  }
};
function createTool(opts) {
  return new ClientTool(opts);
}

exports.ClientTool = ClientTool;
exports.MastraClient = MastraClient;
exports.createTool = createTool;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map