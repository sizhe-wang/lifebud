{"version":3,"sources":["../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validator.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js","../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/fix-json.ts","../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/parse-partial-json.ts","../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/data-stream-parts.ts","../../../node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.76/node_modules/@ai-sdk/ui-utils/src/process-data-stream.ts","../src/utils/index.ts","../src/utils/zod-to-json-schema.ts","../src/utils/process-client-tools.ts","../src/utils/process-mastra-stream.ts","../src/resources/base.ts","../src/resources/agent.ts","../src/resources/memory-thread.ts","../src/resources/vector.ts","../src/resources/tool.ts","../src/resources/run.ts","../src/resources/workflow.ts","../src/resources/a2a.ts","../src/resources/mcp-tool.ts","../src/resources/agent-builder.ts","../src/resources/observability.ts","../src/resources/stored-agent.ts","../src/client.ts","../src/tools.ts"],"names":["_AISDKError","name","marker","symbol","_a","_TypeValidationError","validator","SecureJSON","textStreamPart","errorStreamPart","validCodes","value","requestContext","RequestContext","zodToJsonSchema","schemaCompatZodToJsonSchema","isVercelTool","uuid","part","invocation","getErrorFromUnknown","toolCall","toolInvocation","chunk","RECORD_SEPARATOR"],"mappings":"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","file":"index.cjs","sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n","type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n","import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    // TODO v5 remove usage from finish event (only on step-finish)\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst redactedReasoningStreamPart: DataStreamPart<\n  'i',\n  'redacted_reasoning',\n  { data: string }\n> = {\n  code: 'i',\n  name: 'redacted_reasoning',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string'\n    ) {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.',\n      );\n    }\n    return { type: 'redacted_reasoning', value: { data: value.data } };\n  },\n};\n\nconst reasoningSignatureStreamPart: DataStreamPart<\n  'j',\n  'reasoning_signature',\n  { signature: string }\n> = {\n  code: 'j',\n  name: 'reasoning_signature',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('signature' in value) ||\n      typeof value.signature !== 'string'\n    ) {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.',\n      );\n    }\n    return {\n      type: 'reasoning_signature',\n      value: { signature: value.signature },\n    };\n  },\n};\n\nconst fileStreamPart: DataStreamPart<\n  'k',\n  'file',\n  {\n    data: string; // base64 encoded data\n    mimeType: string;\n  }\n> = {\n  code: 'k',\n  name: 'file',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string' ||\n      !('mimeType' in value) ||\n      typeof value.mimeType !== 'string'\n    ) {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.',\n      );\n    }\n    return { type: 'file', value: value as { data: string; mimeType: string } };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { DataStreamPartType, parseDataStreamPart } from './data-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (DataStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning' })['value'],\n  ) => Promise<void> | void;\n  onReasoningSignaturePart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning_signature' })['value'],\n  ) => Promise<void> | void;\n  onRedactedReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'redacted_reasoning' })['value'],\n  ) => Promise<void> | void;\n  onFilePart?: (\n    streamPart: (DataStreamPartType & { type: 'file' })['value'],\n  ) => Promise<void> | void;\n  onSourcePart?: (\n    streamPart: (DataStreamPartType & { type: 'source' })['value'],\n  ) => Promise<void> | void;\n  onDataPart?: (\n    streamPart: (DataStreamPartType & { type: 'data' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (DataStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onToolCallStreamingStartPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'tool_call_streaming_start';\n    })['value'],\n  ) => Promise<void> | void;\n  onToolCallDeltaPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call_delta' })['value'],\n  ) => Promise<void> | void;\n  onToolCallPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call' })['value'],\n  ) => Promise<void> | void;\n  onToolResultPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_result' })['value'],\n  ) => Promise<void> | void;\n  onMessageAnnotationsPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'message_annotations';\n    })['value'],\n  ) => Promise<void> | void;\n  onFinishMessagePart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_message' })['value'],\n  ) => Promise<void> | void;\n  onFinishStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_step' })['value'],\n  ) => Promise<void> | void;\n  onStartStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'start_step' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseDataStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'reasoning':\n          await onReasoningPart?.(value);\n          break;\n        case 'reasoning_signature':\n          await onReasoningSignaturePart?.(value);\n          break;\n        case 'redacted_reasoning':\n          await onRedactedReasoningPart?.(value);\n          break;\n        case 'file':\n          await onFilePart?.(value);\n          break;\n        case 'source':\n          await onSourcePart?.(value);\n          break;\n        case 'data':\n          await onDataPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'message_annotations':\n          await onMessageAnnotationsPart?.(value);\n          break;\n        case 'tool_call_streaming_start':\n          await onToolCallStreamingStartPart?.(value);\n          break;\n        case 'tool_call_delta':\n          await onToolCallDeltaPart?.(value);\n          break;\n        case 'tool_call':\n          await onToolCallPart?.(value);\n          break;\n        case 'tool_result':\n          await onToolResultPart?.(value);\n          break;\n        case 'finish_message':\n          await onFinishMessagePart?.(value);\n          break;\n        case 'finish_step':\n          await onFinishStepPart?.(value);\n          break;\n        case 'start_step':\n          await onStartStepPart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n","import { RequestContext } from '@mastra/core/request-context';\n\n/**\n * Checks if a value is a \"complex\" type that needs JSON serialization for query params.\n * Complex types: objects (excluding Date), arrays\n * Primitive types: string, number, boolean, null, undefined, Date\n */\nfunction isComplexValue(value: unknown): boolean {\n  if (value === null || value === undefined) return false;\n  if (value instanceof Date) return false;\n  return typeof value === 'object';\n}\n\n/**\n * Serializes a value for use in URL query parameters.\n * - Primitives (string, number, boolean): converted to string\n * - Date: converted to ISO string\n * - Complex types (objects, arrays): JSON-stringified\n */\nfunction serializeQueryValue(value: unknown): string {\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  if (isComplexValue(value)) {\n    return JSON.stringify(value, (_key, val) => {\n      // Handle Date objects inside nested structures\n      if (val instanceof Date) {\n        return val.toISOString();\n      }\n      return val;\n    });\n  }\n  return String(value);\n}\n\n/**\n * Converts a nested params object to flat URL query parameters.\n *\n * This mirrors the server's `wrapSchemaForQueryParams` behavior:\n * - Flattens specified nested keys to top-level params\n * - JSON-stringifies complex values (objects, arrays)\n * - Converts primitives to strings\n * - Handles Date objects by converting to ISO strings\n *\n * @param params - The params object to convert\n * @param flattenKeys - Keys whose values should be flattened to top-level params\n *\n * @example\n * ```ts\n * toQueryParams(\n *   {\n *     pagination: { page: 0, perPage: 10 },\n *     filters: { spanType: 'agent_run', startedAt: { start: new Date() } },\n *     orderBy: { field: 'startedAt', direction: 'DESC' }\n *   },\n *   ['filters', 'pagination', 'orderBy']\n * )\n * // Returns: \"page=0&perPage=10&spanType=agent_run&startedAt=%7B%22start%22%3A%222024-...%22%7D&field=startedAt&direction=DESC\"\n * ```\n */\nexport function toQueryParams<T extends Record<string, unknown>>(params: T, flattenKeys: (keyof T)[] = []): string {\n  const searchParams = new URLSearchParams();\n  const keysToFlatten = flattenKeys as string[];\n\n  function addParams(obj: Record<string, unknown>) {\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === undefined || value === null) continue;\n\n      // Flatten specified nested objects\n      if (\n        keysToFlatten.includes(key) &&\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        !(value instanceof Date)\n      ) {\n        addParams(value as Record<string, unknown>);\n      } else {\n        searchParams.set(key, serializeQueryValue(value));\n      }\n    }\n  }\n\n  addParams(params);\n  return searchParams.toString();\n}\n\nexport function parseClientRequestContext(requestContext?: RequestContext | Record<string, any>) {\n  if (requestContext) {\n    if (requestContext instanceof RequestContext) {\n      return Object.fromEntries(requestContext.entries());\n    }\n    return requestContext;\n  }\n  return undefined;\n}\n\nexport function base64RequestContext(requestContext?: Record<string, any>): string | undefined {\n  if (requestContext) {\n    return btoa(JSON.stringify(requestContext));\n  }\n  return undefined;\n}\n\n/**\n * Converts a request context to a query string\n * @param requestContext - The request context to convert\n * @param delimiter - The delimiter to use in the query string\n * @returns The query string\n */\nexport function requestContextQueryString(\n  requestContext?: RequestContext | Record<string, any>,\n  delimiter: string = '?',\n): string {\n  const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));\n  if (!requestContextParam) return '';\n  const searchParams = new URLSearchParams();\n  searchParams.set('requestContext', requestContextParam);\n  const queryString = searchParams.toString();\n  return queryString ? `${delimiter}${queryString}` : '';\n}\n","import { zodToJsonSchema as schemaCompatZodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport type { ZodType } from 'zod';\n\n/**\n * Check if a value is a Zod schema type.\n * This is a simple check that doesn't require any Node.js dependencies.\n */\nfunction isZodType(value: unknown): value is ZodType {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n/**\n * Converts a Zod schema to JSON Schema, or passes through non-Zod values unchanged.\n *\n * Uses the schema-compat implementation which includes:\n * - Zod v4 z.record() bug fix\n * - Date to date-time format conversion\n * - Handling of unrepresentable types\n */\nexport function zodToJsonSchema<T extends ZodType | any>(zodSchema: T) {\n  if (!isZodType(zodSchema)) {\n    return zodSchema;\n  }\n\n  return schemaCompatZodToJsonSchema(zodSchema);\n}\n","import type { ToolsInput } from '@mastra/core/agent';\nimport { isVercelTool } from '@mastra/core/tools/is-vercel-tool';\nimport { zodToJsonSchema } from './zod-to-json-schema';\n\nexport function processClientTools(clientTools: ToolsInput | undefined): ToolsInput | undefined {\n  if (!clientTools) {\n    return undefined;\n  }\n\n  return Object.fromEntries(\n    Object.entries(clientTools).map(([key, value]) => {\n      if (isVercelTool(value)) {\n        return [\n          key,\n          {\n            ...value,\n            parameters: value.parameters ? zodToJsonSchema(value.parameters) : undefined,\n          },\n        ];\n      } else {\n        return [\n          key,\n          {\n            ...value,\n            inputSchema: value.inputSchema ? zodToJsonSchema(value.inputSchema) : undefined,\n            outputSchema: value.outputSchema ? zodToJsonSchema(value.outputSchema) : undefined,\n          },\n        ];\n      }\n    }),\n  );\n}\n","import type { ReadableStream } from 'node:stream/web';\nimport type { ChunkType, NetworkChunkType } from '@mastra/core/stream';\n\nasync function sharedProcessMastraStream({\n  stream,\n  onChunk,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onChunk: (chunk: any) => Promise<void>;\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      // Decode the chunk and add to buffer\n      buffer += decoder.decode(value, { stream: true });\n\n      // Process complete SSE messages\n      const lines = buffer.split('\\n\\n');\n      buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6); // Remove 'data: '\n\n          if (data === '[DONE]') {\n            return;\n          }\n          let json;\n          try {\n            json = JSON.parse(data);\n          } catch (error) {\n            console.error(' JSON parse error:', error, 'Data:', data);\n            continue;\n          }\n          if (json) {\n            await onChunk(json);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport async function processMastraNetworkStream({\n  stream,\n  onChunk,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onChunk: (chunk: NetworkChunkType) => Promise<void>;\n}) {\n  return sharedProcessMastraStream({\n    stream,\n    onChunk,\n  });\n}\n\nexport async function processMastraStream({\n  stream,\n  onChunk,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onChunk: (chunk: ChunkType) => Promise<void>;\n}) {\n  return sharedProcessMastraStream({\n    stream,\n    onChunk,\n  });\n}\n","import type { RequestOptions, ClientOptions } from '../types';\n\nexport class BaseResource {\n  readonly options: ClientOptions;\n\n  constructor(options: ClientOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Makes an HTTP request to the API with retries and exponential backoff\n   * @param path - The API endpoint path\n   * @param options - Optional request configuration\n   * @returns Promise containing the response data\n   */\n  public async request<T>(path: string, options: RequestOptions = {}): Promise<T> {\n    let lastError: Error | null = null;\n    const {\n      baseUrl,\n      retries = 3,\n      backoffMs = 100,\n      maxBackoffMs = 1000,\n      headers = {},\n      credentials,\n      fetch: customFetch,\n    } = this.options;\n    const fetchFn = customFetch || fetch;\n\n    let delay = backoffMs;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const response = await fetchFn(`${baseUrl.replace(/\\/$/, '')}${path}`, {\n          ...options,\n          headers: {\n            ...(options.body &&\n            !(options.body instanceof FormData) &&\n            (options.method === 'POST' || options.method === 'PUT')\n              ? { 'content-type': 'application/json' }\n              : {}),\n            ...headers,\n            ...options.headers,\n            // TODO: Bring this back once we figure out what we/users need to do to make this work with cross-origin requests\n            // 'x-mastra-client-type': 'js',\n          },\n          signal: this.options.abortSignal,\n          credentials: options.credentials ?? credentials,\n          body:\n            options.body instanceof FormData ? options.body : options.body ? JSON.stringify(options.body) : undefined,\n        });\n\n        if (!response.ok) {\n          const errorBody = await response.text();\n          let errorMessage = `HTTP error! status: ${response.status}`;\n          try {\n            const errorJson = JSON.parse(errorBody);\n            errorMessage += ` - ${JSON.stringify(errorJson)}`;\n          } catch {\n            if (errorBody) {\n              errorMessage += ` - ${errorBody}`;\n            }\n          }\n          throw new Error(errorMessage);\n        }\n\n        if (options.stream) {\n          return response as unknown as T;\n        }\n\n        const data = await response.json();\n        return data as T;\n      } catch (error) {\n        lastError = error as Error;\n\n        if (attempt === retries) {\n          break;\n        }\n\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay = Math.min(delay * 2, maxBackoffMs);\n      }\n    }\n\n    throw lastError || new Error('Request failed');\n  }\n}\n","import { parsePartialJson, processDataStream } from '@ai-sdk/ui-utils';\nimport type {\n  JSONValue,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n  UIMessage,\n  UseChatOptions,\n} from '@ai-sdk/ui-utils';\nimport { v4 as uuid } from '@lukeed/uuid';\nimport type { SerializableStructuredOutputOptions } from '@mastra/core/agent';\nimport type { MessageListInput } from '@mastra/core/agent/message-list';\nimport { getErrorFromUnknown } from '@mastra/core/error';\nimport type { GenerateReturn, CoreMessage } from '@mastra/core/llm';\nimport type { RequestContext } from '@mastra/core/request-context';\nimport type { MastraModelOutput } from '@mastra/core/stream';\nimport type { Tool } from '@mastra/core/tools';\nimport type { JSONSchema7 } from 'json-schema';\nimport type { ZodType } from 'zod';\nimport type {\n  GenerateLegacyParams,\n  GetAgentResponse,\n  GetToolResponse,\n  ClientOptions,\n  StreamParams,\n  StreamLegacyParams,\n  UpdateModelParams,\n  UpdateModelInModelListParams,\n  ReorderModelListParams,\n  NetworkStreamParams,\n  StreamParamsBaseWithoutMessages,\n} from '../types';\n\nimport { parseClientRequestContext, requestContextQueryString } from '../utils';\nimport { processClientTools } from '../utils/process-client-tools';\nimport { processMastraNetworkStream, processMastraStream } from '../utils/process-mastra-stream';\nimport { zodToJsonSchema } from '../utils/zod-to-json-schema';\nimport { BaseResource } from './base';\n\nasync function executeToolCallAndRespond<OUTPUT>({\n  response,\n  params,\n  resourceId,\n  threadId,\n  requestContext,\n  respondFn,\n}: {\n  params: StreamParams<OUTPUT>;\n  response: Awaited<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;\n  resourceId?: string;\n  threadId?: string;\n  requestContext?: RequestContext<any>;\n  respondFn: Agent['generate'];\n}) {\n  if (response.finishReason === 'tool-calls') {\n    const toolCalls = (\n      response as unknown as {\n        toolCalls: { payload: { toolName: string; args: any; toolCallId: string } }[];\n        messages: CoreMessage[];\n      }\n    ).toolCalls;\n\n    if (!toolCalls || !Array.isArray(toolCalls)) {\n      return response;\n    }\n\n    for (const toolCall of toolCalls) {\n      const clientTool = params.clientTools?.[toolCall.payload.toolName] as Tool;\n\n      if (clientTool && clientTool.execute) {\n        const result = await clientTool.execute(toolCall?.payload.args, {\n          requestContext: requestContext as RequestContext,\n          tracingContext: { currentSpan: undefined },\n          agent: {\n            messages: (response as unknown as { messages: CoreMessage[] }).messages,\n            toolCallId: toolCall?.payload.toolCallId,\n            suspend: async () => {},\n            threadId,\n            resourceId,\n          },\n        });\n\n        // Build updated messages from the response, adding the tool result\n        // Do NOT re-include the original user message to avoid storage duplicates\n        const updatedMessages = [\n          ...(response.response.messages || []),\n          {\n            role: 'tool',\n            content: [\n              {\n                type: 'tool-result',\n                toolCallId: toolCall.payload.toolCallId,\n                toolName: toolCall.payload.toolName,\n                result,\n              },\n            ],\n          },\n        ] as MessageListInput;\n\n        return respondFn(updatedMessages, params);\n      }\n    }\n  }\n\n  // If no client tool was executed, return the original response\n  return response;\n}\n\nexport class AgentVoice extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private agentId: string,\n  ) {\n    super(options);\n    this.agentId = agentId;\n  }\n\n  /**\n   * Convert text to speech using the agent's voice provider\n   * @param text - Text to convert to speech\n   * @param options - Optional provider-specific options for speech generation\n   * @returns Promise containing the audio data\n   */\n  async speak(text: string, options?: { speaker?: string; [key: string]: any }): Promise<Response> {\n    return this.request<Response>(`/api/agents/${this.agentId}/voice/speak`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: { input: text, options },\n      stream: true,\n    });\n  }\n\n  /**\n   * Convert speech to text using the agent's voice provider\n   * @param audio - Audio data to transcribe\n   * @param options - Optional provider-specific options\n   * @returns Promise containing the transcribed text\n   */\n  listen(audio: Blob, options?: Record<string, any>): Promise<{ text: string }> {\n    const formData = new FormData();\n    formData.append('audio', audio);\n\n    if (options) {\n      formData.append('options', JSON.stringify(options));\n    }\n\n    return this.request(`/api/agents/${this.agentId}/voice/listen`, {\n      method: 'POST',\n      body: formData,\n    });\n  }\n\n  /**\n   * Get available speakers for the agent's voice provider\n   * @param requestContext - Optional request context to pass as query parameter\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing list of available speakers\n   */\n  getSpeakers(\n    requestContext?: RequestContext | Record<string, any>,\n  ): Promise<Array<{ voiceId: string; [key: string]: any }>> {\n    return this.request(`/api/agents/${this.agentId}/voice/speakers${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Get the listener configuration for the agent's voice provider\n   * @param requestContext - Optional request context to pass as query parameter\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing a check if the agent has listening capabilities\n   */\n  getListener(requestContext?: RequestContext | Record<string, any>): Promise<{ enabled: boolean }> {\n    return this.request(`/api/agents/${this.agentId}/voice/listener${requestContextQueryString(requestContext)}`);\n  }\n}\n\nexport class Agent extends BaseResource {\n  public readonly voice: AgentVoice;\n\n  constructor(\n    options: ClientOptions,\n    private agentId: string,\n  ) {\n    super(options);\n    this.voice = new AgentVoice(options, this.agentId);\n  }\n\n  /**\n   * Retrieves details about the agent\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing agent details including model and instructions\n   */\n  details(requestContext?: RequestContext | Record<string, any>): Promise<GetAgentResponse> {\n    return this.request(`/api/agents/${this.agentId}${requestContextQueryString(requestContext)}`);\n  }\n\n  enhanceInstructions(instructions: string, comment: string): Promise<{ explanation: string; new_prompt: string }> {\n    return this.request(`/api/agents/${this.agentId}/instructions/enhance`, {\n      method: 'POST',\n      body: { instructions, comment },\n    });\n  }\n\n  /**\n   * Generates a response from the agent\n   * @param params - Generation parameters including prompt\n   * @returns Promise containing the generated response\n   */\n  async generateLegacy(\n    params: GenerateLegacyParams<undefined> & { output?: never; experimental_output?: never },\n  ): Promise<GenerateReturn<any, undefined, undefined>>;\n  async generateLegacy<Output extends JSONSchema7 | ZodType>(\n    params: GenerateLegacyParams<Output> & { output: Output; experimental_output?: never },\n  ): Promise<GenerateReturn<any, Output, undefined>>;\n  async generateLegacy<StructuredOutput extends JSONSchema7 | ZodType>(\n    params: GenerateLegacyParams<StructuredOutput> & { output?: never; experimental_output: StructuredOutput },\n  ): Promise<GenerateReturn<any, undefined, StructuredOutput>>;\n  async generateLegacy<\n    Output extends JSONSchema7 | ZodType | undefined = undefined,\n    StructuredOutput extends JSONSchema7 | ZodType | undefined = undefined,\n  >(params: GenerateLegacyParams<Output>): Promise<GenerateReturn<any, Output, StructuredOutput>> {\n    const processedParams = {\n      ...params,\n      output: params.output ? zodToJsonSchema(params.output) : undefined,\n      experimental_output: params.experimental_output ? zodToJsonSchema(params.experimental_output) : undefined,\n      requestContext: parseClientRequestContext(params.requestContext),\n      clientTools: processClientTools(params.clientTools),\n    };\n\n    const { resourceId, threadId, requestContext } = processedParams as GenerateLegacyParams;\n\n    const response: GenerateReturn<any, Output, StructuredOutput> = await this.request(\n      `/api/agents/${this.agentId}/generate-legacy`,\n      {\n        method: 'POST',\n        body: processedParams,\n      },\n    );\n\n    if (response.finishReason === 'tool-calls') {\n      const toolCalls = (\n        response as unknown as {\n          toolCalls: { toolName: string; args: any; toolCallId: string }[];\n          messages: CoreMessage[];\n        }\n      ).toolCalls;\n\n      if (!toolCalls || !Array.isArray(toolCalls)) {\n        return response;\n      }\n\n      for (const toolCall of toolCalls) {\n        const clientTool = params.clientTools?.[toolCall.toolName] as Tool;\n\n        if (clientTool && clientTool.execute) {\n          const result = await clientTool.execute(toolCall?.args, {\n            requestContext: requestContext as RequestContext,\n            tracingContext: { currentSpan: undefined },\n            agent: {\n              messages: (response as unknown as { messages: CoreMessage[] }).messages,\n              toolCallId: toolCall?.toolCallId,\n              suspend: async () => {},\n              threadId,\n              resourceId,\n            },\n          });\n\n          // Build updated messages from the response, adding the tool result\n          // Do NOT re-include the original user message to avoid storage duplicates\n          const updatedMessages = [\n            ...(response.response as unknown as { messages: CoreMessage[] }).messages,\n            {\n              role: 'tool',\n              content: [\n                {\n                  type: 'tool-result',\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  result,\n                },\n              ],\n            },\n          ];\n          // @ts-ignore\n          return this.generate({\n            ...params,\n            messages: updatedMessages,\n          });\n        }\n      }\n    }\n\n    return response;\n  }\n\n  async generate(\n    messages: MessageListInput,\n    options?: StreamParamsBaseWithoutMessages,\n  ): Promise<ReturnType<MastraModelOutput['getFullOutput']>>;\n  async generate<OUTPUT extends {}>(\n    messages: MessageListInput,\n    options: StreamParamsBaseWithoutMessages<OUTPUT> & {\n      structuredOutput: SerializableStructuredOutputOptions<OUTPUT>;\n    },\n  ): Promise<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;\n  // Catch-all overload to handle conditional types when OUTPUT is generic\n  async generate<OUTPUT>(\n    messages: MessageListInput,\n    options?: StreamParamsBaseWithoutMessages<any> & {\n      structuredOutput?: SerializableStructuredOutputOptions<any>;\n    },\n  ): Promise<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;\n  async generate<OUTPUT = any>(\n    messages: MessageListInput,\n    options?: Omit<StreamParams<OUTPUT>, 'messages'>,\n  ): Promise<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>> {\n    // Handle both new signature (messages, options) and old signature (single param object)\n    const params = {\n      ...options,\n      messages: messages,\n    } as StreamParams<OUTPUT>;\n    const processedParams = {\n      ...params,\n      requestContext: parseClientRequestContext(params.requestContext),\n      clientTools: processClientTools(params.clientTools),\n      structuredOutput: params.structuredOutput\n        ? {\n            ...params.structuredOutput,\n            schema: zodToJsonSchema(params.structuredOutput.schema),\n          }\n        : undefined,\n    };\n\n    const { memory, requestContext } = processedParams as StreamParams;\n    const { resource, thread } = memory ?? {};\n    const resourceId = resource;\n    const threadId = typeof thread === 'string' ? thread : thread?.id;\n\n    const response = await this.request<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>(\n      `/api/agents/${this.agentId}/generate`,\n      {\n        method: 'POST',\n        body: processedParams,\n      },\n    );\n\n    if (response.finishReason === 'tool-calls') {\n      return executeToolCallAndRespond<OUTPUT>({\n        response,\n        params,\n        resourceId,\n        threadId,\n        requestContext: requestContext as RequestContext<any>,\n        respondFn: this.generate.bind(this),\n      }) as unknown as Awaited<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;\n    }\n\n    return response;\n  }\n\n  private async processChatResponse({\n    stream,\n    update,\n    onToolCall,\n    onFinish,\n    getCurrentDate = () => new Date(),\n    lastMessage,\n  }: {\n    stream: ReadableStream<Uint8Array>;\n    update: (options: { message: UIMessage; data: JSONValue[] | undefined; replaceLastMessage: boolean }) => void;\n    onToolCall?: UseChatOptions['onToolCall'];\n    onFinish?: (options: { message: UIMessage | undefined; finishReason: string; usage: string }) => void;\n    generateId?: () => string;\n    getCurrentDate?: () => Date;\n    lastMessage: UIMessage | undefined;\n  }) {\n    const replaceLastMessage = lastMessage?.role === 'assistant';\n    let step = replaceLastMessage\n      ? 1 +\n        // find max step in existing tool invocations:\n        (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0) ?? 0)\n      : 0;\n\n    const message: UIMessage = replaceLastMessage\n      ? structuredClone(lastMessage)\n      : {\n          id: uuid(),\n          createdAt: getCurrentDate(),\n          role: 'assistant',\n          content: '',\n          parts: [],\n        };\n\n    let currentTextPart: TextUIPart | undefined = undefined;\n    let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n    let currentReasoningTextDetail: { type: 'text'; text: string; signature?: string } | undefined = undefined;\n\n    function updateToolInvocationPart(toolCallId: string, invocation: ToolInvocation) {\n      const part = message.parts.find(\n        part => part.type === 'tool-invocation' && part.toolInvocation.toolCallId === toolCallId,\n      ) as ToolInvocationUIPart | undefined;\n\n      if (part != null) {\n        part.toolInvocation = invocation;\n      } else {\n        message.parts.push({\n          type: 'tool-invocation',\n          toolInvocation: invocation,\n        });\n      }\n    }\n\n    const data: JSONValue[] = [];\n\n    // keep list of current message annotations for message\n    let messageAnnotations: JSONValue[] | undefined = replaceLastMessage ? lastMessage?.annotations : undefined;\n\n    // keep track of partial tool calls\n    const partialToolCalls: Record<string, { text: string; step: number; index: number; toolName: string }> = {};\n\n    let usage: any = {\n      completionTokens: NaN,\n      promptTokens: NaN,\n      totalTokens: NaN,\n    };\n    let finishReason: string = 'unknown';\n\n    function execUpdate() {\n      // make a copy of the data array to ensure UI is updated (SWR)\n      const copiedData = [...data];\n\n      // keeps the currentMessage up to date with the latest annotations,\n      // even if annotations preceded the message creation\n      if (messageAnnotations?.length) {\n        message.annotations = messageAnnotations;\n      }\n\n      const copiedMessage = {\n        // deep copy the message to ensure that deep changes (msg attachments) are updated\n        // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n        ...structuredClone(message),\n        // add a revision id to ensure that the message is updated with SWR. SWR uses a\n        // hashing approach by default to detect changes, but it only works for shallow\n        // changes. This is why we need to add a revision id to ensure that the message\n        // is updated with SWR (without it, the changes get stuck in SWR and are not\n        // forwarded to rendering):\n        revisionId: uuid(),\n      } as UIMessage;\n\n      update({\n        message: copiedMessage,\n        data: copiedData,\n        replaceLastMessage,\n      });\n    }\n\n    await processDataStream({\n      stream: stream as ReadableStream<Uint8Array>,\n      onTextPart(value) {\n        if (currentTextPart == null) {\n          currentTextPart = {\n            type: 'text',\n            text: value,\n          };\n          message.parts.push(currentTextPart);\n        } else {\n          currentTextPart.text += value;\n        }\n\n        message.content += value;\n        execUpdate();\n      },\n      onReasoningPart(value) {\n        if (currentReasoningTextDetail == null) {\n          currentReasoningTextDetail = { type: 'text', text: value };\n          if (currentReasoningPart != null) {\n            currentReasoningPart.details.push(currentReasoningTextDetail);\n          }\n        } else {\n          currentReasoningTextDetail.text += value;\n        }\n\n        if (currentReasoningPart == null) {\n          currentReasoningPart = {\n            type: 'reasoning',\n            reasoning: value,\n            details: [currentReasoningTextDetail],\n          };\n          message.parts.push(currentReasoningPart);\n        } else {\n          currentReasoningPart.reasoning += value;\n        }\n\n        message.reasoning = (message.reasoning ?? '') + value;\n\n        execUpdate();\n      },\n      onReasoningSignaturePart(value) {\n        if (currentReasoningTextDetail != null) {\n          currentReasoningTextDetail.signature = value.signature;\n        }\n      },\n      onRedactedReasoningPart(value) {\n        if (currentReasoningPart == null) {\n          currentReasoningPart = {\n            type: 'reasoning',\n            reasoning: '',\n            details: [],\n          };\n          message.parts.push(currentReasoningPart);\n        }\n\n        currentReasoningPart.details.push({\n          type: 'redacted',\n          data: value.data,\n        });\n\n        currentReasoningTextDetail = undefined;\n\n        execUpdate();\n      },\n      onFilePart(value) {\n        message.parts.push({\n          type: 'file',\n          mimeType: value.mimeType,\n          data: value.data,\n        });\n\n        execUpdate();\n      },\n      onSourcePart(value) {\n        message.parts.push({\n          type: 'source',\n          source: value,\n        });\n\n        execUpdate();\n      },\n      onToolCallStreamingStartPart(value) {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n\n        // add the partial tool call to the map\n        partialToolCalls[value.toolCallId] = {\n          text: '',\n          step,\n          toolName: value.toolName,\n          index: message.toolInvocations.length,\n        };\n\n        const invocation = {\n          state: 'partial-call',\n          step,\n          toolCallId: value.toolCallId,\n          toolName: value.toolName,\n          args: undefined,\n        } as const;\n\n        message.toolInvocations.push(invocation);\n\n        updateToolInvocationPart(value.toolCallId, invocation);\n\n        execUpdate();\n      },\n      onToolCallDeltaPart(value) {\n        const partialToolCall = partialToolCalls[value.toolCallId];\n\n        partialToolCall!.text += value.argsTextDelta;\n\n        const { value: partialArgs } = parsePartialJson(partialToolCall!.text);\n\n        const invocation = {\n          state: 'partial-call',\n          step: partialToolCall!.step,\n          toolCallId: value.toolCallId,\n          toolName: partialToolCall!.toolName,\n          args: partialArgs,\n        } as const;\n\n        message.toolInvocations![partialToolCall!.index] = invocation;\n\n        updateToolInvocationPart(value.toolCallId, invocation);\n\n        execUpdate();\n      },\n      async onToolCallPart(value) {\n        const invocation = {\n          state: 'call',\n          step,\n          ...value,\n        } as const;\n\n        if (partialToolCalls[value.toolCallId] != null) {\n          // change the partial tool call to a full tool call\n          message.toolInvocations![partialToolCalls[value.toolCallId]!.index] = invocation;\n        } else {\n          if (message.toolInvocations == null) {\n            message.toolInvocations = [];\n          }\n\n          message.toolInvocations.push(invocation);\n        }\n\n        updateToolInvocationPart(value.toolCallId, invocation);\n\n        execUpdate();\n\n        // invoke the onToolCall callback if it exists. This is blocking.\n        // In the future we should make this non-blocking, which\n        // requires additional state management for error handling etc.\n        if (onToolCall) {\n          const result = await onToolCall({ toolCall: value });\n          if (result != null) {\n            const invocation = {\n              state: 'result',\n              step,\n              ...value,\n              result,\n            } as const;\n\n            // store the result in the tool invocation\n            message.toolInvocations![message.toolInvocations!.length - 1] = invocation;\n\n            updateToolInvocationPart(value.toolCallId, invocation);\n\n            execUpdate();\n          }\n        }\n      },\n      onToolResultPart(value) {\n        const toolInvocations = message.toolInvocations;\n\n        if (toolInvocations == null) {\n          throw new Error('tool_result must be preceded by a tool_call');\n        }\n\n        // find if there is any tool invocation with the same toolCallId\n        // and replace it with the result\n        const toolInvocationIndex = toolInvocations.findIndex(invocation => invocation.toolCallId === value.toolCallId);\n\n        if (toolInvocationIndex === -1) {\n          throw new Error('tool_result must be preceded by a tool_call with the same toolCallId');\n        }\n\n        const invocation = {\n          ...toolInvocations[toolInvocationIndex],\n          state: 'result' as const,\n          ...value,\n        } as const;\n\n        toolInvocations[toolInvocationIndex] = invocation as ToolInvocation;\n\n        updateToolInvocationPart(value.toolCallId, invocation as ToolInvocation);\n\n        execUpdate();\n      },\n      onDataPart(value) {\n        data.push(...value);\n        execUpdate();\n      },\n      onMessageAnnotationsPart(value) {\n        if (messageAnnotations == null) {\n          messageAnnotations = [...value];\n        } else {\n          messageAnnotations.push(...value);\n        }\n\n        execUpdate();\n      },\n      onFinishStepPart(value) {\n        step += 1;\n\n        // reset the current text and reasoning parts\n        currentTextPart = value.isContinued ? currentTextPart : undefined;\n        currentReasoningPart = undefined;\n        currentReasoningTextDetail = undefined;\n      },\n      onStartStepPart(value) {\n        // keep message id stable when we are updating an existing message:\n        if (!replaceLastMessage) {\n          message.id = value.messageId;\n        }\n\n        // add a step boundary part to the message\n        message.parts.push({ type: 'step-start' });\n        execUpdate();\n      },\n      onFinishMessagePart(value) {\n        finishReason = value.finishReason;\n        if (value.usage != null) {\n          // usage = calculateLanguageModelUsage(value.usage);\n          usage = value.usage;\n        }\n      },\n      onErrorPart(error) {\n        throw new Error(error);\n      },\n    });\n\n    onFinish?.({ message, finishReason, usage });\n  }\n\n  /**\n   * Streams a response from the agent\n   * @param params - Stream parameters including prompt\n   * @returns Promise containing the enhanced Response object with processDataStream method\n   */\n  async streamLegacy<T extends JSONSchema7 | ZodType | undefined = undefined>(\n    params: StreamLegacyParams<T>,\n  ): Promise<\n    Response & {\n      processDataStream: (options?: Omit<Parameters<typeof processDataStream>[0], 'stream'>) => Promise<void>;\n    }\n  > {\n    const processedParams = {\n      ...params,\n      output: params.output ? zodToJsonSchema(params.output) : undefined,\n      experimental_output: params.experimental_output ? zodToJsonSchema(params.experimental_output) : undefined,\n      requestContext: parseClientRequestContext(params.requestContext),\n      clientTools: processClientTools(params.clientTools),\n    };\n\n    // Create a readable stream that will handle the response processing\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>();\n\n    // Start processing the response in the background\n    const response = await this.processStreamResponseLegacy(processedParams, writable);\n\n    // Create a new response with the readable stream\n    const streamResponse = new Response(readable, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: (options?: Omit<Parameters<typeof processDataStream>[0], 'stream'>) => Promise<void>;\n    };\n\n    // Add the processDataStream method to the response\n    streamResponse.processDataStream = async (options = {}) => {\n      await processDataStream({\n        stream: streamResponse.body as unknown as globalThis.ReadableStream<Uint8Array>,\n        ...options,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  private async processChatResponse_vNext({\n    stream,\n    update,\n    onToolCall,\n    onFinish,\n    getCurrentDate = () => new Date(),\n    lastMessage,\n  }: {\n    stream: ReadableStream<Uint8Array>;\n    update: (options: { message: UIMessage; data: JSONValue[] | undefined; replaceLastMessage: boolean }) => void;\n    onToolCall?: UseChatOptions['onToolCall'];\n    onFinish?: (options: { message: UIMessage | undefined; finishReason: string; usage: string }) => void;\n    generateId?: () => string;\n    getCurrentDate?: () => Date;\n    lastMessage: UIMessage | undefined;\n  }) {\n    const replaceLastMessage = lastMessage?.role === 'assistant';\n    let step = replaceLastMessage\n      ? 1 +\n        // find max step in existing tool invocations:\n        (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0) ?? 0)\n      : 0;\n\n    const message: UIMessage = replaceLastMessage\n      ? structuredClone(lastMessage)\n      : {\n          id: uuid(),\n          createdAt: getCurrentDate(),\n          role: 'assistant',\n          content: '',\n          parts: [],\n        };\n\n    let currentTextPart: TextUIPart | undefined = undefined;\n    let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n    let currentReasoningTextDetail: { type: 'text'; text: string; signature?: string } | undefined = undefined;\n\n    function updateToolInvocationPart(toolCallId: string, invocation: ToolInvocation) {\n      const part = message.parts.find(\n        part => part.type === 'tool-invocation' && part.toolInvocation.toolCallId === toolCallId,\n      ) as ToolInvocationUIPart | undefined;\n\n      if (part != null) {\n        part.toolInvocation = invocation;\n      } else {\n        message.parts.push({\n          type: 'tool-invocation',\n          toolInvocation: invocation,\n        });\n      }\n    }\n\n    const data: JSONValue[] = [];\n\n    // keep list of current message annotations for message\n    let messageAnnotations: JSONValue[] | undefined = replaceLastMessage ? lastMessage?.annotations : undefined;\n\n    // keep track of partial tool calls\n    const partialToolCalls: Record<string, { text: string; step: number; index: number; toolName: string }> = {};\n\n    let usage: any = {\n      completionTokens: NaN,\n      promptTokens: NaN,\n      totalTokens: NaN,\n    };\n    let finishReason: string = 'unknown';\n\n    function execUpdate() {\n      // make a copy of the data array to ensure UI is updated (SWR)\n      const copiedData = [...data];\n\n      // keeps the currentMessage up to date with the latest annotations,\n      // even if annotations preceded the message creation\n      if (messageAnnotations?.length) {\n        message.annotations = messageAnnotations;\n      }\n\n      const copiedMessage = {\n        // deep copy the message to ensure that deep changes (msg attachments) are updated\n        // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n        ...structuredClone(message),\n        // add a revision id to ensure that the message is updated with SWR. SWR uses a\n        // hashing approach by default to detect changes, but it only works for shallow\n        // changes. This is why we need to add a revision id to ensure that the message\n        // is updated with SWR (without it, the changes get stuck in SWR and are not\n        // forwarded to rendering):\n        revisionId: uuid(),\n      } as UIMessage;\n\n      update({\n        message: copiedMessage,\n        data: copiedData,\n        replaceLastMessage,\n      });\n    }\n\n    await processMastraStream({\n      stream,\n      // TODO: casting as any here because the stream types were all typed as any before in core.\n      // but this is completely wrong and this fn is probably broken. Remove \":any\" and you'll see a bunch of type errors\n      onChunk: async (chunk: any) => {\n        switch (chunk.type) {\n          case 'tripwire': {\n            message.parts.push({\n              type: 'text',\n              text: chunk.payload.reason,\n            });\n\n            execUpdate();\n            break;\n          }\n\n          case 'step-start': {\n            // keep message id stable when we are updating an existing message:\n            if (!replaceLastMessage) {\n              message.id = chunk.payload.messageId;\n            }\n\n            // add a step boundary part to the message\n            message.parts.push({ type: 'step-start' });\n            execUpdate();\n            break;\n          }\n\n          case 'text-delta': {\n            if (currentTextPart == null) {\n              currentTextPart = {\n                type: 'text',\n                text: chunk.payload.text,\n              };\n              message.parts.push(currentTextPart);\n            } else {\n              currentTextPart.text += chunk.payload.text;\n            }\n\n            message.content += chunk.payload.text;\n            execUpdate();\n            break;\n          }\n\n          case 'reasoning-delta': {\n            if (currentReasoningTextDetail == null) {\n              currentReasoningTextDetail = { type: 'text', text: chunk.payload.text };\n              if (currentReasoningPart != null) {\n                currentReasoningPart.details.push(currentReasoningTextDetail);\n              }\n            } else {\n              currentReasoningTextDetail.text += chunk.payload.text;\n            }\n\n            if (currentReasoningPart == null) {\n              currentReasoningPart = {\n                type: 'reasoning',\n                reasoning: chunk.payload.text,\n                details: [currentReasoningTextDetail],\n              };\n              message.parts.push(currentReasoningPart);\n            } else {\n              currentReasoningPart.reasoning += chunk.payload.text;\n            }\n\n            message.reasoning = (message.reasoning ?? '') + chunk.payload.text;\n\n            execUpdate();\n            break;\n          }\n          case 'file': {\n            message.parts.push({\n              type: 'file',\n              mimeType: chunk.payload.mimeType,\n              data: chunk.payload.data,\n            });\n\n            execUpdate();\n            break;\n          }\n\n          case 'source': {\n            message.parts.push({\n              type: 'source',\n              source: chunk.payload.source,\n            });\n            execUpdate();\n            break;\n          }\n\n          case 'tool-call': {\n            const invocation = {\n              state: 'call',\n              step,\n              ...chunk.payload,\n            } as const;\n\n            if (partialToolCalls[chunk.payload.toolCallId] != null) {\n              // change the partial tool call to a full tool call\n              message.toolInvocations![partialToolCalls[chunk.payload.toolCallId]!.index] =\n                invocation as ToolInvocation;\n            } else {\n              if (message.toolInvocations == null) {\n                message.toolInvocations = [];\n              }\n\n              message.toolInvocations.push(invocation as ToolInvocation);\n            }\n\n            updateToolInvocationPart(chunk.payload.toolCallId, invocation as ToolInvocation);\n\n            execUpdate();\n\n            // invoke the onToolCall callback if it exists. This is blocking.\n            // In the future we should make this non-blocking, which\n            // requires additional state management for error handling etc.\n            if (onToolCall) {\n              const result = await onToolCall({ toolCall: chunk.payload as any });\n              if (result != null) {\n                const invocation = {\n                  state: 'result',\n                  step,\n                  ...chunk.payload,\n                  result,\n                } as const;\n\n                // store the result in the tool invocation\n                message.toolInvocations![message.toolInvocations!.length - 1] = invocation as ToolInvocation;\n\n                updateToolInvocationPart(chunk.payload.toolCallId, invocation as ToolInvocation);\n\n                execUpdate();\n              }\n            }\n          }\n\n          case 'tool-call-input-streaming-start': {\n            if (message.toolInvocations == null) {\n              message.toolInvocations = [];\n            }\n\n            // add the partial tool call to the map\n            partialToolCalls[chunk.payload.toolCallId] = {\n              text: '',\n              step,\n              toolName: chunk.payload.toolName,\n              index: message.toolInvocations.length,\n            };\n\n            const invocation = {\n              state: 'partial-call',\n              step,\n              toolCallId: chunk.payload.toolCallId,\n              toolName: chunk.payload.toolName,\n              args: chunk.payload.args,\n            } as const;\n\n            message.toolInvocations.push(invocation as ToolInvocation);\n\n            updateToolInvocationPart(chunk.payload.toolCallId, invocation);\n\n            execUpdate();\n            break;\n          }\n\n          case 'tool-call-delta': {\n            const partialToolCall = partialToolCalls[chunk.payload.toolCallId];\n\n            partialToolCall!.text += chunk.payload.argsTextDelta;\n\n            const { value: partialArgs } = parsePartialJson(partialToolCall!.text);\n\n            const invocation = {\n              state: 'partial-call',\n              step: partialToolCall!.step,\n              toolCallId: chunk.payload.toolCallId,\n              toolName: partialToolCall!.toolName,\n              args: partialArgs,\n            } as const;\n\n            message.toolInvocations![partialToolCall!.index] = invocation as ToolInvocation;\n\n            updateToolInvocationPart(chunk.payload.toolCallId, invocation);\n\n            execUpdate();\n            break;\n          }\n\n          case 'tool-result': {\n            const toolInvocations = message.toolInvocations;\n\n            if (toolInvocations == null) {\n              throw new Error('tool_result must be preceded by a tool_call');\n            }\n\n            // find if there is any tool invocation with the same toolCallId\n            // and replace it with the result\n            const toolInvocationIndex = toolInvocations.findIndex(\n              invocation => invocation.toolCallId === chunk.payload.toolCallId,\n            );\n\n            if (toolInvocationIndex === -1) {\n              throw new Error('tool_result must be preceded by a tool_call with the same toolCallId');\n            }\n\n            const invocation = {\n              ...toolInvocations[toolInvocationIndex],\n              state: 'result' as const,\n              ...chunk.payload,\n            } as const;\n\n            toolInvocations[toolInvocationIndex] = invocation as ToolInvocation;\n\n            updateToolInvocationPart(chunk.payload.toolCallId, invocation as ToolInvocation);\n\n            execUpdate();\n            break;\n          }\n\n          case 'error': {\n            throw getErrorFromUnknown(chunk.payload.error, {\n              fallbackMessage: 'Unknown error in stream',\n              supportSerialization: false,\n            });\n          }\n\n          case 'data': {\n            data.push(...chunk.payload.data);\n            execUpdate();\n            break;\n          }\n\n          case 'step-finish': {\n            step += 1;\n\n            // reset the current text and reasoning parts\n            currentTextPart = chunk.payload.stepResult.isContinued ? currentTextPart : undefined;\n            currentReasoningPart = undefined;\n            currentReasoningTextDetail = undefined;\n\n            execUpdate();\n            break;\n          }\n\n          case 'finish': {\n            finishReason = chunk.payload.stepResult.reason;\n            if (chunk.payload.usage != null) {\n              // usage = calculateLanguageModelUsage(value.usage);\n              usage = chunk.payload.usage;\n            }\n            break;\n          }\n        }\n      },\n    });\n\n    onFinish?.({ message, finishReason, usage });\n  }\n\n  async processStreamResponse(\n    processedParams: any,\n    controller: ReadableStreamDefaultController<Uint8Array>,\n    route: string = 'stream',\n  ) {\n    const response: Response = await this.request(`/api/agents/${this.agentId}/${route}`, {\n      method: 'POST',\n      body: processedParams,\n      stream: true,\n    });\n\n    if (!response.body) {\n      throw new Error('No response body');\n    }\n\n    try {\n      let toolCalls: ToolInvocation[] = [];\n      let messages: UIMessage[] = [];\n\n      // Use tee() to split the stream into two branches\n      const [streamForController, streamForProcessing] = response.body.tee();\n\n      // Pipe one branch directly to the controller\n      const pipePromise = streamForController\n        .pipeTo(\n          new WritableStream<Uint8Array>({\n            async write(chunk) {\n              // Filter out terminal markers so the client stream doesn't end before recursion\n              try {\n                const text = new TextDecoder().decode(chunk);\n                const lines = text.split('\\n\\n');\n                const readableLines = lines\n                  .filter(line => line.trim() !== '[DONE]' && line.trim() !== 'data: [DONE]')\n                  .join('\\n\\n');\n                if (readableLines) {\n                  const encoded = new TextEncoder().encode(readableLines);\n                  controller.enqueue(encoded);\n                }\n              } catch (error) {\n                console.error('Error enqueueing to controller:', error);\n                controller.enqueue(chunk);\n              }\n            },\n          }),\n        )\n        .catch(error => {\n          console.error('Error piping to controller:', error);\n          try {\n            controller.close();\n          } catch {\n            // Already closed\n          }\n        });\n\n      // Process the other branch for chat response handling\n      this.processChatResponse_vNext({\n        stream: streamForProcessing as unknown as ReadableStream<Uint8Array>,\n        update: ({ message }) => {\n          const existingIndex = messages.findIndex(m => m.id === message.id);\n\n          if (existingIndex !== -1) {\n            messages[existingIndex] = message;\n          } else {\n            messages.push(message);\n          }\n        },\n        onFinish: async ({ finishReason, message }) => {\n          if (finishReason === 'tool-calls') {\n            const toolCall = [...(message?.parts ?? [])]\n              .reverse()\n              .find(part => part.type === 'tool-invocation')?.toolInvocation;\n            if (toolCall) {\n              toolCalls.push(toolCall);\n            }\n\n            let shouldExecuteClientTool = false;\n            // Handle tool calls if needed\n            for (const toolCall of toolCalls) {\n              const clientTool = processedParams.clientTools?.[toolCall.toolName] as Tool;\n              if (clientTool && clientTool.execute) {\n                shouldExecuteClientTool = true;\n                const result = await clientTool.execute(toolCall?.args, {\n                  requestContext: processedParams.requestContext as RequestContext,\n                  // TODO: Pass proper tracing context when client-js supports tracing\n                  tracingContext: { currentSpan: undefined },\n                  agent: {\n                    messages: (response as unknown as { messages: CoreMessage[] }).messages,\n                    toolCallId: toolCall?.toolCallId,\n                    suspend: async () => {},\n                    threadId: processedParams.threadId,\n                    resourceId: processedParams.resourceId,\n                  },\n                });\n\n                const lastMessageRaw = messages[messages.length - 1];\n                const lastMessage: UIMessage | undefined =\n                  lastMessageRaw != null ? JSON.parse(JSON.stringify(lastMessageRaw)) : undefined;\n\n                const toolInvocationPart = lastMessage?.parts?.find(\n                  part => part.type === 'tool-invocation' && part.toolInvocation?.toolCallId === toolCall.toolCallId,\n                ) as ToolInvocationUIPart | undefined;\n\n                if (toolInvocationPart) {\n                  toolInvocationPart.toolInvocation = {\n                    ...toolInvocationPart.toolInvocation,\n                    state: 'result',\n                    result,\n                  };\n                }\n\n                const toolInvocation = lastMessage?.toolInvocations?.find(\n                  toolInvocation => toolInvocation.toolCallId === toolCall.toolCallId,\n                ) as ToolInvocation | undefined;\n\n                if (toolInvocation) {\n                  toolInvocation.state = 'result';\n                  // @ts-ignore\n                  toolInvocation.result = result;\n                }\n\n                // Build updated messages for the recursive call\n                // Do NOT re-include the original messages to avoid storage duplicates\n                const updatedMessages =\n                  lastMessage != null ? [...messages.filter(m => m.id !== lastMessage.id), lastMessage] : [...messages];\n\n                // Recursively call stream with updated messages\n                // This will wait for the recursive stream to complete before continuing\n                try {\n                  await this.processStreamResponse(\n                    {\n                      ...processedParams,\n                      messages: updatedMessages,\n                    },\n                    controller,\n                  );\n                } catch (error) {\n                  console.error('Error processing recursive stream response:', error);\n                }\n              }\n            }\n\n            // Close the controller after all processing is complete\n            // Wait for current pipe to finish before closing\n            if (!shouldExecuteClientTool) {\n              await pipePromise;\n              controller.close();\n            }\n            // If client tool was executed, the recursive call will handle closing the stream\n          } else {\n            // No tool calls - wait for pipe to complete then close the stream\n            await pipePromise;\n            controller.close();\n          }\n        },\n        lastMessage: undefined,\n      }).catch(async error => {\n        console.error('Error processing stream response:', error);\n        // On error, wait for pipe to complete then close the controller\n        try {\n          await pipePromise;\n          controller.close();\n        } catch {\n          // Already closed\n        }\n      });\n    } catch (error) {\n      console.error('Error processing stream response:', error);\n    }\n\n    return response;\n  }\n\n  async network(params: NetworkStreamParams): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    const response: Response = await this.request(`/api/agents/${this.agentId}/network`, {\n      method: 'POST',\n      body: params,\n      stream: true,\n    });\n\n    if (!response.body) {\n      throw new Error('No response body');\n    }\n\n    const streamResponse = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n    }) => {\n      await processMastraNetworkStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  async approveNetworkToolCall(params: { runId: string }): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    const response: Response = await this.request(`/api/agents/${this.agentId}/approve-network-tool-call`, {\n      method: 'POST',\n      body: params,\n      stream: true,\n    });\n\n    if (!response.body) {\n      throw new Error('No response body');\n    }\n\n    const streamResponse = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n    }) => {\n      await processMastraNetworkStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  async declineNetworkToolCall(params: { runId: string }): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    const response: Response = await this.request(`/api/agents/${this.agentId}/decline-network-tool-call`, {\n      method: 'POST',\n      body: params,\n      stream: true,\n    });\n\n    if (!response.body) {\n      throw new Error('No response body');\n    }\n\n    const streamResponse = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];\n    }) => {\n      await processMastraNetworkStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  async stream<OUTPUT extends {}>(\n    messages: MessageListInput,\n    streamOptions: Omit<StreamParams<OUTPUT>, 'messages' | 'structuredOutput'> & {\n      structuredOutput: SerializableStructuredOutputOptions<OUTPUT>;\n    },\n  ): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  >;\n  // async stream<OUTPUT>(\n  //   messages: MessageListInput,\n  //   streamOptions: Omit<StreamParams<any>, 'messages' | 'structuredOutput'> & {\n  //     structuredOutput?: SerializableStructuredOutputOptions<any>;\n  //   },\n  // ): Promise<\n  //   Response & {\n  //     processDataStream: ({\n  //       onChunk,\n  //     }: {\n  //       onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n  //     }) => Promise<void>;\n  //   }\n  // >;\n  async stream(\n    messages: MessageListInput,\n    streamOptions?: Omit<StreamParams, 'messages'>,\n  ): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  >;\n  async stream<OUTPUT = undefined>(\n    messagesOrParams: MessageListInput,\n    options?: Omit<StreamParams<OUTPUT>, 'messages'>,\n  ): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    // Handle both new signature (messages, options) and old signature (single param object)\n    let params: StreamParams<OUTPUT> = {\n      messages: messagesOrParams as MessageListInput,\n      ...options,\n    } as StreamParams<OUTPUT>;\n    const processedParams: StreamParams<OUTPUT> = {\n      ...params,\n      requestContext: parseClientRequestContext(params.requestContext),\n      clientTools: processClientTools(params.clientTools),\n      structuredOutput: params.structuredOutput\n        ? ({\n            ...params.structuredOutput,\n            schema: zodToJsonSchema(params.structuredOutput.schema),\n          } as SerializableStructuredOutputOptions<OUTPUT>)\n        : undefined,\n    };\n\n    // Create a manually controlled readable stream\n    let readableController: ReadableStreamDefaultController<Uint8Array>;\n    const readable = new ReadableStream<Uint8Array>({\n      start(controller) {\n        readableController = controller;\n      },\n    });\n\n    // Start processing the response in the background\n    // This returns immediately with response metadata and continues streaming in background\n    const response = await this.processStreamResponse(processedParams, readableController!);\n\n    // Create a new response with the readable stream\n    const streamResponse = new Response(readable, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    // Add the processDataStream method to the response\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n    }) => {\n      await processMastraStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  async approveToolCall(params: { runId: string; toolCallId: string }): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    // Create a manually controlled readable stream\n    let readableController: ReadableStreamDefaultController<Uint8Array>;\n    const readable = new ReadableStream<Uint8Array>({\n      start(controller) {\n        readableController = controller;\n      },\n    });\n\n    // Start processing the response in the background\n    const response = await this.processStreamResponse(params, readableController!, 'approve-tool-call');\n\n    // Create a new response with the readable stream\n    const streamResponse = new Response(readable, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    // Add the processDataStream method to the response\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n    }) => {\n      await processMastraStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  async declineToolCall(params: { runId: string; toolCallId: string }): Promise<\n    Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    }\n  > {\n    // Create a manually controlled readable stream\n    let readableController: ReadableStreamDefaultController<Uint8Array>;\n    const readable = new ReadableStream<Uint8Array>({\n      start(controller) {\n        readableController = controller;\n      },\n    });\n\n    // Start processing the response in the background\n    const response = await this.processStreamResponse(params, readableController!, 'decline-tool-call');\n\n    // Create a new response with the readable stream\n    const streamResponse = new Response(readable, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    }) as Response & {\n      processDataStream: ({\n        onChunk,\n      }: {\n        onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n      }) => Promise<void>;\n    };\n\n    // Add the processDataStream method to the response\n    streamResponse.processDataStream = async ({\n      onChunk,\n    }: {\n      onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];\n    }) => {\n      await processMastraStream({\n        stream: streamResponse.body as ReadableStream<Uint8Array>,\n        onChunk,\n      });\n    };\n\n    return streamResponse;\n  }\n\n  /**\n   * Processes the stream response and handles tool calls\n   */\n  private async processStreamResponseLegacy(processedParams: any, writable: WritableStream<Uint8Array>) {\n    const response: Response & {\n      processDataStream: (options?: Omit<Parameters<typeof processDataStream>[0], 'stream'>) => Promise<void>;\n    } = await this.request(`/api/agents/${this.agentId}/stream-legacy`, {\n      method: 'POST',\n      body: processedParams,\n      stream: true,\n    });\n\n    if (!response.body) {\n      throw new Error('No response body');\n    }\n\n    try {\n      let toolCalls: ToolInvocation[] = [];\n      let messages: UIMessage[] = [];\n\n      // Use tee() to split the stream into two branches\n      const [streamForWritable, streamForProcessing] = response.body.tee();\n\n      // Pipe one branch to the writable stream\n      streamForWritable\n        .pipeTo(writable, {\n          preventClose: true,\n        })\n        .catch(error => {\n          console.error('Error piping to writable stream:', error);\n        });\n\n      // Process the other branch for chat response handling\n      this.processChatResponse({\n        stream: streamForProcessing as unknown as ReadableStream<Uint8Array>,\n        update: ({ message }) => {\n          const existingIndex = messages.findIndex(m => m.id === message.id);\n\n          if (existingIndex !== -1) {\n            messages[existingIndex] = message;\n          } else {\n            messages.push(message);\n          }\n        },\n        onFinish: async ({ finishReason, message }) => {\n          if (finishReason === 'tool-calls') {\n            const toolCall = [...(message?.parts ?? [])]\n              .reverse()\n              .find(part => part.type === 'tool-invocation')?.toolInvocation;\n            if (toolCall) {\n              toolCalls.push(toolCall);\n            }\n\n            // Handle tool calls if needed\n            for (const toolCall of toolCalls) {\n              const clientTool = processedParams.clientTools?.[toolCall.toolName] as Tool;\n              if (clientTool && clientTool.execute) {\n                const result = await clientTool.execute(toolCall?.args, {\n                  requestContext: processedParams.requestContext as RequestContext,\n                  // TODO: Pass proper tracing context when client-js supports tracing\n                  tracingContext: { currentSpan: undefined },\n                  agent: {\n                    messages: (response as unknown as { messages: CoreMessage[] }).messages,\n                    toolCallId: toolCall?.toolCallId,\n                    suspend: async () => {},\n                    threadId: processedParams.threadId,\n                    resourceId: processedParams.resourceId,\n                  },\n                });\n\n                const lastMessage: UIMessage = JSON.parse(JSON.stringify(messages[messages.length - 1]));\n\n                const toolInvocationPart = lastMessage?.parts?.find(\n                  part => part.type === 'tool-invocation' && part.toolInvocation?.toolCallId === toolCall.toolCallId,\n                ) as ToolInvocationUIPart | undefined;\n\n                if (toolInvocationPart) {\n                  toolInvocationPart.toolInvocation = {\n                    ...toolInvocationPart.toolInvocation,\n                    state: 'result',\n                    result,\n                  };\n                }\n\n                const toolInvocation = lastMessage?.toolInvocations?.find(\n                  toolInvocation => toolInvocation.toolCallId === toolCall.toolCallId,\n                ) as ToolInvocation | undefined;\n\n                if (toolInvocation) {\n                  toolInvocation.state = 'result';\n                  // @ts-ignore\n                  toolInvocation.result = result;\n                }\n\n                // write the tool result part to the stream\n                const writer = writable.getWriter();\n\n                try {\n                  await writer.write(\n                    new TextEncoder().encode(\n                      'a:' +\n                        JSON.stringify({\n                          toolCallId: toolCall.toolCallId,\n                          result,\n                        }) +\n                        '\\n',\n                    ),\n                  );\n                } finally {\n                  writer.releaseLock();\n                }\n\n                // Recursively call stream with updated messages\n                this.processStreamResponseLegacy(\n                  {\n                    ...processedParams,\n                    messages: [...messages.filter(m => m.id !== lastMessage.id), lastMessage],\n                  },\n                  writable,\n                ).catch(error => {\n                  console.error('Error processing stream response:', error);\n                });\n              }\n            }\n          } else {\n            setTimeout(() => {\n              // We can't close the stream in this function, we have to wait until it's done\n              // eslint-disable-next-line @typescript-eslint/no-floating-promises\n              writable.close();\n            }, 0);\n          }\n        },\n        lastMessage: undefined,\n      }).catch(error => {\n        console.error('Error processing stream response:', error);\n      });\n    } catch (error) {\n      console.error('Error processing stream response:', error);\n    }\n    return response;\n  }\n\n  /**\n   * Gets details about a specific tool available to the agent\n   * @param toolId - ID of the tool to retrieve\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing tool details\n   */\n  getTool(toolId: string, requestContext?: RequestContext | Record<string, any>): Promise<GetToolResponse> {\n    return this.request(`/api/agents/${this.agentId}/tools/${toolId}${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Executes a tool for the agent\n   * @param toolId - ID of the tool to execute\n   * @param params - Parameters required for tool execution\n   * @returns Promise containing the tool execution results\n   */\n  executeTool(\n    toolId: string,\n    params: { data: any; requestContext?: RequestContext | Record<string, any> },\n  ): Promise<any> {\n    const body = {\n      data: params.data,\n      requestContext: parseClientRequestContext(params.requestContext),\n    };\n    return this.request(`/api/agents/${this.agentId}/tools/${toolId}/execute`, {\n      method: 'POST',\n      body,\n    });\n  }\n\n  /**\n   * Updates the model for the agent\n   * @param params - Parameters for updating the model\n   * @returns Promise containing the updated model\n   */\n  updateModel(params: UpdateModelParams): Promise<{ message: string }> {\n    return this.request(`/api/agents/${this.agentId}/model`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  /**\n   * Resets the agent's model to the original model that was set during construction\n   * @returns Promise containing a success message\n   */\n  resetModel(): Promise<{ message: string }> {\n    return this.request(`/api/agents/${this.agentId}/model/reset`, {\n      method: 'POST',\n      body: {},\n    });\n  }\n\n  /**\n   * Updates the model for the agent in the model list\n   * @param params - Parameters for updating the model\n   * @returns Promise containing the updated model\n   */\n  updateModelInModelList({ modelConfigId, ...params }: UpdateModelInModelListParams): Promise<{ message: string }> {\n    return this.request(`/api/agents/${this.agentId}/models/${modelConfigId}`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  /**\n   * Reorders the models for the agent\n   * @param params - Parameters for reordering the model list\n   * @returns Promise containing the updated model list\n   */\n  reorderModelList(params: ReorderModelListParams): Promise<{ message: string }> {\n    return this.request(`/api/agents/${this.agentId}/models/reorder`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n}\n","import type { RequestContext } from '@mastra/core/di';\nimport type { StorageThreadType } from '@mastra/core/memory';\n\nimport type {\n  ClientOptions,\n  UpdateMemoryThreadParams,\n  ListMemoryThreadMessagesParams,\n  ListMemoryThreadMessagesResponse,\n  CloneMemoryThreadParams,\n  CloneMemoryThreadResponse,\n} from '../types';\n\nimport { requestContextQueryString } from '../utils';\nimport { BaseResource } from './base';\n\n/**\n * MemoryThread resource for interacting with memory threads.\n *\n * agentId is optional - when not provided, the server will use storage directly.\n */\nexport class MemoryThread extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private threadId: string,\n    private agentId?: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Builds the query string for agentId (if provided)\n   */\n  private getAgentIdQueryParam(prefix: '?' | '&' = '?'): string {\n    return this.agentId ? `${prefix}agentId=${this.agentId}` : '';\n  }\n\n  /**\n   * Retrieves the memory thread details\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing thread details including title and metadata\n   */\n  get(requestContext?: RequestContext | Record<string, any>): Promise<StorageThreadType> {\n    const agentIdParam = this.getAgentIdQueryParam('?');\n    const contextParam = requestContextQueryString(requestContext, agentIdParam ? '&' : '?');\n    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`);\n  }\n\n  /**\n   * Updates the memory thread properties\n   * @param params - Update parameters including title, metadata, and optional request context\n   * @returns Promise containing updated thread details\n   */\n  update(params: UpdateMemoryThreadParams): Promise<StorageThreadType> {\n    const agentIdParam = this.getAgentIdQueryParam('?');\n    const contextParam = requestContextQueryString(params.requestContext, agentIdParam ? '&' : '?');\n    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`, {\n      method: 'PATCH',\n      body: params,\n    });\n  }\n\n  /**\n   * Deletes the memory thread\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing deletion result\n   */\n  delete(requestContext?: RequestContext | Record<string, any>): Promise<{ result: string }> {\n    const agentIdParam = this.getAgentIdQueryParam('?');\n    const contextParam = requestContextQueryString(requestContext, agentIdParam ? '&' : '?');\n    return this.request(`/api/memory/threads/${this.threadId}${agentIdParam}${contextParam}`, {\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Retrieves paginated messages associated with the thread with filtering and ordering options\n   * @param params - Pagination parameters including page, perPage, orderBy, filter, include options, and request context\n   * @returns Promise containing paginated thread messages with pagination metadata (total, page, perPage, hasMore)\n   */\n  listMessages(\n    params: ListMemoryThreadMessagesParams & {\n      requestContext?: RequestContext | Record<string, any>;\n    } = {},\n  ): Promise<ListMemoryThreadMessagesResponse> {\n    const { page, perPage, orderBy, filter, include, resourceId, requestContext } = params;\n    const queryParams: Record<string, string> = {};\n\n    if (this.agentId) queryParams.agentId = this.agentId;\n    if (resourceId) queryParams.resourceId = resourceId;\n    if (page !== undefined) queryParams.page = String(page);\n    if (perPage !== undefined) queryParams.perPage = String(perPage);\n    if (orderBy) queryParams.orderBy = JSON.stringify(orderBy);\n    if (filter) queryParams.filter = JSON.stringify(filter);\n    if (include) queryParams.include = JSON.stringify(include);\n\n    const query = new URLSearchParams(queryParams);\n    const queryString = query.toString();\n    const url = `/api/memory/threads/${this.threadId}/messages${queryString ? `?${queryString}` : ''}${requestContextQueryString(requestContext, queryString ? '&' : '?')}`;\n    return this.request(url);\n  }\n\n  /**\n   * Deletes one or more messages from the thread\n   * @param messageIds - Can be a single message ID (string), array of message IDs,\n   *                     message object with id property, or array of message objects\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing deletion result\n   */\n  deleteMessages(\n    messageIds: string | string[] | { id: string } | { id: string }[],\n    requestContext?: RequestContext | Record<string, any>,\n  ): Promise<{ success: boolean; message: string }> {\n    const queryParams: Record<string, string> = {};\n    if (this.agentId) queryParams.agentId = this.agentId;\n\n    const query = new URLSearchParams(queryParams);\n    const queryString = query.toString();\n    return this.request(\n      `/api/memory/messages/delete${queryString ? `?${queryString}` : ''}${requestContextQueryString(requestContext, queryString ? '&' : '?')}`,\n      {\n        method: 'POST',\n        body: { messageIds },\n      },\n    );\n  }\n\n  /**\n   * Clones the thread with all its messages to a new thread\n   * @param params - Clone parameters including optional new thread ID, title, metadata, and message filters\n   * @returns Promise containing the cloned thread and copied messages\n   */\n  clone(params: CloneMemoryThreadParams = {}): Promise<CloneMemoryThreadResponse> {\n    const { requestContext, ...body } = params;\n    const agentIdParam = this.getAgentIdQueryParam('?');\n    const contextParam = requestContextQueryString(requestContext, agentIdParam ? '&' : '?');\n    return this.request(`/api/memory/threads/${this.threadId}/clone${agentIdParam}${contextParam}`, {\n      method: 'POST',\n      body,\n    });\n  }\n}\n","import type { RequestContext } from '@mastra/core/request-context';\nimport type {\n  CreateIndexParams,\n  GetVectorIndexResponse,\n  QueryVectorParams,\n  QueryVectorResponse,\n  ClientOptions,\n  UpsertVectorParams,\n} from '../types';\nimport { requestContextQueryString } from '../utils';\n\nimport { BaseResource } from './base';\n\nexport class Vector extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private vectorName: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Retrieves details about a specific vector index\n   * @param indexName - Name of the index to get details for\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing vector index details\n   */\n  details(indexName: string, requestContext?: RequestContext | Record<string, any>): Promise<GetVectorIndexResponse> {\n    return this.request(\n      `/api/vector/${this.vectorName}/indexes/${indexName}${requestContextQueryString(requestContext)}`,\n    );\n  }\n\n  /**\n   * Deletes a vector index\n   * @param indexName - Name of the index to delete\n   * @returns Promise indicating deletion success\n   */\n  delete(indexName: string): Promise<{ success: boolean }> {\n    return this.request(`/api/vector/${this.vectorName}/indexes/${indexName}`, {\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Retrieves a list of all available indexes\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing array of index names\n   */\n  getIndexes(requestContext?: RequestContext | Record<string, any>): Promise<{ indexes: string[] }> {\n    return this.request(`/api/vector/${this.vectorName}/indexes${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Creates a new vector index\n   * @param params - Parameters for index creation including dimension and metric\n   * @returns Promise indicating creation success\n   */\n  createIndex(params: CreateIndexParams): Promise<{ success: boolean }> {\n    return this.request(`/api/vector/${this.vectorName}/create-index`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  /**\n   * Upserts vectors into an index\n   * @param params - Parameters containing vectors, metadata, and optional IDs\n   * @returns Promise containing array of vector IDs\n   */\n  upsert(params: UpsertVectorParams): Promise<string[]> {\n    return this.request(`/api/vector/${this.vectorName}/upsert`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  /**\n   * Queries vectors in an index\n   * @param params - Query parameters including query vector and search options\n   * @returns Promise containing query results\n   */\n  query(params: QueryVectorParams): Promise<QueryVectorResponse> {\n    return this.request(`/api/vector/${this.vectorName}/query`, {\n      method: 'POST',\n      body: params,\n    });\n  }\n}\n","import type { RequestContext } from '@mastra/core/request-context';\nimport type { GetToolResponse, ClientOptions } from '../types';\n\nimport { parseClientRequestContext, requestContextQueryString } from '../utils';\nimport { BaseResource } from './base';\n\nexport class Tool extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private toolId: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Retrieves details about the tool\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing tool details including description and schemas\n   */\n  details(requestContext?: RequestContext | Record<string, any>): Promise<GetToolResponse> {\n    return this.request(`/api/tools/${this.toolId}${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Executes the tool with the provided parameters\n   * @param params - Parameters required for tool execution\n   * @returns Promise containing the tool execution results\n   */\n  execute(params: { data: any; runId?: string; requestContext?: RequestContext | Record<string, any> }): Promise<any> {\n    const url = new URLSearchParams();\n\n    if (params.runId) {\n      url.set('runId', params.runId);\n    }\n\n    const body = {\n      data: params.data,\n      requestContext: parseClientRequestContext(params.requestContext),\n    };\n\n    return this.request(`/api/tools/${this.toolId}/execute?${url.toString()}`, {\n      method: 'POST',\n      body,\n    });\n  }\n}\n","import { getErrorFromUnknown } from '@mastra/core/error';\nimport type { TracingOptions } from '@mastra/core/observability';\nimport type { RequestContext } from '@mastra/core/request-context';\nimport type { ClientOptions, WorkflowRunResult, StreamVNextChunkType, TimeTravelParams } from '../types';\n\nimport { parseClientRequestContext } from '../utils';\nimport { BaseResource } from './base';\n\n/**\n * Deserializes the error property in a workflow result back to an Error instance.\n * Server sends SerializedError (plain object), client converts to Error for instanceof checks.\n */\nfunction deserializeWorkflowError<T extends WorkflowRunResult>(result: T): T {\n  if (result.status === 'failed' && result.error) {\n    result.error = getErrorFromUnknown(result.error, {\n      fallbackMessage: 'Unknown workflow error',\n      supportSerialization: false,\n    });\n  }\n  return result;\n}\n\nconst RECORD_SEPARATOR = '\\x1E';\n\nexport class Run extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private workflowId: string,\n    public readonly runId: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Creates a transform stream that parses RECORD_SEPARATOR-delimited JSON chunks\n   */\n  private createChunkTransformStream<T = StreamVNextChunkType>(): TransformStream<ArrayBuffer, T> {\n    //using undefined instead of empty string to avoid parsing errors\n    let failedChunk: string | undefined = undefined;\n\n    return new TransformStream<ArrayBuffer, T>({\n      start() {},\n      async transform(chunk, controller) {\n        try {\n          // Decode binary data to text\n          const decoded = new TextDecoder().decode(chunk);\n\n          // Split by record separator\n          const chunks = decoded.split(RECORD_SEPARATOR);\n\n          // Process each chunk\n          for (const chunk of chunks) {\n            if (chunk) {\n              const newChunk: string = failedChunk ? failedChunk + chunk : chunk;\n              try {\n                const parsedChunk = JSON.parse(newChunk);\n                controller.enqueue(parsedChunk);\n                failedChunk = undefined;\n              } catch {\n                failedChunk = newChunk;\n              }\n            }\n          }\n        } catch {\n          // Silently ignore processing errors\n        }\n      },\n    });\n  }\n\n  /**\n   * Cancels a specific workflow run by its ID\n   * @returns Promise containing a success message\n   * @deprecated Use `cancel()` instead\n   */\n  cancelRun(): Promise<{ message: string }> {\n    return this.request(`/api/workflows/${this.workflowId}/runs/${this.runId}/cancel`, {\n      method: 'POST',\n    });\n  }\n\n  /**\n   * Cancels a workflow run.\n   *\n   * This method aborts any running steps and updates the workflow status to 'canceled' .\n   * It works for both actively running workflows and suspended/waiting workflows.\n   *\n   * ## How cancellation works\n   *\n   * When called, the workflow will:\n   * 1. **Trigger the abort signal** - Uses the standard Web API AbortSignal to notify running steps\n   * 2. **Prevent subsequent steps** - No further steps will be executed\n   *\n   * ## Abort signal behavior\n   *\n   * Steps that check the `abortSignal` parameter can respond to cancellation:\n   * - Steps can listen to the 'abort' event: `abortSignal.addEventListener('abort', callback)`\n   * - Steps can check if already aborted: `if (abortSignal.aborted) { ... }`\n   * - Useful for canceling timeouts, network requests, or long-running operations\n   *\n   * **Note:** Steps must actively check the abort signal to be canceled mid-execution.\n   * Steps that don't check the signal will run to completion, but subsequent steps won't execute.\n   *\n   * @returns Promise that resolves with `{ message: 'Workflow run canceled' }` when cancellation succeeds\n   * @throws {HTTPException} 400 - If workflow ID or run ID is missing\n   * @throws {HTTPException} 404 - If workflow or workflow run is not found\n   *\n   * @example\n   * ```typescript\n   * const run = await workflow.createRun({ runId: 'run-123' });\n   * await run.cancel();\n   * // Returns: { message: 'Workflow run canceled' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Example of a step that responds to cancellation\n   * const step = createStep({\n   *   id: 'long-running-step',\n   *   execute: async ({ inputData, abortSignal, abort }) => {\n   *     const timeout = new Promise((resolve) => {\n   *       const timer = setTimeout(() => resolve('done'), 10000);\n   *\n   *       // Clean up if canceled\n   *       abortSignal.addEventListener('abort', () => {\n   *         clearTimeout(timer);\n   *         resolve('canceled');\n   *       });\n   *     });\n   *\n   *     const result = await timeout;\n   *\n   *     // Check if aborted after async operation\n   *     if (abortSignal.aborted) {\n   *       return abort(); // Stop execution\n   *     }\n   *\n   *     return { result };\n   *   }\n   * });\n   * ```\n   */\n  cancel(): Promise<{ message: string }> {\n    return this.request(`/api/workflows/${this.workflowId}/runs/${this.runId}/cancel`, {\n      method: 'POST',\n    });\n  }\n\n  /**\n   * Starts a workflow run synchronously without waiting for the workflow to complete\n   * @param params - Object containing the inputData, initialState and requestContext\n   * @returns Promise containing success message\n   */\n  start(params: {\n    inputData: Record<string, any>;\n    initialState?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    perStep?: boolean;\n  }): Promise<{ message: string }> {\n    const requestContext = parseClientRequestContext(params.requestContext);\n    return this.request(`/api/workflows/${this.workflowId}/start?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        inputData: params?.inputData,\n        initialState: params?.initialState,\n        requestContext,\n        tracingOptions: params.tracingOptions,\n        perStep: params.perStep,\n      },\n    });\n  }\n\n  /**\n   * Resumes a suspended workflow step synchronously without waiting for the workflow to complete\n   * @param params - Object containing the step, resumeData and requestContext\n   * @returns Promise containing success message\n   */\n  resume({\n    step,\n    resumeData,\n    tracingOptions,\n    perStep,\n    ...rest\n  }: {\n    step?: string | string[];\n    resumeData?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    perStep?: boolean;\n  }): Promise<{ message: string }> {\n    const requestContext = parseClientRequestContext(rest.requestContext);\n    return this.request(`/api/workflows/${this.workflowId}/resume?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        step,\n        resumeData,\n        requestContext,\n        tracingOptions,\n        perStep,\n      },\n    });\n  }\n\n  /**\n   * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the inputData, initialState and requestContext\n   * @returns Promise containing the workflow execution results\n   */\n  startAsync(params: {\n    inputData: Record<string, any>;\n    initialState?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    resourceId?: string;\n    perStep?: boolean;\n  }): Promise<WorkflowRunResult> {\n    const searchParams = new URLSearchParams();\n\n    searchParams.set('runId', this.runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n\n    return this.request<WorkflowRunResult>(`/api/workflows/${this.workflowId}/start-async?${searchParams.toString()}`, {\n      method: 'POST',\n      body: {\n        inputData: params.inputData,\n        initialState: params.initialState,\n        requestContext,\n        tracingOptions: params.tracingOptions,\n        resourceId: params.resourceId,\n        perStep: params.perStep,\n      },\n    }).then(deserializeWorkflowError);\n  }\n\n  /**\n   * Starts a workflow run and returns a stream\n   * @param params - Object containing the inputData, initialState and requestContext\n   * @returns Promise containing the workflow execution results\n   */\n  async stream(params: {\n    inputData: Record<string, any>;\n    initialState?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    resourceId?: string;\n    perStep?: boolean;\n    closeOnSuspend?: boolean;\n  }) {\n    const searchParams = new URLSearchParams();\n\n    searchParams.set('runId', this.runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const response: Response = await this.request(\n      `/api/workflows/${this.workflowId}/stream?${searchParams.toString()}`,\n      {\n        method: 'POST',\n        body: {\n          inputData: params.inputData,\n          initialState: params.initialState,\n          requestContext,\n          tracingOptions: params.tracingOptions,\n          resourceId: params.resourceId,\n          perStep: params.perStep,\n          closeOnSuspend: params.closeOnSuspend,\n        },\n        stream: true,\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to stream workflow: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    // Pipe the response body through the transform stream\n    return response.body.pipeThrough(this.createChunkTransformStream());\n  }\n\n  /**\n   * Observes workflow stream for a workflow run\n   * @returns Promise containing the workflow execution results\n   */\n  async observeStream() {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', this.runId);\n    const response: Response = await this.request(\n      `/api/workflows/${this.workflowId}/observe-stream?${searchParams.toString()}`,\n      {\n        method: 'POST',\n        stream: true,\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to observe workflow stream: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    // Pipe the response body through the transform stream\n    return response.body.pipeThrough(this.createChunkTransformStream());\n  }\n\n  /**\n   * Resumes a suspended workflow step asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the step, resumeData and requestContext\n   * @returns Promise containing the workflow resume results\n   */\n  resumeAsync(params: {\n    step?: string | string[];\n    resumeData?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    perStep?: boolean;\n  }): Promise<WorkflowRunResult> {\n    const requestContext = parseClientRequestContext(params.requestContext);\n    return this.request<WorkflowRunResult>(`/api/workflows/${this.workflowId}/resume-async?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        step: params.step,\n        resumeData: params.resumeData,\n        requestContext,\n        tracingOptions: params.tracingOptions,\n        perStep: params.perStep,\n      },\n    }).then(deserializeWorkflowError);\n  }\n\n  /**\n   * Resumes a suspended workflow step that uses stream asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the step, resumeData and requestContext\n   * @returns Promise containing the workflow resume results\n   */\n  async resumeStream(params: {\n    step?: string | string[];\n    resumeData?: Record<string, any>;\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n    perStep?: boolean;\n  }) {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', this.runId);\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const response: Response = await this.request(\n      `/api/workflows/${this.workflowId}/resume-stream?${searchParams.toString()}`,\n      {\n        method: 'POST',\n        body: {\n          step: params.step,\n          resumeData: params.resumeData,\n          requestContext,\n          tracingOptions: params.tracingOptions,\n          perStep: params.perStep,\n        },\n        stream: true,\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to stream vNext workflow: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    // Pipe the response body through the transform stream\n    return response.body.pipeThrough(this.createChunkTransformStream());\n  }\n\n  /**\n   * Restarts an active workflow run synchronously without waiting for the workflow to complete\n   * @param params - Object containing the requestContext\n   * @returns Promise containing success message\n   */\n  restart(params: {\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n  }): Promise<{ message: string }> {\n    const requestContext = parseClientRequestContext(params.requestContext);\n    return this.request(`/api/workflows/${this.workflowId}/restart?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        requestContext,\n        tracingOptions: params.tracingOptions,\n      },\n    });\n  }\n\n  /**\n   * Restarts an active workflow run asynchronously\n   * @param params - optional object containing the requestContext\n   * @returns Promise containing the workflow restart results\n   */\n  restartAsync(params?: {\n    requestContext?: RequestContext | Record<string, any>;\n    tracingOptions?: TracingOptions;\n  }): Promise<WorkflowRunResult> {\n    const requestContext = parseClientRequestContext(params?.requestContext);\n    return this.request<WorkflowRunResult>(`/api/workflows/${this.workflowId}/restart-async?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        requestContext,\n        tracingOptions: params?.tracingOptions,\n      },\n    }).then(deserializeWorkflowError);\n  }\n\n  /**\n   * Time travels a workflow run synchronously without waiting for the workflow to complete\n   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions\n   * @returns Promise containing success message\n   */\n  timeTravel({ requestContext: paramsRequestContext, ...params }: TimeTravelParams): Promise<{ message: string }> {\n    const requestContext = parseClientRequestContext(paramsRequestContext);\n    return this.request(`/api/workflows/${this.workflowId}/time-travel?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        ...params,\n        requestContext,\n      },\n    });\n  }\n\n  /**\n   * Time travels a workflow run asynchronously\n   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions\n   * @returns Promise containing the workflow time travel results\n   */\n  timeTravelAsync({ requestContext: paramsRequestContext, ...params }: TimeTravelParams): Promise<WorkflowRunResult> {\n    const requestContext = parseClientRequestContext(paramsRequestContext);\n    return this.request<WorkflowRunResult>(`/api/workflows/${this.workflowId}/time-travel-async?runId=${this.runId}`, {\n      method: 'POST',\n      body: {\n        ...params,\n        requestContext,\n      },\n    }).then(deserializeWorkflowError);\n  }\n\n  /**\n   * Time travels a workflow run and returns a stream\n   * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions\n   * @returns Promise containing the workflow execution results\n   */\n  async timeTravelStream({ requestContext: paramsRequestContext, ...params }: TimeTravelParams) {\n    const requestContext = parseClientRequestContext(paramsRequestContext);\n    const response: Response = await this.request(\n      `/api/workflows/${this.workflowId}/time-travel-stream?runId=${this.runId}`,\n      {\n        method: 'POST',\n        body: {\n          ...params,\n          requestContext,\n        },\n        stream: true,\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to time travel workflow: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    // Pipe the response body through the transform stream\n    return response.body.pipeThrough(this.createChunkTransformStream());\n  }\n}\n","import type { RequestContext } from '@mastra/core/request-context';\nimport type {\n  ClientOptions,\n  GetWorkflowResponse,\n  ListWorkflowRunsResponse,\n  ListWorkflowRunsParams,\n  GetWorkflowRunByIdResponse,\n} from '../types';\n\nimport { parseClientRequestContext, base64RequestContext, requestContextQueryString } from '../utils';\nimport { BaseResource } from './base';\nimport { Run } from './run';\n\nconst RECORD_SEPARATOR = '\\x1E';\n\nexport class Workflow extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private workflowId: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Retrieves details about the workflow\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing workflow details including steps and graphs\n   */\n  details(requestContext?: RequestContext | Record<string, any>): Promise<GetWorkflowResponse> {\n    return this.request(`/api/workflows/${this.workflowId}${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Retrieves all runs for a workflow\n   * @param params - Parameters for filtering runs\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing workflow runs array\n   */\n  runs(\n    params?: ListWorkflowRunsParams,\n    requestContext?: RequestContext | Record<string, any>,\n  ): Promise<ListWorkflowRunsResponse> {\n    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));\n\n    const searchParams = new URLSearchParams();\n    if (params?.fromDate) {\n      searchParams.set('fromDate', params.fromDate.toISOString());\n    }\n    if (params?.toDate) {\n      searchParams.set('toDate', params.toDate.toISOString());\n    }\n    if (params?.page !== undefined) {\n      searchParams.set('page', String(params.page));\n    }\n    if (params?.perPage !== undefined) {\n      searchParams.set('perPage', String(params.perPage));\n    }\n    // Legacy support: also send limit/offset if provided (for older servers)\n    if (params?.limit !== null && params?.limit !== undefined) {\n      if (params.limit === false) {\n        searchParams.set('limit', 'false');\n      } else if (typeof params.limit === 'number' && params.limit > 0 && Number.isInteger(params.limit)) {\n        searchParams.set('limit', String(params.limit));\n      }\n    }\n    if (params?.offset !== null && params?.offset !== undefined && !isNaN(Number(params?.offset))) {\n      searchParams.set('offset', String(params.offset));\n    }\n    if (params?.resourceId) {\n      searchParams.set('resourceId', params.resourceId);\n    }\n    if (params?.status) {\n      searchParams.set('status', params.status);\n    }\n    if (requestContextParam) {\n      searchParams.set('requestContext', requestContextParam);\n    }\n\n    if (searchParams.size) {\n      return this.request(`/api/workflows/${this.workflowId}/runs?${searchParams}`);\n    } else {\n      return this.request(`/api/workflows/${this.workflowId}/runs`);\n    }\n  }\n\n  /**\n   * Retrieves a specific workflow run by its ID\n   * @param runId - The ID of the workflow run to retrieve\n   * @param options - Optional configuration\n   * @param options.requestContext - Optional request context to pass as query parameter\n   * @param options.fields - Optional array of fields to return (e.g., ['result', 'steps']). Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph. Metadata fields (runId, workflowName, resourceId, createdAt, updatedAt) and status are always included.\n   * @param options.withNestedWorkflows - Whether to include nested workflow data in steps. Defaults to true. Set to false for better performance when you don't need nested workflow details.\n   * @returns Promise containing the workflow run details with metadata and processed execution state\n   */\n  runById(\n    runId: string,\n    options?: {\n      requestContext?: RequestContext | Record<string, any>;\n      fields?: string[];\n      withNestedWorkflows?: boolean;\n    },\n  ): Promise<GetWorkflowRunByIdResponse> {\n    const searchParams = new URLSearchParams();\n\n    if (options?.fields && options.fields.length > 0) {\n      searchParams.set('fields', options.fields.join(','));\n    }\n\n    if (options?.withNestedWorkflows !== undefined) {\n      searchParams.set('withNestedWorkflows', String(options.withNestedWorkflows));\n    }\n\n    const requestContextParam = base64RequestContext(parseClientRequestContext(options?.requestContext));\n    if (requestContextParam) {\n      searchParams.set('requestContext', requestContextParam);\n    }\n\n    const queryString = searchParams.size > 0 ? `?${searchParams.toString()}` : '';\n    return this.request(`/api/workflows/${this.workflowId}/runs/${runId}${queryString}`);\n  }\n\n  /**\n   * Deletes a specific workflow run by its ID\n   * @param runId - The ID of the workflow run to delete\n   * @returns Promise containing a success message\n   */\n  deleteRunById(runId: string): Promise<{ message: string }> {\n    return this.request(`/api/workflows/${this.workflowId}/runs/${runId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Creates a new workflow run\n   * @param params - Optional object containing the optional runId\n   * @returns Promise containing the Run instance\n   */\n  async createRun(params?: { runId?: string; resourceId?: string; disableScorers?: boolean }) {\n    const searchParams = new URLSearchParams();\n\n    if (!!params?.runId) {\n      searchParams.set('runId', params.runId);\n    }\n\n    const res = await this.request<{ runId: string }>(\n      `/api/workflows/${this.workflowId}/create-run?${searchParams.toString()}`,\n      {\n        method: 'POST',\n        body: {\n          resourceId: params?.resourceId,\n          disableScorers: params?.disableScorers,\n        },\n      },\n    );\n\n    const run = new Run(this.options, this.workflowId, res.runId);\n\n    return run;\n  }\n\n  /**\n   * Creates a new ReadableStream from an iterable or async iterable of objects,\n   * serializing each as JSON and separating them with the record separator (\\x1E).\n   *\n   * @param records - An iterable or async iterable of objects to stream\n   * @returns A ReadableStream emitting the records as JSON strings separated by the record separator\n   */\n  static createRecordStream(records: Iterable<any> | AsyncIterable<any>): ReadableStream {\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start(controller) {\n        try {\n          for await (const record of records as AsyncIterable<any>) {\n            const json = JSON.stringify(record) + RECORD_SEPARATOR;\n            controller.enqueue(encoder.encode(json));\n          }\n          controller.close();\n        } catch (err) {\n          controller.error(err);\n        }\n      },\n    });\n  }\n}\n","import type {\n  AgentCard,\n  GetTaskResponse,\n  MessageSendParams,\n  SendMessageResponse,\n  SendStreamingMessageResponse,\n  Task,\n  TaskQueryParams,\n} from '@mastra/core/a2a';\nimport type { ClientOptions } from '../types';\nimport { BaseResource } from './base';\n\n/**\n * Class for interacting with an agent via the A2A protocol\n */\nexport class A2A extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private agentId: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Get the agent card with metadata about the agent\n   * @returns Promise containing the agent card information\n   */\n  async getCard(): Promise<AgentCard> {\n    return this.request(`/.well-known/${this.agentId}/agent-card.json`);\n  }\n\n  /**\n   * Send a message to the agent and gets a message or task response\n   * @param params - Parameters for the task\n   * @returns Promise containing the response\n   */\n  async sendMessage(params: MessageSendParams): Promise<SendMessageResponse> {\n    const response = await this.request<SendMessageResponse>(`/a2a/${this.agentId}`, {\n      method: 'POST',\n      body: {\n        method: 'message/send',\n        params,\n      },\n    });\n\n    return response;\n  }\n\n  /**\n   * Sends a message to an agent to initiate/continue a task and subscribes\n   * the client to real-time updates for that task via Server-Sent Events (SSE).\n   * @param params - Parameters for the task\n   * @returns A stream of Server-Sent Events. Each SSE `data` field contains a `SendStreamingMessageResponse`\n   */\n  async sendStreamingMessage(params: MessageSendParams): Promise<AsyncIterable<SendStreamingMessageResponse>> {\n    const response = await this.request<AsyncIterable<SendStreamingMessageResponse>>(`/a2a/${this.agentId}`, {\n      method: 'POST',\n      body: {\n        method: 'message/stream',\n        params,\n      },\n      stream: true,\n    });\n\n    return response;\n  }\n\n  /**\n   * Get the status and result of a task\n   * @param params - Parameters for querying the task\n   * @returns Promise containing the task response\n   */\n  async getTask(params: TaskQueryParams): Promise<GetTaskResponse> {\n    const response = await this.request<GetTaskResponse>(`/a2a/${this.agentId}`, {\n      method: 'POST',\n      body: {\n        method: 'tasks/get',\n        params,\n      },\n    });\n\n    return response;\n  }\n\n  /**\n   * Cancel a running task\n   * @param params - Parameters identifying the task to cancel\n   * @returns Promise containing the task response\n   */\n  async cancelTask(params: TaskQueryParams): Promise<Task> {\n    return this.request(`/a2a/${this.agentId}`, {\n      method: 'POST',\n      body: {\n        method: 'tasks/cancel',\n        params,\n      },\n    });\n  }\n}\n","import type { RequestContext } from '@mastra/core/request-context';\nimport type { ClientOptions, McpToolInfo } from '../types';\nimport { requestContextQueryString } from '../utils';\nimport { BaseResource } from './base';\n\n/**\n * Represents a specific tool available on a specific MCP server.\n * Provides methods to get details and execute the tool.\n */\nexport class MCPTool extends BaseResource {\n  private serverId: string;\n  private toolId: string;\n\n  constructor(options: ClientOptions, serverId: string, toolId: string) {\n    super(options);\n    this.serverId = serverId;\n    this.toolId = toolId;\n  }\n\n  /**\n   * Retrieves details about this specific tool from the MCP server.\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing the tool's information (name, description, schema).\n   */\n  details(requestContext?: RequestContext | Record<string, any>): Promise<McpToolInfo> {\n    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}${requestContextQueryString(requestContext)}`);\n  }\n\n  /**\n   * Executes this specific tool on the MCP server.\n   * @param params - Parameters for tool execution, including data/args and optional requestContext.\n   * @returns Promise containing the result of the tool execution.\n   */\n  execute(params: { data?: any; requestContext?: RequestContext }): Promise<any> {\n    const body: any = {};\n    if (params.data !== undefined) body.data = params.data;\n    // If none of data, args the body might be empty or just contain requestContext.\n    // The handler will look for these, so an empty args object might be appropriate if that's the intent.\n    // else body.data = {}; // Or let it be empty if no specific input fields are used\n\n    if (params.requestContext !== undefined) {\n      body.requestContext = params.requestContext;\n    }\n\n    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}/execute`, {\n      method: 'POST',\n      body: Object.keys(body).length > 0 ? body : undefined,\n    });\n  }\n}\n","import type { RequestContext } from '@mastra/core/request-context';\nimport type { WorkflowInfo } from '@mastra/core/workflows';\nimport type { ClientOptions, ListWorkflowRunsParams } from '../types';\nimport { parseClientRequestContext } from '../utils';\nimport { BaseResource } from './base';\n\nconst RECORD_SEPARATOR = '\\x1E';\n\nexport interface AgentBuilderActionRequest {\n  /** Input data specific to the workflow type */\n  inputData: any;\n  /** Request context for the action execution */\n  requestContext?: RequestContext;\n}\n\nexport interface AgentBuilderActionResult {\n  success: boolean;\n  applied: boolean;\n  branchName?: string;\n  message: string;\n  validationResults?: any;\n  error?: string;\n  errors?: string[];\n  stepResults?: any;\n}\n\n/**\n * Agent Builder resource: operations related to agent-builder workflows via server endpoints.\n */\nexport class AgentBuilder extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private actionId: string,\n  ) {\n    super(options);\n  }\n\n  // Helper function to transform workflow result to action result\n  transformWorkflowResult(result: any): AgentBuilderActionResult {\n    if (result.status === 'success') {\n      return {\n        success: result.result.success || false,\n        applied: result.result.applied || false,\n        branchName: result.result.branchName,\n        message: result.result.message || 'Agent builder action completed',\n        validationResults: result.result.validationResults,\n        error: result.result.error,\n        errors: result.result.errors,\n        stepResults: result.result.stepResults,\n      };\n    } else if (result.status === 'failed') {\n      return {\n        success: false,\n        applied: false,\n        message: `Agent builder action failed: ${result.error.message}`,\n        error: result.error.message,\n      };\n    } else {\n      return {\n        success: false,\n        applied: false,\n        message: 'Agent builder action was suspended',\n        error: 'Workflow suspended - manual intervention required',\n      };\n    }\n  }\n\n  /**\n   * Creates a transform stream that parses binary chunks into JSON records.\n   */\n  private createRecordParserTransform(): TransformStream<ArrayBuffer, { type: string; payload: any }> {\n    let failedChunk: string | undefined = undefined;\n\n    return new TransformStream<ArrayBuffer, { type: string; payload: any }>({\n      start() {},\n      async transform(chunk, controller) {\n        try {\n          // Decode binary data to text\n          const decoded = new TextDecoder().decode(chunk);\n\n          // Split by record separator\n          const chunks = decoded.split(RECORD_SEPARATOR);\n\n          // Process each chunk\n          for (const chunk of chunks) {\n            if (chunk) {\n              const newChunk: string = failedChunk ? failedChunk + chunk : chunk;\n              try {\n                const parsedChunk = JSON.parse(newChunk);\n                controller.enqueue(parsedChunk);\n                failedChunk = undefined;\n              } catch {\n                failedChunk = newChunk;\n              }\n            }\n          }\n        } catch {\n          // Silently ignore processing errors\n        }\n      },\n    });\n  }\n\n  /**\n   * Creates a new agent builder action run and returns the runId.\n   * This calls `/api/agent-builder/:actionId/create-run`.\n   */\n  async createRun(params?: { runId?: string }): Promise<{ runId: string }> {\n    const searchParams = new URLSearchParams();\n\n    if (!!params?.runId) {\n      searchParams.set('runId', params.runId);\n    }\n\n    const url = `/api/agent-builder/${this.actionId}/create-run${searchParams.toString() ? `?${searchParams.toString()}` : ''}`;\n    return this.request(url, {\n      method: 'POST',\n    });\n  }\n\n  /**\n   * Starts agent builder action asynchronously and waits for completion.\n   * This calls `/api/agent-builder/:actionId/start-async`.\n   */\n  async startAsync(params: AgentBuilderActionRequest, runId?: string): Promise<AgentBuilderActionResult> {\n    const searchParams = new URLSearchParams();\n    if (runId) {\n      searchParams.set('runId', runId);\n    }\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { requestContext: _, ...actionParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/start-async${searchParams.toString() ? `?${searchParams.toString()}` : ''}`;\n    const result = await this.request(url, {\n      method: 'POST',\n      body: { ...actionParams, requestContext },\n    });\n\n    return this.transformWorkflowResult(result);\n  }\n\n  /**\n   * Starts an existing agent builder action run.\n   * This calls `/api/agent-builder/:actionId/start`.\n   */\n  async startActionRun(params: AgentBuilderActionRequest, runId: string): Promise<{ message: string }> {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { requestContext: _, ...actionParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/start?${searchParams.toString()}`;\n    return this.request(url, {\n      method: 'POST',\n      body: { ...actionParams, requestContext },\n    });\n  }\n\n  /**\n   * Resumes a suspended agent builder action step.\n   * This calls `/api/agent-builder/:actionId/resume`.\n   */\n  async resume(\n    params: {\n      step?: string | string[];\n      resumeData?: unknown;\n      requestContext?: RequestContext;\n    },\n    runId: string,\n  ): Promise<{ message: string }> {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { requestContext: _, ...resumeParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/resume?${searchParams.toString()}`;\n    return this.request(url, {\n      method: 'POST',\n      body: { ...resumeParams, requestContext },\n    });\n  }\n\n  /**\n   * Resumes a suspended agent builder action step asynchronously.\n   * This calls `/api/agent-builder/:actionId/resume-async`.\n   */\n  async resumeAsync(\n    params: {\n      step?: string | string[];\n      resumeData?: unknown;\n      requestContext?: RequestContext;\n    },\n    runId: string,\n  ): Promise<AgentBuilderActionResult> {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { requestContext: _, ...resumeParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/resume-async?${searchParams.toString()}`;\n    const result = await this.request(url, {\n      method: 'POST',\n      body: { ...resumeParams, requestContext },\n    });\n\n    return this.transformWorkflowResult(result);\n  }\n\n  /**\n   * Creates an async generator that processes a readable stream and yields action records\n   * separated by the Record Separator character (\\x1E)\n   *\n   * @param stream - The readable stream to process\n   * @returns An async generator that yields parsed records\n   */\n  private async *streamProcessor(\n    stream: ReadableStream,\n  ): AsyncGenerator<{ type: string; payload: any }, void, unknown> {\n    const reader = stream.getReader();\n\n    // Track if we've finished reading from the stream\n    let doneReading = false;\n    // Buffer to accumulate partial chunks\n    let buffer = '';\n\n    try {\n      while (!doneReading) {\n        // Read the next chunk from the stream\n        const { done, value } = await reader.read();\n        doneReading = done;\n\n        // Skip processing if we're done and there's no value\n        if (done && !value) continue;\n\n        try {\n          // Decode binary data to text\n          const decoded = value ? new TextDecoder().decode(value) : '';\n\n          // Split the combined buffer and new data by record separator\n          const chunks = (buffer + decoded).split(RECORD_SEPARATOR);\n\n          // The last chunk might be incomplete, so save it for the next iteration\n          buffer = chunks.pop() || '';\n\n          // Process complete chunks\n          for (const chunk of chunks) {\n            if (chunk) {\n              // Only process non-empty chunks\n              if (typeof chunk === 'string') {\n                try {\n                  const parsedChunk = JSON.parse(chunk);\n                  yield parsedChunk;\n                } catch {\n                  // Silently ignore parsing errors to maintain stream processing\n                  // This allows the stream to continue even if one record is malformed\n                }\n              }\n            }\n          }\n        } catch {\n          // Silently ignore parsing errors to maintain stream processing\n          // This allows the stream to continue even if one record is malformed\n        }\n      }\n\n      // Process any remaining data in the buffer after stream is done\n      if (buffer) {\n        try {\n          yield JSON.parse(buffer);\n        } catch {\n          // Ignore parsing error for final chunk\n        }\n      }\n    } finally {\n      // Always ensure we clean up the reader\n      reader.cancel().catch(() => {\n        // Ignore cancel errors\n      });\n    }\n  }\n\n  /**\n   * Streams agent builder action progress in real-time.\n   * This calls `/api/agent-builder/:actionId/stream`.\n   */\n  async stream(params: AgentBuilderActionRequest, runId?: string) {\n    const searchParams = new URLSearchParams();\n    if (runId) {\n      searchParams.set('runId', runId);\n    }\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { requestContext: _, ...actionParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/stream${searchParams.toString() ? `?${searchParams.toString()}` : ''}`;\n    const response: Response = await this.request(url, {\n      method: 'POST',\n      body: { ...actionParams, requestContext },\n      stream: true,\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to stream agent builder action: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    return response.body.pipeThrough(this.createRecordParserTransform());\n  }\n\n  /**\n   * Observes an existing agent builder action run stream.\n   * Replays cached execution from the beginning, then continues with live stream.\n   * This is the recommended method for recovery after page refresh/hot reload.\n   * This calls `/api/agent-builder/:actionId/observe`\n   */\n  async observeStream(params: { runId: string }) {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', params.runId);\n\n    const url = `/api/agent-builder/${this.actionId}/observe?${searchParams.toString()}`;\n    const response: Response = await this.request(url, {\n      method: 'POST',\n      stream: true,\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to observe agent builder action stream: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    return response.body.pipeThrough(this.createRecordParserTransform());\n  }\n\n  /**\n   * Observes an existing agent builder action run stream using legacy streaming API.\n   * Replays cached execution from the beginning, then continues with live stream.\n   * This calls `/api/agent-builder/:actionId/observe-stream-legacy`.\n   */\n  async observeStreamLegacy(params: { runId: string }) {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', params.runId);\n\n    const url = `/api/agent-builder/${this.actionId}/observe-stream-legacy?${searchParams.toString()}`;\n    const response: Response = await this.request(url, {\n      method: 'POST',\n      stream: true,\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to observe agent builder action stream legacy: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    return response.body.pipeThrough(this.createRecordParserTransform());\n  }\n\n  /**\n   * Resumes a suspended agent builder action and streams the results.\n   * This calls `/api/agent-builder/:actionId/resume-stream`.\n   */\n  async resumeStream(params: {\n    runId: string;\n    step: string | string[];\n    resumeData?: unknown;\n    requestContext?: RequestContext;\n  }): Promise<ReadableStream> {\n    const searchParams = new URLSearchParams();\n    searchParams.set('runId', params.runId);\n\n    const requestContext = parseClientRequestContext(params.requestContext);\n    const { runId: _, requestContext: __, ...resumeParams } = params;\n\n    const url = `/api/agent-builder/${this.actionId}/resume-stream?${searchParams.toString()}`;\n    const response: Response = await this.request(url, {\n      method: 'POST',\n      body: { ...resumeParams, requestContext },\n      stream: true,\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to resume agent builder action stream: ${response.statusText}`);\n    }\n\n    if (!response.body) {\n      throw new Error('Response body is null');\n    }\n\n    return response.body.pipeThrough(this.createRecordParserTransform());\n  }\n\n  /**\n   * Gets a specific action run by its ID.\n   * This calls `/api/agent-builder/:actionId/runs/:runId`.\n   * @param runId - The ID of the action run to retrieve\n   * @param options - Optional configuration\n   * @param options.fields - Optional array of fields to return (e.g., ['result', 'steps']). Available fields: result, error, payload, steps, activeStepsPath, serializedStepGraph. Metadata fields (runId, workflowName, resourceId, createdAt, updatedAt) and status are always included.\n   * @param options.withNestedWorkflows - Whether to include nested workflow data in steps. Defaults to true. Set to false for better performance when you don't need nested workflow details.\n   * @returns Promise containing the action run details with metadata and processed execution state\n   */\n  async runById(\n    runId: string,\n    options?: {\n      fields?: string[];\n      withNestedWorkflows?: boolean;\n    },\n  ) {\n    const searchParams = new URLSearchParams();\n\n    if (options?.fields && options.fields.length > 0) {\n      searchParams.set('fields', options.fields.join(','));\n    }\n\n    if (options?.withNestedWorkflows !== undefined) {\n      searchParams.set('withNestedWorkflows', String(options.withNestedWorkflows));\n    }\n\n    const queryString = searchParams.size > 0 ? `?${searchParams.toString()}` : '';\n    const url = `/api/agent-builder/${this.actionId}/runs/${runId}${queryString}`;\n    return this.request(url, {\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Gets details about this agent builder action.\n   * This calls `/api/agent-builder/:actionId`.\n   */\n  async details(): Promise<WorkflowInfo> {\n    const result = await this.request<WorkflowInfo>(`/api/agent-builder/${this.actionId}`);\n    return result;\n  }\n\n  /**\n   * Gets all runs for this agent builder action.\n   * This calls `/api/agent-builder/:actionId/runs`.\n   */\n  async runs(params?: ListWorkflowRunsParams) {\n    const searchParams = new URLSearchParams();\n    if (params?.fromDate) {\n      searchParams.set('fromDate', params.fromDate.toISOString());\n    }\n    if (params?.toDate) {\n      searchParams.set('toDate', params.toDate.toISOString());\n    }\n    if (params?.perPage !== undefined) {\n      searchParams.set('perPage', String(params.perPage));\n    }\n    if (params?.page !== undefined) {\n      searchParams.set('page', String(params.page));\n    }\n    // Legacy support: also send limit/offset if provided (for older servers)\n    if (params?.limit !== null && params?.limit !== undefined) {\n      if (params.limit === false) {\n        searchParams.set('limit', 'false');\n      } else if (typeof params.limit === 'number' && params.limit > 0 && Number.isInteger(params.limit)) {\n        searchParams.set('limit', String(params.limit));\n      }\n    }\n    if (params?.offset !== null && params?.offset !== undefined && !isNaN(Number(params?.offset))) {\n      searchParams.set('offset', String(params.offset));\n    }\n    if (params?.resourceId) {\n      searchParams.set('resourceId', params.resourceId);\n    }\n\n    const url = `/api/agent-builder/${this.actionId}/runs${searchParams.toString() ? `?${searchParams.toString()}` : ''}`;\n    return this.request(url, {\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Cancels an agent builder action run.\n   * This calls `/api/agent-builder/:actionId/runs/:runId/cancel`.\n   */\n  async cancelRun(runId: string): Promise<{ message: string }> {\n    const url = `/api/agent-builder/${this.actionId}/runs/${runId}/cancel`;\n    return this.request(url, {\n      method: 'POST',\n    });\n  }\n}\n","import type { ListScoresResponse } from '@mastra/core/evals';\nimport type { SpanType } from '@mastra/core/observability';\nimport type {\n  TraceRecord,\n  ListTracesArgs,\n  ListTracesResponse,\n  SpanIds,\n  PaginationArgs,\n  SpanRecord,\n  PaginationInfo,\n  ScoreTracesRequest,\n  ScoreTracesResponse,\n} from '@mastra/core/storage';\nimport type { ClientOptions } from '../types';\nimport { toQueryParams } from '../utils';\nimport { BaseResource } from './base';\n\n// ============================================================================\n// Legacy Types (for backward compatibility with main branch API)\n// ============================================================================\n\n/**\n * Legacy pagination arguments from main branch.\n * @deprecated Use ListTracesArgs instead with the new listTraces() method.\n */\nexport interface LegacyPaginationArgs {\n  dateRange?: {\n    start?: Date;\n    end?: Date;\n  };\n  page?: number;\n  perPage?: number;\n}\n\n/**\n * Legacy traces query parameters from main branch.\n * @deprecated Use ListTracesArgs instead with the new listTraces() method.\n */\nexport interface LegacyTracesPaginatedArg {\n  filters?: {\n    name?: string;\n    spanType?: SpanType;\n    entityId?: string;\n    entityType?: 'agent' | 'workflow';\n  };\n  pagination?: LegacyPaginationArgs;\n}\n\n/**\n * Legacy response type from main branch.\n * @deprecated Use ListTracesResponse instead.\n */\nexport interface LegacyGetTracesResponse {\n  spans: SpanRecord[];\n  pagination: PaginationInfo;\n}\n\nexport type ListScoresBySpanParams = SpanIds & PaginationArgs;\n\n// ============================================================================\n// Observability Resource\n// ============================================================================\n\nexport class Observability extends BaseResource {\n  constructor(options: ClientOptions) {\n    super(options);\n  }\n\n  /**\n   * Retrieves a specific trace by ID\n   * @param traceId - ID of the trace to retrieve\n   * @returns Promise containing the trace with all its spans\n   */\n  getTrace(traceId: string): Promise<TraceRecord> {\n    return this.request(`/api/observability/traces/${traceId}`);\n  }\n\n  /**\n   * Retrieves paginated list of traces with optional filtering.\n   * This is the legacy API preserved for backward compatibility.\n   *\n   * @param params - Parameters for pagination and filtering (legacy format)\n   * @returns Promise containing paginated traces and pagination info\n   * @deprecated Use {@link listTraces} instead for new features like ordering and more filters.\n   */\n  getTraces(params: LegacyTracesPaginatedArg): Promise<LegacyGetTracesResponse> {\n    const { pagination, filters } = params;\n    const { page, perPage, dateRange } = pagination || {};\n    const { name, spanType, entityId, entityType } = filters || {};\n    const searchParams = new URLSearchParams();\n\n    if (page !== undefined) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage !== undefined) {\n      searchParams.set('perPage', String(perPage));\n    }\n    if (name) {\n      searchParams.set('name', name);\n    }\n    if (spanType !== undefined) {\n      searchParams.set('spanType', String(spanType));\n    }\n    if (entityId && entityType) {\n      searchParams.set('entityId', entityId);\n      searchParams.set('entityType', entityType);\n    }\n\n    if (dateRange) {\n      const dateRangeStr = JSON.stringify({\n        start: dateRange.start instanceof Date ? dateRange.start.toISOString() : dateRange.start,\n        end: dateRange.end instanceof Date ? dateRange.end.toISOString() : dateRange.end,\n      });\n      searchParams.set('dateRange', dateRangeStr);\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/observability/traces${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves paginated list of traces with optional filtering and sorting.\n   * This is the new API with improved filtering options.\n   *\n   * @param params - Parameters for pagination, filtering, and ordering\n   * @returns Promise containing paginated traces and pagination info\n   */\n  listTraces(params: ListTracesArgs = {}): Promise<ListTracesResponse> {\n    const queryString = toQueryParams(params, ['filters', 'pagination', 'orderBy']);\n    return this.request(`/api/observability/traces${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves scores by trace ID and span ID\n   * @param params - Parameters containing trace ID, span ID, and pagination options\n   * @returns Promise containing scores and pagination info\n   */\n  listScoresBySpan(params: ListScoresBySpanParams): Promise<ListScoresResponse> {\n    const { traceId, spanId, ...pagination } = params;\n    const queryString = toQueryParams(pagination);\n    return this.request(\n      `/api/observability/traces/${encodeURIComponent(traceId)}/${encodeURIComponent(spanId)}/scores${queryString ? `?${queryString}` : ''}`,\n    );\n  }\n\n  /**\n   * Scores one or more traces using a specified scorer.\n   * @param params - Scorer name and targets to score\n   * @returns Promise containing the scoring status\n   */\n  score(params: ScoreTracesRequest): Promise<ScoreTracesResponse> {\n    return this.request(`/api/observability/traces/score`, {\n      method: 'POST',\n      body: { ...params },\n    });\n  }\n}\n","import type { ClientOptions, StoredAgentResponse, UpdateStoredAgentParams, DeleteStoredAgentResponse } from '../types';\n\nimport { BaseResource } from './base';\n\n/**\n * Resource for interacting with a specific stored agent\n */\nexport class StoredAgent extends BaseResource {\n  constructor(\n    options: ClientOptions,\n    private storedAgentId: string,\n  ) {\n    super(options);\n  }\n\n  /**\n   * Retrieves details about the stored agent\n   * @returns Promise containing stored agent details\n   */\n  details(): Promise<StoredAgentResponse> {\n    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`);\n  }\n\n  /**\n   * Updates the stored agent with the provided fields\n   * @param params - Fields to update\n   * @returns Promise containing the updated stored agent\n   */\n  update(params: UpdateStoredAgentParams): Promise<StoredAgentResponse> {\n    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`, {\n      method: 'PATCH',\n      body: params,\n    });\n  }\n\n  /**\n   * Deletes the stored agent\n   * @returns Promise containing deletion confirmation\n   */\n  delete(): Promise<DeleteStoredAgentResponse> {\n    return this.request(`/api/stored/agents/${encodeURIComponent(this.storedAgentId)}`, {\n      method: 'DELETE',\n    });\n  }\n}\n","import type { ListScoresResponse } from '@mastra/core/evals';\nimport type { ServerDetailInfo } from '@mastra/core/mcp';\nimport type { RequestContext } from '@mastra/core/request-context';\nimport type { TraceRecord, ListTracesArgs, ListTracesResponse } from '@mastra/core/storage';\nimport type { WorkflowInfo } from '@mastra/core/workflows';\nimport {\n  Agent,\n  MemoryThread,\n  Tool,\n  Workflow,\n  Vector,\n  BaseResource,\n  A2A,\n  MCPTool,\n  AgentBuilder,\n  Observability,\n  StoredAgent,\n} from './resources';\nimport type {\n  ListScoresBySpanParams,\n  LegacyTracesPaginatedArg,\n  LegacyGetTracesResponse,\n} from './resources/observability';\nimport type {\n  ClientOptions,\n  CreateMemoryThreadParams,\n  CreateMemoryThreadResponse,\n  GetAgentResponse,\n  GetLogParams,\n  GetLogsParams,\n  GetLogsResponse,\n  GetToolResponse,\n  GetWorkflowResponse,\n  SaveMessageToMemoryParams,\n  SaveMessageToMemoryResponse,\n  McpServerListResponse,\n  McpServerToolListResponse,\n  GetScorerResponse,\n  ListScoresByScorerIdParams,\n  ListScoresByRunIdParams,\n  ListScoresByEntityIdParams,\n  SaveScoreParams,\n  SaveScoreResponse,\n  GetMemoryConfigParams,\n  GetMemoryConfigResponse,\n  ListMemoryThreadMessagesResponse,\n  MemorySearchResponse,\n  ListAgentsModelProvidersResponse,\n  ListMemoryThreadsParams,\n  ListMemoryThreadsResponse,\n  ListStoredAgentsParams,\n  ListStoredAgentsResponse,\n  CreateStoredAgentParams,\n  StoredAgentResponse,\n  GetSystemPackagesResponse,\n  ListScoresResponse as ListScoresResponseOld,\n} from './types';\nimport { base64RequestContext, parseClientRequestContext, requestContextQueryString } from './utils';\n\nexport class MastraClient extends BaseResource {\n  private observability: Observability;\n  constructor(options: ClientOptions) {\n    super(options);\n    this.observability = new Observability(options);\n  }\n\n  /**\n   * Retrieves all available agents\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing map of agent IDs to agent details\n   */\n  public listAgents(\n    requestContext?: RequestContext | Record<string, any>,\n    partial?: boolean,\n  ): Promise<Record<string, GetAgentResponse>> {\n    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));\n\n    const searchParams = new URLSearchParams();\n\n    if (requestContextParam) {\n      searchParams.set('requestContext', requestContextParam);\n    }\n\n    if (partial) {\n      searchParams.set('partial', 'true');\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/agents${queryString ? `?${queryString}` : ''}`);\n  }\n\n  public listAgentsModelProviders(): Promise<ListAgentsModelProvidersResponse> {\n    return this.request(`/api/agents/providers`);\n  }\n\n  /**\n   * Gets an agent instance by ID\n   * @param agentId - ID of the agent to retrieve\n   * @returns Agent instance\n   */\n  public getAgent(agentId: string) {\n    return new Agent(this.options, agentId);\n  }\n\n  /**\n   * Lists memory threads for a resource with pagination support\n   * @param params - Parameters containing resource ID, pagination options, and optional request context\n   * @returns Promise containing paginated array of memory threads with metadata\n   */\n  public async listMemoryThreads(params: ListMemoryThreadsParams): Promise<ListMemoryThreadsResponse> {\n    const queryParams = new URLSearchParams({\n      resourceId: params.resourceId,\n      resourceid: params.resourceId,\n      ...(params.agentId && { agentId: params.agentId }),\n      ...(params.page !== undefined && { page: params.page.toString() }),\n      ...(params.perPage !== undefined && { perPage: params.perPage.toString() }),\n      ...(params.orderBy && { orderBy: params.orderBy }),\n      ...(params.sortDirection && { sortDirection: params.sortDirection }),\n    });\n\n    const response: ListMemoryThreadsResponse | ListMemoryThreadsResponse['threads'] = await this.request(\n      `/api/memory/threads?${queryParams.toString()}${requestContextQueryString(params.requestContext, '&')}`,\n    );\n\n    const actualResponse: ListMemoryThreadsResponse =\n      'threads' in response\n        ? response\n        : {\n            threads: response,\n            total: response.length,\n            page: params.page ?? 0,\n            perPage: params.perPage ?? 100,\n            hasMore: false,\n          };\n\n    return actualResponse;\n  }\n\n  /**\n   * Retrieves memory config for a resource\n   * @param params - Parameters containing the resource ID and optional request context\n   * @returns Promise containing memory configuration\n   */\n  public getMemoryConfig(params: GetMemoryConfigParams): Promise<GetMemoryConfigResponse> {\n    return this.request(\n      `/api/memory/config?agentId=${params.agentId}${requestContextQueryString(params.requestContext, '&')}`,\n    );\n  }\n\n  /**\n   * Creates a new memory thread\n   * @param params - Parameters for creating the memory thread including optional request context\n   * @returns Promise containing the created memory thread\n   */\n  public createMemoryThread(params: CreateMemoryThreadParams): Promise<CreateMemoryThreadResponse> {\n    return this.request(\n      `/api/memory/threads?agentId=${params.agentId}${requestContextQueryString(params.requestContext, '&')}`,\n      { method: 'POST', body: params },\n    );\n  }\n\n  /**\n   * Gets a memory thread instance by ID\n   * @param threadId - ID of the memory thread to retrieve\n   * @param agentId - Optional agent ID. When not provided, uses storage directly\n   * @returns MemoryThread instance\n   */\n  public getMemoryThread({ threadId, agentId }: { threadId: string; agentId?: string }) {\n    return new MemoryThread(this.options, threadId, agentId);\n  }\n\n  /**\n   * Lists messages for a thread.\n   * @param threadId - ID of the thread\n   * @param opts - Optional parameters including agentId, networkId, and requestContext\n   *   - When agentId is provided, uses the agent's memory\n   *   - When networkId is provided, uses the network endpoint\n   *   - When neither is provided, uses storage directly\n   * @returns Promise containing the thread messages\n   */\n  public listThreadMessages(\n    threadId: string,\n    opts: { agentId?: string; networkId?: string; requestContext?: RequestContext | Record<string, any> } = {},\n  ): Promise<ListMemoryThreadMessagesResponse> {\n    let url = '';\n    if (opts.networkId) {\n      url = `/api/memory/network/threads/${threadId}/messages?networkId=${opts.networkId}${requestContextQueryString(opts.requestContext, '&')}`;\n    } else if (opts.agentId) {\n      url = `/api/memory/threads/${threadId}/messages?agentId=${opts.agentId}${requestContextQueryString(opts.requestContext, '&')}`;\n    } else {\n      url = `/api/memory/threads/${threadId}/messages${requestContextQueryString(opts.requestContext, '?')}`;\n    }\n    return this.request(url);\n  }\n\n  public deleteThread(\n    threadId: string,\n    opts: { agentId?: string; networkId?: string; requestContext?: RequestContext | Record<string, any> } = {},\n  ): Promise<{ success: boolean; message: string }> {\n    let url = '';\n\n    if (opts.agentId) {\n      url = `/api/memory/threads/${threadId}?agentId=${opts.agentId}${requestContextQueryString(opts.requestContext, '&')}`;\n    } else if (opts.networkId) {\n      url = `/api/memory/network/threads/${threadId}?networkId=${opts.networkId}${requestContextQueryString(opts.requestContext, '&')}`;\n    }\n    return this.request(url, { method: 'DELETE' });\n  }\n\n  /**\n   * Saves messages to memory\n   * @param params - Parameters containing messages to save and optional request context\n   * @returns Promise containing the saved messages\n   */\n  public saveMessageToMemory(params: SaveMessageToMemoryParams): Promise<SaveMessageToMemoryResponse> {\n    return this.request(\n      `/api/memory/save-messages?agentId=${params.agentId}${requestContextQueryString(params.requestContext, '&')}`,\n      {\n        method: 'POST',\n        body: params,\n      },\n    );\n  }\n\n  /**\n   * Gets the status of the memory system\n   * @param agentId - The agent ID\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing memory system status\n   */\n  public getMemoryStatus(\n    agentId: string,\n    requestContext?: RequestContext | Record<string, any>,\n  ): Promise<{ result: boolean }> {\n    return this.request(`/api/memory/status?agentId=${agentId}${requestContextQueryString(requestContext, '&')}`);\n  }\n\n  /**\n   * Retrieves all available tools\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing map of tool IDs to tool details\n   */\n  public listTools(requestContext?: RequestContext | Record<string, any>): Promise<Record<string, GetToolResponse>> {\n    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));\n\n    const searchParams = new URLSearchParams();\n\n    if (requestContextParam) {\n      searchParams.set('requestContext', requestContextParam);\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/tools${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Gets a tool instance by ID\n   * @param toolId - ID of the tool to retrieve\n   * @returns Tool instance\n   */\n  public getTool(toolId: string) {\n    return new Tool(this.options, toolId);\n  }\n\n  /**\n   * Retrieves all available workflows\n   * @param requestContext - Optional request context to pass as query parameter\n   * @returns Promise containing map of workflow IDs to workflow details\n   */\n  public listWorkflows(\n    requestContext?: RequestContext | Record<string, any>,\n    partial?: boolean,\n  ): Promise<Record<string, GetWorkflowResponse>> {\n    const requestContextParam = base64RequestContext(parseClientRequestContext(requestContext));\n\n    const searchParams = new URLSearchParams();\n\n    if (requestContextParam) {\n      searchParams.set('requestContext', requestContextParam);\n    }\n\n    if (partial) {\n      searchParams.set('partial', 'true');\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/workflows${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Gets a workflow instance by ID\n   * @param workflowId - ID of the workflow to retrieve\n   * @returns Workflow instance\n   */\n  public getWorkflow(workflowId: string) {\n    return new Workflow(this.options, workflowId);\n  }\n\n  /**\n   * Gets all available agent builder actions\n   * @returns Promise containing map of action IDs to action details\n   */\n  public getAgentBuilderActions(): Promise<Record<string, WorkflowInfo>> {\n    return this.request('/api/agent-builder/');\n  }\n\n  /**\n   * Gets an agent builder instance for executing agent-builder workflows\n   * @returns AgentBuilder instance\n   */\n  public getAgentBuilderAction(actionId: string) {\n    return new AgentBuilder(this.options, actionId);\n  }\n\n  /**\n   * Gets a vector instance by name\n   * @param vectorName - Name of the vector to retrieve\n   * @returns Vector instance\n   */\n  public getVector(vectorName: string) {\n    return new Vector(this.options, vectorName);\n  }\n\n  /**\n   * Retrieves logs\n   * @param params - Parameters for filtering logs\n   * @returns Promise containing array of log messages\n   */\n  public listLogs(params: GetLogsParams): Promise<GetLogsResponse> {\n    const { transportId, fromDate, toDate, logLevel, filters, page, perPage } = params;\n    const _filters = filters ? Object.entries(filters).map(([key, value]) => `${key}:${value}`) : [];\n\n    const searchParams = new URLSearchParams();\n    if (transportId) {\n      searchParams.set('transportId', transportId);\n    }\n    if (fromDate) {\n      searchParams.set('fromDate', fromDate.toISOString());\n    }\n    if (toDate) {\n      searchParams.set('toDate', toDate.toISOString());\n    }\n    if (logLevel) {\n      searchParams.set('logLevel', logLevel);\n    }\n    if (page) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage) {\n      searchParams.set('perPage', String(perPage));\n    }\n    if (_filters) {\n      if (Array.isArray(_filters)) {\n        for (const filter of _filters) {\n          searchParams.append('filters', filter);\n        }\n      } else {\n        searchParams.set('filters', _filters);\n      }\n    }\n\n    if (searchParams.size) {\n      return this.request(`/api/logs?${searchParams}`);\n    } else {\n      return this.request(`/api/logs`);\n    }\n  }\n\n  /**\n   * Gets logs for a specific run\n   * @param params - Parameters containing run ID to retrieve\n   * @returns Promise containing array of log messages\n   */\n  public getLogForRun(params: GetLogParams): Promise<GetLogsResponse> {\n    const { runId, transportId, fromDate, toDate, logLevel, filters, page, perPage } = params;\n\n    const _filters = filters ? Object.entries(filters).map(([key, value]) => `${key}:${value}`) : [];\n    const searchParams = new URLSearchParams();\n    if (runId) {\n      searchParams.set('runId', runId);\n    }\n    if (transportId) {\n      searchParams.set('transportId', transportId);\n    }\n    if (fromDate) {\n      searchParams.set('fromDate', fromDate.toISOString());\n    }\n    if (toDate) {\n      searchParams.set('toDate', toDate.toISOString());\n    }\n    if (logLevel) {\n      searchParams.set('logLevel', logLevel);\n    }\n    if (page) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage) {\n      searchParams.set('perPage', String(perPage));\n    }\n\n    if (_filters) {\n      if (Array.isArray(_filters)) {\n        for (const filter of _filters) {\n          searchParams.append('filters', filter);\n        }\n      } else {\n        searchParams.set('filters', _filters);\n      }\n    }\n\n    if (searchParams.size) {\n      return this.request(`/api/logs/${runId}?${searchParams}`);\n    } else {\n      return this.request(`/api/logs/${runId}`);\n    }\n  }\n\n  /**\n   * List of all log transports\n   * @returns Promise containing list of log transports\n   */\n  public listLogTransports(): Promise<{ transports: string[] }> {\n    return this.request('/api/logs/transports');\n  }\n\n  /**\n   * Retrieves a list of available MCP servers.\n   * @param params - Optional parameters for pagination (page, perPage, or deprecated offset, limit).\n   * @returns Promise containing the list of MCP servers and pagination info.\n   */\n  public getMcpServers(params?: {\n    page?: number;\n    perPage?: number;\n    /** @deprecated Use page instead */\n    offset?: number;\n    /** @deprecated Use perPage instead */\n    limit?: number;\n  }): Promise<McpServerListResponse> {\n    const searchParams = new URLSearchParams();\n    if (params?.page !== undefined) {\n      searchParams.set('page', String(params.page));\n    }\n    if (params?.perPage !== undefined) {\n      searchParams.set('perPage', String(params.perPage));\n    }\n    // Legacy support: also send limit/offset if provided (for older servers)\n    if (params?.limit !== undefined) {\n      searchParams.set('limit', String(params.limit));\n    }\n    if (params?.offset !== undefined) {\n      searchParams.set('offset', String(params.offset));\n    }\n    const queryString = searchParams.toString();\n    return this.request(`/api/mcp/v0/servers${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves detailed information for a specific MCP server.\n   * @param serverId - The ID of the MCP server to retrieve.\n   * @param params - Optional parameters, e.g., specific version.\n   * @returns Promise containing the detailed MCP server information.\n   */\n  public getMcpServerDetails(serverId: string, params?: { version?: string }): Promise<ServerDetailInfo> {\n    const searchParams = new URLSearchParams();\n    if (params?.version) {\n      searchParams.set('version', params.version);\n    }\n    const queryString = searchParams.toString();\n    return this.request(`/api/mcp/v0/servers/${serverId}${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves a list of tools for a specific MCP server.\n   * @param serverId - The ID of the MCP server.\n   * @returns Promise containing the list of tools.\n   */\n  public getMcpServerTools(serverId: string): Promise<McpServerToolListResponse> {\n    return this.request(`/api/mcp/${serverId}/tools`);\n  }\n\n  /**\n   * Gets an MCPTool resource instance for a specific tool on an MCP server.\n   * This instance can then be used to fetch details or execute the tool.\n   * @param serverId - The ID of the MCP server.\n   * @param toolId - The ID of the tool.\n   * @returns MCPTool instance.\n   */\n  public getMcpServerTool(serverId: string, toolId: string): MCPTool {\n    return new MCPTool(this.options, serverId, toolId);\n  }\n\n  /**\n   * Gets an A2A client for interacting with an agent via the A2A protocol\n   * @param agentId - ID of the agent to interact with\n   * @returns A2A client instance\n   */\n  public getA2A(agentId: string) {\n    return new A2A(this.options, agentId);\n  }\n\n  /**\n   * Retrieves the working memory for a specific thread (optionally resource-scoped).\n   * @param agentId - ID of the agent.\n   * @param threadId - ID of the thread.\n   * @param resourceId - Optional ID of the resource.\n   * @returns Working memory for the specified thread or resource.\n   */\n  public getWorkingMemory({\n    agentId,\n    threadId,\n    resourceId,\n    requestContext,\n  }: {\n    agentId: string;\n    threadId: string;\n    resourceId?: string;\n    requestContext?: RequestContext | Record<string, any>;\n  }) {\n    return this.request(\n      `/api/memory/threads/${threadId}/working-memory?agentId=${agentId}&resourceId=${resourceId}${requestContextQueryString(requestContext, '&')}`,\n    );\n  }\n\n  public searchMemory({\n    agentId,\n    resourceId,\n    threadId,\n    searchQuery,\n    memoryConfig,\n    requestContext,\n  }: {\n    agentId: string;\n    resourceId: string;\n    threadId?: string;\n    searchQuery: string;\n    memoryConfig?: any;\n    requestContext?: RequestContext | Record<string, any>;\n  }): Promise<MemorySearchResponse> {\n    const params = new URLSearchParams({\n      searchQuery,\n      resourceId,\n      agentId,\n    });\n\n    if (threadId) {\n      params.append('threadId', threadId);\n    }\n\n    if (memoryConfig) {\n      params.append('memoryConfig', JSON.stringify(memoryConfig));\n    }\n\n    return this.request(`/api/memory/search?${params}${requestContextQueryString(requestContext, '&')}`);\n  }\n\n  /**\n   * Updates the working memory for a specific thread (optionally resource-scoped).\n   * @param agentId - ID of the agent.\n   * @param threadId - ID of the thread.\n   * @param workingMemory - The new working memory content.\n   * @param resourceId - Optional ID of the resource.\n   */\n  public updateWorkingMemory({\n    agentId,\n    threadId,\n    workingMemory,\n    resourceId,\n    requestContext,\n  }: {\n    agentId: string;\n    threadId: string;\n    workingMemory: string;\n    resourceId?: string;\n    requestContext?: RequestContext | Record<string, any>;\n  }) {\n    return this.request(\n      `/api/memory/threads/${threadId}/working-memory?agentId=${agentId}${requestContextQueryString(requestContext, '&')}`,\n      {\n        method: 'POST',\n        body: {\n          workingMemory,\n          resourceId,\n        },\n      },\n    );\n  }\n\n  /**\n   * Retrieves all available scorers\n   * @returns Promise containing list of available scorers\n   */\n  public listScorers(): Promise<Record<string, GetScorerResponse>> {\n    return this.request('/api/scores/scorers');\n  }\n\n  /**\n   * Retrieves a scorer by ID\n   * @param scorerId - ID of the scorer to retrieve\n   * @returns Promise containing the scorer\n   */\n  public getScorer(scorerId: string): Promise<GetScorerResponse> {\n    return this.request(`/api/scores/scorers/${encodeURIComponent(scorerId)}`);\n  }\n\n  public listScoresByScorerId(params: ListScoresByScorerIdParams): Promise<ListScoresResponseOld> {\n    const { page, perPage, scorerId, entityId, entityType } = params;\n    const searchParams = new URLSearchParams();\n\n    if (entityId) {\n      searchParams.set('entityId', entityId);\n    }\n    if (entityType) {\n      searchParams.set('entityType', entityType);\n    }\n\n    if (page !== undefined) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage !== undefined) {\n      searchParams.set('perPage', String(perPage));\n    }\n    const queryString = searchParams.toString();\n    return this.request(`/api/scores/scorer/${encodeURIComponent(scorerId)}${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves scores by run ID\n   * @param params - Parameters containing run ID and pagination options\n   * @returns Promise containing scores and pagination info\n   */\n  public listScoresByRunId(params: ListScoresByRunIdParams): Promise<ListScoresResponseOld> {\n    const { runId, page, perPage } = params;\n    const searchParams = new URLSearchParams();\n\n    if (page !== undefined) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage !== undefined) {\n      searchParams.set('perPage', String(perPage));\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/scores/run/${encodeURIComponent(runId)}${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Retrieves scores by entity ID and type\n   * @param params - Parameters containing entity ID, type, and pagination options\n   * @returns Promise containing scores and pagination info\n   */\n  public listScoresByEntityId(params: ListScoresByEntityIdParams): Promise<ListScoresResponseOld> {\n    const { entityId, entityType, page, perPage } = params;\n    const searchParams = new URLSearchParams();\n\n    if (page !== undefined) {\n      searchParams.set('page', String(page));\n    }\n    if (perPage !== undefined) {\n      searchParams.set('perPage', String(perPage));\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(\n      `/api/scores/entity/${encodeURIComponent(entityType)}/${encodeURIComponent(entityId)}${queryString ? `?${queryString}` : ''}`,\n    );\n  }\n\n  /**\n   * Saves a score\n   * @param params - Parameters containing the score data to save\n   * @returns Promise containing the saved score\n   */\n  public saveScore(params: SaveScoreParams): Promise<SaveScoreResponse> {\n    return this.request('/api/scores', {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  getTrace(traceId: string): Promise<TraceRecord> {\n    return this.observability.getTrace(traceId);\n  }\n\n  /**\n   * Retrieves paginated list of traces with optional filtering.\n   * This is the legacy API preserved for backward compatibility.\n   *\n   * @param params - Parameters for pagination and filtering (legacy format)\n   * @returns Promise containing paginated traces and pagination info\n   * @deprecated Use {@link listTraces} instead for new features like ordering and more filters.\n   */\n  getTraces(params: LegacyTracesPaginatedArg): Promise<LegacyGetTracesResponse> {\n    return this.observability.getTraces(params);\n  }\n\n  /**\n   * Retrieves paginated list of traces with optional filtering and sorting.\n   * This is the new API with improved filtering options.\n   *\n   * @param params - Parameters for pagination, filtering, and ordering\n   * @returns Promise containing paginated traces and pagination info\n   */\n  listTraces(params: ListTracesArgs = {}): Promise<ListTracesResponse> {\n    return this.observability.listTraces(params);\n  }\n\n  listScoresBySpan(params: ListScoresBySpanParams): Promise<ListScoresResponse> {\n    return this.observability.listScoresBySpan(params);\n  }\n\n  score(params: {\n    scorerName: string;\n    targets: Array<{ traceId: string; spanId?: string }>;\n  }): Promise<{ status: string; message: string }> {\n    return this.observability.score(params);\n  }\n\n  // ============================================================================\n  // Stored Agents\n  // ============================================================================\n\n  /**\n   * Lists all stored agents with optional pagination\n   * @param params - Optional pagination and ordering parameters\n   * @returns Promise containing paginated list of stored agents\n   */\n  public listStoredAgents(params?: ListStoredAgentsParams): Promise<ListStoredAgentsResponse> {\n    const searchParams = new URLSearchParams();\n\n    if (params?.page !== undefined) {\n      searchParams.set('page', String(params.page));\n    }\n    if (params?.perPage !== undefined) {\n      searchParams.set('perPage', String(params.perPage));\n    }\n    if (params?.orderBy) {\n      if (params.orderBy.field) {\n        searchParams.set('orderBy[field]', params.orderBy.field);\n      }\n      if (params.orderBy.direction) {\n        searchParams.set('orderBy[direction]', params.orderBy.direction);\n      }\n    }\n\n    const queryString = searchParams.toString();\n    return this.request(`/api/stored/agents${queryString ? `?${queryString}` : ''}`);\n  }\n\n  /**\n   * Creates a new stored agent\n   * @param params - Agent configuration including id, name, instructions, model, etc.\n   * @returns Promise containing the created stored agent\n   */\n  public createStoredAgent(params: CreateStoredAgentParams): Promise<StoredAgentResponse> {\n    return this.request('/api/stored/agents', {\n      method: 'POST',\n      body: params,\n    });\n  }\n\n  /**\n   * Gets a stored agent instance by ID for further operations (details, update, delete)\n   * @param storedAgentId - ID of the stored agent to retrieve\n   * @returns StoredAgent instance\n   */\n  public getStoredAgent(storedAgentId: string): StoredAgent {\n    return new StoredAgent(this.options, storedAgentId);\n  }\n\n  // ============================================================================\n  // System\n  // ============================================================================\n\n  /**\n   * Retrieves installed Mastra packages and their versions\n   * @returns Promise containing the list of installed Mastra packages\n   */\n  public getSystemPackages(): Promise<GetSystemPackagesResponse> {\n    return this.request('/api/system/packages');\n  }\n}\n","import type { ToolCallOptions } from '@internal/ai-sdk-v5';\nimport type { z } from 'zod';\n\n// Client-side tool execution context (simplified version without server dependencies)\nexport interface ClientToolExecutionContext<TSchemaIn extends z.ZodSchema | undefined = undefined> {\n  context: TSchemaIn extends z.ZodSchema ? z.infer<TSchemaIn> : unknown;\n}\n\n// Client-side tool action interface\nexport interface ClientToolAction<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n> {\n  id: string;\n  description: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  execute?: (\n    context: ClientToolExecutionContext<TSchemaIn>,\n    options?: ToolCallOptions,\n  ) => Promise<TSchemaOut extends z.ZodSchema ? z.infer<TSchemaOut> : unknown>;\n}\n\n// Client-side tool class (simplified version without server dependencies)\nexport class ClientTool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n> implements ClientToolAction<TSchemaIn, TSchemaOut> {\n  id: string;\n  description: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  execute?: ClientToolAction<TSchemaIn, TSchemaOut>['execute'];\n\n  constructor(opts: ClientToolAction<TSchemaIn, TSchemaOut>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.execute = opts.execute;\n  }\n}\n\n// Client-side createTool function\nexport function createTool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n>(opts: ClientToolAction<TSchemaIn, TSchemaOut>): ClientTool<TSchemaIn, TSchemaOut> {\n  return new ClientTool(opts);\n}\n"]}