import { processDataStream } from '../_types/@ai-sdk_ui-utils/dist/index.js';
import type { SerializableStructuredOutputOptions } from '@mastra/core/agent';
import type { MessageListInput } from '@mastra/core/agent/message-list';
import type { GenerateReturn } from '@mastra/core/llm';
import type { RequestContext } from '@mastra/core/request-context';
import type { MastraModelOutput } from '@mastra/core/stream';
import type { JSONSchema7 } from 'json-schema';
import type { ZodType } from 'zod';
import type { GenerateLegacyParams, GetAgentResponse, GetToolResponse, ClientOptions, StreamParams, StreamLegacyParams, UpdateModelParams, UpdateModelInModelListParams, ReorderModelListParams, NetworkStreamParams, StreamParamsBaseWithoutMessages } from '../types.js';
import { processMastraNetworkStream, processMastraStream } from '../utils/process-mastra-stream.js';
import { BaseResource } from './base.js';
export declare class AgentVoice extends BaseResource {
    private agentId;
    constructor(options: ClientOptions, agentId: string);
    /**
     * Convert text to speech using the agent's voice provider
     * @param text - Text to convert to speech
     * @param options - Optional provider-specific options for speech generation
     * @returns Promise containing the audio data
     */
    speak(text: string, options?: {
        speaker?: string;
        [key: string]: any;
    }): Promise<Response>;
    /**
     * Convert speech to text using the agent's voice provider
     * @param audio - Audio data to transcribe
     * @param options - Optional provider-specific options
     * @returns Promise containing the transcribed text
     */
    listen(audio: Blob, options?: Record<string, any>): Promise<{
        text: string;
    }>;
    /**
     * Get available speakers for the agent's voice provider
     * @param requestContext - Optional request context to pass as query parameter
     * @param requestContext - Optional request context to pass as query parameter
     * @returns Promise containing list of available speakers
     */
    getSpeakers(requestContext?: RequestContext | Record<string, any>): Promise<Array<{
        voiceId: string;
        [key: string]: any;
    }>>;
    /**
     * Get the listener configuration for the agent's voice provider
     * @param requestContext - Optional request context to pass as query parameter
     * @param requestContext - Optional request context to pass as query parameter
     * @returns Promise containing a check if the agent has listening capabilities
     */
    getListener(requestContext?: RequestContext | Record<string, any>): Promise<{
        enabled: boolean;
    }>;
}
export declare class Agent extends BaseResource {
    private agentId;
    readonly voice: AgentVoice;
    constructor(options: ClientOptions, agentId: string);
    /**
     * Retrieves details about the agent
     * @param requestContext - Optional request context to pass as query parameter
     * @returns Promise containing agent details including model and instructions
     */
    details(requestContext?: RequestContext | Record<string, any>): Promise<GetAgentResponse>;
    enhanceInstructions(instructions: string, comment: string): Promise<{
        explanation: string;
        new_prompt: string;
    }>;
    /**
     * Generates a response from the agent
     * @param params - Generation parameters including prompt
     * @returns Promise containing the generated response
     */
    generateLegacy(params: GenerateLegacyParams<undefined> & {
        output?: never;
        experimental_output?: never;
    }): Promise<GenerateReturn<any, undefined, undefined>>;
    generateLegacy<Output extends JSONSchema7 | ZodType>(params: GenerateLegacyParams<Output> & {
        output: Output;
        experimental_output?: never;
    }): Promise<GenerateReturn<any, Output, undefined>>;
    generateLegacy<StructuredOutput extends JSONSchema7 | ZodType>(params: GenerateLegacyParams<StructuredOutput> & {
        output?: never;
        experimental_output: StructuredOutput;
    }): Promise<GenerateReturn<any, undefined, StructuredOutput>>;
    generate(messages: MessageListInput, options?: StreamParamsBaseWithoutMessages): Promise<ReturnType<MastraModelOutput['getFullOutput']>>;
    generate<OUTPUT extends {}>(messages: MessageListInput, options: StreamParamsBaseWithoutMessages<OUTPUT> & {
        structuredOutput: SerializableStructuredOutputOptions<OUTPUT>;
    }): Promise<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;
    generate<OUTPUT>(messages: MessageListInput, options?: StreamParamsBaseWithoutMessages<any> & {
        structuredOutput?: SerializableStructuredOutputOptions<any>;
    }): Promise<ReturnType<MastraModelOutput<OUTPUT>['getFullOutput']>>;
    private processChatResponse;
    /**
     * Streams a response from the agent
     * @param params - Stream parameters including prompt
     * @returns Promise containing the enhanced Response object with processDataStream method
     */
    streamLegacy<T extends JSONSchema7 | ZodType | undefined = undefined>(params: StreamLegacyParams<T>): Promise<Response & {
        processDataStream: (options?: Omit<Parameters<typeof processDataStream>[0], 'stream'>) => Promise<void>;
    }>;
    private processChatResponse_vNext;
    processStreamResponse(processedParams: any, controller: ReadableStreamDefaultController<Uint8Array>, route?: string): Promise<Response>;
    network(params: NetworkStreamParams): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    approveNetworkToolCall(params: {
        runId: string;
    }): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    declineNetworkToolCall(params: {
        runId: string;
    }): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraNetworkStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    stream<OUTPUT extends {}>(messages: MessageListInput, streamOptions: Omit<StreamParams<OUTPUT>, 'messages' | 'structuredOutput'> & {
        structuredOutput: SerializableStructuredOutputOptions<OUTPUT>;
    }): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    stream(messages: MessageListInput, streamOptions?: Omit<StreamParams, 'messages'>): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    approveToolCall(params: {
        runId: string;
        toolCallId: string;
    }): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    declineToolCall(params: {
        runId: string;
        toolCallId: string;
    }): Promise<Response & {
        processDataStream: ({ onChunk, }: {
            onChunk: Parameters<typeof processMastraStream>[0]['onChunk'];
        }) => Promise<void>;
    }>;
    /**
     * Processes the stream response and handles tool calls
     */
    private processStreamResponseLegacy;
    /**
     * Gets details about a specific tool available to the agent
     * @param toolId - ID of the tool to retrieve
     * @param requestContext - Optional request context to pass as query parameter
     * @returns Promise containing tool details
     */
    getTool(toolId: string, requestContext?: RequestContext | Record<string, any>): Promise<GetToolResponse>;
    /**
     * Executes a tool for the agent
     * @param toolId - ID of the tool to execute
     * @param params - Parameters required for tool execution
     * @returns Promise containing the tool execution results
     */
    executeTool(toolId: string, params: {
        data: any;
        requestContext?: RequestContext | Record<string, any>;
    }): Promise<any>;
    /**
     * Updates the model for the agent
     * @param params - Parameters for updating the model
     * @returns Promise containing the updated model
     */
    updateModel(params: UpdateModelParams): Promise<{
        message: string;
    }>;
    /**
     * Resets the agent's model to the original model that was set during construction
     * @returns Promise containing a success message
     */
    resetModel(): Promise<{
        message: string;
    }>;
    /**
     * Updates the model for the agent in the model list
     * @param params - Parameters for updating the model
     * @returns Promise containing the updated model
     */
    updateModelInModelList({ modelConfigId, ...params }: UpdateModelInModelListParams): Promise<{
        message: string;
    }>;
    /**
     * Reorders the models for the agent
     * @param params - Parameters for reordering the model list
     * @returns Promise containing the updated model list
     */
    reorderModelList(params: ReorderModelListParams): Promise<{
        message: string;
    }>;
}
//# sourceMappingURL=agent.d.ts.map