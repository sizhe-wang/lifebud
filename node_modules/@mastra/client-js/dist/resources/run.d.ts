import type { TracingOptions } from '@mastra/core/observability';
import type { RequestContext } from '@mastra/core/request-context';
import type { ClientOptions, WorkflowRunResult, StreamVNextChunkType, TimeTravelParams } from '../types.js';
import { BaseResource } from './base.js';
export declare class Run extends BaseResource {
    private workflowId;
    readonly runId: string;
    constructor(options: ClientOptions, workflowId: string, runId: string);
    /**
     * Creates a transform stream that parses RECORD_SEPARATOR-delimited JSON chunks
     */
    private createChunkTransformStream;
    /**
     * Cancels a specific workflow run by its ID
     * @returns Promise containing a success message
     * @deprecated Use `cancel()` instead
     */
    cancelRun(): Promise<{
        message: string;
    }>;
    /**
     * Cancels a workflow run.
     *
     * This method aborts any running steps and updates the workflow status to 'canceled' .
     * It works for both actively running workflows and suspended/waiting workflows.
     *
     * ## How cancellation works
     *
     * When called, the workflow will:
     * 1. **Trigger the abort signal** - Uses the standard Web API AbortSignal to notify running steps
     * 2. **Prevent subsequent steps** - No further steps will be executed
     *
     * ## Abort signal behavior
     *
     * Steps that check the `abortSignal` parameter can respond to cancellation:
     * - Steps can listen to the 'abort' event: `abortSignal.addEventListener('abort', callback)`
     * - Steps can check if already aborted: `if (abortSignal.aborted) { ... }`
     * - Useful for canceling timeouts, network requests, or long-running operations
     *
     * **Note:** Steps must actively check the abort signal to be canceled mid-execution.
     * Steps that don't check the signal will run to completion, but subsequent steps won't execute.
     *
     * @returns Promise that resolves with `{ message: 'Workflow run canceled' }` when cancellation succeeds
     * @throws {HTTPException} 400 - If workflow ID or run ID is missing
     * @throws {HTTPException} 404 - If workflow or workflow run is not found
     *
     * @example
     * ```typescript
     * const run = await workflow.createRun({ runId: 'run-123' });
     * await run.cancel();
     * // Returns: { message: 'Workflow run canceled' }
     * ```
     *
     * @example
     * ```typescript
     * // Example of a step that responds to cancellation
     * const step = createStep({
     *   id: 'long-running-step',
     *   execute: async ({ inputData, abortSignal, abort }) => {
     *     const timeout = new Promise((resolve) => {
     *       const timer = setTimeout(() => resolve('done'), 10000);
     *
     *       // Clean up if canceled
     *       abortSignal.addEventListener('abort', () => {
     *         clearTimeout(timer);
     *         resolve('canceled');
     *       });
     *     });
     *
     *     const result = await timeout;
     *
     *     // Check if aborted after async operation
     *     if (abortSignal.aborted) {
     *       return abort(); // Stop execution
     *     }
     *
     *     return { result };
     *   }
     * });
     * ```
     */
    cancel(): Promise<{
        message: string;
    }>;
    /**
     * Starts a workflow run synchronously without waiting for the workflow to complete
     * @param params - Object containing the inputData, initialState and requestContext
     * @returns Promise containing success message
     */
    start(params: {
        inputData: Record<string, any>;
        initialState?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        perStep?: boolean;
    }): Promise<{
        message: string;
    }>;
    /**
     * Resumes a suspended workflow step synchronously without waiting for the workflow to complete
     * @param params - Object containing the step, resumeData and requestContext
     * @returns Promise containing success message
     */
    resume({ step, resumeData, tracingOptions, perStep, ...rest }: {
        step?: string | string[];
        resumeData?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        perStep?: boolean;
    }): Promise<{
        message: string;
    }>;
    /**
     * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete
     * @param params - Object containing the inputData, initialState and requestContext
     * @returns Promise containing the workflow execution results
     */
    startAsync(params: {
        inputData: Record<string, any>;
        initialState?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        resourceId?: string;
        perStep?: boolean;
    }): Promise<WorkflowRunResult>;
    /**
     * Starts a workflow run and returns a stream
     * @param params - Object containing the inputData, initialState and requestContext
     * @returns Promise containing the workflow execution results
     */
    stream(params: {
        inputData: Record<string, any>;
        initialState?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        resourceId?: string;
        perStep?: boolean;
        closeOnSuspend?: boolean;
    }): Promise<import("stream/web").ReadableStream<StreamVNextChunkType>>;
    /**
     * Observes workflow stream for a workflow run
     * @returns Promise containing the workflow execution results
     */
    observeStream(): Promise<import("stream/web").ReadableStream<StreamVNextChunkType>>;
    /**
     * Resumes a suspended workflow step asynchronously and returns a promise that resolves when the workflow is complete
     * @param params - Object containing the step, resumeData and requestContext
     * @returns Promise containing the workflow resume results
     */
    resumeAsync(params: {
        step?: string | string[];
        resumeData?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        perStep?: boolean;
    }): Promise<WorkflowRunResult>;
    /**
     * Resumes a suspended workflow step that uses stream asynchronously and returns a promise that resolves when the workflow is complete
     * @param params - Object containing the step, resumeData and requestContext
     * @returns Promise containing the workflow resume results
     */
    resumeStream(params: {
        step?: string | string[];
        resumeData?: Record<string, any>;
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
        perStep?: boolean;
    }): Promise<import("stream/web").ReadableStream<StreamVNextChunkType>>;
    /**
     * Restarts an active workflow run synchronously without waiting for the workflow to complete
     * @param params - Object containing the requestContext
     * @returns Promise containing success message
     */
    restart(params: {
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
    }): Promise<{
        message: string;
    }>;
    /**
     * Restarts an active workflow run asynchronously
     * @param params - optional object containing the requestContext
     * @returns Promise containing the workflow restart results
     */
    restartAsync(params?: {
        requestContext?: RequestContext | Record<string, any>;
        tracingOptions?: TracingOptions;
    }): Promise<WorkflowRunResult>;
    /**
     * Time travels a workflow run synchronously without waiting for the workflow to complete
     * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
     * @returns Promise containing success message
     */
    timeTravel({ requestContext: paramsRequestContext, ...params }: TimeTravelParams): Promise<{
        message: string;
    }>;
    /**
     * Time travels a workflow run asynchronously
     * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
     * @returns Promise containing the workflow time travel results
     */
    timeTravelAsync({ requestContext: paramsRequestContext, ...params }: TimeTravelParams): Promise<WorkflowRunResult>;
    /**
     * Time travels a workflow run and returns a stream
     * @param params - Object containing the step, inputData, resumeData, initialState, context, nestedStepsContext, requestContext and tracingOptions
     * @returns Promise containing the workflow execution results
     */
    timeTravelStream({ requestContext: paramsRequestContext, ...params }: TimeTravelParams): Promise<import("stream/web").ReadableStream<StreamVNextChunkType>>;
}
//# sourceMappingURL=run.d.ts.map