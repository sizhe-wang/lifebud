import { JSONSchema7 } from '@ai-sdk/provider';
import { JSONValue } from '@ai-sdk/provider';
import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';
import { LanguageModelV2ToolResultOutput } from '@ai-sdk/provider';
import { LanguageModelV2ToolResultPart } from '@ai-sdk/provider';
import { Schema } from '@ai-sdk/ui-utils';
import { SharedV2ProviderOptions } from '@ai-sdk/provider';
import { z } from 'zod';
import * as z3 from 'zod/v3';
import * as z4 from 'zod/v4';

/**
 Content of an assistant message.
 It can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.
 */
declare type AssistantContent = string | Array<TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart>;

/**
 Content of an assistant message.
 It can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.
 */
declare type AssistantContent_2 = string | Array<TextPart_2 | FilePart_2 | ReasoningPart_2 | ToolCallPart_2 | ToolResultPart_2>;

/**
 An assistant message. It can contain text, tool calls, or a combination of text and tool calls.
 */
declare type AssistantModelMessage = {
    role: 'assistant';
    content: AssistantContent_2;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
};

/**
 An assistant message. It can contain text, tool calls, or a combination of text and tool calls.
 */
declare type CoreAssistantMessage = {
    role: 'assistant';
    content: AssistantContent;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
};

/**
 A message that can be used in the `messages` field of a prompt.
 It can be a user message, an assistant message, or a tool message.
 */
declare type CoreMessage = CoreSystemMessage | CoreUserMessage | CoreAssistantMessage | CoreToolMessage;

/**
 A system message. It can contain system information.

 Note: using the "system" part of the prompt is strongly preferred
 to increase the resilience against prompt injection attacks,
 and because not all providers support several system messages.
 */
declare type CoreSystemMessage = {
    role: 'system';
    content: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
};

/**
 A tool message. It contains the result of one or more tool calls.
 */
declare type CoreToolMessage = {
    role: 'tool';
    content: ToolContent;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
};

/**
 A user message. It can contain text or a combination of text and images.
 */
declare type CoreUserMessage = {
    role: 'user';
    content: UserContent;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
};

/**
 Data content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.
 */
declare type DataContent = string | Uint8Array | ArrayBuffer | Buffer;

/**
 Data content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.
 */
declare type DataContent_2 = string | Uint8Array | ArrayBuffer | Buffer;

declare const _default: {};
export default _default;

/**
 File content part of a prompt. It contains a file.
 */
declare interface FilePart {
    type: 'file';
    /**
     File data. Can either be:

     - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     - URL: a URL that points to the image
     */
    data: DataContent | URL;
    /**
     Optional filename of the file.
     */
    filename?: string;
    /**
     Mime type of the file.
     */
    mimeType: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 File content part of a prompt. It contains a file.
 */
declare interface FilePart_2 {
    type: 'file';
    /**
     File data. Can either be:

     - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     - URL: a URL that points to the image
     */
    data: DataContent_2 | URL;
    /**
     Optional filename of the file.
     */
    filename?: string;
    /**
     IANA media type of the file.

     @see https://www.iana.org/assignments/media-types/media-types.xhtml
     */
    mediaType: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
}

export declare type FlexibleSchema<SCHEMA> = z4.core.$ZodType<SCHEMA, any> | z3.Schema<SCHEMA, z3.ZodTypeDef, any> | Schema_2<SCHEMA> | LazySchema<SCHEMA>;

/**
 Image content part of a prompt. It contains an image.
 */
declare interface ImagePart {
    type: 'image';
    /**
     Image data. Can either be:

     - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     - URL: a URL that points to the image
     */
    image: DataContent | URL;
    /**
     Optional mime type of the image.
     */
    mimeType?: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 Image content part of a prompt. It contains an image.
 */
declare interface ImagePart_2 {
    type: 'image';
    /**
     Image data. Can either be:

     - data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
     - URL: a URL that points to the image
     */
    image: DataContent_2 | URL;
    /**
     Optional IANA media type of the image.

     @see https://www.iana.org/assignments/media-types/media-types.xhtml
     */
    mediaType?: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
}

declare type inferParameters<PARAMETERS extends ToolParameters> = PARAMETERS extends Schema<any> ? PARAMETERS['_type'] : PARAMETERS extends z.ZodTypeAny ? z.infer<PARAMETERS> : never;

declare type LazySchema<SCHEMA> = () => Schema_2<SCHEMA>;

/**
 A message that can be used in the `messages` field of a prompt.
 It can be a user message, an assistant message, or a tool message.
 */
declare type ModelMessage = SystemModelMessage | UserModelMessage | AssistantModelMessage | ToolModelMessage;

declare type NeverOptional<N, T> = 0 extends 1 & N ? Partial<T> : [N] extends [never] ? Partial<Record<keyof T, undefined>> : T;

/**
 * Structural type to accept provider-defined tools from external packages.
 *
 * This is necessary due to TypeScript's module path discrimination combined with
 * version mismatches. Provider SDKs like `@ai-sdk/google` or `@ai-sdk/anthropic`
 * may depend on different versions of `@ai-sdk/provider-utils` than Mastra uses.
 * Even if the versions are identical, npm may install separate instances in
 * different node_modules paths, causing TypeScript to see them as different types
 * despite being structurally identical.
 *
 * This structural type allows Mastra to accept any object that looks like a tool,
 * regardless of which module path or version it came from.
 *
 * Uses union type to match both Tool (v4) and ToolV5 structures, with index
 * signature to remain future-proof as the AI SDK evolves.
 */
export declare type ProviderDefinedTool = {
    parameters: unknown;
    description?: string;
    type?: string;
    id?: string;
    args?: Record<string, unknown>;
    execute?: (...args: any[]) => any;
    [key: string]: any;
} | {
    inputSchema: unknown;
    description?: string;
    type?: string;
    id?: string;
    name?: string;
    providerOptions?: any;
    execute?: (...args: any[]) => any;
    outputSchema?: any;
    [key: string]: any;
};

/**
 Additional provider-specific metadata that is returned from the provider.

 This is needed to enable provider-specific functionality that can be
 fully encapsulated in the provider.
 */
declare type ProviderMetadata = LanguageModelV1ProviderMetadata;

/**
 Additional provider-specific options.

 They are passed through to the provider from the AI SDK and enable
 provider-specific functionality that can be fully encapsulated in the provider.
 */
declare type ProviderOptions = LanguageModelV1ProviderMetadata;

/**
 Additional provider-specific options.

 They are passed through to the provider from the AI SDK and enable
 provider-specific functionality that can be fully encapsulated in the provider.
 */
declare type ProviderOptions_2 = SharedV2ProviderOptions;

/**
 * Reasoning content part of a prompt. It contains a reasoning.
 */
declare interface ReasoningPart {
    type: 'reasoning';
    /**
     The reasoning text.
     */
    text: string;
    /**
     An optional signature for verifying that the reasoning originated from the model.
     */
    signature?: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 * Reasoning content part of a prompt. It contains a reasoning.
 */
declare interface ReasoningPart_2 {
    type: 'reasoning';
    /**
     The reasoning text.
     */
    text: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
}

/**
 Redacted reasoning content part of a prompt.
 */
declare interface RedactedReasoningPart {
    type: 'redacted-reasoning';
    /**
     Redacted reasoning data.
     */
    data: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

export { Schema }

declare type Schema_2<OBJECT = unknown> = Validator<OBJECT> & {
    /**
     * Used to mark schemas so we can support both Zod and custom schemas.
     */
    [schemaSymbol]: true;
    /**
     * Schema type for inference.
     */
    _type: OBJECT;
    /**
     * The JSON Schema for the schema. It is passed to the providers.
     */
    readonly jsonSchema: JSONSchema7;
};

/**
 * Used to mark schemas so we can support both Zod and custom schemas.
 */
declare const schemaSymbol: unique symbol;

/**
 A system message. It can contain system information.

 Note: using the "system" part of the prompt is strongly preferred
 to increase the resilience against prompt injection attacks,
 and because not all providers support several system messages.
 */
declare type SystemModelMessage = {
    role: 'system';
    content: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
};

/**
 Text content part of a prompt. It contains a string of text.
 */
declare interface TextPart {
    type: 'text';
    /**
     The text content.
     */
    text: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 Text content part of a prompt. It contains a string of text.
 */
declare interface TextPart_2 {
    type: 'text';
    /**
     The text content.
     */
    text: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
}

/**
 A tool contains the description and the schema of the input that the tool expects.
 This enables the language model to generate the input.

 The tool can also contain an optional execute function for the actual execution function of the tool.
 */
export declare type Tool<PARAMETERS extends ToolParameters = any, RESULT = any> = {
    /**
     The schema of the input that the tool expects. The language model will use this to generate the input.
     It is also used to validate the output of the language model.
     Use descriptions to make the input understandable for the language model.
     */
    parameters: PARAMETERS;
    /**
     An optional description of what the tool does.
     Will be used by the language model to decide whether to use the tool.
     Not used for provider-defined tools.
     */
    description?: string;
    /**
     Optional conversion function that maps the tool result to multi-part tool content for LLMs.
     */
    experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;
    /**
     An async function that is called with the arguments from the tool call and produces a result.
     If not provided, the tool will not be executed automatically.

     @args is the input of the tool call.
     @options.abortSignal is a signal that can be used to abort the tool call.
     */
    execute?: (args: inferParameters<PARAMETERS>, options: ToolExecutionOptions) => PromiseLike<RESULT>;
} & ({
    /**
     Function tool.
     */
    type?: undefined | 'function';
} | {
    /**
     Provider-defined tool.
     */
    type: 'provider-defined';
    /**
     The ID of the tool. Should follow the format `<provider-name>.<tool-name>`.
     */
    id: `${string}.${string}`;
    /**
     The arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.
     */
    args: Record<string, unknown>;
});

/**
 * Additional options that are sent into each tool call.
 */
export declare interface ToolCallOptions {
    /**
     * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.
     */
    toolCallId: string;
    /**
     * Messages that were sent to the language model to initiate the response that contained the tool call.
     * The messages **do not** include the system prompt nor the assistant response that contained the tool call.
     */
    messages: ModelMessage[];
    /**
     * An optional abort signal that indicates that the overall operation should be aborted.
     */
    abortSignal?: AbortSignal;
    /**
     * Additional context.
     *
     * Experimental (can break in patch releases).
     */
    experimental_context?: unknown;
}

/**
 Tool call content part of a prompt. It contains a tool call (usually generated by the AI model).
 */
declare interface ToolCallPart {
    type: 'tool-call';
    /**
     ID of the tool call. This ID is used to match the tool call with the tool result.
     */
    toolCallId: string;
    /**
     Name of the tool that is being called.
     */
    toolName: string;
    /**
     Arguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.
     */
    args: unknown;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 Tool call content part of a prompt. It contains a tool call (usually generated by the AI model).
 */
declare interface ToolCallPart_2 {
    type: 'tool-call';
    /**
     ID of the tool call. This ID is used to match the tool call with the tool result.
     */
    toolCallId: string;
    /**
     Name of the tool that is being called.
     */
    toolName: string;
    /**
     Arguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.
     */
    input: unknown;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
    /**
     Whether the tool call was executed by the provider.
     */
    providerExecuted?: boolean;
}

/**
 Content of a tool message. It is an array of tool result parts.
 */
declare type ToolContent = Array<ToolResultPart>;

/**
 Content of a tool message. It is an array of tool result parts.
 */
declare type ToolContent_2 = Array<ToolResultPart_2>;

declare type ToolExecuteFunction<INPUT, OUTPUT> = (input: INPUT, options: ToolCallOptions) => AsyncIterable<OUTPUT> | PromiseLike<OUTPUT> | OUTPUT;

export declare interface ToolExecutionOptions {
    /**
     * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.
     */
    toolCallId: string;
    /**
     * Messages that were sent to the language model to initiate the response that contained the tool call.
     * The messages **do not** include the system prompt nor the assistant response that contained the tool call.
     */
    messages: CoreMessage[];
    /**
     * An optional abort signal that indicates that the overall operation should be aborted.
     */
    abortSignal?: AbortSignal;
}

/**
 A tool message. It contains the result of one or more tool calls.
 */
declare type ToolModelMessage = {
    role: 'tool';
    content: ToolContent_2;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
};

declare type ToolOutputProperties<INPUT, OUTPUT> = NeverOptional<OUTPUT, {
    /**
     An async function that is called with the arguments from the tool call and produces a result.
     If not provided, the tool will not be executed automatically.

     @args is the input of the tool call.
     @options.abortSignal is a signal that can be used to abort the tool call.
     */
    execute: ToolExecuteFunction<INPUT, OUTPUT>;
    outputSchema?: FlexibleSchema<OUTPUT>;
} | {
    outputSchema: FlexibleSchema<OUTPUT>;
    execute?: never;
}>;

declare type ToolParameters = z.ZodTypeAny | Schema<any>;

declare type ToolResultContent = Array<{
    type: 'text';
    text: string;
} | {
    type: 'image';
    data: string;
    mimeType?: string;
}>;

/**
 Tool result content part of a prompt. It contains the result of the tool call with the matching ID.
 */
declare interface ToolResultPart {
    type: 'tool-result';
    /**
     ID of the tool call that this result is associated with.
     */
    toolCallId: string;
    /**
     Name of the tool that generated this result.
     */
    toolName: string;
    /**
     Result of the tool call. This is a JSON-serializable object.
     */
    result: unknown;
    /**
     Multi-part content of the tool result. Only for tools that support multipart results.
     */
    experimental_content?: ToolResultContent;
    /**
     Optional flag if the result is an error or an error message.
     */
    isError?: boolean;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions;
    /**
     @deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
}

/**
 Tool result content part of a prompt. It contains the result of the tool call with the matching ID.
 */
declare interface ToolResultPart_2 {
    type: 'tool-result';
    /**
     ID of the tool call that this result is associated with.
     */
    toolCallId: string;
    /**
     Name of the tool that generated this result.
     */
    toolName: string;
    /**
     Result of the tool call. This is a JSON-serializable object.
     */
    output: LanguageModelV2ToolResultOutput;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
}

/**
 A tool contains the description and the schema of the input that the tool expects.
 This enables the language model to generate the input.

 The tool can also contain an optional execute function for the actual execution function of the tool.
 */
export declare type ToolV5<INPUT extends JSONValue | unknown | never = any, OUTPUT extends JSONValue | unknown | never = any> = {
    /**
     An optional description of what the tool does.
     Will be used by the language model to decide whether to use the tool.
     Not used for provider-defined tools.
     */
    description?: string;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
    /**
     The schema of the input that the tool expects. The language model will use this to generate the input.
     It is also used to validate the output of the language model.
     Use descriptions to make the input understandable for the language model.
     */
    inputSchema: FlexibleSchema<INPUT>;
    /**
     * Optional function that is called when the argument streaming starts.
     * Only called when the tool is used in a streaming context.
     */
    onInputStart?: (options: ToolCallOptions) => void | PromiseLike<void>;
    /**
     * Optional function that is called when an argument streaming delta is available.
     * Only called when the tool is used in a streaming context.
     */
    onInputDelta?: (options: {
        inputTextDelta: string;
    } & ToolCallOptions) => void | PromiseLike<void>;
    /**
     * Optional function that is called when a tool call can be started,
     * even if the execute function is not provided.
     */
    onInputAvailable?: (options: {
        input: [INPUT] extends [never] ? undefined : INPUT;
    } & ToolCallOptions) => void | PromiseLike<void>;
} & ToolOutputProperties<INPUT, OUTPUT> & {
    /**
     Optional conversion function that maps the tool result to an output that can be used by the language model.

     If not provided, the tool result will be sent as a JSON object.
     */
    toModelOutput?: (output: 0 extends 1 & OUTPUT ? any : [OUTPUT] extends [never] ? any : NoInfer<OUTPUT>) => LanguageModelV2ToolResultPart['output'];
} & ({
    /**
     Tool with user-defined input and output schemas.
     */
    type?: undefined | 'function';
} | {
    /**
     Tool that is defined at runtime (e.g. an MCP tool).
     The types of input and output are not known at development time.
     */
    type: 'dynamic';
} | {
    /**
     Tool with provider-defined input and output schemas.
     */
    type: 'provider-defined';
    /**
     The ID of the tool. Should follow the format `<provider-name>.<unique-tool-name>`.
     */
    id: `${string}.${string}`;
    /**
     The name of the tool that the user must use in the tool set.
     */
    name: string;
    /**
     The arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.
     */
    args: Record<string, unknown>;
});

/**
 Content of a user message. It can be a string or an array of text and image parts.
 */
declare type UserContent = string | Array<TextPart | ImagePart | FilePart>;

/**
 Content of a user message. It can be a string or an array of text and image parts.
 */
declare type UserContent_2 = string | Array<TextPart_2 | ImagePart_2 | FilePart_2>;

/**
 A user message. It can contain text or a combination of text and images.
 */
declare type UserModelMessage = {
    role: 'user';
    content: UserContent_2;
    /**
     Additional provider-specific metadata. They are passed through
     to the provider from the AI SDK and enable provider-specific
     functionality that can be fully encapsulated in the provider.
     */
    providerOptions?: ProviderOptions_2;
};

declare type ValidationResult<OBJECT> = {
    success: true;
    value: OBJECT;
} | {
    success: false;
    error: Error;
};

declare type Validator<OBJECT = unknown> = {
    /**
     * Used to mark validator functions so we can support both Zod and custom schemas.
     */
    [validatorSymbol]: true;
    /**
     * Optional. Validates that the structure of a value matches this schema,
     * and returns a typed version of the value if it does.
     */
    readonly validate?: (value: unknown) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>;
};

/**
 * Used to mark validator functions so we can support both Zod and custom schemas.
 */
declare const validatorSymbol: unique symbol;

export { }
