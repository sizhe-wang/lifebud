import type { MastraDBMessage } from '../state/types.js';
/**
 * MessageMerger - Handles complex logic for merging assistant messages
 *
 * When streaming responses from LLMs, we often receive multiple messages that need to be
 * merged together:
 * - Tool calls that need to be updated with their results
 * - Text parts that need to be appended
 * - Step-start markers that need to be inserted
 *
 * This class encapsulates all the complex merging logic that was previously spread
 * throughout the MessageList.addOne method.
 */
export declare class MessageMerger {
    /**
     * Check if we should merge an incoming message with the latest message
     *
     * @param latestMessage - The most recent message in the list
     * @param incomingMessage - The message being added
     * @param messageSource - The source of the incoming message ('memory', 'input', 'response', 'context')
     * @param isLatestFromMemory - Whether the latest message is from memory
     * @param agentNetworkAppend - Whether agent network append mode is enabled
     */
    static shouldMerge(latestMessage: MastraDBMessage | undefined, incomingMessage: MastraDBMessage, messageSource: string, isLatestFromMemory: boolean, agentNetworkAppend?: boolean): boolean;
    /**
     * Merge an incoming assistant message into the latest assistant message
     *
     * This handles:
     * - Updating tool invocations with their results
     * - Adding new parts in the correct order using anchor maps
     * - Inserting step-start markers where needed
     * - Updating timestamps and content strings
     */
    static merge(latestMessage: MastraDBMessage, incomingMessage: MastraDBMessage): void;
    /**
     * Add parts from the incoming message to the latest message using anchor positions
     */
    private static addPartsToMessage;
    /**
     * Push a new message part to the latest message
     */
    private static pushNewPart;
}
//# sourceMappingURL=MessageMerger.d.ts.map