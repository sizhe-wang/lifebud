'use strict';

var chunkPS5SHNDR_cjs = require('./chunk-PS5SHNDR.cjs');
var chunkU6CL7U6Y_cjs = require('./chunk-U6CL7U6Y.cjs');
var chunk4U7ZLI36_cjs = require('./chunk-4U7ZLI36.cjs');
var pMap = require('p-map');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var pMap__default = /*#__PURE__*/_interopDefault(pMap);

function createOnScorerHook(mastra) {
  return async (hookData) => {
    const storage = mastra.getStorage();
    if (!storage) {
      mastra.getLogger()?.warn("Storage not found, skipping score validation and saving");
      return;
    }
    const entityId = hookData.entity.id;
    const entityType = hookData.entityType;
    const scorer = hookData.scorer;
    const scorerId = scorer.id;
    if (!scorerId) {
      mastra.getLogger()?.warn("Scorer ID not found, skipping score validation and saving");
      return;
    }
    try {
      const scorerToUse = await findScorer(mastra, entityId, entityType, scorerId);
      if (!scorerToUse) {
        throw new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_SCORER_NOT_FOUND",
          domain: "MASTRA" /* MASTRA */,
          category: "USER" /* USER */,
          text: `Scorer with ID ${scorerId} not found`
        });
      }
      let input = hookData.input;
      let output = hookData.output;
      const { structuredOutput, ...rest } = hookData;
      const runResult = await scorerToUse.scorer.run({
        ...rest,
        input,
        output
      });
      let spanId;
      let traceId;
      const currentSpan = hookData.tracingContext?.currentSpan;
      if (currentSpan && currentSpan.isValid) {
        spanId = currentSpan.id;
        traceId = currentSpan.traceId;
      }
      const payload = {
        ...rest,
        ...runResult,
        entityId,
        scorerId,
        spanId,
        traceId,
        metadata: {
          structuredOutput: !!structuredOutput
        }
      };
      await validateAndSaveScore(storage, payload);
      if (currentSpan && spanId && traceId) {
        await pMap__default.default(
          currentSpan.observabilityInstance.getExporters(),
          async (exporter) => {
            if (exporter.addScoreToTrace) {
              try {
                await exporter.addScoreToTrace({
                  traceId,
                  spanId,
                  score: runResult.score,
                  reason: runResult.reason,
                  scorerName: scorerToUse.scorer.id,
                  metadata: {
                    ...currentSpan.metadata ?? {}
                  }
                });
              } catch (error) {
                mastra.getLogger()?.error(`Failed to add score to trace via exporter: ${error}`);
              }
            }
          },
          { concurrency: 3 }
        );
      }
    } catch (error) {
      const mastraError = new chunk4U7ZLI36_cjs.MastraError(
        {
          id: "MASTRA_SCORER_FAILED_TO_RUN_HOOK",
          domain: "SCORER" /* SCORER */,
          category: "USER" /* USER */,
          details: {
            scorerId,
            entityId,
            entityType
          }
        },
        error
      );
      mastra.getLogger()?.trackException(mastraError);
      mastra.getLogger()?.error(mastraError.toString());
    }
  };
}
async function validateAndSaveScore(storage, payload) {
  const scoresStore = await storage.getStore("scores");
  if (!scoresStore) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: "MASTRA_SCORES_STORAGE_NOT_AVAILABLE",
      domain: "STORAGE" /* STORAGE */,
      category: "SYSTEM" /* SYSTEM */,
      text: "Scores storage domain is not available"
    });
  }
  const payloadToSave = chunkU6CL7U6Y_cjs.saveScorePayloadSchema.parse(payload);
  await scoresStore.saveScore(payloadToSave);
}
async function findScorer(mastra, entityId, entityType, scorerId) {
  let scorerToUse;
  if (entityType === "AGENT") {
    const scorers = await mastra.getAgentById(entityId).listScorers();
    for (const [_, scorer] of Object.entries(scorers)) {
      if (scorer.scorer.id === scorerId) {
        scorerToUse = scorer;
        break;
      }
    }
  } else if (entityType === "WORKFLOW") {
    const scorers = await mastra.getWorkflowById(entityId).listScorers();
    for (const [_, scorer] of Object.entries(scorers)) {
      if (scorer.scorer.id === scorerId) {
        scorerToUse = scorer;
        break;
      }
    }
  }
  if (!scorerToUse) {
    const mastraRegisteredScorer = mastra.getScorerById(scorerId);
    scorerToUse = mastraRegisteredScorer ? { scorer: mastraRegisteredScorer } : void 0;
  }
  return scorerToUse;
}

// src/evals/run/scorerAccumulator.ts
var ScoreAccumulator = class {
  flatScores = {};
  workflowScores = {};
  stepScores = {};
  addScores(scorerResults) {
    const isTargetWorkflowAndHasStepScores = "steps" in scorerResults;
    if (isTargetWorkflowAndHasStepScores) {
      this.addNestedScores(scorerResults);
    } else {
      this.addFlatScores(scorerResults);
    }
  }
  addFlatScores(scorerResults) {
    for (const [scorerName, result] of Object.entries(scorerResults)) {
      if (!this.flatScores[scorerName]) {
        this.flatScores[scorerName] = [];
      }
      this.flatScores[scorerName].push(result.score);
    }
  }
  addNestedScores(scorerResults) {
    if ("workflow" in scorerResults && scorerResults.workflow) {
      for (const [scorerName, result] of Object.entries(scorerResults.workflow)) {
        if (!this.workflowScores[scorerName]) {
          this.workflowScores[scorerName] = [];
        }
        this.workflowScores[scorerName].push(result.score);
      }
    }
    if ("steps" in scorerResults && scorerResults.steps) {
      for (const [stepId, stepResults] of Object.entries(scorerResults.steps)) {
        if (!this.stepScores[stepId]) {
          this.stepScores[stepId] = {};
        }
        for (const [scorerName, result] of Object.entries(stepResults)) {
          if (!this.stepScores[stepId][scorerName]) {
            this.stepScores[stepId][scorerName] = [];
          }
          this.stepScores[stepId][scorerName].push(result.score);
        }
      }
    }
  }
  addStepScores(stepScorerResults) {
    for (const [stepId, stepResults] of Object.entries(stepScorerResults)) {
      if (!this.stepScores[stepId]) {
        this.stepScores[stepId] = {};
      }
      for (const [scorerName, result] of Object.entries(stepResults)) {
        if (!this.stepScores[stepId][scorerName]) {
          this.stepScores[stepId][scorerName] = [];
        }
        this.stepScores[stepId][scorerName].push(result.score);
      }
    }
  }
  getAverageScores() {
    const result = {};
    for (const [scorerName, scoreArray] of Object.entries(this.flatScores)) {
      result[scorerName] = this.getAverageScore(scoreArray);
    }
    if (Object.keys(this.workflowScores).length > 0) {
      result.workflow = {};
      for (const [scorerName, scoreArray] of Object.entries(this.workflowScores)) {
        result.workflow[scorerName] = this.getAverageScore(scoreArray);
      }
    }
    if (Object.keys(this.stepScores).length > 0) {
      result.steps = {};
      for (const [stepId, stepScorers] of Object.entries(this.stepScores)) {
        result.steps[stepId] = {};
        for (const [scorerName, scoreArray] of Object.entries(stepScorers)) {
          result.steps[stepId][scorerName] = this.getAverageScore(scoreArray);
        }
      }
    }
    return result;
  }
  getAverageScore(scoreArray) {
    if (scoreArray.length > 0) {
      return scoreArray.reduce((a, b) => a + b, 0) / scoreArray.length;
    } else {
      return 0;
    }
  }
};

// src/evals/run/index.ts
async function runEvals(config) {
  const { data, scorers, target, onItemComplete, concurrency = 1 } = config;
  validateEvalsInputs(data, scorers, target);
  let totalItems = 0;
  const scoreAccumulator = new ScoreAccumulator();
  const mastra = target.getMastraInstance?.() || target.mastra;
  const storage = mastra?.getStorage();
  const pMap2 = (await import('p-map')).default;
  await pMap2(
    data,
    async (item) => {
      const targetResult = await executeTarget(target, item);
      const scorerResults = await runScorers(scorers, targetResult, item);
      scoreAccumulator.addScores(scorerResults);
      if (storage) {
        await saveScoresToStorage({
          storage,
          scorerResults,
          target,
          item,
          mastra
        });
      }
      if (onItemComplete) {
        await onItemComplete({
          item,
          targetResult,
          scorerResults
        });
      }
      totalItems++;
    },
    { concurrency }
  );
  return {
    scores: scoreAccumulator.getAverageScores(),
    summary: {
      totalItems
    }
  };
}
function isWorkflow(target) {
  return target instanceof chunkPS5SHNDR_cjs.Workflow;
}
function isWorkflowScorerConfig(scorers) {
  return typeof scorers === "object" && !Array.isArray(scorers) && ("workflow" in scorers || "steps" in scorers);
}
function validateEvalsInputs(data, scorers, target) {
  if (data.length === 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      domain: "SCORER",
      id: "RUN_EXPERIMENT_FAILED_NO_DATA_PROVIDED",
      category: "USER",
      text: "Failed to run experiment: Data array is empty"
    });
  }
  for (let i = 0; i < data.length; i++) {
    const item = data[i];
    if (!item || typeof item !== "object" || !("input" in item)) {
      throw new chunk4U7ZLI36_cjs.MastraError({
        domain: "SCORER",
        id: "INVALID_DATA_ITEM",
        category: "USER",
        text: `Invalid data item at index ${i}: must have 'input' properties`
      });
    }
  }
  if (Array.isArray(scorers)) {
    if (scorers.length === 0) {
      throw new chunk4U7ZLI36_cjs.MastraError({
        domain: "SCORER",
        id: "NO_SCORERS_PROVIDED",
        category: "USER",
        text: "At least one scorer must be provided"
      });
    }
  } else if (isWorkflow(target) && isWorkflowScorerConfig(scorers)) {
    const hasScorers = scorers.workflow && scorers.workflow.length > 0 || scorers.steps && Object.keys(scorers.steps).length > 0;
    if (!hasScorers) {
      throw new chunk4U7ZLI36_cjs.MastraError({
        domain: "SCORER",
        id: "NO_SCORERS_PROVIDED",
        category: "USER",
        text: "At least one workflow or step scorer must be provided"
      });
    }
  } else if (!isWorkflow(target) && !Array.isArray(scorers)) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      domain: "SCORER",
      id: "INVALID_AGENT_SCORERS",
      category: "USER",
      text: "Agent scorers must be an array of scorers"
    });
  }
}
async function executeTarget(target, item) {
  try {
    if (isWorkflow(target)) {
      return await executeWorkflow(target, item);
    } else {
      return await executeAgent(target, item);
    }
  } catch (error) {
    throw new chunk4U7ZLI36_cjs.MastraError(
      {
        domain: "SCORER",
        id: "RUN_EXPERIMENT_TARGET_FAILED_TO_GENERATE_RESULT",
        category: "USER",
        text: "Failed to run experiment: Error generating result from target",
        details: {
          item: JSON.stringify(item)
        }
      },
      error
    );
  }
}
async function executeWorkflow(target, item) {
  const run = await target.createRun({ disableScorers: true });
  const workflowResult = await run.start({
    inputData: item.input,
    requestContext: item.requestContext
  });
  return {
    scoringData: {
      input: item.input,
      output: workflowResult.status === "success" ? workflowResult.result : void 0,
      stepResults: workflowResult.steps
    }
  };
}
async function executeAgent(agent, item) {
  const model = await agent.getModel();
  if (chunkPS5SHNDR_cjs.isSupportedLanguageModel(model)) {
    return await agent.generate(item.input, {
      scorers: {},
      returnScorerData: true,
      requestContext: item.requestContext
    });
  } else {
    return await agent.generateLegacy(item.input, {
      scorers: {},
      returnScorerData: true,
      requestContext: item.requestContext
    });
  }
}
async function runScorers(scorers, targetResult, item) {
  const scorerResults = {};
  if (Array.isArray(scorers)) {
    for (const scorer of scorers) {
      try {
        const score = await scorer.run({
          input: targetResult.scoringData?.input,
          output: targetResult.scoringData?.output,
          groundTruth: item.groundTruth,
          requestContext: item.requestContext,
          tracingContext: item.tracingContext
        });
        scorerResults[scorer.id] = score;
      } catch (error) {
        throw new chunk4U7ZLI36_cjs.MastraError(
          {
            domain: "SCORER",
            id: "RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_RESULT",
            category: "USER",
            text: `Failed to run experiment: Error running scorer ${scorer.id}`,
            details: {
              scorerId: scorer.id,
              item: JSON.stringify(item)
            }
          },
          error
        );
      }
    }
  } else {
    if (scorers.workflow) {
      const workflowScorerResults = {};
      for (const scorer of scorers.workflow) {
        const score = await scorer.run({
          input: targetResult.scoringData.input,
          output: targetResult.scoringData.output,
          groundTruth: item.groundTruth,
          requestContext: item.requestContext,
          tracingContext: item.tracingContext
        });
        workflowScorerResults[scorer.id] = score;
      }
      if (Object.keys(workflowScorerResults).length > 0) {
        scorerResults.workflow = workflowScorerResults;
      }
    }
    if (scorers.steps) {
      const stepScorerResults = {};
      for (const [stepId, stepScorers] of Object.entries(scorers.steps)) {
        const stepResult = targetResult.scoringData.stepResults?.[stepId];
        if (stepResult?.status === "success" && stepResult.payload && stepResult.output) {
          const stepResults = {};
          for (const scorer of stepScorers) {
            try {
              const score = await scorer.run({
                input: stepResult.payload,
                output: stepResult.output,
                groundTruth: item.groundTruth,
                requestContext: item.requestContext,
                tracingContext: item.tracingContext
              });
              stepResults[scorer.id] = score;
            } catch (error) {
              throw new chunk4U7ZLI36_cjs.MastraError(
                {
                  domain: "SCORER",
                  id: "RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_STEP_RESULT",
                  category: "USER",
                  text: `Failed to run experiment: Error running scorer ${scorer.id} on step ${stepId}`,
                  details: {
                    scorerId: scorer.id,
                    stepId
                  }
                },
                error
              );
            }
          }
          if (Object.keys(stepResults).length > 0) {
            stepScorerResults[stepId] = stepResults;
          }
        }
      }
      if (Object.keys(stepScorerResults).length > 0) {
        scorerResults.steps = stepScorerResults;
      }
    }
  }
  return scorerResults;
}
async function saveScoresToStorage({
  storage,
  scorerResults,
  target,
  item,
  mastra
}) {
  const entityId = target.id;
  const entityType = isWorkflow(target) ? "WORKFLOW" : "AGENT";
  if (Array.isArray(scorerResults) || !("workflow" in scorerResults && "steps" in scorerResults)) {
    for (const [scorerId, scoreResult] of Object.entries(scorerResults)) {
      if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
        await saveSingleScore({
          storage,
          scoreResult,
          scorerId,
          entityId,
          entityType,
          mastra,
          target,
          item
        });
      }
    }
  } else {
    if (scorerResults.workflow) {
      for (const [scorerId, scoreResult] of Object.entries(scorerResults.workflow)) {
        if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
          await saveSingleScore({
            storage,
            scoreResult,
            scorerId,
            entityId,
            entityType: "WORKFLOW",
            mastra,
            target,
            item
          });
        }
      }
    }
    if (scorerResults.steps) {
      for (const [stepId, stepScorers] of Object.entries(scorerResults.steps)) {
        for (const [scorerId, scoreResult] of Object.entries(stepScorers)) {
          if (scoreResult && typeof scoreResult === "object" && "score" in scoreResult) {
            await saveSingleScore({
              storage,
              scoreResult,
              scorerId,
              entityId: stepId,
              entityType: "STEP",
              mastra,
              target,
              item
            });
          }
        }
      }
    }
  }
}
async function saveSingleScore({
  storage,
  scoreResult,
  scorerId,
  entityId,
  entityType,
  mastra,
  target,
  item
}) {
  try {
    let scorer = mastra?.getScorerById?.(scorerId);
    if (!scorer) {
      const targetScorers = await target.listScorers?.();
      if (targetScorers) {
        for (const [_, scorerEntry] of Object.entries(targetScorers)) {
          if (scorerEntry.scorer?.id === scorerId) {
            scorer = scorerEntry.scorer;
            break;
          }
        }
      }
    }
    let traceId;
    let spanId;
    if (item.tracingContext?.currentSpan && item.tracingContext.currentSpan.isValid) {
      spanId = item.tracingContext.currentSpan.id;
      traceId = item.tracingContext.currentSpan.traceId;
    }
    const additionalContext = {};
    if (item.groundTruth !== void 0) {
      additionalContext.groundTruth = item.groundTruth;
    }
    const payload = {
      ...scoreResult,
      scorerId,
      entityId,
      entityType,
      source: "TEST",
      scorer: {
        id: scorer?.id || scorerId,
        name: scorer?.name || scorerId,
        description: scorer?.description || "",
        type: scorer?.type || "unknown"
      },
      entity: {
        id: target.id,
        name: target.name || target.id
      },
      // Include requestContext from item
      requestContext: item.requestContext ? Object.fromEntries(item.requestContext.entries()) : void 0,
      // Include additionalContext with groundTruth
      additionalContext: Object.keys(additionalContext).length > 0 ? additionalContext : void 0,
      // Include tracing information
      traceId,
      spanId
    };
    await validateAndSaveScore(storage, payload);
  } catch (error) {
    mastra?.getLogger?.()?.warn?.(`Failed to save score for scorer ${scorerId}:`, error);
  }
}

exports.createOnScorerHook = createOnScorerHook;
exports.runEvals = runEvals;
//# sourceMappingURL=chunk-5WPPG6IA.cjs.map
//# sourceMappingURL=chunk-5WPPG6IA.cjs.map