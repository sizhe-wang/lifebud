import { EntityType, SpanType } from './chunk-XKBYPAOY.js';
import { getZodTypeName } from './chunk-AIJLACR2.js';
import { z } from 'zod';

var createdAtField = z.date().describe("Database record creation time");
var updatedAtField = z.date().describe("Database record last update time");
var dbTimestamps = {
  createdAt: createdAtField,
  updatedAt: updatedAtField.nullable()
};
var paginationArgsSchema = z.object({
  page: z.coerce.number().int().min(0).optional().default(0).describe("Zero-indexed page number"),
  perPage: z.coerce.number().int().min(1).max(100).optional().default(10).describe("Number of items per page")
}).describe("Pagination options for list queries");
var paginationInfoSchema = z.object({
  total: z.number().describe("Total number of items available"),
  page: z.number().describe("Current page"),
  perPage: z.union([z.number(), z.literal(false)]).describe("Number of items per page, or false if pagination is disabled"),
  hasMore: z.boolean().describe("True if more pages are available")
});
var dateRangeSchema = z.object({
  start: z.coerce.date().optional().describe("Start of date range (inclusive by default)"),
  end: z.coerce.date().optional().describe("End of date range (inclusive by default)"),
  startExclusive: z.boolean().optional().describe("When true, excludes the start date from results (uses > instead of >=)"),
  endExclusive: z.boolean().optional().describe("When true, excludes the end date from results (uses < instead of <=)")
}).describe("Date range filter for timestamps");
var sortDirectionSchema = z.enum(["ASC", "DESC"]).describe("Sort direction: 'ASC' | 'DESC'");
var entityTypeField = z.nativeEnum(EntityType).describe(`Entity type (e.g., 'agent' | 'processor' | 'tool' | 'workflow')`);
var entityIdField = z.string().describe('ID of the entity (e.g., "weatherAgent", "orderWorkflow")');
var entityNameField = z.string().describe("Name of the entity");
var userIdField = z.string().describe("Human end-user who triggered execution");
var organizationIdField = z.string().describe("Multi-tenant organization/account");
var resourceIdField = z.string().describe("Broader resource context (Mastra memory compatibility)");
var runIdField = z.string().describe("Unique execution run identifier");
var sessionIdField = z.string().describe("Session identifier for grouping traces");
var threadIdField = z.string().describe("Conversation thread identifier");
var requestIdField = z.string().describe("HTTP request ID for log correlation");
var environmentField = z.string().describe(`Environment (e.g., "production" | "staging" | "development")`);
var sourceField = z.string().describe(`Source of execution (e.g., "local" | "cloud" | "ci")`);
var serviceNameField = z.string().describe("Name of the service");

// src/evals/types.ts
var scoringSourceSchema = z.enum(["LIVE", "TEST"]);
var scoringEntityTypeSchema = z.enum(["AGENT", "WORKFLOW", ...Object.values(SpanType)]);
var scoringPromptsSchema = z.object({
  description: z.string(),
  prompt: z.string()
});
var recordSchema = z.record(z.string(), z.unknown());
var optionalRecordSchema = recordSchema.optional();
var scoringInputSchema = z.object({
  runId: z.string().optional(),
  input: z.unknown().optional(),
  output: z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema
  // Note: tracingContext is not serializable, so we don't include it in the schema
  // It's added at runtime when needed
});
var scoringHookInputSchema = z.object({
  runId: z.string().optional(),
  scorer: recordSchema,
  input: z.unknown(),
  output: z.unknown(),
  metadata: optionalRecordSchema,
  additionalContext: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema,
  requestContext: optionalRecordSchema,
  structuredOutput: z.boolean().optional(),
  traceId: z.string().optional(),
  spanId: z.string().optional(),
  resourceId: z.string().optional(),
  threadId: z.string().optional()
  // Note: tracingContext is not serializable, so we don't include it in the schema
});
var scoringExtractStepResultSchema = optionalRecordSchema;
var scoringValueSchema = z.number();
var scoreResultSchema = z.object({
  result: optionalRecordSchema,
  score: scoringValueSchema,
  prompt: z.string().optional()
});
var scoringInputWithExtractStepResultSchema = scoringInputSchema.extend({
  runId: z.string(),
  // Required in this context
  extractStepResult: optionalRecordSchema,
  extractPrompt: z.string().optional()
});
var scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultSchema.extend({
  score: z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: z.string().optional()
});
var scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema.extend({
  reason: z.string().optional(),
  reasonPrompt: z.string().optional()
});
var scoreRowDataSchema = z.object({
  id: z.string(),
  scorerId: z.string(),
  entityId: z.string(),
  // From ScoringInputWithExtractStepResultAndScoreAndReason
  runId: z.string(),
  input: z.unknown().optional(),
  output: z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema,
  extractStepResult: optionalRecordSchema,
  extractPrompt: z.string().optional(),
  score: z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: z.string().optional(),
  reason: z.string().optional(),
  reasonPrompt: z.string().optional(),
  // From ScoringHookInput
  scorer: recordSchema,
  metadata: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema.optional(),
  structuredOutput: z.boolean().optional(),
  traceId: z.string().optional(),
  spanId: z.string().optional(),
  resourceId: z.string().optional(),
  threadId: z.string().optional(),
  // Additional ScoreRowData fields
  preprocessStepResult: optionalRecordSchema,
  preprocessPrompt: z.string().optional(),
  generateScorePrompt: z.string().optional(),
  generateReasonPrompt: z.string().optional(),
  // Timestamps
  ...dbTimestamps
});
var saveScorePayloadSchema = scoreRowDataSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var listScoresResponseSchema = z.object({
  pagination: paginationInfoSchema,
  scores: z.array(scoreRowDataSchema)
});

// src/storage/domains/observability/types.ts
var createOmitKeys = (shape) => Object.fromEntries(Object.keys(shape).map((k) => [k, true]));
var traceIdField = z.string().describe("Unique trace identifier");
var spanIdField = z.string().describe("Unique span identifier within a trace");
var spanNameField = z.string().describe("Human-readable span name");
var parentSpanIdField = z.string().describe("Parent span reference (null = root span)");
var spanTypeField = z.nativeEnum(SpanType).describe("Span type (e.g., WORKFLOW_RUN, AGENT_RUN, TOOL_CALL, etc.)");
var attributesField = z.record(z.unknown()).describe("Span-type specific attributes (e.g., model, tokens, tools)");
var metadataField = z.record(z.unknown()).describe("User-defined metadata for custom filtering");
var tagsField = z.array(z.string()).describe("Labels for filtering traces (only on the root span)");
var scopeField = z.record(z.unknown()).describe('Arbitrary package/app version info (e.g., {"core": "1.0.0", "memory": "1.0.0", "gitSha": "abcd1234"})');
var linksField = z.array(z.unknown()).describe("References to related spans in other traces");
var inputField = z.unknown().describe("Input data passed to the span");
var outputField = z.unknown().describe("Output data returned from the span");
var errorField = z.unknown().describe("Error info - presence indicates failure (status derived from this)");
var isEventField = z.boolean().describe("Whether this is an event (point-in-time) vs a span (duration)");
var startedAtField = z.date().describe("When the span started");
var endedAtField = z.date().describe("When the span ended (null = running, status derived from this)");
var TraceStatus = /* @__PURE__ */ ((TraceStatus2) => {
  TraceStatus2["SUCCESS"] = "success";
  TraceStatus2["ERROR"] = "error";
  TraceStatus2["RUNNING"] = "running";
  return TraceStatus2;
})(TraceStatus || {});
var traceStatusField = z.nativeEnum(TraceStatus).describe("Current status of the trace");
var hasChildErrorField = z.preprocess((v) => {
  if (v === "true") return true;
  if (v === "false") return false;
  return v;
}, z.boolean()).describe("True if any span in the trace encountered an error");
var sharedFields = {
  // Entity identification - first-class fields for filtering (e.g., agent, workflow, tool)
  entityType: entityTypeField.nullish(),
  entityId: entityIdField.nullish(),
  entityName: entityNameField.nullish(),
  // Identity & tenancy - for multi-tenant applications
  userId: userIdField.nullish(),
  organizationId: organizationIdField.nullish(),
  resourceId: resourceIdField.nullish(),
  // Correlation IDs - for linking related operations
  runId: runIdField.nullish(),
  sessionId: sessionIdField.nullish(),
  threadId: threadIdField.nullish(),
  requestId: requestIdField.nullish(),
  // Deployment context - these fields only exist on the root span
  environment: environmentField.nullish(),
  source: sourceField.nullish(),
  serviceName: serviceNameField.nullish(),
  scope: scopeField.nullish(),
  // Filterable data - user-defined metadata and tags (tags only on root span)
  metadata: metadataField.nullish(),
  tags: tagsField.nullish()
};
var spanIds = {
  traceId: traceIdField,
  spanId: spanIdField
};
var spanIdsSchema = z.object({
  ...spanIds
});
var omitDbTimestamps = createOmitKeys(dbTimestamps);
var omitSpanIds = createOmitKeys(spanIds);
var spanRecordSchema = z.object({
  // Required identifiers
  ...spanIds,
  name: spanNameField,
  spanType: spanTypeField,
  isEvent: isEventField,
  startedAt: startedAtField,
  // Shared fields
  parentSpanId: parentSpanIdField.nullish(),
  ...sharedFields,
  // Additional span-specific nullish fields
  attributes: attributesField.nullish(),
  links: linksField.nullish(),
  input: inputField.nullish(),
  output: outputField.nullish(),
  error: errorField.nullish(),
  endedAt: endedAtField.nullish(),
  // Database timestamps
  ...dbTimestamps
}).describe("Span record data");
var createSpanRecordSchema = spanRecordSchema.omit(omitDbTimestamps);
var createSpanArgsSchema = z.object({
  span: createSpanRecordSchema
}).describe("Arguments for creating a single span");
var batchCreateSpansArgsSchema = z.object({
  records: z.array(createSpanRecordSchema)
}).describe("Arguments for batch creating spans");
var getSpanArgsSchema = z.object({
  traceId: traceIdField.min(1),
  spanId: spanIdField.min(1)
}).describe("Arguments for getting a single span");
var getSpanResponseSchema = z.object({
  span: spanRecordSchema
});
var getRootSpanArgsSchema = z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a root span");
var getRootSpanResponseSchema = z.object({
  span: spanRecordSchema
});
var getTraceArgsSchema = z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a single trace");
var getTraceResponseSchema = z.object({
  traceId: traceIdField,
  spans: z.array(spanRecordSchema)
});
var tracesFilterSchema = z.object({
  // Date range filters
  startedAt: dateRangeSchema.optional().describe("Filter by span start time range"),
  endedAt: dateRangeSchema.optional().describe("Filter by span end time range"),
  // Span type filter
  spanType: spanTypeField.optional(),
  // Shared fields
  ...sharedFields,
  // Filter-specific derived status fields
  status: traceStatusField.optional(),
  hasChildError: hasChildErrorField.optional()
}).describe("Filters for querying traces");
var tracesOrderByFieldSchema = z.enum(["startedAt", "endedAt"]).describe("Field to order by: 'startedAt' | 'endedAt'");
var tracesOrderBySchema = z.object({
  field: tracesOrderByFieldSchema.default("startedAt").describe("Field to order by"),
  direction: sortDirectionSchema.default("DESC").describe("Sort direction")
}).describe("Order by configuration");
var listTracesArgsSchema = z.object({
  filters: tracesFilterSchema.optional().describe("Optional filters to apply"),
  pagination: paginationArgsSchema.default({}).describe("Pagination settings"),
  orderBy: tracesOrderBySchema.default({}).describe("Ordering configuration (defaults to startedAt desc)")
}).describe("Arguments for listing traces");
var listTracesResponseSchema = z.object({
  pagination: paginationInfoSchema,
  spans: z.array(spanRecordSchema)
});
var updateSpanRecordSchema = createSpanRecordSchema.omit(omitSpanIds);
var updateSpanArgsSchema = z.object({
  spanId: spanIdField,
  traceId: traceIdField,
  updates: updateSpanRecordSchema.partial()
}).describe("Arguments for updating a single span");
var batchUpdateSpansArgsSchema = z.object({
  records: z.array(
    z.object({
      traceId: traceIdField,
      spanId: spanIdField,
      updates: updateSpanRecordSchema.partial()
    })
  )
}).describe("Arguments for batch updating spans");
var batchDeleteTracesArgsSchema = z.object({
  traceIds: z.array(traceIdField)
}).describe("Arguments for batch deleting traces");
var listScoresBySpanResponseSchema = z.object({
  pagination: paginationInfoSchema,
  scores: z.array(scoreRowDataSchema)
});
var scoreTracesRequestSchema = z.object({
  scorerName: z.string().min(1),
  targets: z.array(
    z.object({
      traceId: traceIdField,
      spanId: spanIdField.optional()
    })
  ).min(1)
});
var scoreTracesResponseSchema = z.object({
  status: z.string(),
  message: z.string(),
  traceCount: z.number()
});

// src/storage/types.ts
function getInnerType(schema, typeName) {
  const schemaAny = schema;
  if (typeName === "ZodNullable" || typeName === "ZodOptional" || typeName === "ZodDefault") {
    return schemaAny._zod?.def?.innerType ?? schemaAny._def?.innerType;
  }
  if (typeName === "ZodEffects") {
    return schemaAny._zod?.def?.schema ?? schemaAny._def?.schema;
  }
  if (typeName === "ZodBranded") {
    return schemaAny._zod?.def?.type ?? schemaAny._def?.type;
  }
  return void 0;
}
function unwrapSchema(schema) {
  let current = schema;
  let nullable = false;
  while (true) {
    const typeName = getZodTypeName(current);
    if (typeName === "ZodNullable") {
      nullable = true;
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodOptional") {
      nullable = true;
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodDefault") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodEffects") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodBranded") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    break;
  }
  return { base: current, nullable };
}
function getZodChecks(schema) {
  const schemaAny = schema;
  if (schemaAny._zod?.def?.checks) {
    return schemaAny._zod.def.checks;
  }
  if (schemaAny._def?.checks) {
    return schemaAny._def.checks;
  }
  return [];
}
function zodToStorageType(schema) {
  const typeName = getZodTypeName(schema);
  if (typeName === "ZodString") {
    const checks = getZodChecks(schema);
    if (checks.some((c) => c.kind === "uuid")) {
      return "uuid";
    }
    return "text";
  }
  if (typeName === "ZodNativeEnum" || typeName === "ZodEnum") {
    return "text";
  }
  if (typeName === "ZodNumber") {
    const checks = getZodChecks(schema);
    return checks.some((c) => c.kind === "int") ? "integer" : "float";
  }
  if (typeName === "ZodBigInt") {
    return "bigint";
  }
  if (typeName === "ZodDate") {
    return "timestamp";
  }
  if (typeName === "ZodBoolean") {
    return "boolean";
  }
  return "jsonb";
}
function buildStorageSchema(zObject) {
  const shape = zObject.shape;
  const result = {};
  for (const [key, field] of Object.entries(shape)) {
    const { base, nullable } = unwrapSchema(field);
    result[key] = {
      type: zodToStorageType(base),
      nullable
    };
  }
  return result;
}

// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_RESOURCES = "mastra_resources";
var TABLE_SCORERS = "mastra_scorers";
var TABLE_SPANS = "mastra_ai_spans";
var TABLE_AGENTS = "mastra_agents";
var SCORERS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerId: { type: "text" },
  traceId: { type: "text", nullable: true },
  spanId: { type: "text", nullable: true },
  runId: { type: "text" },
  scorer: { type: "jsonb" },
  preprocessStepResult: { type: "jsonb", nullable: true },
  extractStepResult: { type: "jsonb", nullable: true },
  analyzeStepResult: { type: "jsonb", nullable: true },
  score: { type: "float" },
  reason: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  preprocessPrompt: { type: "text", nullable: true },
  extractPrompt: { type: "text", nullable: true },
  generateScorePrompt: { type: "text", nullable: true },
  generateReasonPrompt: { type: "text", nullable: true },
  analyzePrompt: { type: "text", nullable: true },
  // Deprecated
  reasonPrompt: { type: "text", nullable: true },
  input: { type: "jsonb" },
  output: { type: "jsonb" },
  // MESSAGE OUTPUT
  additionalContext: { type: "jsonb", nullable: true },
  // DATA FROM THE CONTEXT PARAM ON AN AGENT
  requestContext: { type: "jsonb", nullable: true },
  // THE EVALUATE Request Context FOR THE RUN
  /**
   * Things you can evaluate
   */
  entityType: { type: "text", nullable: true },
  // WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entity: { type: "jsonb", nullable: true },
  // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entityId: { type: "text", nullable: true },
  source: { type: "text" },
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  createdAt: { type: "timestamp" },
  updatedAt: { type: "timestamp" }
};
var SPAN_SCHEMA = buildStorageSchema(spanRecordSchema);
var OLD_SPAN_SCHEMA = {
  // Composite primary key of traceId and spanId
  traceId: { type: "text", nullable: false },
  spanId: { type: "text", nullable: false },
  parentSpanId: { type: "text", nullable: true },
  name: { type: "text", nullable: false },
  scope: { type: "jsonb", nullable: true },
  // Mastra package info {"core-version": "0.1.0"}
  spanType: { type: "text", nullable: false },
  // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.
  attributes: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  links: { type: "jsonb", nullable: true },
  input: { type: "jsonb", nullable: true },
  output: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  // When the span started
  endedAt: { type: "timestamp", nullable: true },
  // When the span ended
  createdAt: { type: "timestamp", nullable: false },
  // The time the database record was created
  updatedAt: { type: "timestamp", nullable: true },
  // The time the database record was last updated
  isEvent: { type: "boolean", nullable: false }
};
var AGENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  instructions: { type: "text", nullable: false },
  // System instructions for the agent
  model: { type: "jsonb", nullable: false },
  // Model configuration (provider, name, etc.)
  tools: { type: "jsonb", nullable: true },
  // Serialized tool references/configurations
  defaultOptions: { type: "jsonb", nullable: true },
  // Default options for generate/stream calls
  workflows: { type: "jsonb", nullable: true },
  // Workflow references (IDs or configurations)
  agents: { type: "jsonb", nullable: true },
  // Sub-agent references (IDs or configurations)
  inputProcessors: { type: "jsonb", nullable: true },
  // Input processor configurations
  outputProcessors: { type: "jsonb", nullable: true },
  // Output processor configurations
  memory: { type: "jsonb", nullable: true },
  // Memory configuration
  scorers: { type: "jsonb", nullable: true },
  // Scorer configurations
  metadata: { type: "jsonb", nullable: true },
  // Additional metadata for the agent
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var TABLE_SCHEMAS = {
  [TABLE_WORKFLOW_SNAPSHOT]: {
    workflow_name: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    resourceId: { type: "text", nullable: true },
    snapshot: {
      type: "jsonb"
    },
    createdAt: {
      type: "timestamp"
    },
    updatedAt: {
      type: "timestamp"
    }
  },
  [TABLE_SCORERS]: SCORERS_SCHEMA,
  [TABLE_THREADS]: {
    id: { type: "text", nullable: false, primaryKey: true },
    resourceId: { type: "text", nullable: false },
    title: { type: "text", nullable: false },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_MESSAGES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    thread_id: { type: "text", nullable: false },
    content: { type: "text", nullable: false },
    role: { type: "text", nullable: false },
    type: { type: "text", nullable: false },
    createdAt: { type: "timestamp", nullable: false },
    resourceId: { type: "text", nullable: true }
  },
  [TABLE_SPANS]: SPAN_SCHEMA,
  [TABLE_TRACES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    parentSpanId: { type: "text", nullable: true },
    name: { type: "text", nullable: false },
    traceId: { type: "text", nullable: false },
    scope: { type: "text", nullable: false },
    kind: { type: "integer", nullable: false },
    attributes: { type: "jsonb", nullable: true },
    status: { type: "jsonb", nullable: true },
    events: { type: "jsonb", nullable: true },
    links: { type: "jsonb", nullable: true },
    other: { type: "text", nullable: true },
    startTime: { type: "bigint", nullable: false },
    endTime: { type: "bigint", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  },
  [TABLE_RESOURCES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    workingMemory: { type: "text", nullable: true },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_AGENTS]: AGENTS_SCHEMA
};

export { AGENTS_SCHEMA, OLD_SPAN_SCHEMA, SCORERS_SCHEMA, SPAN_SCHEMA, TABLE_AGENTS, TABLE_MESSAGES, TABLE_RESOURCES, TABLE_SCHEMAS, TABLE_SCORERS, TABLE_SPANS, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT, TraceStatus, batchCreateSpansArgsSchema, batchDeleteTracesArgsSchema, batchUpdateSpansArgsSchema, buildStorageSchema, createSpanArgsSchema, createSpanRecordSchema, createdAtField, dateRangeSchema, dbTimestamps, entityIdField, entityNameField, entityTypeField, environmentField, getRootSpanArgsSchema, getRootSpanResponseSchema, getSpanArgsSchema, getSpanResponseSchema, getTraceArgsSchema, getTraceResponseSchema, listScoresBySpanResponseSchema, listScoresResponseSchema, listTracesArgsSchema, listTracesResponseSchema, organizationIdField, paginationArgsSchema, paginationInfoSchema, requestIdField, resourceIdField, runIdField, saveScorePayloadSchema, scoreResultSchema, scoreRowDataSchema, scoreTracesRequestSchema, scoreTracesResponseSchema, scoringEntityTypeSchema, scoringExtractStepResultSchema, scoringHookInputSchema, scoringInputSchema, scoringInputWithExtractStepResultAndAnalyzeStepResultSchema, scoringInputWithExtractStepResultAndScoreAndReasonSchema, scoringInputWithExtractStepResultSchema, scoringPromptsSchema, scoringSourceSchema, scoringValueSchema, serviceNameField, sessionIdField, sortDirectionSchema, sourceField, spanIdField, spanIds, spanIdsSchema, spanRecordSchema, threadIdField, traceIdField, tracesFilterSchema, tracesOrderByFieldSchema, tracesOrderBySchema, updateSpanArgsSchema, updateSpanRecordSchema, updatedAtField, userIdField };
//# sourceMappingURL=chunk-65QFXXAD.js.map
//# sourceMappingURL=chunk-65QFXXAD.js.map