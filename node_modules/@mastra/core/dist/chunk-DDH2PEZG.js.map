{"version":3,"sources":["../src/storage/base.ts","../src/storage/domains/base.ts","../src/storage/domains/agents/base.ts","../src/storage/domains/agents/inmemory.ts","../src/storage/domains/inmemory-db.ts","../src/storage/utils.ts","../src/storage/domains/memory/base.ts","../src/storage/domains/memory/inmemory.ts","../src/storage/domains/observability/base.ts","../src/storage/domains/observability/inmemory.ts","../src/storage/domains/scores/base.ts","../src/storage/domains/scores/inmemory.ts","../src/storage/domains/workflows/base.ts","../src/storage/domains/workflows/inmemory.ts","../src/storage/mock.ts","../src/storage/domains/operations/base.ts","../src/storage/domains/operations/inmemory.ts"],"names":[],"mappings":"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","file":"chunk-DDH2PEZG.js","sourcesContent":["import { MastraBase } from '../base';\n\nimport type { AgentsStorage, ScoresStorage, WorkflowsStorage, MemoryStorage, ObservabilityStorage } from './domains';\n\nexport type StorageDomains = {\n  workflows: WorkflowsStorage;\n  scores: ScoresStorage;\n  memory: MemoryStorage;\n  observability?: ObservabilityStorage;\n  agents?: AgentsStorage;\n};\n\n/**\n * Normalizes perPage input for pagination queries.\n *\n * @param perPageInput - The raw perPage value from the user\n * @param defaultValue - The default perPage value to use when undefined (typically 40 for messages, 100 for threads)\n * @returns A numeric perPage value suitable for queries (false becomes MAX_SAFE_INTEGER, negative values fall back to default)\n */\nexport function normalizePerPage(perPageInput: number | false | undefined, defaultValue: number): number {\n  if (perPageInput === false) {\n    return Number.MAX_SAFE_INTEGER; // Get all results\n  } else if (perPageInput === 0) {\n    return 0; // Return zero results\n  } else if (typeof perPageInput === 'number' && perPageInput > 0) {\n    return perPageInput; // Valid positive number\n  }\n  // For undefined, negative, or other invalid values, use default\n  return defaultValue;\n}\n\n/**\n * Calculates pagination offset and prepares perPage value for response.\n * When perPage is false (fetch all), offset is always 0 regardless of page.\n *\n * @param page - The page number (0-indexed)\n * @param perPageInput - The original perPage input (number, false for all, or undefined)\n * @param normalizedPerPage - The normalized perPage value (from normalizePerPage)\n * @returns Object with offset for query and perPage for response\n */\nexport function calculatePagination(\n  page: number,\n  perPageInput: number | false | undefined,\n  normalizedPerPage: number,\n): { offset: number; perPage: number | false } {\n  return {\n    offset: perPageInput === false ? 0 : page * normalizedPerPage,\n    perPage: perPageInput === false ? false : normalizedPerPage,\n  };\n}\n\n/**\n * Configuration for individual domain overrides.\n * Each domain can be sourced from a different storage adapter.\n */\nexport type MastraStorageDomains = Partial<StorageDomains>;\n\n/**\n * Configuration options for MastraStorage.\n *\n * Can be used in two ways:\n * 1. By store implementations: `{ id, name, disableInit? }` - stores set `this.stores` directly\n * 2. For composition: `{ id, default?, domains?, disableInit? }` - compose domains from multiple stores\n */\nexport interface MastraStorageConfig {\n  /**\n   * Unique identifier for this storage instance.\n   */\n  id: string;\n\n  /**\n   * Name of the storage adapter (used for logging).\n   * Required for store implementations extending MastraStorage.\n   */\n  name?: string;\n\n  /**\n   * Default storage adapter to use for domains not explicitly specified.\n   * If provided, domains from this storage will be used as fallbacks.\n   */\n  default?: MastraStorage;\n\n  /**\n   * Individual domain overrides. Each domain can come from a different storage adapter.\n   * These take precedence over the default storage.\n   *\n   * @example\n   * ```typescript\n   * domains: {\n   *   memory: pgStore.stores?.memory,\n   *   workflows: libsqlStore.stores?.workflows,\n   * }\n   * ```\n   */\n  domains?: MastraStorageDomains;\n\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   * This is useful for CI/CD pipelines where you want to:\n   * 1. Run migrations explicitly during deployment (not at runtime)\n   * 2. Use different credentials for schema changes vs runtime operations\n   *\n   * When disableInit is true:\n   * - The storage will not automatically create/alter tables on first use\n   * - You must call `storage.init()` explicitly in your CI/CD scripts\n   *\n   * @example\n   * // In CI/CD script:\n   * const storage = new PostgresStore({ ...config, disableInit: false });\n   * await storage.init(); // Explicitly run migrations\n   *\n   * // In runtime application:\n   * const storage = new PostgresStore({ ...config, disableInit: true });\n   * // No auto-init, tables must already exist\n   */\n  disableInit?: boolean;\n}\n\n/**\n * Base class for all Mastra storage adapters.\n *\n * Can be used in two ways:\n *\n * 1. **Extended by store implementations** (PostgresStore, LibSQLStore, etc.):\n *    Store implementations extend this class and set `this.stores` with their domain implementations.\n *\n * 2. **Directly instantiated for composition**:\n *    Compose domains from multiple storage backends using `default` and `domains` options.\n *\n * All domain-specific operations should be accessed through `getStore()`:\n *\n * @example\n * ```typescript\n * // Composition: mix domains from different stores\n * const storage = new MastraStorage({\n *   id: 'composite',\n *   default: pgStore,\n *   domains: {\n *     memory: libsqlStore.stores?.memory,\n *   },\n * });\n *\n * // Access domains\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n * ```\n */\nexport class MastraStorage extends MastraBase {\n  protected hasInitialized: null | Promise<boolean> = null;\n  protected shouldCacheInit = true;\n\n  id: string;\n  stores?: StorageDomains;\n\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   */\n  disableInit: boolean = false;\n\n  constructor(config: MastraStorageConfig) {\n    const name = config.name ?? 'MastraStorage';\n\n    if (!config.id || typeof config.id !== 'string' || config.id.trim() === '') {\n      throw new Error(`${name}: id must be provided and cannot be empty.`);\n    }\n\n    super({\n      component: 'STORAGE',\n      name,\n    });\n\n    this.id = config.id;\n    this.disableInit = config.disableInit ?? false;\n\n    // If composition config is provided (default or domains), compose the stores\n    if (config.default || config.domains) {\n      const defaultStores = config.default?.stores;\n      const domainOverrides = config.domains ?? {};\n\n      // Validate that at least one storage source is provided\n      const hasDefaultDomains = defaultStores && Object.values(defaultStores).some(v => v !== undefined);\n      const hasOverrideDomains = Object.values(domainOverrides).some(v => v !== undefined);\n\n      if (!hasDefaultDomains && !hasOverrideDomains) {\n        throw new Error(\n          'MastraStorage requires at least one storage source. Provide either a default storage with domains or domain overrides.',\n        );\n      }\n\n      // Build the composed stores object\n      // Domain overrides take precedence over default storage\n      this.stores = {\n        memory: domainOverrides.memory ?? defaultStores?.memory,\n        workflows: domainOverrides.workflows ?? defaultStores?.workflows,\n        scores: domainOverrides.scores ?? defaultStores?.scores,\n        observability: domainOverrides.observability ?? defaultStores?.observability,\n        agents: domainOverrides.agents ?? defaultStores?.agents,\n      } as StorageDomains;\n    }\n    // Otherwise, subclasses set stores themselves\n  }\n\n  /**\n   * Get a domain-specific storage interface.\n   *\n   * @param storeName - The name of the domain to access ('memory', 'workflows', 'scores', 'observability', 'agents')\n   * @returns The domain storage interface, or undefined if not available\n   *\n   * @example\n   * ```typescript\n   * const memory = await storage.getStore('memory');\n   * if (memory) {\n   *   await memory.saveThread({ thread });\n   * }\n   * ```\n   */\n  async getStore<K extends keyof StorageDomains>(storeName: K): Promise<StorageDomains[K] | undefined> {\n    return this.stores?.[storeName];\n  }\n\n  /**\n   * Initialize all domain stores.\n   * This creates necessary tables, indexes, and performs any required migrations.\n   */\n  async init(): Promise<void> {\n    // to prevent race conditions, await any current init\n    if (this.shouldCacheInit && (await this.hasInitialized)) {\n      return;\n    }\n\n    // Initialize all domain stores\n    const initTasks: Promise<void>[] = [];\n\n    if (this.stores?.memory) {\n      initTasks.push(this.stores.memory.init());\n    }\n\n    if (this.stores?.workflows) {\n      initTasks.push(this.stores.workflows.init());\n    }\n\n    if (this.stores?.scores) {\n      initTasks.push(this.stores.scores.init());\n    }\n\n    if (this.stores?.observability) {\n      initTasks.push(this.stores.observability.init());\n    }\n\n    if (this.stores?.agents) {\n      initTasks.push(this.stores.agents.init());\n    }\n\n    this.hasInitialized = Promise.all(initTasks).then(() => true);\n\n    await this.hasInitialized;\n  }\n}\n","import { MastraBase } from '../../base';\n\n/**\n * Base class for all storage domains.\n * Provides common interface for initialization and data clearing.\n */\nexport abstract class StorageDomain extends MastraBase {\n  /**\n   * Initialize the storage domain.\n   * This should create any necessary tables/collections.\n   * Default implementation is a no-op - override in adapters that need initialization.\n   */\n  async init(): Promise<void> {\n    // Default no-op - adapters override if they need to create tables/collections\n  }\n\n  /**\n   * Clears all data from this storage domain.\n   * This is a destructive operation - use with caution.\n   * Primarily used for testing.\n   */\n  abstract dangerouslyClearAll(): Promise<void>;\n}\n","import type {\n  StorageAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n  StorageOrderBy,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class AgentsStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'AGENTS',\n    });\n  }\n\n  /**\n   * Retrieves an agent by its unique identifier.\n   * @param id - The unique identifier of the agent\n   * @returns The agent if found, null otherwise\n   */\n  abstract getAgentById({ id }: { id: string }): Promise<StorageAgentType | null>;\n\n  /**\n   * Creates a new agent in storage.\n   * @param agent - The agent data to create\n   * @returns The created agent with timestamps\n   */\n  abstract createAgent({ agent }: { agent: StorageCreateAgentInput }): Promise<StorageAgentType>;\n\n  /**\n   * Updates an existing agent in storage.\n   * @param id - The unique identifier of the agent to update\n   * @param updates - The fields to update\n   * @returns The updated agent\n   */\n  abstract updateAgent({ id, ...updates }: StorageUpdateAgentInput): Promise<StorageAgentType>;\n\n  /**\n   * Deletes an agent from storage.\n   * @param id - The unique identifier of the agent to delete\n   */\n  abstract deleteAgent({ id }: { id: string }): Promise<void>;\n\n  /**\n   * Lists all agents with optional pagination.\n   * @param args - Pagination and ordering options\n   * @returns Paginated list of agents\n   */\n  abstract listAgents(args?: StorageListAgentsInput): Promise<StorageListAgentsOutput>;\n\n  /**\n   * Parses orderBy input for consistent sorting behavior.\n   */\n  protected parseOrderBy(\n    orderBy?: StorageOrderBy,\n    defaultDirection: ThreadSortDirection = 'DESC',\n  ): { field: ThreadOrderBy; direction: ThreadSortDirection } {\n    return {\n      field: orderBy?.field && orderBy.field in AGENT_ORDER_BY_SET ? orderBy.field : 'createdAt',\n      direction:\n        orderBy?.direction && orderBy.direction in AGENT_SORT_DIRECTION_SET ? orderBy.direction : defaultDirection,\n    };\n  }\n}\n\nconst AGENT_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst AGENT_SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n","import { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { AgentsStorage } from './base';\n\nexport class InMemoryAgentsStorage extends AgentsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.agents.clear();\n  }\n\n  async getAgentById({ id }: { id: string }): Promise<StorageAgentType | null> {\n    this.logger.debug(`InMemoryAgentsStorage: getAgentById called for ${id}`);\n    const agent = this.db.agents.get(id);\n    return agent\n      ? {\n          ...agent,\n          metadata: agent.metadata ? { ...agent.metadata } : agent.metadata,\n          model: { ...agent.model },\n          tools: agent.tools ? [...agent.tools] : agent.tools,\n          workflows: agent.workflows ? [...agent.workflows] : agent.workflows,\n          agents: agent.agents ? [...agent.agents] : agent.agents,\n          scorers: agent.scorers ? { ...agent.scorers } : agent.scorers,\n        }\n      : null;\n  }\n\n  async createAgent({ agent }: { agent: StorageCreateAgentInput }): Promise<StorageAgentType> {\n    this.logger.debug(`InMemoryAgentsStorage: createAgent called for ${agent.id}`);\n\n    if (this.db.agents.has(agent.id)) {\n      throw new Error(`Agent with id ${agent.id} already exists`);\n    }\n\n    const now = new Date();\n    const newAgent: StorageAgentType = {\n      ...agent,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.agents.set(agent.id, newAgent);\n    return { ...newAgent };\n  }\n\n  async updateAgent({ id, ...updates }: StorageUpdateAgentInput): Promise<StorageAgentType> {\n    this.logger.debug(`InMemoryAgentsStorage: updateAgent called for ${id}`);\n\n    const existingAgent = this.db.agents.get(id);\n    if (!existingAgent) {\n      throw new Error(`Agent with id ${id} not found`);\n    }\n\n    const updatedAgent: StorageAgentType = {\n      ...existingAgent,\n      ...(updates.name !== undefined && { name: updates.name }),\n      ...(updates.description !== undefined && { description: updates.description }),\n      ...(updates.instructions !== undefined && { instructions: updates.instructions }),\n      ...(updates.model !== undefined && { model: updates.model }),\n      ...(updates.tools !== undefined && { tools: updates.tools }),\n      ...(updates.defaultOptions !== undefined && {\n        defaultOptions: updates.defaultOptions,\n      }),\n      ...(updates.workflows !== undefined && { workflows: updates.workflows }),\n      ...(updates.agents !== undefined && { agents: updates.agents }),\n      ...(updates.inputProcessors !== undefined && { inputProcessors: updates.inputProcessors }),\n      ...(updates.outputProcessors !== undefined && { outputProcessors: updates.outputProcessors }),\n      ...(updates.memory !== undefined && { memory: updates.memory }),\n      ...(updates.scorers !== undefined && { scorers: updates.scorers }),\n      ...(updates.metadata !== undefined && {\n        metadata: { ...existingAgent.metadata, ...updates.metadata },\n      }),\n      updatedAt: new Date(),\n    };\n\n    this.db.agents.set(id, updatedAgent);\n    return { ...updatedAgent };\n  }\n\n  async deleteAgent({ id }: { id: string }): Promise<void> {\n    this.logger.debug(`InMemoryAgentsStorage: deleteAgent called for ${id}`);\n    // Idempotent delete - no-op if agent doesn't exist\n    this.db.agents.delete(id);\n  }\n\n  async listAgents(args?: StorageListAgentsInput): Promise<StorageListAgentsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryAgentsStorage: listAgents called`);\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  100)\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Get all agents and sort them\n    const agents = Array.from(this.db.agents.values());\n    const sortedAgents = this.sortAgents(agents, field, direction);\n\n    // Clone agents to avoid mutation\n    const clonedAgents = sortedAgents.map(agent => ({\n      ...agent,\n      metadata: agent.metadata ? { ...agent.metadata } : agent.metadata,\n      model: { ...agent.model },\n      tools: agent.tools ? [...agent.tools] : agent.tools,\n      workflows: agent.workflows ? [...agent.workflows] : agent.workflows,\n      agents: agent.agents ? [...agent.agents] : agent.agents,\n      scorers: agent.scorers ? { ...agent.scorers } : agent.scorers,\n    }));\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      agents: clonedAgents.slice(offset, offset + perPage),\n      total: clonedAgents.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedAgents.length,\n    };\n  }\n\n  private sortAgents(\n    agents: StorageAgentType[],\n    field: ThreadOrderBy,\n    direction: ThreadSortDirection,\n  ): StorageAgentType[] {\n    return agents.sort((a, b) => {\n      const aValue = new Date(a[field]).getTime();\n      const bValue = new Date(b[field]).getTime();\n\n      return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n    });\n  }\n}\n","import type { ScoreRowData } from '../../evals/types';\nimport type { StorageThreadType } from '../../memory/types';\nimport type { StorageAgentType, StorageMessageType, StorageResourceType, StorageWorkflowRun } from '../types';\nimport type { TraceEntry } from './observability';\n\n/**\n * InMemoryDB is a thin database layer for in-memory storage.\n * It holds all the Maps that store data, similar to how a real database\n * connection (pg-promise client, libsql client) is shared across domains.\n *\n * Each domain receives a reference to this db and operates on the relevant Maps.\n */\nexport class InMemoryDB {\n  readonly threads = new Map<string, StorageThreadType>();\n  readonly messages = new Map<string, StorageMessageType>();\n  readonly resources = new Map<string, StorageResourceType>();\n  readonly workflows = new Map<string, StorageWorkflowRun>();\n  readonly scores = new Map<string, ScoreRowData>();\n  readonly traces = new Map<string, TraceEntry>();\n  readonly agents = new Map<string, StorageAgentType>();\n\n  /**\n   * Clears all data from all collections.\n   * Useful for testing.\n   */\n  clear(): void {\n    this.threads.clear();\n    this.messages.clear();\n    this.resources.clear();\n    this.workflows.clear();\n    this.scores.clear();\n    this.traces.clear();\n    this.agents.clear();\n  }\n}\n","import type { ScoreRowData } from '../evals/types';\nimport { TABLE_SCHEMAS, TABLE_SCORERS } from './constants';\nimport type { TABLE_NAMES } from './constants';\nimport type { StorageColumn } from './types';\n\n/**\n * Canonical store names for type safety.\n * Provides autocomplete suggestions while still accepting any string.\n */\nexport type StoreName =\n  | 'PG'\n  | 'MSSQL'\n  | 'LIBSQL'\n  | 'MONGODB'\n  | 'CLICKHOUSE'\n  | 'CLOUDFLARE'\n  | 'CLOUDFLARE_D1'\n  | 'DYNAMODB'\n  | 'LANCE'\n  | 'UPSTASH'\n  | 'ASTRA'\n  | 'CHROMA'\n  | 'COUCHBASE'\n  | 'OPENSEARCH'\n  | 'PINECONE'\n  | 'QDRANT'\n  | 'S3'\n  | 'TURBOPUFFER'\n  | 'VECTORIZE'\n  | (string & {});\n\nexport function safelyParseJSON(input: any): any {\n  // If already an object (and not null), return as-is\n  if (input && typeof input === 'object') return input;\n  if (input == null) return {};\n  // If it's a string, try to parse\n  if (typeof input === 'string') {\n    try {\n      return JSON.parse(input);\n    } catch {\n      return input;\n    }\n  }\n  // For anything else (number, boolean, etc.), return empty object\n  return {};\n}\n\n/**\n * Options for transforming storage rows\n */\nexport interface TransformRowOptions {\n  /**\n   * Preferred source fields for timestamps (e.g., { createdAt: 'createdAtZ' } means use createdAtZ if available, else createdAt)\n   */\n  preferredTimestampFields?: Record<string, string>;\n\n  /**\n   * Convert timestamp strings to Date objects (default: false for backwards compatibility)\n   */\n  convertTimestamps?: boolean;\n\n  /**\n   * Pattern to treat as null (e.g., '_null_' for ClickHouse)\n   */\n  nullValuePattern?: string;\n\n  /**\n   * Custom field mappings from source to target (e.g., { entity: 'entityData' } for DynamoDB)\n   */\n  fieldMappings?: Record<string, string>;\n}\n\n/**\n * Generic schema-driven row transformer.\n * Uses TABLE_SCHEMAS to determine field types and apply appropriate transformations:\n * - 'jsonb' fields: parsed from JSON strings using safelyParseJSON\n * - 'timestamp' fields: optionally converted to Date objects\n *\n * @param row - The raw row from storage\n * @param tableName - The table name to look up schema from TABLE_SCHEMAS\n * @param options - Optional configuration for store-specific behavior\n * @returns Transformed row with proper types\n */\nexport function transformRow<T = Record<string, any>>(\n  row: Record<string, any>,\n  tableName: TABLE_NAMES,\n  options: TransformRowOptions = {},\n): T {\n  const { preferredTimestampFields = {}, convertTimestamps = false, nullValuePattern, fieldMappings = {} } = options;\n\n  const tableSchema = TABLE_SCHEMAS[tableName];\n  const result: Record<string, any> = {};\n\n  for (const [key, columnSchema] of Object.entries(tableSchema)) {\n    // Handle field mappings (e.g., entityData -> entity for DynamoDB)\n    const sourceKey = fieldMappings[key] ?? key;\n    let value = row[sourceKey];\n\n    // Handle preferred timestamp sources (e.g., use createdAtZ if available, else createdAt)\n    if (preferredTimestampFields[key]) {\n      value = row[preferredTimestampFields[key]] ?? value;\n    }\n\n    // Skip null/undefined values\n    if (value === undefined || value === null) {\n      continue;\n    }\n\n    // Skip null pattern values (e.g., ClickHouse's '_null_')\n    if (nullValuePattern && value === nullValuePattern) {\n      continue;\n    }\n\n    // Transform based on column type\n    if (columnSchema.type === 'jsonb') {\n      if (typeof value === 'string') {\n        result[key] = safelyParseJSON(value);\n      } else if (typeof value === 'object') {\n        result[key] = value; // Already parsed\n      } else {\n        result[key] = value;\n      }\n    } else if (columnSchema.type === 'timestamp' && convertTimestamps && typeof value === 'string') {\n      result[key] = new Date(value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result as T;\n}\n\n/**\n * Transform a raw score row from storage to ScoreRowData.\n * Convenience wrapper around transformRow for the scores table (TABLE_SCORERS).\n *\n * @param row - The raw row from storage\n * @param options - Optional configuration for store-specific behavior\n * @returns Transformed ScoreRowData\n */\nexport function transformScoreRow(row: Record<string, any>, options: TransformRowOptions = {}): ScoreRowData {\n  return transformRow<ScoreRowData>(row, TABLE_SCORERS, options);\n}\n\n/**\n * Converts a string to UPPER_SNAKE_CASE, preserving word boundaries from camelCase, PascalCase, kebab-case, etc.\n */\nfunction toUpperSnakeCase(str: string): string {\n  return (\n    str\n      // Insert underscore before uppercase letters that follow lowercase letters (camelCase -> camel_Case)\n      .replace(/([a-z])([A-Z])/g, '$1_$2')\n      // Insert underscore before uppercase letters that are followed by lowercase letters (XMLParser -> XML_Parser)\n      .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')\n      // Convert to uppercase\n      .toUpperCase()\n      // Replace any non-alphanumeric characters with underscore\n      .replace(/[^A-Z0-9]+/g, '_')\n      // Remove leading/trailing underscores\n      .replace(/^_+|_+$/g, '')\n  );\n}\n\n/**\n * Generates a standardized error ID for storage and vector operations.\n *\n * Formats:\n * - Storage: MASTRA_STORAGE_{STORE}_{OPERATION}_{STATUS}\n * - Vector:  MASTRA_VECTOR_{STORE}_{OPERATION}_{STATUS}\n *\n * This function auto-normalizes inputs to UPPER_SNAKE_CASE for flexibility.\n * The store parameter is type-checked against canonical store names for IDE autocomplete.\n *\n * @param type - The operation type ('storage' or 'vector')\n * @param store - The store adapter name (type-checked canonical names)\n * @param operation - The operation that failed (e.g., 'LIST_THREADS_BY_RESOURCE_ID', 'QUERY')\n * @param status - The status/error type (e.g., 'FAILED', 'INVALID_THREAD_ID', 'DUPLICATE_KEY')\n *\n * @example\n * ```ts\n * // Storage operations\n * createStoreErrorId('storage', 'PG', 'LIST_THREADS_BY_RESOURCE_ID', 'FAILED')\n * // Returns: 'MASTRA_STORAGE_PG_LIST_THREADS_BY_RESOURCE_ID_FAILED'\n *\n * // Vector operations\n * createStoreErrorId('vector', 'CHROMA', 'QUERY', 'FAILED')\n * // Returns: 'MASTRA_VECTOR_CHROMA_QUERY_FAILED'\n *\n * // Auto-normalizes any casing\n * createStoreErrorId('storage', 'PG', 'listMessagesById', 'failed')\n * // Returns: 'MASTRA_STORAGE_PG_LIST_MESSAGES_BY_ID_FAILED'\n * ```\n */\nexport function createStoreErrorId(\n  type: 'storage' | 'vector',\n  store: StoreName,\n  operation: string,\n  status: string,\n): Uppercase<string> {\n  const normalizedStore = toUpperSnakeCase(store);\n  const normalizedOperation = toUpperSnakeCase(operation);\n  const normalizedStatus = toUpperSnakeCase(status);\n  const typePrefix = type === 'storage' ? 'STORAGE' : 'VECTOR';\n\n  return `MASTRA_${typePrefix}_${normalizedStore}_${normalizedOperation}_${normalizedStatus}` as Uppercase<string>;\n}\n\nexport function createStorageErrorId(store: StoreName, operation: string, status: string): Uppercase<string> {\n  return createStoreErrorId('storage', store, operation, status);\n}\n\nexport function createVectorErrorId(store: StoreName, operation: string, status: string): Uppercase<string> {\n  return createStoreErrorId('vector', store, operation, status);\n}\n\nexport function getSqlType(type: StorageColumn['type']): string {\n  switch (type) {\n    case 'text':\n      return 'TEXT';\n    case 'timestamp':\n      return 'TIMESTAMP';\n    case 'float':\n      return 'FLOAT';\n    case 'integer':\n      return 'INTEGER';\n    case 'bigint':\n      return 'BIGINT';\n    case 'jsonb':\n      return 'JSONB';\n    case 'boolean':\n      return 'BOOLEAN';\n    default:\n      return 'TEXT';\n  }\n}\n\nexport function getDefaultValue(type: StorageColumn['type']): string {\n  switch (type) {\n    case 'text':\n    case 'uuid':\n      return \"DEFAULT ''\";\n    case 'timestamp':\n      return \"DEFAULT '1970-01-01 00:00:00'\";\n    case 'integer':\n    case 'bigint':\n    case 'float':\n      return 'DEFAULT 0';\n    case 'jsonb':\n      return \"DEFAULT '{}'\";\n    case 'boolean':\n      return 'DEFAULT FALSE';\n    default:\n      return \"DEFAULT ''\";\n  }\n}\n\nexport function ensureDate(date: Date | string | undefined): Date | undefined {\n  if (!date) return undefined;\n  return date instanceof Date ? date : new Date(date);\n}\n\nexport function serializeDate(date: Date | string | undefined): string | undefined {\n  if (!date) return undefined;\n  const dateObj = ensureDate(date);\n  return dateObj?.toISOString();\n}\n\n/**\n * Date range filter configuration for in-memory filtering operations.\n */\nexport interface DateRangeFilter {\n  start?: Date | string;\n  end?: Date | string;\n  startExclusive?: boolean;\n  endExclusive?: boolean;\n}\n\n/**\n * Filter an array of items by date range. Used by in-memory storage adapters.\n *\n * This provides a consistent implementation of date range filtering with\n * support for inclusive/exclusive bounds across all storage adapters.\n *\n * @param items - Array of items to filter\n * @param getCreatedAt - Function to extract the createdAt date from an item\n * @param dateRange - Optional date range filter configuration\n * @returns Filtered array of items\n *\n * @example\n * ```ts\n * const filtered = filterByDateRange(\n *   messages,\n *   (msg) => new Date(msg.createdAt),\n *   { start: new Date('2024-01-01'), startExclusive: true }\n * );\n * ```\n */\nexport function filterByDateRange<T>(items: T[], getCreatedAt: (item: T) => Date, dateRange?: DateRangeFilter): T[] {\n  if (!dateRange) return items;\n\n  let result = items;\n\n  if (dateRange.start) {\n    const startTime = ensureDate(dateRange.start)!.getTime();\n    result = result.filter(item => {\n      const itemTime = getCreatedAt(item).getTime();\n      return dateRange.startExclusive ? itemTime > startTime : itemTime >= startTime;\n    });\n  }\n\n  if (dateRange.end) {\n    const endTime = ensureDate(dateRange.end)!.getTime();\n    result = result.filter(item => {\n      const itemTime = getCreatedAt(item).getTime();\n      return dateRange.endExclusive ? itemTime < endTime : itemTime <= endTime;\n    });\n  }\n\n  return result;\n}\n","import type { MastraMessageContentV2 } from '../../../agent';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport type {\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n  StorageOrderBy,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n} from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class MemoryStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'MEMORY',\n    });\n  }\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  abstract listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput>;\n\n  abstract listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract updateMessages(args: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraDBMessage[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  abstract listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput>;\n\n  /**\n   * Clone a thread and its messages to create a new independent thread.\n   * The cloned thread will have clone metadata stored in its metadata field.\n   *\n   * @param args - Clone configuration options\n   * @returns The newly created thread and the cloned messages\n   */\n  async cloneThread(_args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    throw new Error(\n      `Thread cloning is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `The cloneThread method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  protected parseOrderBy(\n    orderBy?: StorageOrderBy,\n    defaultDirection: ThreadSortDirection = 'DESC',\n  ): { field: ThreadOrderBy; direction: ThreadSortDirection } {\n    return {\n      field: orderBy?.field && orderBy.field in THREAD_ORDER_BY_SET ? orderBy.field : 'createdAt',\n      direction:\n        orderBy?.direction && orderBy.direction in THREAD_THREAD_SORT_DIRECTION_SET\n          ? orderBy.direction\n          : defaultDirection,\n    };\n  }\n}\n\nconst THREAD_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst THREAD_THREAD_SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n","import { MessageList } from '../../../agent/message-list';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageMessageType,\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n  ThreadCloneMetadata,\n} from '../../types';\nimport { filterByDateRange, safelyParseJSON } from '../../utils';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { MemoryStorage } from './base';\n\nexport class InMemoryMemory extends MemoryStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.threads.clear();\n    this.db.messages.clear();\n    this.db.resources.clear();\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    this.logger.debug(`InMemoryMemory: getThreadById called for ${threadId}`);\n    const thread = this.db.threads.get(threadId);\n    return thread ? { ...thread, metadata: thread.metadata ? { ...thread.metadata } : thread.metadata } : null;\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    this.logger.debug(`InMemoryMemory: saveThread called for ${thread.id}`);\n    const key = thread.id;\n    this.db.threads.set(key, thread);\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    this.logger.debug(`InMemoryMemory: updateThread called for ${id}`);\n    const thread = this.db.threads.get(id);\n\n    if (!thread) {\n      throw new Error(`Thread with id ${id} not found`);\n    }\n\n    if (thread) {\n      thread.title = title;\n      thread.metadata = { ...thread.metadata, ...metadata };\n      thread.updatedAt = new Date();\n    }\n    return thread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    this.logger.debug(`InMemoryMemory: deleteThread called for ${threadId}`);\n    this.db.threads.delete(threadId);\n\n    this.db.messages.forEach((msg, key) => {\n      if (msg.thread_id === threadId) {\n        this.db.messages.delete(key);\n      }\n    });\n  }\n\n  async listMessages({\n    threadId,\n    resourceId,\n    include,\n    filter,\n    perPage: perPageInput,\n    page = 0,\n    orderBy,\n  }: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    // Normalize threadId to array\n    const threadIds = Array.isArray(threadId) ? threadId : [threadId];\n\n    this.logger.debug(`InMemoryMemory: listMessages called for threads ${threadIds.join(', ')}`);\n\n    if (threadIds.length === 0 || threadIds.some(id => !id.trim())) {\n      throw new Error('threadId must be a non-empty string or array of non-empty strings');\n    }\n\n    const threadIdSet = new Set(threadIds);\n\n    const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  40)\n    const perPage = normalizePerPage(perPageInput, 40);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Calculate offset from page\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    // Step 1: Get regular paginated messages from the thread(s) first\n    let threadMessages = Array.from(this.db.messages.values()).filter((msg: any) => {\n      if (!threadIdSet.has(msg.thread_id)) return false;\n      if (resourceId && msg.resourceId !== resourceId) return false;\n      return true;\n    });\n\n    // Apply date filtering\n    threadMessages = filterByDateRange(threadMessages, (msg: any) => new Date(msg.createdAt), filter?.dateRange);\n\n    // Sort thread messages before pagination\n    threadMessages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Get total count of thread messages (for pagination metadata)\n    const totalThreadMessages = threadMessages.length;\n\n    // Apply pagination to thread messages\n    const start = offset;\n    const end = start + perPage;\n    const paginatedThreadMessages = threadMessages.slice(start, end);\n\n    // Convert paginated thread messages to MastraDBMessage\n    const messages: MastraDBMessage[] = [];\n    const messageIds = new Set<string>();\n\n    for (const msg of paginatedThreadMessages) {\n      const convertedMessage = this.parseStoredMessage(msg);\n      messages.push(convertedMessage);\n      messageIds.add(msg.id);\n    }\n\n    // Step 2: Add included messages with context (if any), excluding duplicates\n    if (include && include.length > 0) {\n      for (const includeItem of include) {\n        const targetMessage = this.db.messages.get(includeItem.id);\n        if (targetMessage) {\n          // Convert StorageMessageType to MastraDBMessage\n          const convertedMessage = {\n            id: targetMessage.id,\n            threadId: targetMessage.thread_id,\n            content: safelyParseJSON(targetMessage.content),\n            role: targetMessage.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: targetMessage.type,\n            createdAt: targetMessage.createdAt,\n            resourceId: targetMessage.resourceId,\n          } as MastraDBMessage;\n\n          // Only add if not already in messages array (deduplication)\n          if (!messageIds.has(convertedMessage.id)) {\n            messages.push(convertedMessage);\n            messageIds.add(convertedMessage.id);\n          }\n\n          // Add previous messages if requested\n          if (includeItem.withPreviousMessages) {\n            const allThreadMessages = Array.from(this.db.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));\n              for (let i = startIndex; i < targetIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedPrevMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedPrevMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n\n          // Add next messages if requested\n          if (includeItem.withNextMessages) {\n            const allThreadMessages = Array.from(this.db.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const endIndex = Math.min(\n                allThreadMessages.length,\n                targetIndex + (includeItem.withNextMessages || 0) + 1,\n              );\n              for (let i = targetIndex + 1; i < endIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedNextMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedNextMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Sort all messages (paginated + included) for final output\n    messages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Calculate hasMore\n    let hasMore;\n    if (include && include.length > 0) {\n      // When using include, check if we've returned all messages from the thread\n      // because include might bring in messages beyond the pagination window\n      const returnedThreadMessageIds = new Set(messages.filter(m => m.threadId === threadId).map(m => m.id));\n      hasMore = returnedThreadMessageIds.size < totalThreadMessages;\n    } else {\n      // Standard pagination: check if there are more pages\n      hasMore = end < totalThreadMessages;\n    }\n\n    return {\n      messages,\n      total: totalThreadMessages,\n      page,\n      perPage: perPageForResponse,\n      hasMore,\n    };\n  }\n\n  protected parseStoredMessage(message: StorageMessageType): MastraDBMessage {\n    const { resourceId, content, role, thread_id, ...rest } = message;\n\n    // Parse content using safelyParseJSON utility\n    let parsedContent = safelyParseJSON(content);\n\n    // If the result is a plain string (V1 format), wrap it in V2 structure\n    if (typeof parsedContent === 'string') {\n      parsedContent = {\n        format: 2,\n        content: parsedContent,\n        parts: [{ type: 'text', text: parsedContent }],\n      };\n    }\n\n    return {\n      ...rest,\n      threadId: thread_id,\n      ...(message.resourceId && { resourceId: message.resourceId }),\n      content: parsedContent,\n      role: role as MastraDBMessage['role'],\n    } satisfies MastraDBMessage;\n  }\n\n  async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    this.logger.debug(`InMemoryMemory: listMessagesById called`);\n\n    const rawMessages = messageIds.map(id => this.db.messages.get(id)).filter(message => !!message);\n\n    const list = new MessageList().add(\n      rawMessages.map(m => this.parseStoredMessage(m)),\n      'memory',\n    );\n    return { messages: list.get.all.db() };\n  }\n\n  async saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    const { messages } = args;\n    this.logger.debug(`InMemoryMemory: saveMessages called with ${messages.length} messages`);\n    // Simulate error handling for testing - check before saving\n    if (messages.some(msg => msg.id === 'error-message' || msg.resourceId === null)) {\n      throw new Error('Simulated error for testing');\n    }\n\n    // Update thread timestamps for each unique threadId\n    const threadIds = new Set(messages.map(msg => msg.threadId).filter((id): id is string => Boolean(id)));\n    for (const threadId of threadIds) {\n      const thread = this.db.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = new Date();\n      }\n    }\n\n    for (const message of messages) {\n      const key = message.id;\n      // Convert MastraDBMessage to StorageMessageType\n      const storageMessage: StorageMessageType = {\n        id: message.id,\n        thread_id: message.threadId || '',\n        content: JSON.stringify(message.content),\n        role: message.role || 'user',\n        type: message.type || 'text',\n        createdAt: message.createdAt,\n        resourceId: message.resourceId || null,\n      };\n      this.db.messages.set(key, storageMessage);\n    }\n\n    const list = new MessageList().add(messages, 'memory');\n    return { messages: list.get.all.db() };\n  }\n\n  async updateMessages(args: { messages: (Partial<MastraDBMessage> & { id: string })[] }): Promise<MastraDBMessage[]> {\n    const updatedMessages: MastraDBMessage[] = [];\n    for (const update of args.messages) {\n      const storageMsg = this.db.messages.get(update.id);\n      if (!storageMsg) continue;\n\n      // Track old threadId for possible move\n      const oldThreadId = storageMsg.thread_id;\n      const newThreadId = update.threadId || oldThreadId;\n      let threadIdChanged = false;\n      if (update.threadId && update.threadId !== oldThreadId) {\n        threadIdChanged = true;\n      }\n\n      // Update fields\n      if (update.role !== undefined) storageMsg.role = update.role;\n      if (update.type !== undefined) storageMsg.type = update.type;\n      if (update.createdAt !== undefined) storageMsg.createdAt = update.createdAt;\n      if (update.resourceId !== undefined) storageMsg.resourceId = update.resourceId;\n      // Deep merge content if present\n      if (update.content !== undefined) {\n        let oldContent = safelyParseJSON(storageMsg.content);\n        let newContent = update.content;\n        if (typeof newContent === 'object' && typeof oldContent === 'object') {\n          // Deep merge for metadata/content fields\n          newContent = { ...oldContent, ...newContent };\n          if (oldContent.metadata && newContent.metadata) {\n            newContent.metadata = { ...oldContent.metadata, ...newContent.metadata };\n          }\n        }\n        storageMsg.content = JSON.stringify(newContent);\n      }\n      // Handle threadId change\n      if (threadIdChanged) {\n        storageMsg.thread_id = newThreadId;\n        // Update updatedAt for both threads, ensuring strictly greater and not equal\n        const base = Date.now();\n        let oldThreadNewTime: number | undefined;\n        const oldThread = this.db.threads.get(oldThreadId);\n        if (oldThread) {\n          const prev = new Date(oldThread.updatedAt).getTime();\n          oldThreadNewTime = Math.max(base, prev + 1);\n          oldThread.updatedAt = new Date(oldThreadNewTime);\n        }\n        const newThread = this.db.threads.get(newThreadId);\n        if (newThread) {\n          const prev = new Date(newThread.updatedAt).getTime();\n          let newThreadNewTime = Math.max(base + 1, prev + 1);\n          if (oldThreadNewTime !== undefined && newThreadNewTime <= oldThreadNewTime) {\n            newThreadNewTime = oldThreadNewTime + 1;\n          }\n          newThread.updatedAt = new Date(newThreadNewTime);\n        }\n      } else {\n        // Only update the thread's updatedAt if not a move\n        const thread = this.db.threads.get(oldThreadId);\n        if (thread) {\n          const prev = new Date(thread.updatedAt).getTime();\n          let newTime = Date.now();\n          if (newTime <= prev) newTime = prev + 1;\n          thread.updatedAt = new Date(newTime);\n        }\n      }\n      // Save the updated message\n      this.db.messages.set(update.id, storageMsg);\n      // Return as MastraDBMessage\n      updatedMessages.push({\n        id: storageMsg.id,\n        threadId: storageMsg.thread_id,\n        content: safelyParseJSON(storageMsg.content),\n        role: storageMsg.role === 'user' || storageMsg.role === 'assistant' ? storageMsg.role : 'user',\n        type: storageMsg.type,\n        createdAt: storageMsg.createdAt,\n        resourceId: storageMsg.resourceId === null ? undefined : storageMsg.resourceId,\n      });\n    }\n    return updatedMessages;\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    this.logger.debug(`InMemoryMemory: deleteMessages called for ${messageIds.length} messages`);\n\n    // Collect thread IDs to update\n    const threadIds = new Set<string>();\n\n    for (const messageId of messageIds) {\n      const message = this.db.messages.get(messageId);\n      if (message && message.thread_id) {\n        threadIds.add(message.thread_id);\n      }\n      // Delete the message\n      this.db.messages.delete(messageId);\n    }\n\n    // Update thread timestamps\n    const now = new Date();\n    for (const threadId of threadIds) {\n      const thread = this.db.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = now;\n      }\n    }\n  }\n\n  async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;\n    const { field, direction } = this.parseOrderBy(orderBy);\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    this.logger.debug(`InMemoryMemory: listThreadsByResourceId called for ${resourceId}`);\n    // Mock implementation - find threads by resourceId\n    const threads = Array.from(this.db.threads.values()).filter((t: any) => t.resourceId === resourceId);\n    const sortedThreads = this.sortThreads(threads, field, direction);\n    const clonedThreads = sortedThreads.map(thread => ({\n      ...thread,\n      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata,\n    })) as StorageThreadType[];\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    return {\n      threads: clonedThreads.slice(offset, offset + perPage),\n      total: clonedThreads.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedThreads.length,\n    };\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    this.logger.debug(`InMemoryMemory: getResourceById called for ${resourceId}`);\n    const resource = this.db.resources.get(resourceId);\n    return resource\n      ? { ...resource, metadata: resource.metadata ? { ...resource.metadata } : resource.metadata }\n      : null;\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    this.logger.debug(`InMemoryMemory: saveResource called for ${resource.id}`);\n    this.db.resources.set(resource.id, resource);\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    this.logger.debug(`InMemoryMemory: updateResource called for ${resourceId}`);\n    let resource = this.db.resources.get(resourceId);\n\n    if (!resource) {\n      // Create new resource if it doesn't exist\n      resource = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    } else {\n      resource = {\n        ...resource,\n        workingMemory: workingMemory !== undefined ? workingMemory : resource.workingMemory,\n        metadata: {\n          ...resource.metadata,\n          ...metadata,\n        },\n        updatedAt: new Date(),\n      };\n    }\n\n    this.db.resources.set(resourceId, resource);\n    return resource;\n  }\n\n  async cloneThread(args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;\n\n    this.logger.debug(`InMemoryMemory: cloneThread called for source thread ${sourceThreadId}`);\n\n    // Get the source thread\n    const sourceThread = this.db.threads.get(sourceThreadId);\n    if (!sourceThread) {\n      throw new Error(`Source thread with id ${sourceThreadId} not found`);\n    }\n\n    // Use provided ID or generate a new one\n    const newThreadId = providedThreadId || crypto.randomUUID();\n\n    // Check if the new thread ID already exists\n    if (this.db.threads.has(newThreadId)) {\n      throw new Error(`Thread with id ${newThreadId} already exists`);\n    }\n\n    // Get messages from the source thread\n    let sourceMessages = Array.from(this.db.messages.values())\n      .filter((msg: StorageMessageType) => msg.thread_id === sourceThreadId)\n      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n    // Apply message filters if provided\n    if (options?.messageFilter) {\n      const { startDate, endDate, messageIds } = options.messageFilter;\n\n      if (messageIds && messageIds.length > 0) {\n        const messageIdSet = new Set(messageIds);\n        sourceMessages = sourceMessages.filter(msg => messageIdSet.has(msg.id));\n      }\n\n      if (startDate) {\n        sourceMessages = sourceMessages.filter(msg => new Date(msg.createdAt) >= startDate);\n      }\n\n      if (endDate) {\n        sourceMessages = sourceMessages.filter(msg => new Date(msg.createdAt) <= endDate);\n      }\n    }\n\n    // Apply message limit (take from the end to get most recent)\n    if (options?.messageLimit && options.messageLimit > 0 && sourceMessages.length > options.messageLimit) {\n      sourceMessages = sourceMessages.slice(-options.messageLimit);\n    }\n\n    const now = new Date();\n\n    // Determine the last message ID for clone metadata\n    const lastMessageId = sourceMessages.length > 0 ? sourceMessages[sourceMessages.length - 1]!.id : undefined;\n\n    // Create clone metadata\n    const cloneMetadata: ThreadCloneMetadata = {\n      sourceThreadId,\n      clonedAt: now,\n      ...(lastMessageId && { lastMessageId }),\n    };\n\n    // Create the new thread\n    const newThread: StorageThreadType = {\n      id: newThreadId,\n      resourceId: resourceId || sourceThread.resourceId,\n      title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : undefined),\n      metadata: {\n        ...metadata,\n        clone: cloneMetadata,\n      },\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    // Save the new thread\n    this.db.threads.set(newThreadId, newThread);\n\n    // Clone messages with new IDs\n    const clonedMessages: MastraDBMessage[] = [];\n    for (const sourceMsg of sourceMessages) {\n      const newMessageId = crypto.randomUUID();\n      const parsedContent = safelyParseJSON(sourceMsg.content);\n\n      // Create storage message\n      const newStorageMessage: StorageMessageType = {\n        id: newMessageId,\n        thread_id: newThreadId,\n        content: sourceMsg.content,\n        role: sourceMsg.role,\n        type: sourceMsg.type,\n        createdAt: sourceMsg.createdAt,\n        resourceId: resourceId || sourceMsg.resourceId,\n      };\n\n      this.db.messages.set(newMessageId, newStorageMessage);\n\n      // Create MastraDBMessage for return\n      clonedMessages.push({\n        id: newMessageId,\n        threadId: newThreadId,\n        content: parsedContent,\n        role: sourceMsg.role as MastraDBMessage['role'],\n        type: sourceMsg.type,\n        createdAt: sourceMsg.createdAt,\n        resourceId: resourceId || sourceMsg.resourceId || undefined,\n      });\n    }\n\n    this.logger.debug(\n      `InMemoryMemory: cloned thread ${sourceThreadId} to ${newThreadId} with ${clonedMessages.length} messages`,\n    );\n\n    return {\n      thread: newThread,\n      clonedMessages,\n    };\n  }\n\n  private sortThreads(threads: any[], field: ThreadOrderBy, direction: ThreadSortDirection): any[] {\n    return threads.sort((a, b) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        if (direction === 'ASC') {\n          return aValue - bValue;\n        } else {\n          return bValue - aValue;\n        }\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport { StorageDomain } from '../base';\nimport type {\n  BatchCreateSpansArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  CreateSpanArgs,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n  ListTracesArgs,\n  ListTracesResponse,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n} from './types';\n\n/**\n * ObservabilityStorage is not abstract because it provides default implementations\n * that throw errors - adapters override only the methods they support.\n */\nexport class ObservabilityStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OBSERVABILITY',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Provides hints for tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates', // Default for most SQL stores\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  /**\n   * Creates a single Span record in the storage provider.\n   */\n  async createSpan(_args: CreateSpanArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support creating spans',\n    });\n  }\n\n  /**\n   * Updates a single Span with partial data. Primarily used for realtime trace creation.\n   */\n  async updateSpan(_args: UpdateSpanArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_UPDATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support updating spans',\n    });\n  }\n\n  /**\n   * Retrieves a single span.\n   */\n  async getSpan(_args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting spans',\n    });\n  }\n\n  /**\n   * Retrieves a single root span.\n   */\n  async getRootSpan(_args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_ROOT_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting root spans',\n    });\n  }\n\n  /**\n   * Retrieves a single trace with all its associated spans.\n   */\n  async getTrace(_args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_TRACE_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting traces',\n    });\n  }\n\n  /**\n   * Retrieves a list of traces with optional filtering.\n   */\n  async listTraces(_args: ListTracesArgs): Promise<ListTracesResponse> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_LIST_TRACES_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support listing traces',\n    });\n  }\n\n  /**\n   * Creates multiple Spans in a single batch.\n   */\n  async batchCreateSpans(_args: BatchCreateSpansArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch creating spans',\n    });\n  }\n\n  /**\n   * Updates multiple Spans in a single batch.\n   */\n  async batchUpdateSpans(_args: BatchUpdateSpansArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_UPDATE_SPANS_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch updating spans',\n    });\n  }\n\n  /**\n   * Deletes multiple traces and all their associated spans in a single batch operation.\n   */\n  async batchDeleteTraces(_args: BatchDeleteTracesArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_DELETE_TRACES_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch deleting traces',\n    });\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { PaginationInfo } from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { ObservabilityStorage } from './base';\nimport type {\n  BatchCreateSpansArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  CreateSpanArgs,\n  CreateSpanRecord,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n  ListTracesArgs,\n  SpanRecord,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n} from './types';\nimport { listTracesArgsSchema, TraceStatus } from './types';\n\n/**\n * Internal structure for storing a trace with computed properties for efficient filtering\n */\nexport interface TraceEntry {\n  /** All spans in this trace, keyed by spanId */\n  spans: Record<string, SpanRecord>;\n  /** Root span for this trace (parentSpanId === null) */\n  rootSpan: SpanRecord | null;\n  /** Computed trace status based on root span state */\n  status: TraceStatus;\n  /** True if any span in the trace has an error */\n  hasChildError: boolean;\n}\n\nexport class ObservabilityInMemory extends ObservabilityStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.traces.clear();\n  }\n\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'realtime',\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createSpan(args: CreateSpanArgs): Promise<void> {\n    const { span } = args;\n    this.validateCreateSpan(span);\n    const now = new Date();\n    const record: SpanRecord = {\n      ...span,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.upsertSpanToTrace(record);\n  }\n\n  async batchCreateSpans(args: BatchCreateSpansArgs): Promise<void> {\n    const now = new Date();\n    for (const span of args.records) {\n      this.validateCreateSpan(span);\n      const record: SpanRecord = {\n        ...span,\n        createdAt: now,\n        updatedAt: now,\n      };\n      this.upsertSpanToTrace(record);\n    }\n  }\n\n  private validateCreateSpan(record: CreateSpanRecord): void {\n    if (!record.spanId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_SPAN_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span ID is required for creating a span',\n      });\n    }\n\n    if (!record.traceId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_TRACE_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace ID is required for creating a span',\n      });\n    }\n  }\n\n  /**\n   * Inserts or updates a span in the trace and recomputes trace-level properties\n   */\n  private upsertSpanToTrace(span: SpanRecord): void {\n    const { traceId, spanId } = span;\n    let traceEntry = this.db.traces.get(traceId);\n\n    if (!traceEntry) {\n      traceEntry = {\n        spans: {},\n        rootSpan: null,\n        status: TraceStatus.RUNNING,\n        hasChildError: false,\n      };\n      this.db.traces.set(traceId, traceEntry);\n    }\n\n    traceEntry.spans[spanId] = span;\n\n    // Update root span if this is a root span\n    if (span.parentSpanId === null) {\n      traceEntry.rootSpan = span;\n    }\n\n    this.recomputeTraceProperties(traceEntry);\n  }\n\n  /**\n   * Recomputes derived trace properties from all spans\n   */\n  private recomputeTraceProperties(traceEntry: TraceEntry): void {\n    const spans = Object.values(traceEntry.spans);\n    if (spans.length === 0) return;\n\n    // Compute hasChildError (use != null to catch both null and undefined)\n    traceEntry.hasChildError = spans.some(s => s.error != null);\n\n    // Compute status from root span\n    const rootSpan = traceEntry.rootSpan;\n    if (rootSpan) {\n      if (rootSpan.error != null) {\n        traceEntry.status = TraceStatus.ERROR;\n      } else if (rootSpan.endedAt === null) {\n        traceEntry.status = TraceStatus.RUNNING;\n      } else {\n        traceEntry.status = TraceStatus.SUCCESS;\n      }\n    } else {\n      // No root span yet, consider it running\n      traceEntry.status = TraceStatus.RUNNING;\n    }\n  }\n\n  async getSpan(args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    const { traceId, spanId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry) {\n      return null;\n    }\n\n    const span = traceEntry.spans[spanId];\n    if (!span) {\n      return null;\n    }\n\n    return { span };\n  }\n\n  async getRootSpan(args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    const { traceId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry || !traceEntry.rootSpan) {\n      return null;\n    }\n\n    return { span: traceEntry.rootSpan };\n  }\n\n  async getTrace(args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    const { traceId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry) {\n      return null;\n    }\n\n    const spans = Object.values(traceEntry.spans);\n    if (spans.length === 0) {\n      return null;\n    }\n\n    // Sort spans by startedAt\n    spans.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());\n\n    return {\n      traceId,\n      spans,\n    };\n  }\n\n  async listTraces(args: ListTracesArgs): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    // Parse args through schema to apply defaults\n    const { filters, pagination, orderBy } = listTracesArgsSchema.parse(args);\n\n    // Collect all traces that match filters\n    const matchingRootSpans: SpanRecord[] = [];\n\n    for (const [, traceEntry] of this.db.traces) {\n      if (!traceEntry.rootSpan) continue;\n\n      if (this.traceMatchesFilters(traceEntry, filters)) {\n        matchingRootSpans.push(traceEntry.rootSpan);\n      }\n    }\n\n    // Sort by orderBy field\n    const { field: sortField, direction: sortDirection } = orderBy;\n\n    matchingRootSpans.sort((a, b) => {\n      if (sortField === 'endedAt') {\n        const aVal = a.endedAt;\n        const bVal = b.endedAt;\n\n        // Handle nullish values (running spans with null endedAt)\n        // For endedAt DESC: NULLs FIRST (running spans on top when viewing newest)\n        // For endedAt ASC: NULLs LAST (running spans at end when viewing oldest)\n        if (aVal == null && bVal == null) return 0;\n        if (aVal == null) return sortDirection === 'DESC' ? -1 : 1;\n        if (bVal == null) return sortDirection === 'DESC' ? 1 : -1;\n\n        const diff = aVal.getTime() - bVal.getTime();\n        return sortDirection === 'DESC' ? -diff : diff;\n      } else {\n        // startedAt is never null (required field)\n        const diff = a.startedAt.getTime() - b.startedAt.getTime();\n        return sortDirection === 'DESC' ? -diff : diff;\n      }\n    });\n\n    // Apply pagination\n    const total = matchingRootSpans.length;\n    const { page, perPage } = pagination;\n    const start = page * perPage;\n    const end = start + perPage;\n\n    const paged = matchingRootSpans.slice(start, end);\n\n    return {\n      spans: paged,\n      pagination: { total, page, perPage, hasMore: end < total },\n    };\n  }\n\n  /**\n   * Check if a trace matches all provided filters\n   */\n  private traceMatchesFilters(traceEntry: TraceEntry, filters: ListTracesArgs['filters']): boolean {\n    if (!filters) return true;\n\n    const rootSpan = traceEntry.rootSpan;\n    if (!rootSpan) return false;\n\n    // Date range filters on startedAt (based on root span)\n    if (filters.startedAt) {\n      if (filters.startedAt.start && rootSpan.startedAt < filters.startedAt.start) {\n        return false;\n      }\n      if (filters.startedAt.end && rootSpan.startedAt > filters.startedAt.end) {\n        return false;\n      }\n    }\n\n    // Date range filters on endedAt (based on root span)\n    if (filters.endedAt) {\n      // If root span is still running (endedAt is nullish), it doesn't match endedAt filters\n      if (rootSpan.endedAt == null) {\n        return false;\n      }\n      if (filters.endedAt.start && rootSpan.endedAt < filters.endedAt.start) {\n        return false;\n      }\n      if (filters.endedAt.end && rootSpan.endedAt > filters.endedAt.end) {\n        return false;\n      }\n    }\n\n    // Span type filter (on root span)\n    if (filters.spanType !== undefined && rootSpan.spanType !== filters.spanType) {\n      return false;\n    }\n\n    // Entity filters\n    if (filters.entityType !== undefined && rootSpan.entityType !== filters.entityType) {\n      return false;\n    }\n    if (filters.entityId !== undefined && rootSpan.entityId !== filters.entityId) {\n      return false;\n    }\n    if (filters.entityName !== undefined && rootSpan.entityName !== filters.entityName) {\n      return false;\n    }\n\n    // Identity & Tenancy filters\n    if (filters.userId !== undefined && rootSpan.userId !== filters.userId) {\n      return false;\n    }\n    if (filters.organizationId !== undefined && rootSpan.organizationId !== filters.organizationId) {\n      return false;\n    }\n    if (filters.resourceId !== undefined && rootSpan.resourceId !== filters.resourceId) {\n      return false;\n    }\n\n    // Correlation ID filters\n    if (filters.runId !== undefined && rootSpan.runId !== filters.runId) {\n      return false;\n    }\n    if (filters.sessionId !== undefined && rootSpan.sessionId !== filters.sessionId) {\n      return false;\n    }\n    if (filters.threadId !== undefined && rootSpan.threadId !== filters.threadId) {\n      return false;\n    }\n    if (filters.requestId !== undefined && rootSpan.requestId !== filters.requestId) {\n      return false;\n    }\n\n    // Deployment context filters\n    if (filters.environment !== undefined && rootSpan.environment !== filters.environment) {\n      return false;\n    }\n    if (filters.source !== undefined && rootSpan.source !== filters.source) {\n      return false;\n    }\n    if (filters.serviceName !== undefined && rootSpan.serviceName !== filters.serviceName) {\n      return false;\n    }\n\n    // Scope filter (partial match - all provided keys must match)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.scope != null && rootSpan.scope != null) {\n      for (const [key, value] of Object.entries(filters.scope)) {\n        if (!this.jsonValueEquals(rootSpan.scope[key], value)) {\n          return false;\n        }\n      }\n    } else if (filters.scope != null && rootSpan.scope == null) {\n      return false;\n    }\n\n    // Metadata filter (partial match - all provided keys must match)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.metadata != null && rootSpan.metadata != null) {\n      for (const [key, value] of Object.entries(filters.metadata)) {\n        if (!this.jsonValueEquals(rootSpan.metadata[key], value)) {\n          return false;\n        }\n      }\n    } else if (filters.metadata != null && rootSpan.metadata == null) {\n      return false;\n    }\n\n    // Tags filter (all provided tags must be present)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.tags != null && filters.tags.length > 0) {\n      if (rootSpan.tags == null) {\n        return false;\n      }\n      for (const tag of filters.tags) {\n        if (!rootSpan.tags.includes(tag)) {\n          return false;\n        }\n      }\n    }\n\n    // Derived status filter\n    if (filters.status !== undefined && traceEntry.status !== filters.status) {\n      return false;\n    }\n\n    // Has child error filter\n    if (filters.hasChildError !== undefined && traceEntry.hasChildError !== filters.hasChildError) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Deep equality check for JSON values\n   */\n  private jsonValueEquals(a: unknown, b: unknown): boolean {\n    if (a === undefined || b === undefined) {\n      return a === b;\n    }\n    if (a === null || b === null) {\n      return a === b;\n    }\n    if (typeof a !== typeof b) {\n      return false;\n    }\n    // Handle Date objects\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n    if (a instanceof Date || b instanceof Date) {\n      return false; // One is Date, other is not\n    }\n    if (typeof a === 'object') {\n      if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) return false;\n        return a.every((val, i) => this.jsonValueEquals(val, b[i]));\n      }\n      if (Array.isArray(a) || Array.isArray(b)) {\n        return false;\n      }\n      const aKeys = Object.keys(a as object);\n      const bKeys = Object.keys(b as object);\n      if (aKeys.length !== bKeys.length) return false;\n      return aKeys.every(key =>\n        this.jsonValueEquals((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key]),\n      );\n    }\n    return a === b;\n  }\n\n  async updateSpan(args: UpdateSpanArgs): Promise<void> {\n    const { traceId, spanId, updates } = args;\n    const traceEntry = this.db.traces.get(traceId);\n\n    if (!traceEntry) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace not found for span update',\n      });\n    }\n\n    const span = traceEntry.spans[spanId];\n    if (!span) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span not found for update',\n      });\n    }\n\n    const updatedSpan: SpanRecord = {\n      ...span,\n      ...updates,\n      updatedAt: new Date(),\n    };\n\n    traceEntry.spans[spanId] = updatedSpan;\n\n    // Update root span reference if this is the root span\n    if (updatedSpan.parentSpanId === null) {\n      traceEntry.rootSpan = updatedSpan;\n    }\n\n    this.recomputeTraceProperties(traceEntry);\n  }\n\n  async batchUpdateSpans(args: BatchUpdateSpansArgs): Promise<void> {\n    for (const record of args.records) {\n      await this.updateSpan(record);\n    }\n  }\n\n  async batchDeleteTraces(args: BatchDeleteTracesArgs): Promise<void> {\n    for (const traceId of args.traceIds) {\n      this.db.traces.delete(traceId);\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '../../../evals/types';\nimport type { StoragePagination } from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class ScoresStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'SCORES',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }>;\n\n  abstract listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<ListScoresResponse>;\n\n  abstract listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse>;\n\n  abstract listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<ListScoresResponse>;\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n}\n","import type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '../../../evals/types';\nimport { calculatePagination, normalizePerPage } from '../../base';\nimport type { StoragePagination } from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { ScoresStorage } from './base';\n\nexport class ScoresInMemory extends ScoresStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.scores.clear();\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.db.scores.get(id) ?? null;\n  }\n\n  async saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }> {\n    const newScore = { id: crypto.randomUUID(), createdAt: new Date(), updatedAt: new Date(), ...score };\n    this.db.scores.set(newScore.id, newScore);\n    return { score: newScore };\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => {\n      let baseFilter = score.scorerId === scorerId;\n\n      if (entityId) {\n        baseFilter = baseFilter && score.entityId === entityId;\n      }\n\n      if (entityType) {\n        baseFilter = baseFilter && score.entityType === entityType;\n      }\n\n      if (source) {\n        baseFilter = baseFilter && score.source === source;\n      }\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => score.runId === runId);\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER); // false  MAX_SAFE_INTEGER\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => {\n      const baseFilter = score.entityId === entityId && score.entityType === entityType;\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(\n      score => score.traceId === traceId && score.spanId === spanId,\n    );\n    scores.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport type { UpdateWorkflowStateOptions, WorkflowRun, WorkflowRuns, StorageListWorkflowRunsInput } from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class WorkflowsStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'WORKFLOWS',\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined>;\n\n  abstract persistWorkflowSnapshot(_: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }): Promise<void>;\n\n  abstract loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null>;\n\n  abstract listWorkflowRuns(args?: StorageListWorkflowRunsInput): Promise<WorkflowRuns>;\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n\n  abstract deleteWorkflowRunById(args: { runId: string; workflowName: string }): Promise<void>;\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport { normalizePerPage } from '../../base';\nimport type {\n  StorageWorkflowRun,\n  WorkflowRun,\n  WorkflowRuns,\n  StorageListWorkflowRunsInput,\n  UpdateWorkflowStateOptions,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { WorkflowsStorage } from './base';\n\nexport class WorkflowsInMemory extends WorkflowsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.workflows.clear();\n  }\n\n  private getWorkflowKey(workflowName: string, runId: string): string {\n    return `${workflowName}-${runId}`;\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    this.logger.debug(`WorkflowsInMemory: updateWorkflowResults called for ${workflowName} ${runId} ${stepId}`, result);\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return {};\n    }\n\n    let snapshot: WorkflowRunState;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.db.workflows.set(key, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot.context[stepId] = result;\n    snapshot.requestContext = { ...snapshot.requestContext, ...requestContext };\n\n    this.db.workflows.set(key, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return JSON.parse(JSON.stringify(snapshot.context));\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return;\n    }\n\n    let snapshot: WorkflowRunState;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.db.workflows.set(key, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot = { ...snapshot, ...opts };\n    this.db.workflows.set(key, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return snapshot;\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n    createdAt,\n    updatedAt,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }): Promise<void> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    const now = new Date();\n    const data: StorageWorkflowRun = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: createdAt ?? now,\n      updatedAt: updatedAt ?? now,\n    };\n\n    this.db.workflows.set(key, data);\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return null;\n    }\n\n    const snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    // Return a deep copy to prevent mutation\n    return snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;\n  }\n\n  async listWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    perPage,\n    page,\n    resourceId,\n    status,\n  }: StorageListWorkflowRunsInput = {}): Promise<WorkflowRuns> {\n    if (page !== undefined && page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    let runs = Array.from(this.db.workflows.values());\n\n    if (workflowName) runs = runs.filter((run: any) => run.workflow_name === workflowName);\n    if (status) {\n      runs = runs.filter((run: any) => {\n        let snapshot: WorkflowRunState | string = run?.snapshot!;\n\n        if (!snapshot) {\n          return false;\n        }\n\n        if (typeof snapshot === 'string') {\n          try {\n            snapshot = JSON.parse(snapshot) as WorkflowRunState;\n          } catch {\n            return false;\n          }\n        } else {\n          snapshot = JSON.parse(JSON.stringify(snapshot)) as WorkflowRunState;\n        }\n\n        return snapshot.status === status;\n      });\n    }\n\n    if (fromDate && toDate) {\n      runs = runs.filter(\n        (run: any) =>\n          new Date(run.createdAt).getTime() >= fromDate.getTime() &&\n          new Date(run.createdAt).getTime() <= toDate.getTime(),\n      );\n    } else if (fromDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() >= fromDate.getTime());\n    } else if (toDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() <= toDate.getTime());\n    }\n    if (resourceId) runs = runs.filter((run: any) => run.resourceId === resourceId);\n\n    const total = runs.length;\n\n    // Sort by createdAt\n    runs.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Apply pagination\n    if (perPage !== undefined && page !== undefined) {\n      // Use MAX_SAFE_INTEGER as default to maintain \"no pagination\" behavior when undefined\n      const normalizedPerPage = normalizePerPage(perPage, Number.MAX_SAFE_INTEGER);\n      const offset = page * normalizedPerPage;\n      const start = offset;\n      const end = start + normalizedPerPage;\n      runs = runs.slice(start, end);\n    }\n\n    // Deserialize snapshot if it's a string\n    const parsedRuns = runs.map((run: any) => ({\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    }));\n\n    return { runs: parsedRuns as WorkflowRun[], total };\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const runs = Array.from(this.db.workflows.values()).filter((r: any) => r.run_id === runId);\n    let run = runs.find((r: any) => r.workflow_name === workflowName);\n\n    if (!run) return null;\n\n    // Return a deep copy to prevent mutation\n    const parsedRun = {\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    };\n\n    return parsedRun as WorkflowRun;\n  }\n\n  async deleteWorkflowRunById({ runId, workflowName }: { runId: string; workflowName: string }): Promise<void> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    this.db.workflows.delete(key);\n  }\n}\n","import { MastraStorage } from './base';\nimport type { StorageDomains } from './base';\nimport { InMemoryAgentsStorage } from './domains/agents/inmemory';\nimport { InMemoryDB } from './domains/inmemory-db';\nimport { InMemoryMemory } from './domains/memory/inmemory';\nimport { ObservabilityInMemory } from './domains/observability/inmemory';\nimport { ScoresInMemory } from './domains/scores/inmemory';\nimport { WorkflowsInMemory } from './domains/workflows/inmemory';\n/**\n * In-memory storage implementation for testing and development.\n *\n * All data is stored in memory and will be lost when the process ends.\n * Access domain-specific storage via `getStore()`:\n *\n * @example\n * ```typescript\n * const storage = new InMemoryStore();\n *\n * // Access memory domain\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n *\n * // Access workflows domain\n * const workflows = await storage.getStore('workflows');\n * await workflows?.persistWorkflowSnapshot({ workflowName, runId, snapshot });\n * ```\n */\nexport class InMemoryStore extends MastraStorage {\n  stores: StorageDomains;\n\n  /**\n   * Internal database layer shared across all domains.\n   * This is an implementation detail - domains interact with this\n   * rather than managing their own data structures.\n   */\n  #db: InMemoryDB;\n\n  constructor({ id = 'in-memory' }: { id?: string } = {}) {\n    super({ id, name: 'InMemoryStorage' });\n    // InMemoryStore doesn't need async initialization\n    this.hasInitialized = Promise.resolve(true);\n\n    // Create internal db layer - shared across all domains\n    this.#db = new InMemoryDB();\n\n    // Create all domain instances with the shared db\n    this.stores = {\n      memory: new InMemoryMemory({ db: this.#db }),\n      workflows: new WorkflowsInMemory({ db: this.#db }),\n      scores: new ScoresInMemory({ db: this.#db }),\n      observability: new ObservabilityInMemory({ db: this.#db }),\n      agents: new InMemoryAgentsStorage({ db: this.#db }),\n    };\n  }\n\n  /**\n   * Clears all data from the in-memory database.\n   * Useful for testing.\n   * @deprecated Use dangerouslyClearAll() on individual domains instead.\n   */\n  clear(): void {\n    this.#db.clear();\n  }\n}\n\nexport const MockStore = InMemoryStore;\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn, CreateIndexOptions, IndexInfo, StorageIndexStats } from '../../types';\n\nexport abstract class StoreOperations extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OPERATIONS',\n    });\n  }\n\n  abstract hasColumn(table: string, column: string): Promise<boolean>;\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * Optional methods for database index management.\n   * Storage adapters can override these to provide index management capabilities.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(_options: CreateIndexOptions): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(_indexName: string): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(_tableName?: string): Promise<IndexInfo[]> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(_indexName: string): Promise<StorageIndexStats> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Returns definitions for automatic performance indexes\n   * Storage adapters can override this to define indexes that should be created during initialization\n   * @returns Array of index definitions to create automatically\n   */\n  protected getAutomaticIndexDefinitions(): CreateIndexOptions[] {\n    return [];\n  }\n}\n","import { TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn } from '../../types';\nimport { StoreOperations } from './base';\n\nexport class StoreOperationsInMemory extends StoreOperations {\n  data: Record<TABLE_NAMES, Map<string, Record<string, any>>>;\n\n  constructor() {\n    super();\n    this.data = {\n      mastra_workflow_snapshot: new Map(),\n      mastra_messages: new Map(),\n      mastra_threads: new Map(),\n      mastra_traces: new Map(),\n      mastra_resources: new Map(),\n      mastra_scorers: new Map(),\n      mastra_ai_spans: new Map(),\n      mastra_agents: new Map(),\n    };\n  }\n\n  getDatabase() {\n    return this.data;\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    const table = this.data[tableName];\n    let key = record.id;\n    if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n      key = record.workflow_name ? `${record.workflow_name}-${record.run_id}` : record.run_id;\n      record.id = key;\n    } else if (!record.id) {\n      key = `auto-${Date.now()}-${Math.random()}`;\n      record.id = key;\n    }\n    table.set(key, record);\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    const table = this.data[tableName];\n    for (const record of records) {\n      let key = record.id;\n      if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n        key = record.run_id;\n        record.id = key;\n      } else if (!record.id) {\n        key = `auto-${Date.now()}-${Math.random()}`;\n        record.id = key;\n      }\n      table.set(key, record);\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);\n\n    const table = this.data[tableName];\n\n    const records = Array.from(table.values());\n\n    return records.filter(record => Object.keys(keys).every(key => record[key] === keys[key]))?.[0] as R | null;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);\n\n    this.data[tableName] = new Map();\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: clearTable called for ${tableName}`);\n\n    this.data[tableName].clear();\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: dropTable called for ${tableName}`);\n    this.data[tableName].clear();\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);\n    return true;\n  }\n}\n"]}