{"version":3,"sources":["../src/voice/voice.ts","../src/voice/aisdk/speech.ts","../src/voice/aisdk/transcription.ts","../src/voice/composite-voice.ts","../src/voice/default-voice.ts"],"names":["MastraBase","generateSpeech","stream","PassThrough","transcribe","MastraError"],"mappings":"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","file":"chunk-KHO4KFXW.cjs","sourcesContent":["import type { ToolsInput } from '../agent';\nimport { MastraBase } from '../base';\n\nexport type VoiceEventType = 'speaking' | 'writing' | 'error' | string;\n\nexport interface VoiceEventMap {\n  speaker: NodeJS.ReadableStream;\n  speaking: { audio?: string };\n  writing: { text: string; role: 'assistant' | 'user' };\n  error: { message: string; code?: string; details?: unknown };\n  [key: string]: unknown;\n}\n\ninterface BuiltInModelConfig {\n  name: string;\n  apiKey?: string;\n}\n\nexport interface VoiceConfig<T = unknown> {\n  listeningModel?: BuiltInModelConfig;\n  speechModel?: BuiltInModelConfig;\n  speaker?: string;\n  name?: string;\n  realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: T;\n  };\n}\n\nexport abstract class MastraVoice<\n  TOptions = unknown,\n  TSpeakOptions = unknown,\n  TListenOptions = unknown,\n  TTools extends ToolsInput = ToolsInput,\n  TEventArgs extends VoiceEventMap = VoiceEventMap,\n  TSpeakerMetadata = unknown,\n> extends MastraBase {\n  protected listeningModel?: BuiltInModelConfig;\n  protected speechModel?: BuiltInModelConfig;\n  protected speaker?: string;\n  protected realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: TOptions;\n  };\n\n  constructor({ listeningModel, speechModel, speaker, realtimeConfig, name }: VoiceConfig<TOptions> = {}) {\n    super({\n      component: 'VOICE',\n      name,\n    });\n    this.listeningModel = listeningModel;\n    this.speechModel = speechModel;\n    this.speaker = speaker;\n    this.realtimeConfig = realtimeConfig;\n  }\n\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream\n   */\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in chat mode\n   */\n  abstract speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n    } & TSpeakOptions,\n  ): Promise<NodeJS.ReadableStream | void>;\n\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text or text stream\n   */\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text, text stream, or void if in chat mode\n   */\n  abstract listen(\n    audioStream: NodeJS.ReadableStream | unknown, // Allow other audio input types for OpenAI realtime API\n    options?: TListenOptions,\n  ): Promise<string | NodeJS.ReadableStream | void>;\n\n  updateConfig(_options: Record<string, unknown>): void {\n    this.logger.warn('updateConfig not implemented by this voice provider');\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(_options?: Record<string, unknown>): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('connect not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to relay\n   */\n  send(_audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('relay not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(_options?: Record<string, unknown>): Promise<void> {\n    this.logger.warn('answer not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(_instructions?: string): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(_tools: TTools): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('close not implemented by this voice provider');\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('on not implemented by this voice provider');\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('off not implemented by this voice provider');\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getSpeakers(): Promise<\n    Array<\n      {\n        voiceId: string;\n      } & TSpeakerMetadata\n    >\n  > {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getSpeakers not implemented by this voice provider');\n    return Promise.resolve([]);\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getListener(): Promise<{ enabled: boolean }> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getListener not implemented by this voice provider');\n    return Promise.resolve({ enabled: false });\n  }\n}\n","import { PassThrough } from 'node:stream';\nimport { experimental_generateSpeech } from '@internal/ai-sdk-v5';\nimport type { SpeechModel } from '@internal/ai-sdk-v5';\nimport { MastraVoice } from '../voice';\n\nexport class AISDKSpeech extends MastraVoice {\n  private model: SpeechModel;\n  private defaultVoice?: string;\n\n  constructor(model: SpeechModel, options?: { voice?: string }) {\n    super({ name: 'ai-sdk-speech' });\n    this.model = model;\n    this.defaultVoice = options?.voice;\n  }\n\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n      language?: string;\n      providerOptions?: Record<string, any>;\n      abortSignal?: AbortSignal;\n      headers?: Record<string, string>;\n    },\n  ): Promise<NodeJS.ReadableStream> {\n    // Convert stream to text if needed\n    const text = typeof input === 'string' ? input : await this.streamToText(input);\n\n    const result = await experimental_generateSpeech({\n      model: this.model,\n      text,\n      voice: options?.speaker || this.defaultVoice, // Map speaker to AI SDK's voice parameter\n      language: options?.language,\n      providerOptions: options?.providerOptions,\n      abortSignal: options?.abortSignal,\n      headers: options?.headers,\n    });\n\n    // Convert Uint8Array to Node stream\n    const stream = new PassThrough();\n    stream.end(Buffer.from(result.audio.uint8Array));\n    return stream;\n  }\n\n  async listen(): Promise<string> {\n    throw new Error('AI SDK speech models do not support transcription. Use AISDKTranscription instead.');\n  }\n\n  async getSpeakers() {\n    // Return empty array - voice must be specified in speak() options\n    return [];\n  }\n\n  async getListener() {\n    return { enabled: false };\n  }\n\n  private async streamToText(stream: NodeJS.ReadableStream): Promise<string> {\n    const chunks: Buffer[] = [];\n    for await (const chunk of stream) {\n      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n    }\n    return Buffer.concat(chunks).toString('utf-8');\n  }\n}\n","import { experimental_transcribe } from '@internal/ai-sdk-v5';\nimport type { TranscriptionModel } from '@internal/ai-sdk-v5';\nimport { MastraVoice } from '../voice';\n\nexport class AISDKTranscription extends MastraVoice {\n  private model: TranscriptionModel;\n\n  constructor(model: TranscriptionModel) {\n    super({ name: 'ai-sdk-transcription' });\n    this.model = model;\n  }\n\n  async speak(): Promise<NodeJS.ReadableStream> {\n    throw new Error('AI SDK transcription models do not support text-to-speech. Use AISDKSpeech instead.');\n  }\n\n  async getSpeakers() {\n    return [];\n  }\n\n  async getListener() {\n    return { enabled: true };\n  }\n\n  /**\n   * Transcribe audio to text\n   * For enhanced metadata (segments, language, duration), use AI SDK's transcribe() directly\n   */\n  async listen(\n    audioStream: NodeJS.ReadableStream,\n    options?: {\n      providerOptions?: Record<string, any>;\n      abortSignal?: AbortSignal;\n      headers?: Record<string, string>;\n    },\n  ): Promise<string> {\n    const audioBuffer = await this.convertToBuffer(audioStream);\n\n    const result = await experimental_transcribe({\n      model: this.model,\n      audio: audioBuffer,\n      providerOptions: options?.providerOptions,\n      abortSignal: options?.abortSignal,\n      headers: options?.headers,\n    });\n\n    return result.text;\n  }\n\n  private async convertToBuffer(audio: NodeJS.ReadableStream | Buffer | Uint8Array | string): Promise<Buffer> {\n    if (Buffer.isBuffer(audio)) return audio;\n    if (audio instanceof Uint8Array) return Buffer.from(audio);\n    if (typeof audio === 'string') return Buffer.from(audio, 'base64');\n\n    const chunks: Buffer[] = [];\n    for await (const chunk of audio) {\n      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n    }\n    return Buffer.concat(chunks);\n  }\n}\n","import type { TranscriptionModel, SpeechModel } from '@internal/ai-sdk-v5';\n\nimport type { ToolsInput } from '../agent';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\n\nimport { AISDKSpeech } from './aisdk/speech';\nimport { AISDKTranscription } from './aisdk/transcription';\nimport { MastraVoice } from './voice';\nimport type { VoiceEventType, VoiceEventMap } from '.';\n\nconst supportedSpecificationVersions = ['v2', 'v3'];\n\n// Helper to check if something is an AI SDK model\nfunction isTranscriptionModel(obj: any): obj is TranscriptionModel {\n  return (\n    obj && typeof obj === 'object' && obj.modelId && supportedSpecificationVersions.includes(obj.specificationVersion)\n  );\n}\n\nfunction isSpeechModel(obj: any): obj is SpeechModel {\n  return (\n    obj && typeof obj === 'object' && obj.modelId && supportedSpecificationVersions.includes(obj.specificationVersion)\n  );\n}\n\nexport class CompositeVoice extends MastraVoice<unknown, unknown, unknown, ToolsInput, VoiceEventMap> {\n  protected speakProvider?: MastraVoice;\n  protected listenProvider?: MastraVoice;\n  protected realtimeProvider?: MastraVoice;\n\n  constructor({\n    input,\n    output,\n    realtime,\n  }: {\n    input?: MastraVoice | TranscriptionModel;\n    output?: MastraVoice | SpeechModel;\n    realtime?: MastraVoice;\n  }) {\n    super();\n\n    // Auto-wrap AI SDK models\n    if (input) {\n      this.listenProvider = isTranscriptionModel(input) ? new AISDKTranscription(input) : input;\n    }\n\n    if (output) {\n      this.speakProvider = isSpeechModel(output) ? new AISDKSpeech(output) : output;\n    }\n\n    this.realtimeProvider = realtime;\n  }\n\n  /**\n   * Convert text to speech using the configured provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in realtime mode\n   */\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: { speaker?: string } & any,\n  ): Promise<NodeJS.ReadableStream | void> {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.speak(input, options);\n    } else if (this.speakProvider) {\n      return this.speakProvider.speak(input, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAK_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(audioStream: NodeJS.ReadableStream, options?: any) {\n    if (this.realtimeProvider) {\n      return await this.realtimeProvider.listen(audioStream, options);\n    } else if (this.listenProvider) {\n      return await this.listenProvider.listen(audioStream, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTEN_PROVIDER',\n      text: 'No listen provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getSpeakers();\n    } else if (this.speakProvider) {\n      return this.speakProvider.getSpeakers();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAKERS_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getListener();\n    } else if (this.listenProvider) {\n      return this.listenProvider.getListener();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTENER_PROVIDER',\n      text: 'No listener provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  updateConfig(options: Record<string, unknown>): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.updateConfig(options);\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CONNECT',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.connect(options);\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to send\n   */\n  send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_SEND',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.send(audioData);\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ANSWER',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.answer(options);\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(instructions: string): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addInstructions(instructions);\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(tools: ToolsInput): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addTools(tools);\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CLOSE',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.close();\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ON',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.on(event, callback);\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_OFF',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.off(event, callback);\n  }\n}\n","import { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport { MastraVoice } from '.';\n\nexport class DefaultVoice extends MastraVoice {\n  constructor() {\n    super();\n  }\n\n  async speak(_input: string | NodeJS.ReadableStream): Promise<NodeJS.ReadableStream> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAK_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(_input: string | NodeJS.ReadableStream): Promise<string> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTEN_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers(): Promise<{ voiceId: string }[]> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAKERS_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener(): Promise<{ enabled: boolean }> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTENER_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n}\n"]}