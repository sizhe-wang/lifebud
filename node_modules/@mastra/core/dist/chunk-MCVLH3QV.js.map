{"version":3,"sources":["../src/tools/tool-builder/builder.ts","../src/utils.ts"],"names":["schema","args","resumeData","error","logger","z","delay"],"mappings":"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","file":"chunk-MCVLH3QV.js","sourcesContent":["import type { ProviderDefinedTool, ToolExecutionOptions } from '@internal/external-types';\nimport {\n  OpenAIReasoningSchemaCompatLayer,\n  OpenAISchemaCompatLayer,\n  GoogleSchemaCompatLayer,\n  AnthropicSchemaCompatLayer,\n  DeepSeekSchemaCompatLayer,\n  MetaSchemaCompatLayer,\n  applyCompatLayer,\n  convertZodSchemaToAISDKSchema,\n} from '@mastra/schema-compat';\nimport { zodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport { z } from 'zod';\nimport { MastraBase } from '../../base';\nimport { ErrorCategory, MastraError, ErrorDomain } from '../../error';\nimport { SpanType, wrapMastra, executeWithContext, EntityType } from '../../observability';\nimport { RequestContext } from '../../request-context';\nimport { isVercelTool } from '../../tools/toolchecks';\nimport type { ToolOptions } from '../../utils';\nimport { isZodObject } from '../../utils/zod-utils';\nimport type { SuspendOptions } from '../../workflows';\nimport { ToolStream } from '../stream';\nimport type { CoreTool, MastraToolInvocationOptions, ToolAction, VercelTool, VercelToolV5 } from '../types';\nimport { validateToolInput, validateToolOutput, validateToolSuspendData } from '../validation';\n\n/**\n * Types that can be converted to Mastra tools.\n * Includes provider-defined tools from external packages via ProviderDefinedTool.\n */\nexport type ToolToConvert = VercelTool | ToolAction<any, any, any> | VercelToolV5 | ProviderDefinedTool;\nexport type LogType = 'tool' | 'toolset' | 'client-tool';\n\ninterface LogOptions {\n  agentName?: string;\n  toolName: string;\n  type?: 'tool' | 'toolset' | 'client-tool';\n}\n\ninterface LogMessageOptions {\n  start: string;\n  error: string;\n}\n\nexport class CoreToolBuilder extends MastraBase {\n  private originalTool: ToolToConvert;\n  private options: ToolOptions;\n  private logType?: LogType;\n\n  constructor(input: {\n    originalTool: ToolToConvert;\n    options: ToolOptions;\n    logType?: LogType;\n    autoResumeSuspendedTools?: boolean;\n  }) {\n    super({ name: 'CoreToolBuilder' });\n    this.originalTool = input.originalTool;\n    this.options = input.options;\n    this.logType = input.logType;\n    if (!isVercelTool(this.originalTool) && input.autoResumeSuspendedTools) {\n      let schema = this.originalTool.inputSchema;\n      if (typeof schema === 'function') {\n        schema = schema();\n      }\n      if (!schema) {\n        schema = z.object({});\n      }\n      if (isZodObject(schema)) {\n        this.originalTool.inputSchema = schema.extend({\n          suspendedToolRunId: z.string().describe('The runId of the suspended tool').optional().default(''),\n          resumeData: z\n            .any()\n            .describe('The resumeData object created from the resumeSchema of suspended tool')\n            .optional(),\n        });\n      }\n    }\n  }\n\n  // Helper to get parameters based on tool type\n  private getParameters = () => {\n    if (isVercelTool(this.originalTool)) {\n      // Handle both 'parameters' (v4) and 'inputSchema' (v5) properties\n      // Also handle case where the schema is a function that returns a schema\n      let schema =\n        this.originalTool.parameters ??\n        ('inputSchema' in this.originalTool ? (this.originalTool as any).inputSchema : undefined) ??\n        z.object({});\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof schema === 'function') {\n        schema = schema();\n      }\n\n      return schema;\n    }\n\n    // For Mastra tools, inputSchema might also be a function\n    let schema = this.originalTool.inputSchema;\n\n    // If schema is a function, call it to get the actual schema\n    if (typeof schema === 'function') {\n      schema = schema();\n    }\n\n    return schema;\n  };\n\n  private getOutputSchema = () => {\n    if ('outputSchema' in this.originalTool) {\n      let schema = this.originalTool.outputSchema;\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof schema === 'function') {\n        schema = schema();\n      }\n\n      return schema;\n    }\n    return null;\n  };\n\n  private getResumeSchema = () => {\n    if ('resumeSchema' in this.originalTool) {\n      let schema = this.originalTool.resumeSchema;\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof schema === 'function') {\n        schema = schema();\n      }\n\n      return schema;\n    }\n    return null;\n  };\n\n  private getSuspendSchema = () => {\n    if ('suspendSchema' in this.originalTool) {\n      let schema = this.originalTool.suspendSchema;\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof schema === 'function') {\n        schema = schema();\n      }\n\n      return schema;\n    }\n    return null;\n  };\n\n  // For provider-defined tools, we need to include all required properties\n  // AI SDK v5 uses type: 'provider-defined', AI SDK v6 uses type: 'provider'\n  private buildProviderTool(tool: ToolToConvert): (CoreTool & { id: `${string}.${string}` }) | undefined {\n    if (\n      'type' in tool &&\n      (tool.type === 'provider-defined' || tool.type === 'provider') &&\n      'id' in tool &&\n      typeof tool.id === 'string' &&\n      tool.id.includes('.')\n    ) {\n      // Get schema directly from provider-defined tool (v4 uses parameters, v5 uses inputSchema)\n      let parameters: unknown =\n        'parameters' in tool ? tool.parameters : 'inputSchema' in tool ? (tool as any).inputSchema : undefined;\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof parameters === 'function') {\n        parameters = parameters();\n      }\n\n      // Get output schema directly from provider-defined tool\n      let outputSchema: unknown = 'outputSchema' in tool ? (tool as any).outputSchema : undefined;\n\n      // If schema is a function, call it to get the actual schema\n      if (typeof outputSchema === 'function') {\n        outputSchema = outputSchema();\n      }\n\n      // Convert parameters to AI SDK Schema format\n      let processedParameters;\n      if (parameters !== undefined && parameters !== null) {\n        if (typeof parameters === 'object' && 'jsonSchema' in parameters) {\n          // Already in AI SDK Schema format\n          processedParameters = parameters;\n        } else {\n          // Convert Zod schema to AI SDK Schema\n          processedParameters = convertZodSchemaToAISDKSchema(parameters as z.ZodType);\n        }\n      }\n\n      // Convert output schema to AI SDK Schema format if present\n      let processedOutputSchema;\n      if (outputSchema !== undefined && outputSchema !== null) {\n        if (typeof outputSchema === 'object' && 'jsonSchema' in outputSchema) {\n          // Already in AI SDK Schema format\n          processedOutputSchema = outputSchema;\n        } else {\n          // Convert Zod schema to AI SDK Schema\n          processedOutputSchema = convertZodSchemaToAISDKSchema(outputSchema as z.ZodType);\n        }\n      }\n\n      return {\n        ...(processedOutputSchema ? { outputSchema: processedOutputSchema } : {}),\n        type: 'provider-defined' as const,\n        id: tool.id as `${string}.${string}`,\n        args: ('args' in this.originalTool ? this.originalTool.args : {}) as Record<string, unknown>,\n        description: tool.description,\n        parameters: processedParameters,\n        execute: this.originalTool.execute\n          ? this.createExecute(\n              this.originalTool,\n              { ...this.options, description: this.originalTool.description },\n              this.logType,\n            )\n          : undefined,\n      } as unknown as (CoreTool & { id: `${string}.${string}` }) | undefined;\n    }\n\n    return undefined;\n  }\n\n  private createLogMessageOptions({ agentName, toolName, type }: LogOptions): LogMessageOptions {\n    // If no agent name, use default format\n    if (!agentName) {\n      return {\n        start: `Executing tool ${toolName}`,\n        error: `Failed tool execution`,\n      };\n    }\n\n    const prefix = `[Agent:${agentName}]`;\n    const toolType = type === 'toolset' ? 'toolset' : 'tool';\n\n    return {\n      start: `${prefix} - Executing ${toolType} ${toolName}`,\n      error: `${prefix} - Failed ${toolType} execution`,\n    };\n  }\n\n  private createExecute(\n    tool: ToolToConvert,\n    options: ToolOptions,\n    logType?: 'tool' | 'toolset' | 'client-tool',\n    processedSchema?: z.ZodTypeAny,\n  ) {\n    // dont't add memory or mastra to logging\n    const { logger, mastra: _mastra, memory: _memory, requestContext, model, ...rest } = options;\n    const logModelObject = {\n      modelId: model?.modelId,\n      provider: model?.provider,\n      specificationVersion: model?.specificationVersion,\n    };\n\n    const { start, error } = this.createLogMessageOptions({\n      agentName: options.agentName,\n      toolName: options.name,\n      type: logType,\n    });\n\n    const execFunction = async (args: unknown, execOptions: MastraToolInvocationOptions) => {\n      // Prefer execution-time tracingContext (passed at runtime for VNext methods)\n      // Fall back to build-time context for Legacy methods (AI SDK v4 doesn't support passing custom options)\n      const tracingContext = execOptions.tracingContext || options.tracingContext;\n\n      // Create tool span if we have a current span available\n      const toolSpan = tracingContext?.currentSpan?.createChildSpan({\n        type: SpanType.TOOL_CALL,\n        name: `tool: '${options.name}'`,\n        input: args,\n        entityType: EntityType.TOOL,\n        entityName: options.name,\n        attributes: {\n          toolDescription: options.description,\n          toolType: logType || 'tool',\n        },\n        tracingPolicy: options.tracingPolicy,\n      });\n\n      try {\n        let result;\n        let suspendData = null;\n\n        if (isVercelTool(tool)) {\n          // Handle Vercel tools (AI SDK tools)\n          result = await executeWithContext({\n            span: toolSpan,\n            fn: async () => tool?.execute?.(args, execOptions as ToolExecutionOptions),\n          });\n        } else {\n          // Handle Mastra tools - wrap mastra instance with tracing context for context propagation\n\n          /**\n           * MASTRA INSTANCE TYPES IN TOOL EXECUTION:\n           *\n           * Full Mastra & MastraPrimitives (has getAgent, getWorkflow, etc.):\n           * - Auto-generated workflow tools from agent.listWorkflows()\n           * - These get this.#mastra directly and can be wrapped\n           *\n           * MastraPrimitives only (limited interface):\n           * - Memory tools (from memory.listTools())\n           * - Assigned tools (agent.tools)\n           * - Toolset tools (from toolsets)\n           * - Client tools (passed as tools in generate/stream options)\n           * - These get mastraProxy and have limited functionality\n           *\n           * TODO: Consider providing full Mastra instance to more tool types for enhanced functionality\n           */\n          // Wrap mastra with tracing context - wrapMastra will handle whether it's a full instance or primitives\n          const wrappedMastra = options.mastra ? wrapMastra(options.mastra, { currentSpan: toolSpan }) : options.mastra;\n\n          const resumeSchema = this.getResumeSchema();\n          // Pass raw args as first parameter, context as second\n          // Properly structure context based on execution source\n          const baseContext = {\n            threadId: options.threadId,\n            resourceId: options.resourceId,\n            mastra: wrappedMastra,\n            memory: options.memory,\n            runId: options.runId,\n            requestContext: options.requestContext ?? new RequestContext(),\n            writer: new ToolStream(\n              {\n                prefix: 'tool',\n                callId: execOptions.toolCallId,\n                name: options.name,\n                runId: options.runId!,\n              },\n              options.outputWriter || execOptions.outputWriter,\n            ),\n            tracingContext: { currentSpan: toolSpan },\n            abortSignal: execOptions.abortSignal,\n            suspend: (args: any, suspendOptions?: SuspendOptions) => {\n              suspendData = args;\n              const newSuspendOptions = {\n                ...(suspendOptions ?? {}),\n                resumeSchema:\n                  suspendOptions?.resumeSchema ??\n                  (resumeSchema ? JSON.stringify(zodToJsonSchema(resumeSchema)) : undefined),\n              };\n              return execOptions.suspend?.(args, newSuspendOptions);\n            },\n            resumeData: execOptions.resumeData,\n          };\n\n          // Check if this is agent execution\n          // Agent execution takes precedence over workflow execution because agents may\n          // use workflows internally for their agentic loop\n          // Note: AI SDK v4 doesn't pass toolCallId/messages, so we also check for agentName and threadId\n          const isAgentExecution =\n            (execOptions.toolCallId && execOptions.messages) ||\n            (options.agentName && options.threadId && !options.workflowId);\n\n          // Check if this is workflow execution (has workflow properties in options)\n          // Only consider it workflow execution if it's NOT agent execution\n          const isWorkflowExecution = !isAgentExecution && (options.workflow || options.workflowId);\n\n          let toolContext;\n          if (isAgentExecution) {\n            // Nest agent-specific properties under 'agent' key\n            // Do NOT include workflow context even if workflow properties exist\n            // (agents use workflows internally but tools should see agent context)\n            const { suspend, resumeData, threadId, resourceId, ...restBaseContext } = baseContext;\n            toolContext = {\n              ...restBaseContext,\n              agent: {\n                toolCallId: execOptions.toolCallId || '',\n                messages: execOptions.messages || [],\n                suspend,\n                resumeData,\n                threadId,\n                resourceId,\n                outputWriter: execOptions.outputWriter,\n              },\n            };\n          } else if (isWorkflowExecution) {\n            // Nest workflow-specific properties under 'workflow' key\n            const { suspend, resumeData, ...restBaseContext } = baseContext;\n            toolContext = {\n              ...restBaseContext,\n              workflow: options.workflow || {\n                runId: options.runId,\n                workflowId: options.workflowId,\n                state: options.state,\n                setState: options.setState,\n                suspend,\n                resumeData,\n              },\n            };\n          } else if (execOptions.mcp) {\n            // MCP execution context\n            toolContext = {\n              ...baseContext,\n              mcp: execOptions.mcp,\n            };\n          } else {\n            // Direct execution or unknown context\n            toolContext = baseContext;\n          }\n\n          const resumeData = execOptions.resumeData;\n\n          if (resumeData) {\n            const resumeValidation = validateToolInput(resumeSchema, resumeData, options.name);\n            if (resumeValidation.error) {\n              logger?.warn(resumeValidation.error.message);\n              toolSpan?.end({ output: resumeValidation.error, attributes: { success: false } });\n              return resumeValidation.error as any;\n            }\n          }\n\n          result = await executeWithContext({ span: toolSpan, fn: async () => tool?.execute?.(args, toolContext) });\n        }\n\n        if (suspendData) {\n          const suspendSchema = this.getSuspendSchema();\n          const suspendValidation = validateToolSuspendData(suspendSchema, suspendData, options.name);\n          if (suspendValidation.error) {\n            logger?.warn(suspendValidation.error.message);\n            toolSpan?.end({ output: suspendValidation.error, attributes: { success: false } });\n            return suspendValidation.error as any;\n          }\n        }\n\n        // Skip validation if suspend was called without a result\n        const shouldSkipValidation = typeof result === 'undefined' && !!suspendData;\n        if (shouldSkipValidation) {\n          toolSpan?.end({ output: result, attributes: { success: true } });\n          return result;\n        }\n\n        // Validate output for Vercel/AI SDK tools which don't have built-in validation\n        // Mastra tools handle their own validation in Tool.execute() which properly\n        // applies Zod transforms (e.g., .transform(), .pipe()) to the output\n        if (isVercelTool(tool)) {\n          const outputSchema = this.getOutputSchema();\n          const outputValidation = validateToolOutput(outputSchema, result, options.name, false);\n          if (outputValidation.error) {\n            logger?.warn(outputValidation.error.message);\n            toolSpan?.end({ output: outputValidation.error, attributes: { success: false } });\n            return outputValidation.error;\n          }\n          result = outputValidation.data;\n        }\n\n        // Return result (validated for Vercel tools, already validated for Mastra tools)\n        toolSpan?.end({ output: result, attributes: { success: true } });\n        return result;\n      } catch (error) {\n        toolSpan?.error({ error: error as Error, attributes: { success: false } });\n        throw error;\n      }\n    };\n\n    return async (args: unknown, execOptions?: MastraToolInvocationOptions) => {\n      let logger = options.logger || this.logger;\n      try {\n        logger.debug(start, { ...rest, model: logModelObject, args });\n\n        // Validate input parameters if schema exists\n        // Use the processed schema for validation if available, otherwise fall back to original\n        const parameters = processedSchema || this.getParameters();\n        const { data, error } = validateToolInput(parameters, args, options.name);\n        if (error) {\n          logger.warn(error.message);\n          return error;\n        }\n        // Use validated/transformed data\n        args = data;\n\n        // there is a small delay in stream output so we add an immediate to ensure the stream is ready\n        return await new Promise((resolve, reject) => {\n          setImmediate(async () => {\n            try {\n              const result = await execFunction(args, execOptions!);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n      } catch (err) {\n        const mastraError = new MastraError(\n          {\n            id: 'TOOL_EXECUTION_FAILED',\n            domain: ErrorDomain.TOOL,\n            category: ErrorCategory.USER,\n            details: {\n              errorMessage: String(error),\n              argsJson: JSON.stringify(args),\n              model: model?.modelId ?? '',\n            },\n          },\n          err,\n        );\n        logger.trackException(mastraError);\n        logger.error(error, { ...rest, model: logModelObject, error: mastraError, args });\n        return mastraError;\n      }\n    };\n  }\n\n  buildV5() {\n    const builtTool = this.build();\n\n    if (!builtTool.parameters) {\n      throw new Error('Tool parameters are required');\n    }\n\n    const base = {\n      ...builtTool,\n      inputSchema: builtTool.parameters,\n      onInputStart: 'onInputStart' in this.originalTool ? this.originalTool.onInputStart : undefined,\n      onInputDelta: 'onInputDelta' in this.originalTool ? this.originalTool.onInputDelta : undefined,\n      onInputAvailable: 'onInputAvailable' in this.originalTool ? this.originalTool.onInputAvailable : undefined,\n      onOutput: 'onOutput' in this.originalTool ? this.originalTool.onOutput : undefined,\n    };\n\n    // For provider-defined tools, exclude execute and add name as per v5 spec\n    if (builtTool.type === 'provider-defined') {\n      const { execute, parameters, ...rest } = base;\n      const name = builtTool.id.split('.')[1] || builtTool.id;\n      return {\n        ...rest,\n        type: builtTool.type,\n        id: builtTool.id,\n        name,\n        args: builtTool.args,\n      } as VercelToolV5;\n    }\n\n    return base as VercelToolV5;\n  }\n\n  build(): CoreTool {\n    const providerTool = this.buildProviderTool(this.originalTool);\n    if (providerTool) {\n      return providerTool;\n    }\n\n    const model = this.options.model;\n\n    const schemaCompatLayers = [];\n\n    if (model) {\n      // Respect the model's own capability flag; do not disable it based solely on specificationVersion.\n      const supportsStructuredOutputs =\n        'supportsStructuredOutputs' in model ? (model.supportsStructuredOutputs ?? false) : false;\n\n      const modelInfo = {\n        modelId: model.modelId,\n        supportsStructuredOutputs,\n        provider: model.provider,\n      };\n\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(modelInfo),\n        new OpenAISchemaCompatLayer(modelInfo),\n        new GoogleSchemaCompatLayer(modelInfo),\n        new AnthropicSchemaCompatLayer(modelInfo),\n        new DeepSeekSchemaCompatLayer(modelInfo),\n        new MetaSchemaCompatLayer(modelInfo),\n      );\n    }\n\n    // Apply schema compatibility to get both the transformed Zod schema (for validation)\n    // and the AI SDK Schema (for the LLM)\n    let processedZodSchema: z.ZodTypeAny | undefined;\n    let processedSchema;\n\n    const originalSchema = this.getParameters();\n\n    // Find the first applicable compatibility layer\n    const applicableLayer = schemaCompatLayers.find(layer => layer.shouldApply());\n\n    if (applicableLayer && originalSchema) {\n      // Get the transformed Zod schema (with constraints removed/modified)\n      processedZodSchema = applicableLayer.processZodType(originalSchema);\n      // Convert to AI SDK Schema for the LLM\n      processedSchema = applyCompatLayer({\n        schema: originalSchema,\n        compatLayers: schemaCompatLayers,\n        mode: 'aiSdkSchema',\n      });\n    } else if (originalSchema) {\n      // No compatibility layer applies, use original schema\n      processedZodSchema = originalSchema;\n      processedSchema = applyCompatLayer({\n        schema: originalSchema,\n        compatLayers: schemaCompatLayers,\n        mode: 'aiSdkSchema',\n      });\n    } else {\n      // No schema to process, set to undefined\n      processedZodSchema = undefined;\n      processedSchema = undefined;\n    }\n\n    let processedOutputSchema;\n\n    if (this.getOutputSchema()) {\n      // Don't add any compat layers to outputSchema since it's never sent to the LLM\n      processedOutputSchema = applyCompatLayer({\n        schema: this.getOutputSchema(),\n        compatLayers: [],\n        mode: 'aiSdkSchema',\n      });\n    }\n\n    // Map AI SDK's needsApproval to our requireApproval\n    // needsApproval can be boolean or a function that takes input and returns boolean\n    let requireApproval = this.options.requireApproval;\n    let needsApprovalFn: ((input: any) => boolean | Promise<boolean>) | undefined;\n\n    if (isVercelTool(this.originalTool) && 'needsApproval' in this.originalTool) {\n      const needsApproval = (this.originalTool as any).needsApproval;\n      if (typeof needsApproval === 'boolean') {\n        requireApproval = needsApproval;\n      } else if (typeof needsApproval === 'function') {\n        // Store the function to evaluate it per-call\n        needsApprovalFn = needsApproval;\n        // Set requireApproval to true so the tool-call-step knows to check the function\n        requireApproval = true;\n      }\n    }\n\n    const definition = {\n      type: 'function' as const,\n      description: this.originalTool.description,\n      requireApproval,\n      needsApprovalFn,\n      hasSuspendSchema: !!this.getSuspendSchema(),\n      execute: this.originalTool.execute\n        ? this.createExecute(\n            this.originalTool,\n            { ...this.options, description: this.originalTool.description },\n            this.logType,\n            processedZodSchema, // Pass the processed Zod schema for validation\n          )\n        : undefined,\n    };\n\n    return {\n      ...definition,\n      id: 'id' in this.originalTool ? this.originalTool.id : undefined,\n      parameters: processedSchema ?? z.object({}),\n      outputSchema: processedOutputSchema,\n      providerOptions: 'providerOptions' in this.originalTool ? this.originalTool.providerOptions : undefined,\n      mcp: 'mcp' in this.originalTool ? this.originalTool.mcp : undefined,\n    } as unknown as CoreTool;\n  }\n}\n","import { createHash } from 'node:crypto';\nimport type { CoreMessage } from '@internal/ai-sdk-v4';\nimport { jsonSchemaToZod } from '@mastra/schema-compat/json-to-zod';\nimport { z } from 'zod';\nimport type { MastraPrimitives } from './action';\nimport type { ToolsInput } from './agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from './error';\nimport type { MastraLanguageModel, MastraLegacyLanguageModel } from './llm/model/shared.types';\nimport type { IMastraLogger } from './logger';\nimport type { Mastra } from './mastra';\nimport type { AiMessageType, MastraMemory } from './memory';\nimport type { TracingContext, TracingPolicy } from './observability';\nimport type { RequestContext } from './request-context';\nimport type { CoreTool, VercelTool, VercelToolV5 } from './tools';\nimport { Tool } from './tools/tool';\nimport { CoreToolBuilder } from './tools/tool-builder/builder';\nimport type { ToolToConvert } from './tools/tool-builder/builder';\nimport { isVercelTool } from './tools/toolchecks';\nimport type { OutputWriter } from './workflows/types';\n\n// Re-export Zod utilities for external use (isZodType is defined locally below)\nexport { getZodTypeName, getZodDef, isZodArray, isZodObject } from './utils/zod-utils';\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Deep merges two objects, recursively merging nested objects and arrays\n */\nexport function deepMerge<T extends object = object>(target: T, source: Partial<T>): T {\n  const output = { ...target };\n\n  if (!source) return output;\n\n  Object.keys(source).forEach(key => {\n    const targetValue = output[key as keyof T];\n    const sourceValue = source[key as keyof T];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      (output as any)[key] = sourceValue;\n    } else if (\n      sourceValue instanceof Object &&\n      targetValue instanceof Object &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      (output as any)[key] = deepMerge(targetValue, sourceValue as T);\n    } else if (sourceValue !== undefined) {\n      (output as any)[key] = sourceValue;\n    }\n  });\n\n  return output;\n}\n\nexport function generateEmptyFromSchema(schema: string) {\n  try {\n    const parsedSchema = JSON.parse(schema);\n    if (!parsedSchema || parsedSchema.type !== 'object' || !parsedSchema.properties) return {};\n    const obj: Record<string, any> = {};\n    const TYPE_DEFAULTS = {\n      string: '',\n      array: [],\n      object: {},\n      number: 0,\n      integer: 0,\n      boolean: false,\n    };\n    for (const [key, prop] of Object.entries<any>(parsedSchema.properties)) {\n      obj[key] = TYPE_DEFAULTS[prop.type as keyof typeof TYPE_DEFAULTS] ?? null;\n    }\n    return obj;\n  } catch {\n    return {};\n  }\n}\n\nexport interface TagMaskOptions {\n  /** Called when masking begins */\n  onStart?: () => void;\n  /** Called when masking ends */\n  onEnd?: () => void;\n  /** Called for each chunk that is masked */\n  onMask?: (chunk: string) => void;\n}\n\n/**\n * Transforms a stream by masking content between XML tags.\n * @param stream Input stream to transform\n * @param tag Tag name to mask between (e.g. for <foo>...</foo>, use 'foo')\n * @param options Optional configuration for masking behavior\n */\nexport async function* maskStreamTags(\n  stream: AsyncIterable<string>,\n  tag: string,\n  options: TagMaskOptions = {},\n): AsyncIterable<string> {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n\n  let buffer = '';\n  let fullContent = '';\n  let isMasking = false;\n  let isBuffering = false;\n\n  // used for checking in chunks that include tags or partial tags + some other non-tag text\n  // eg: \"o <tag_name\" or \"name> w\", can trim before-start to get \"<tag_name\" or after-end to get \"name>\"\n  const trimOutsideDelimiter = (text: string, delimiter: string, trim: 'before-start' | 'after-end') => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n\n    const parts = text.split(delimiter);\n\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n\n    return `${parts[0]}${delimiter}`;\n  };\n\n  // Helper to check if text starts with pattern (ignoring whitespace)\n  // When checking partial tags: startsWith(buffer, openTag) checks if buffer could be start of tag\n  // When checking full tags: startsWith(chunk, openTag) checks if chunk starts with full tag\n  const startsWith = (text: string, pattern: string) => {\n    // check start of opening tag\n    if (pattern.includes(openTag.substring(0, 3))) {\n      // our pattern for checking the start is always based on xml-like tags\n      // if the pattern looks like our opening tag and the pattern also includes\n      // some other chunked text before it, we just wanted to check the xml part of the pattern\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n\n    return text.trim().startsWith(pattern.trim());\n  };\n\n  for await (const chunk of stream) {\n    fullContent += chunk;\n\n    if (isBuffering) buffer += chunk;\n\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n\n    let toYieldBeforeMaskedStartTag = ``;\n    // Check if we should start masking chunks\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n\n      // check if the buffered text includes text before the start tag. ex \"o <tag_name\", \"o\" should be yielded and not masked\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n\n      buffer = '';\n      onStart?.();\n    }\n\n    // Check if we should start buffering (looks like part of the opening tag but it's not the full <tag> yet eg <ta - could be <table> but we don't know yet)\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== '') {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n\n    // We're buffering, need to check again if our buffer has deviated from the opening <tag> eg <tag2>\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = '';\n      isBuffering = false;\n      continue;\n    }\n\n    // Check if we should stop masking chunks (since the content includes the closing </tag>)\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``; // reset to handle streams with multiple full tags that have text inbetween\n\n      // check to see if we have a partial chunk outside the close tag. if we do we need to yield it so it isn't swallowed with the masked text\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, 'after-end');\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n\n      continue;\n    }\n\n    // We're currently masking chunks inside a <tag>\n    if (isMasking) {\n      onMask?.(chunk);\n      // in the case that there was a chunk that included a tag to mask and some other text, ex \"o <tag_name\" we need to still yield the\n      // text before the tag (\"o \") so it's not swallowed with the masked text\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n\n    // default yield the chunk\n    yield chunk;\n  }\n}\n\n/**\n * Resolve serialized zod output - This function takes the string output ot the `jsonSchemaToZod` function\n * and instantiates the zod object correctly.\n *\n * @param schema - serialized zod object\n * @returns resolved zod object\n */\nexport function resolveSerializedZodOutput(schema: string): z.ZodType {\n  // Creates and immediately executes a new function that takes 'z' as a parameter\n  // The function body is a string that returns the serialized zod schema\n  // When executed with the 'z' parameter, it reconstructs the zod schema in the current context\n  return Function('z', `\"use strict\";return (${schema});`)(z);\n}\n\nexport interface ToolOptions {\n  name: string;\n  runId?: string;\n  threadId?: string;\n  resourceId?: string;\n  logger?: IMastraLogger;\n  description?: string;\n  mastra?: (Mastra & MastraPrimitives) | MastraPrimitives;\n  requestContext: RequestContext;\n  /** Build-time tracing context (fallback for Legacy methods that can't pass request context) */\n  tracingContext?: TracingContext;\n  tracingPolicy?: TracingPolicy;\n  memory?: MastraMemory;\n  agentName?: string;\n  model?: MastraLanguageModel | MastraLegacyLanguageModel;\n  /**\n   * Optional async writer used to stream tool output chunks back to the caller. Tools should treat this as fire-and-forget I/O.\n   */\n  outputWriter?: OutputWriter;\n  requireApproval?: boolean;\n  // Workflow-specific properties\n  workflow?: any;\n  workflowId?: string;\n  state?: any;\n  setState?: (state: any) => void;\n}\n\n/**\n * Checks if a value is a Zod type\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n */\nexport function isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n// Helper function to create a deterministic hash\nfunction createDeterministicId(input: string): string {\n  return createHash('sha256').update(input).digest('hex').slice(0, 8); // Take first 8 characters for a shorter but still unique ID\n}\n\n/**\n * Sets the properties for a Vercel Tool, including an ID and inputSchema\n * @param tool - The tool to set the properties for\n * @returns The tool with the properties set\n */\nfunction setVercelToolProperties(tool: VercelTool) {\n  // Check if the tool already has inputSchema (v5 format)\n  // If it does, use it directly (it might be a function)\n  // Otherwise, convert the parameters to inputSchema\n  const inputSchema = 'inputSchema' in tool ? tool.inputSchema : convertVercelToolParameters(tool);\n\n  const toolId = !('id' in tool)\n    ? tool.description\n      ? `tool-${createDeterministicId(tool.description)}`\n      : `tool-${Math.random().toString(36).substring(2, 9)}`\n    : tool.id;\n\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema,\n  };\n}\n\n/**\n * Ensures a tool has an ID and inputSchema by generating one if not present\n * @param tool - The tool to ensure has an ID and inputSchema\n * @returns The tool with an ID and inputSchema\n */\nexport function ensureToolProperties(tools: ToolsInput): ToolsInput {\n  const toolsWithProperties = Object.keys(tools).reduce<ToolsInput>((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      // Check if the tool is a plain function (not a Tool instance or Vercel tool)\n      // This catches the common mistake of passing a tool factory function instead of the tool itself\n      // We need to cast to unknown first since ToolsInput doesn't include functions in its type,\n      // but users can still pass functions at runtime which causes silent failures\n      if (typeof tool === 'function' && !((tool as unknown) instanceof Tool) && !isVercelTool(tool)) {\n        throw new MastraError({\n          id: 'TOOL_INVALID_FORMAT',\n          domain: ErrorDomain.TOOL,\n          category: ErrorCategory.USER,\n          text: `Tool \"${key}\" is not a valid tool format. Tools must be created using createTool() or be a valid Vercel AI SDK tool. Received a function.`,\n        });\n      }\n\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool) as VercelTool;\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n\n  return toolsWithProperties;\n}\n\nfunction convertVercelToolParameters(tool: VercelTool): z.ZodType {\n  // If the tool is a Vercel Tool, check if the parameters are already a zod object\n  // If not, convert the parameters to a zod object using jsonSchemaToZod\n  // Handle case where parameters (or inputSchema in v5) is a function that returns a schema\n  let schema = tool.parameters ?? z.object({});\n\n  // If schema is a function, call it to get the actual schema\n  if (typeof schema === 'function') {\n    schema = schema();\n  }\n\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\n\n/**\n * Converts a Vercel Tool or Mastra Tool into a CoreTool format\n * @param originalTool - The tool to convert (either VercelTool or ToolAction)\n * @param options - Tool options including Mastra-specific settings\n * @param logType - Type of tool to log (tool or toolset)\n * @returns A CoreTool that can be used by the system\n */\nexport function makeCoreTool(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n  autoResumeSuspendedTools?: boolean,\n): CoreTool {\n  return new CoreToolBuilder({ originalTool, options, logType, autoResumeSuspendedTools }).build();\n}\n\nexport function makeCoreToolV5(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n  autoResumeSuspendedTools?: boolean,\n): VercelToolV5 {\n  return new CoreToolBuilder({ originalTool, options, logType, autoResumeSuspendedTools }).buildV5();\n}\n\n/**\n * Creates a proxy for a Mastra instance to handle deprecated properties\n * @param mastra - The Mastra instance to proxy\n * @param logger - The logger to use for warnings\n * @returns A proxy for the Mastra instance\n */\nexport function createMastraProxy({ mastra, logger }: { mastra: Mastra; logger: IMastraLogger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === 'function';\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n\n      if (prop === 'logger') {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n\n      if (prop === 'storage') {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, 'storage');\n      }\n\n      if (prop === 'agents') {\n        logger.warn(`Please use 'listAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.listAgents, target, []);\n      }\n\n      if (prop === 'tts') {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n\n      if (prop === 'vectors') {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n\n      if (prop === 'memory') {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, 'memory');\n      }\n\n      return Reflect.get(target, prop);\n    },\n  });\n}\n\nexport function checkEvalStorageFields(traceObject: any, logger?: IMastraLogger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push('input');\n  if (!traceObject.output) missingFields.push('output');\n  if (!traceObject.agentName) missingFields.push('agent_name');\n  if (!traceObject.metricName) missingFields.push('metric_name');\n  if (!traceObject.instructions) missingFields.push('instructions');\n  if (!traceObject.globalRunId) missingFields.push('global_run_id');\n  if (!traceObject.runId) missingFields.push('run_id');\n\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    } else {\n      console.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// lifted from https://github.com/vercel/ai/blob/main/packages/ai/core/prompt/detect-prompt-type.ts#L27\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n\nexport function isUiMessage(message: CoreMessage | AiMessageType): message is AiMessageType {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nexport function isCoreMessage(message: CoreMessage | AiMessageType): message is CoreMessage {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\n\n/** Represents a validated SQL identifier (e.g., table or column name). */\ntype SqlIdentifier = string & { __brand: 'SqlIdentifier' };\n/** Represents a validated dot-separated SQL field key. */\ntype FieldKey = string & { __brand: 'FieldKey' };\n\nconst SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\n/**\n * Parses and returns a valid SQL identifier (such as a table or column name).\n * The identifier must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param name - The identifier string to parse.\n * @param kind - Optional label for error messages (e.g., 'table name').\n * @returns The validated identifier as a branded type.\n * @throws {Error} If the identifier does not conform to SQL naming rules.\n *\n * @example\n * const id = parseSqlIdentifier('my_table'); // Ok\n * parseSqlIdentifier('123table'); // Throws error\n */\nexport function parseSqlIdentifier(name: string, kind = 'identifier'): SqlIdentifier {\n  if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {\n    throw new Error(\n      `Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`,\n    );\n  }\n  return name as SqlIdentifier;\n}\n\n/**\n * Parses and returns a valid dot-separated SQL field key (e.g., 'user.profile.name').\n * Each segment must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param key - The dot-separated field key string to parse.\n * @returns The validated field key as a branded type.\n * @throws {Error} If any segment of the key is invalid.\n *\n * @example\n * const key = parseFieldKey('user_profile.name'); // Ok\n * parseFieldKey('user..name'); // Throws error\n * parseFieldKey('user.123name'); // Throws error\n */\nexport function parseFieldKey(key: string): FieldKey {\n  if (!key) throw new Error('Field key cannot be empty');\n  const segments = key.split('.');\n  for (const segment of segments) {\n    if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {\n      throw new Error(`Invalid field key segment: ${segment} in ${key}`);\n    }\n  }\n  return key as FieldKey;\n}\n\n/**\n * Performs a fetch request with automatic retries using exponential backoff\n * @param url The URL to fetch from\n * @param options Standard fetch options\n * @param maxRetries Maximum number of retry attempts\n * @param validateResponse Optional function to validate the response beyond HTTP status\n * @returns The fetch Response if successful\n */\nexport async function fetchWithRetry(\n  url: string,\n  options: RequestInit = {},\n  maxRetries: number = 3,\n): Promise<Response> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n\n  while (retryCount < maxRetries) {\n    try {\n      const response = await fetch(url, options);\n\n      if (!response.ok) {\n        throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);\n      }\n\n      return response;\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      retryCount++;\n\n      if (retryCount >= maxRetries) {\n        break;\n      }\n\n      const delay = Math.min(1000 * Math.pow(2, retryCount) * 1000, 10000);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError || new Error('Request failed after multiple retry attempts');\n}\n\n/**\n * Removes specific keys from an object.\n * @param obj - The original object\n * @param keysToOmit - Keys to exclude from the returned object\n * @returns A new object with the specified keys removed\n */\nexport function omitKeys<T extends Record<string, any>>(obj: T, keysToOmit: string[]): Partial<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => !keysToOmit.includes(key))) as Partial<T>;\n}\n\n/**\n * Selectively extracts specific fields from an object using dot notation.\n * Does not error if fields don't exist - simply omits them from the result.\n * @param obj - The source object to extract fields from\n * @param fields - Array of field paths (supports dot notation like 'output.text')\n * @returns New object containing only the specified fields\n */\nexport function selectFields(obj: any, fields: string[]): any {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const result: any = {};\n\n  for (const field of fields) {\n    const value = getNestedValue(obj, field);\n    if (value !== undefined) {\n      setNestedValue(result, field, value);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Gets a nested value from an object using dot notation\n * @param obj - Source object\n * @param path - Dot notation path (e.g., 'output.text')\n * @returns The value at the path, or undefined if not found\n */\nexport function getNestedValue(obj: any, path: string): any {\n  return path.split('.').reduce((current, key) => {\n    return current && typeof current === 'object' ? current[key] : undefined;\n  }, obj);\n}\n\n/**\n * Sets a nested value in an object using dot notation\n * @param obj - Target object\n * @param path - Dot notation path (e.g., 'output.text')\n * @param value - Value to set\n */\nexport function setNestedValue(obj: any, path: string, value: any): void {\n  const keys = path.split('.');\n  const lastKey = keys.pop();\n  if (!lastKey) {\n    return;\n  }\n\n  const target = keys.reduce((current, key) => {\n    if (!current[key] || typeof current[key] !== 'object') {\n      current[key] = {};\n    }\n    return current[key];\n  }, obj);\n\n  target[lastKey] = value;\n}\n\nexport const removeUndefinedValues = (obj: Record<string, any>) => {\n  return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== undefined));\n};\n"]}