import { isZodArray, isZodObject } from './chunk-AIJLACR2.js';
import { RequestContext } from './chunk-Y22QMA7S.js';

// src/tools/validation.ts
function truncateForLogging(data, maxLength = 200) {
  try {
    const stringified = JSON.stringify(data, null, 2);
    if (stringified.length <= maxLength) {
      return stringified;
    }
    return stringified.slice(0, maxLength) + "... (truncated)";
  } catch {
    return "[Unable to serialize data]";
  }
}
function validateToolSuspendData(schema, suspendData, toolId) {
  if (!schema || !("safeParse" in schema)) {
    return { data: suspendData };
  }
  const validation = schema.safeParse(suspendData);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(suspendData)}`,
    validationErrors: validation.error.format()
  };
  return { data: suspendData, error };
}
function normalizeNullishInput(schema, input) {
  if (input !== void 0 && input !== null) {
    return input;
  }
  if (isZodArray(schema)) {
    return [];
  }
  if (isZodObject(schema)) {
    return {};
  }
  return input;
}
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function convertUndefinedToNull(input) {
  if (input === void 0) {
    return null;
  }
  if (input === null || typeof input !== "object") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map(convertUndefinedToNull);
  }
  if (!isPlainObject(input)) {
    return input;
  }
  const result = {};
  for (const [key, value] of Object.entries(input)) {
    result[key] = convertUndefinedToNull(value);
  }
  return result;
}
function validateToolInput(schema, input, toolId) {
  if (!schema || !("safeParse" in schema)) {
    return { data: input };
  }
  let normalizedInput = normalizeNullishInput(schema, input);
  normalizedInput = convertUndefinedToNull(normalizedInput);
  const validation = schema.safeParse(normalizedInput);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool input validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(input)}`,
    validationErrors: validation.error.format()
  };
  return { data: input, error };
}
function validateToolOutput(schema, output, toolId, suspendCalled) {
  if (!schema || !("safeParse" in schema) || suspendCalled) {
    return { data: output };
  }
  const validation = schema.safeParse(output);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool output validation failed${toolId ? ` for ${toolId}` : ""}. The tool returned invalid output:
${errorMessages}

Returned output: ${truncateForLogging(output)}`,
    validationErrors: validation.error.format()
  };
  return { data: output, error };
}

// src/tools/tool.ts
var Tool = class {
  /** Unique identifier for the tool */
  id;
  /** Description of what the tool does */
  description;
  /** Schema for validating input parameters */
  inputSchema;
  /** Schema for validating output structure */
  outputSchema;
  /** Schema for suspend operation data */
  suspendSchema;
  /** Schema for resume operation data */
  resumeSchema;
  /**
   * Tool execution function
   * @param inputData - The raw, validated input data
   * @param context - Optional execution context with metadata
   * @returns Promise resolving to tool output or a ValidationError if input validation fails
   */
  execute;
  /** Parent Mastra instance for accessing shared resources */
  mastra;
  /**
   * Whether the tool requires explicit user approval before execution
   * @example
   * ```typescript
   * // For destructive operations
   * requireApproval: true
   * ```
   */
  requireApproval;
  /**
   * Provider-specific options passed to the model when this tool is used.
   * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.
   * @example
   * ```typescript
   * providerOptions: {
   *   anthropic: {
   *     cacheControl: { type: 'ephemeral' }
   *   }
   * }
   * ```
   */
  providerOptions;
  /**
   * Optional MCP-specific properties including annotations and metadata.
   * Only relevant when the tool is being used in an MCP context.
   * @example
   * ```typescript
   * mcp: {
   *   annotations: {
   *     title: 'Weather Lookup',
   *     readOnlyHint: true,
   *     destructiveHint: false
   *   },
   *   _meta: {
   *     version: '1.0.0',
   *     author: 'team@example.com'
   *   }
   * }
   * ```
   */
  mcp;
  /**
   * Creates a new Tool instance with input validation wrapper.
   *
   * @param opts - Tool configuration and execute function
   * @example
   * ```typescript
   * const tool = new Tool({
   *   id: 'my-tool',
   *   description: 'Does something useful',
   *   inputSchema: z.object({ name: z.string() }),
   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })
   * });
   * ```
   */
  constructor(opts) {
    this.id = opts.id;
    this.description = opts.description;
    this.inputSchema = opts.inputSchema;
    this.outputSchema = opts.outputSchema;
    this.suspendSchema = opts.suspendSchema;
    this.resumeSchema = opts.resumeSchema;
    this.mastra = opts.mastra;
    this.requireApproval = opts.requireApproval || false;
    this.providerOptions = opts.providerOptions;
    this.mcp = opts.mcp;
    if (opts.execute) {
      const originalExecute = opts.execute;
      this.execute = async (inputData, context) => {
        const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);
        if (error) {
          return error;
        }
        let suspendData = null;
        const baseContext = context ? {
          ...context,
          ...context.suspend ? {
            suspend: (args, suspendOptions) => {
              suspendData = args;
              return context.suspend?.(args, suspendOptions);
            }
          } : {}
        } : {};
        let organizedContext = baseContext;
        if (!context) {
          organizedContext = {
            requestContext: new RequestContext(),
            mastra: void 0
          };
        } else {
          const isAgentExecution = baseContext.toolCallId && baseContext.messages;
          const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);
          if (isAgentExecution && !baseContext.agent) {
            const { toolCallId, messages, suspend, resumeData: resumeData2, threadId, resourceId, writableStream, ...rest } = baseContext;
            organizedContext = {
              ...rest,
              agent: {
                toolCallId,
                messages,
                suspend,
                resumeData: resumeData2,
                threadId,
                resourceId,
                writableStream
              },
              // Ensure requestContext is always present
              requestContext: rest.requestContext || new RequestContext()
            };
          } else if (isWorkflowExecution && !baseContext.workflow) {
            const { workflowId, runId, state, setState, suspend, resumeData: resumeData2, ...rest } = baseContext;
            organizedContext = {
              ...rest,
              workflow: {
                workflowId,
                runId,
                state,
                setState,
                suspend,
                resumeData: resumeData2
              },
              // Ensure requestContext is always present
              requestContext: rest.requestContext || new RequestContext()
            };
          } else {
            organizedContext = {
              ...baseContext,
              agent: baseContext.agent ? {
                ...baseContext.agent,
                suspend: (args, suspendOptions) => {
                  suspendData = args;
                  return baseContext.agent?.suspend?.(args, suspendOptions);
                }
              } : baseContext.agent,
              workflow: baseContext.workflow ? {
                ...baseContext.workflow,
                suspend: (args, suspendOptions) => {
                  suspendData = args;
                  return baseContext.workflow?.suspend?.(args, suspendOptions);
                }
              } : baseContext.workflow,
              requestContext: baseContext.requestContext || new RequestContext()
            };
          }
        }
        const resumeData = organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;
        if (resumeData) {
          const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);
          if (resumeValidation.error) {
            return resumeValidation.error;
          }
        }
        const output = await originalExecute(data, organizedContext);
        if (suspendData) {
          const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);
          if (suspendValidation.error) {
            return suspendValidation.error;
          }
        }
        const skiptOutputValidation = !!(typeof output === "undefined" && suspendData);
        const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);
        if (outputValidation.error) {
          return outputValidation.error;
        }
        return outputValidation.data;
      };
    }
  }
};
function createTool(opts) {
  return new Tool(opts);
}

// src/tools/toolchecks.ts
function isVercelTool(tool) {
  return !!(tool && !(tool instanceof Tool) && ("parameters" in tool || "execute" in tool && typeof tool.execute === "function" && "inputSchema" in tool));
}

export { Tool, createTool, isVercelTool, validateToolInput, validateToolOutput, validateToolSuspendData };
//# sourceMappingURL=chunk-N3PAHTKU.js.map
//# sourceMappingURL=chunk-N3PAHTKU.js.map