{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":["isZodArray","isZodObject","RequestContext","resumeData"],"mappings":"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","file":"chunk-OZ75PBBK.cjs","sourcesContent":["import type { z } from 'zod';\nimport type { SchemaWithValidation } from '../stream/base/schema';\nimport { isZodArray, isZodObject } from '../utils/zod-utils';\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Safely truncates data for error messages to avoid exposing sensitive information.\n * @param data The data to truncate\n * @param maxLength Maximum length of the truncated string (default: 200)\n * @returns Truncated string representation\n */\nfunction truncateForLogging(data: unknown, maxLength: number = 200): string {\n  try {\n    const stringified = JSON.stringify(data, null, 2);\n    if (stringified.length <= maxLength) {\n      return stringified;\n    }\n    return stringified.slice(0, maxLength) + '... (truncated)';\n  } catch {\n    return '[Unable to serialize data]';\n  }\n}\n\n/**\n * Validates raw suspend data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param suspendData The raw suspend data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolSuspendData<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  suspendData: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return suspend data as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: suspendData };\n  }\n\n  // Validate the input directly - no unwrapping needed in v1.0\n  const validation = schema.safeParse(suspendData);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(suspendData)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: suspendData, error };\n}\n\n/**\n * Normalizes undefined/null input to an appropriate default value based on schema type.\n * This handles LLMs (Claude Sonnet 4.5, Gemini 2.4, etc.) that send undefined/null\n * instead of {} or [] when all parameters are optional.\n *\n * @param schema The Zod schema to check\n * @param input The input to normalize\n * @returns The normalized input (original value, {}, or [])\n */\nfunction normalizeNullishInput(schema: SchemaWithValidation<unknown>, input: unknown): unknown {\n  if (input !== undefined && input !== null) {\n    return input;\n  }\n\n  // Check if schema is an array type (using typeName to avoid dual-package hazard)\n  if (isZodArray(schema)) {\n    return [];\n  }\n\n  // Check if schema is an object type (using typeName to avoid dual-package hazard)\n  if (isZodObject(schema)) {\n    return {};\n  }\n\n  // For other schema types, return the original input and let Zod validate\n  return input;\n}\n\n/**\n * Checks if a value is a plain object (created by {} or new Object()).\n * This excludes class instances, built-in objects like Date/Map/URL, etc.\n *\n * @param value The value to check\n * @returns true if the value is a plain object\n */\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  if (value === null || typeof value !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n}\n\n/**\n * Recursively converts undefined values to null in an object.\n * This is needed for OpenAI compat layers which convert .optional() to .nullable()\n * for strict mode compliance. When fields are omitted (undefined), we convert them\n * to null so the schema validation passes, and the transform then converts null back\n * to undefined. (GitHub #11457)\n *\n * Only recurses into plain objects to preserve class instances and built-in objects\n * like Date, Map, URL, etc. (GitHub #11502)\n *\n * @param input The input to process\n * @returns The processed input with undefined values converted to null\n */\nfunction convertUndefinedToNull(input: unknown): unknown {\n  if (input === undefined) {\n    return null;\n  }\n\n  if (input === null || typeof input !== 'object') {\n    return input;\n  }\n\n  if (Array.isArray(input)) {\n    return input.map(convertUndefinedToNull);\n  }\n\n  // Only recurse into plain objects - preserve class instances, built-in objects\n  // (Date, Map, Set, URL, etc.) and any other non-plain objects\n  if (!isPlainObject(input)) {\n    return input;\n  }\n\n  // It's a plain object - recursively process all properties\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(input)) {\n    result[key] = convertUndefinedToNull(value);\n  }\n  return result;\n}\n\n/**\n * Validates raw input data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param input The raw input data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolInput<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return input as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Normalize undefined/null input to appropriate default for the schema type\n  // This handles LLMs that send undefined instead of {} or [] for optional parameters\n  let normalizedInput = normalizeNullishInput(schema, input);\n\n  // Convert undefined values to null recursively (GitHub #11457)\n  // This is needed because OpenAI compat layers convert .optional() to .nullable()\n  // for strict mode compliance. When fields are omitted (undefined), we convert them\n  // to null so the schema validation passes. The schema's transform will then convert\n  // null back to undefined to match the original .optional() semantics.\n  normalizedInput = convertUndefinedToNull(normalizedInput);\n\n  // Validate the normalized input\n  const validation = schema.safeParse(normalizedInput);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool input validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(input)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: input, error };\n}\n\n/**\n * Validates tool output data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param output The output data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolOutput<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  output: unknown,\n  toolId?: string,\n  suspendCalled?: boolean,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return output as-is\n  if (!schema || !('safeParse' in schema) || suspendCalled) {\n    return { data: output };\n  }\n\n  // Validate the output\n  const validation = schema.safeParse(output);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool output validation failed${toolId ? ` for ${toolId}` : ''}. The tool returned invalid output:\\n${errorMessages}\\n\\nReturned output: ${truncateForLogging(output)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: output, error };\n}\n","import type { Mastra } from '../mastra';\nimport { RequestContext } from '../request-context';\nimport type { SchemaWithValidation } from '../stream/base/schema';\nimport type { SuspendOptions } from '../workflows';\nimport type { MCPToolProperties, ToolAction, ToolExecutionContext } from './types';\nimport { validateToolInput, validateToolOutput, validateToolSuspendData } from './validation';\n\n/**\n * A type-safe tool that agents and workflows can call to perform specific actions.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n *\n * @example Basic tool with validation\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'get-weather',\n *   description: 'Get weather for a location',\n *   inputSchema: z.object({\n *     location: z.string(),\n *     units: z.enum(['celsius', 'fahrenheit']).optional()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchWeather(inputData.location, inputData.units);\n *   }\n * });\n * ```\n *\n * @example Tool requiring approval\n * ```typescript\n * const deleteFileTool = createTool({\n *   id: 'delete-file',\n *   description: 'Delete a file',\n *   requireApproval: true,\n *   inputSchema: z.object({ filepath: z.string() }),\n *   execute: async (inputData) => {\n *     await fs.unlink(inputData.filepath);\n *     return { deleted: true };\n *   }\n * });\n * ```\n *\n * @example Tool with Mastra integration\n * ```typescript\n * const saveTool = createTool({\n *   id: 'save-data',\n *   description: 'Save data to storage',\n *   inputSchema: z.object({ key: z.string(), value: z.any() }),\n *   execute: async (inputData, context) => {\n *     const storage = context?.mastra?.getStorage();\n *     await storage?.set(inputData.key, inputData.value);\n *     return { saved: true };\n *   }\n * });\n * ```\n */\nexport class Tool<\n  TSchemaIn = unknown,\n  TSchemaOut = unknown,\n  TSuspendSchema = unknown,\n  TResumeSchema = unknown,\n  TContext extends ToolExecutionContext<TSuspendSchema, TResumeSchema> = ToolExecutionContext<\n    TSuspendSchema,\n    TResumeSchema\n  >,\n  TId extends string = string,\n> implements ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId> {\n  /** Unique identifier for the tool */\n  id: TId;\n\n  /** Description of what the tool does */\n  description: string;\n\n  /** Schema for validating input parameters */\n  inputSchema?: SchemaWithValidation<TSchemaIn>;\n\n  /** Schema for validating output structure */\n  outputSchema?: SchemaWithValidation<TSchemaOut>;\n\n  /** Schema for suspend operation data */\n  suspendSchema?: SchemaWithValidation<TSuspendSchema>;\n\n  /** Schema for resume operation data */\n  resumeSchema?: SchemaWithValidation<TResumeSchema>;\n\n  /**\n   * Tool execution function\n   * @param inputData - The raw, validated input data\n   * @param context - Optional execution context with metadata\n   * @returns Promise resolving to tool output or a ValidationError if input validation fails\n   */\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>['execute'];\n\n  /** Parent Mastra instance for accessing shared resources */\n  mastra?: Mastra;\n\n  /**\n   * Whether the tool requires explicit user approval before execution\n   * @example\n   * ```typescript\n   * // For destructive operations\n   * requireApproval: true\n   * ```\n   */\n  requireApproval?: boolean;\n\n  /**\n   * Provider-specific options passed to the model when this tool is used.\n   * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.\n   * @example\n   * ```typescript\n   * providerOptions: {\n   *   anthropic: {\n   *     cacheControl: { type: 'ephemeral' }\n   *   }\n   * }\n   * ```\n   */\n  providerOptions?: Record<string, Record<string, unknown>>;\n\n  /**\n   * Optional MCP-specific properties including annotations and metadata.\n   * Only relevant when the tool is being used in an MCP context.\n   * @example\n   * ```typescript\n   * mcp: {\n   *   annotations: {\n   *     title: 'Weather Lookup',\n   *     readOnlyHint: true,\n   *     destructiveHint: false\n   *   },\n   *   _meta: {\n   *     version: '1.0.0',\n   *     author: 'team@example.com'\n   *   }\n   * }\n   * ```\n   */\n  mcp?: MCPToolProperties;\n\n  /**\n   * Creates a new Tool instance with input validation wrapper.\n   *\n   * @param opts - Tool configuration and execute function\n   * @example\n   * ```typescript\n   * const tool = new Tool({\n   *   id: 'my-tool',\n   *   description: 'Does something useful',\n   *   inputSchema: z.object({ name: z.string() }),\n   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })\n   * });\n   * ```\n   */\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.suspendSchema = opts.suspendSchema;\n    this.resumeSchema = opts.resumeSchema;\n    this.mastra = opts.mastra;\n    this.requireApproval = opts.requireApproval || false;\n    this.providerOptions = opts.providerOptions;\n    this.mcp = opts.mcp;\n\n    // Tools receive two parameters:\n    // 1. input - The raw, validated input data\n    // 2. context - Execution metadata (mastra, suspend, etc.)\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (inputData: unknown, context?: any) => {\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        let suspendData = null;\n\n        const baseContext = context\n          ? {\n              ...context,\n              ...(context.suspend\n                ? {\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return context.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : {}),\n            }\n          : {};\n\n        // Organize context based on execution source\n        let organizedContext = baseContext;\n        if (!context) {\n          // No context provided - create a minimal context with requestContext\n          organizedContext = {\n            requestContext: new RequestContext(),\n            mastra: undefined,\n          };\n        } else {\n          // Check if this is agent execution (has toolCallId and messages)\n          const isAgentExecution = baseContext.toolCallId && baseContext.messages;\n\n          // Check if this is workflow execution (has workflow properties)\n          // Agent execution takes precedence - don't treat as workflow if it's an agent call\n          const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);\n\n          if (isAgentExecution && !baseContext.agent) {\n            // Reorganize agent context - nest agent-specific properties under 'agent' key\n            const { toolCallId, messages, suspend, resumeData, threadId, resourceId, writableStream, ...rest } =\n              baseContext;\n            organizedContext = {\n              ...rest,\n              agent: {\n                toolCallId,\n                messages,\n                suspend,\n                resumeData,\n                threadId,\n                resourceId,\n                writableStream,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else if (isWorkflowExecution && !baseContext.workflow) {\n            // Reorganize workflow context - nest workflow-specific properties under 'workflow' key\n            const { workflowId, runId, state, setState, suspend, resumeData, ...rest } = baseContext;\n            organizedContext = {\n              ...rest,\n              workflow: {\n                workflowId,\n                runId,\n                state,\n                setState,\n                suspend,\n                resumeData,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else {\n            // Ensure requestContext is always present even for direct execution\n            organizedContext = {\n              ...baseContext,\n              agent: baseContext.agent\n                ? {\n                    ...baseContext.agent,\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return baseContext.agent?.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : baseContext.agent,\n              workflow: baseContext.workflow\n                ? {\n                    ...baseContext.workflow,\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return baseContext.workflow?.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : baseContext.workflow,\n              requestContext: baseContext.requestContext || new RequestContext(),\n            };\n          }\n        }\n\n        const resumeData =\n          organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;\n\n        if (resumeData) {\n          const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);\n          if (resumeValidation.error) {\n            return resumeValidation.error as any;\n          }\n        }\n\n        // Call the original execute with validated input and organized context\n        const output = await originalExecute(data as any, organizedContext);\n\n        if (suspendData) {\n          const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);\n          if (suspendValidation.error) {\n            return suspendValidation.error as any;\n          }\n        }\n\n        const skiptOutputValidation = !!(typeof output === 'undefined' && suspendData);\n\n        // Validate output if schema exists\n        const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);\n        if (outputValidation.error) {\n          return outputValidation.error as any;\n        }\n\n        return outputValidation.data;\n      };\n    }\n  }\n}\n\n/**\n * Creates a type-safe tool with automatic input validation.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n * @template TExecute - Execute function type\n *\n * @param opts - Tool configuration including schemas and execute function\n * @returns Type-safe Tool instance with conditional typing based on schemas\n *\n * @example Simple tool\n * ```typescript\n * const greetTool = createTool({\n *   id: 'greet',\n *   description: 'Say hello',\n *   execute: async () => ({ message: 'Hello!' })\n * });\n * ```\n *\n * @example Tool with input validation\n * ```typescript\n * const calculateTool = createTool({\n *   id: 'calculate',\n *   description: 'Perform calculations',\n *   inputSchema: z.object({\n *     operation: z.enum(['add', 'subtract']),\n *     a: z.number(),\n *     b: z.number()\n *   }),\n *   execute: async (inputData) => {\n *     const result = inputData.operation === 'add'\n *       ? inputData.a + inputData.b\n *       : inputData.a - inputData.b;\n *     return { result };\n *   }\n * });\n * ```\n *\n * @example Tool with output schema\n * ```typescript\n * const userTool = createTool({\n *   id: 'get-user',\n *   description: 'Get user data',\n *   inputSchema: z.object({ userId: z.string() }),\n *   outputSchema: z.object({\n *     id: z.string(),\n *     name: z.string(),\n *     email: z.string()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchUser(inputData.userId);\n *   }\n * });\n * ```\n *\n * @example Tool with external API\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'weather',\n *   description: 'Get weather data',\n *   inputSchema: z.object({\n *     city: z.string(),\n *     units: z.enum(['metric', 'imperial']).default('metric')\n *   }),\n *   execute: async (inputData) => {\n *     const response = await fetch(\n *       `https://api.weather.com/v1/weather?q=${inputData.city}&units=${inputData.units}`\n *     );\n *     return response.json();\n *   }\n * });\n * ```\n */\nexport function createTool<\n  TId extends string = string,\n  TSchemaIn = unknown,\n  TSchemaOut = unknown,\n  TSuspend = unknown,\n  TResume = unknown,\n  TContext extends ToolExecutionContext<TSuspend, TResume> = ToolExecutionContext<TSuspend, TResume>,\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId>,\n): Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId> {\n  return new Tool(opts);\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool (AI SDK tool)\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Mastra's Tool class\n  // AI SDK tools must have an execute function and either:\n  // - 'parameters' (v4) or 'inputSchema' (v5/v6)\n  // This prevents plain objects with inputSchema (like client tools) from being treated as VercelTools\n  return !!(\n    tool &&\n    !(tool instanceof Tool) &&\n    ('parameters' in tool || ('execute' in tool && typeof tool.execute === 'function' && 'inputSchema' in tool))\n  );\n}\n"]}