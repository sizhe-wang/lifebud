{"version":3,"sources":["../src/observability/types/tracing.ts","../src/observability/no-op.ts","../src/observability/utils.ts","../src/observability/context.ts"],"names":["SpanType","EntityType","InternalSpans","SamplingStrategyType","TracingEventType"],"mappings":"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","file":"chunk-S65YV6YB.cjs","sourcesContent":["/**\n * Tracing interfaces\n */\nimport type { MastraError } from '../../error';\nimport type { IMastraLogger } from '../../logger';\nimport type { Mastra } from '../../mastra';\nimport type { RequestContext } from '../../request-context';\nimport type { LanguageModelUsage, ProviderMetadata, StepStartPayload } from '../../stream/types';\nimport type { WorkflowRunStatus, WorkflowStepStatus } from '../../workflows';\n\n// ============================================================================\n// Span Types\n// ============================================================================\n\n/**\n * AI-specific span types with their associated metadata\n */\nexport enum SpanType {\n  /** Agent run - root span for agent processes */\n  AGENT_RUN = 'agent_run',\n  /** Generic span for custom operations */\n  GENERIC = 'generic',\n  /** Model generation with model calls, token usage, prompts, completions */\n  MODEL_GENERATION = 'model_generation',\n  /** Single model execution step within a generation (one API call) */\n  MODEL_STEP = 'model_step',\n  /** Individual model streaming chunk/event */\n  MODEL_CHUNK = 'model_chunk',\n  /** MCP (Model Context Protocol) tool execution */\n  MCP_TOOL_CALL = 'mcp_tool_call',\n  /** Input or Output Processor execution */\n  PROCESSOR_RUN = 'processor_run',\n  /** Function/tool execution with inputs, outputs, errors */\n  TOOL_CALL = 'tool_call',\n  /** Workflow run - root span for workflow processes */\n  WORKFLOW_RUN = 'workflow_run',\n  /** Workflow step execution with step status, data flow */\n  WORKFLOW_STEP = 'workflow_step',\n  /** Workflow conditional execution with condition evaluation */\n  WORKFLOW_CONDITIONAL = 'workflow_conditional',\n  /** Individual condition evaluation within conditional */\n  WORKFLOW_CONDITIONAL_EVAL = 'workflow_conditional_eval',\n  /** Workflow parallel execution */\n  WORKFLOW_PARALLEL = 'workflow_parallel',\n  /** Workflow loop execution */\n  WORKFLOW_LOOP = 'workflow_loop',\n  /** Workflow sleep operation */\n  WORKFLOW_SLEEP = 'workflow_sleep',\n  /** Workflow wait for event operation */\n  WORKFLOW_WAIT_EVENT = 'workflow_wait_event',\n}\n\nexport enum EntityType {\n  /** Agent/Model execution */\n  AGENT = 'agent',\n  /** Eval */\n  EVAL = 'eval',\n  /** Input Processor */\n  INPUT_PROCESSOR = 'input_processor',\n  /** Input Step Processor */\n  INPUT_STEP_PROCESSOR = 'input_step_processor',\n  /** Output Processor */\n  OUTPUT_PROCESSOR = 'output_processor',\n  /** Output Step Processor */\n  OUTPUT_STEP_PROCESSOR = 'output_step_processor',\n  /** Workflow Step */\n  WORKFLOW_STEP = 'workflow_step',\n  /** Tool */\n  TOOL = 'tool',\n  /** Workflow */\n  WORKFLOW_RUN = 'workflow_run',\n}\n\n// ============================================================================\n// Type-Specific Attributes Interfaces\n// ============================================================================\n\n/**\n * Base attributes that all spans can have\n */\nexport interface AIBaseAttributes {}\n\n/**\n * Agent Run attributes\n */\nexport interface AgentRunAttributes extends AIBaseAttributes {\n  /** Conversation/thread/session identifier for multi-turn interactions */\n  conversationId?: string;\n  /** Agent Instructions **/\n  instructions?: string;\n  /** Agent Prompt **/\n  prompt?: string;\n  /** Available tools for this execution */\n  availableTools?: string[];\n  /** Maximum steps allowed */\n  maxSteps?: number;\n}\n\n/**\n * Detailed breakdown of input token usage by type.\n * Based on OpenInference semantic conventions.\n */\nexport interface InputTokenDetails {\n  /** Regular text tokens (non-cached, non-audio, non-image) */\n  text?: number;\n  /** Tokens served from cache (cache hit/read) */\n  cacheRead?: number;\n  /** Tokens written to cache (cache creation - Anthropic only) */\n  cacheWrite?: number;\n  /** Audio input tokens */\n  audio?: number;\n  /** Image input tokens (includes PDF pages) */\n  image?: number;\n}\n\n/**\n * Detailed breakdown of output token usage by type.\n * Based on OpenInference semantic conventions.\n */\nexport interface OutputTokenDetails {\n  /** Regular text output tokens */\n  text?: number;\n  /** Reasoning/thinking tokens (o1, Claude thinking, Gemini thoughts) */\n  reasoning?: number;\n  /** Audio output tokens */\n  audio?: number;\n  /** Image output tokens (DALL-E, etc.) */\n  image?: number;\n}\n\n/** Token usage statistics */\nexport interface UsageStats {\n  /** Total input tokens (sum of all input details) */\n  inputTokens?: number;\n  /** Total output tokens (sum of all output details) */\n  outputTokens?: number;\n  /** Detailed breakdown of input token usage */\n  inputDetails?: InputTokenDetails;\n  /** Detailed breakdown of output token usage */\n  outputDetails?: OutputTokenDetails;\n}\n\n/**\n * Model Generation attributes\n */\nexport interface ModelGenerationAttributes extends AIBaseAttributes {\n  /** Model name (e.g., 'gpt-4', 'claude-3') */\n  model?: string;\n  /** Model provider (e.g., 'openai', 'anthropic') */\n  provider?: string;\n  /** Type of result/output this LLM call produced */\n  resultType?: 'tool_selection' | 'response_generation' | 'reasoning' | 'planning';\n  /** Token usage statistics */\n  usage?: UsageStats;\n  /** Model parameters */\n  parameters?: {\n    maxOutputTokens?: number;\n    temperature?: number;\n    topP?: number;\n    topK?: number;\n    presencePenalty?: number;\n    frequencyPenalty?: number;\n    stopSequences?: string[];\n    seed?: number;\n    maxRetries?: number;\n    abortSignal?: any;\n    headers?: Record<string, string | undefined>;\n  };\n  /** Whether this was a streaming response */\n  streaming?: boolean;\n  /** Reason the generation finished */\n  finishReason?: string;\n  /**\n   * When the first token/chunk of the completion was received.\n   * Used to calculate time-to-first-token (TTFT) metrics.\n   * Only applicable for streaming responses.\n   */\n  completionStartTime?: Date;\n  /** Actual model used in the response (may differ from request model) */\n  responseModel?: string;\n  /** Unique identifier for the response */\n  responseId?: string;\n  /** Server address for the model endpoint */\n  serverAddress?: string;\n  /** Server port for the model endpoint */\n  serverPort?: number;\n}\n\n/**\n * Model Step attributes - for a single model execution within a generation\n */\nexport interface ModelStepAttributes extends AIBaseAttributes {\n  /** Index of this step in the generation (0, 1, 2, ...) */\n  stepIndex?: number;\n  /** Token usage statistics */\n  usage?: UsageStats;\n  /** Reason this step finished (stop, tool-calls, length, etc.) */\n  finishReason?: string;\n  /** Should execution continue */\n  isContinued?: boolean;\n  /** Result warnings */\n  warnings?: Record<string, any>;\n}\n\n/**\n * Model Chunk attributes - for individual streaming chunks/events\n */\nexport interface ModelChunkAttributes extends AIBaseAttributes {\n  /** Type of chunk (text-delta, reasoning-delta, tool-call, etc.) */\n  chunkType?: string;\n  /** Sequence number of this chunk in the stream */\n  sequenceNumber?: number;\n}\n\n/**\n * Tool Call attributes\n */\nexport interface ToolCallAttributes extends AIBaseAttributes {\n  toolType?: string;\n  toolDescription?: string;\n  success?: boolean;\n}\n\n/**\n * MCP Tool Call attributes\n */\nexport interface MCPToolCallAttributes extends AIBaseAttributes {\n  /** MCP server identifier */\n  mcpServer: string;\n  /** MCP server version */\n  serverVersion?: string;\n  /** Whether tool execution was successful */\n  success?: boolean;\n}\n\n/**\n * Processor attributes\n */\nexport interface ProcessorRunAttributes extends AIBaseAttributes {\n  /** Processor executor type (workflow or legacy) */\n  processorExecutor?: 'workflow' | 'legacy';\n  /** Processor index in the agent */\n  processorIndex?: number;\n  /** MessageList mutations performed by this processor */\n  messageListMutations?: Array<{\n    type: 'add' | 'addSystem' | 'removeByIds' | 'clear';\n    source?: string;\n    count?: number;\n    ids?: string[];\n    text?: string;\n    tag?: string;\n    message?: any;\n  }>;\n}\n\n/**\n * Workflow Run attributes\n */\nexport interface WorkflowRunAttributes extends AIBaseAttributes {\n  /** Workflow status */\n  status?: WorkflowRunStatus;\n}\n\n/**\n * Workflow Step attributes\n */\nexport interface WorkflowStepAttributes extends AIBaseAttributes {\n  /** Step status */\n  status?: WorkflowStepStatus;\n}\n\n/**\n * Workflow Conditional attributes\n */\nexport interface WorkflowConditionalAttributes extends AIBaseAttributes {\n  /** Number of conditions evaluated */\n  conditionCount: number;\n  /** Which condition indexes evaluated to true */\n  truthyIndexes?: number[];\n  /** Which steps will be executed */\n  selectedSteps?: string[];\n}\n\n/**\n * Workflow Conditional Evaluation attributes\n */\nexport interface WorkflowConditionalEvalAttributes extends AIBaseAttributes {\n  /** Index of this condition in the conditional */\n  conditionIndex: number;\n  /** Result of condition evaluation */\n  result?: boolean;\n}\n\n/**\n * Workflow Parallel attributes\n */\nexport interface WorkflowParallelAttributes extends AIBaseAttributes {\n  /** Number of parallel branches */\n  branchCount: number;\n  /** Step IDs being executed in parallel */\n  parallelSteps?: string[];\n}\n\n/**\n * Workflow Loop attributes\n */\nexport interface WorkflowLoopAttributes extends AIBaseAttributes {\n  /** Type of loop (foreach, dowhile, dountil) */\n  loopType?: 'foreach' | 'dowhile' | 'dountil';\n  /** Current iteration number (for individual iterations) */\n  iteration?: number;\n  /** Total iterations (if known) */\n  totalIterations?: number;\n  /** Number of steps to run concurrently in foreach loop */\n  concurrency?: number;\n}\n\n/**\n * Workflow Sleep attributes\n */\nexport interface WorkflowSleepAttributes extends AIBaseAttributes {\n  /** Sleep duration in milliseconds */\n  durationMs?: number;\n  /** Sleep until date */\n  untilDate?: Date;\n  /** Sleep type */\n  sleepType?: 'fixed' | 'dynamic';\n}\n\n/**\n * Workflow Wait Event attributes\n */\nexport interface WorkflowWaitEventAttributes extends AIBaseAttributes {\n  /** Event name being waited for */\n  eventName?: string;\n  /** Timeout in milliseconds */\n  timeoutMs?: number;\n  /** Whether event was received or timed out */\n  eventReceived?: boolean;\n  /** Wait duration in milliseconds */\n  waitDurationMs?: number;\n}\n\n/**\n * AI-specific span types mapped to their attributes\n */\nexport interface SpanTypeMap {\n  [SpanType.AGENT_RUN]: AgentRunAttributes;\n  [SpanType.WORKFLOW_RUN]: WorkflowRunAttributes;\n  [SpanType.MODEL_GENERATION]: ModelGenerationAttributes;\n  [SpanType.MODEL_STEP]: ModelStepAttributes;\n  [SpanType.MODEL_CHUNK]: ModelChunkAttributes;\n  [SpanType.TOOL_CALL]: ToolCallAttributes;\n  [SpanType.MCP_TOOL_CALL]: MCPToolCallAttributes;\n  [SpanType.PROCESSOR_RUN]: ProcessorRunAttributes;\n  [SpanType.WORKFLOW_STEP]: WorkflowStepAttributes;\n  [SpanType.WORKFLOW_CONDITIONAL]: WorkflowConditionalAttributes;\n  [SpanType.WORKFLOW_CONDITIONAL_EVAL]: WorkflowConditionalEvalAttributes;\n  [SpanType.WORKFLOW_PARALLEL]: WorkflowParallelAttributes;\n  [SpanType.WORKFLOW_LOOP]: WorkflowLoopAttributes;\n  [SpanType.WORKFLOW_SLEEP]: WorkflowSleepAttributes;\n  [SpanType.WORKFLOW_WAIT_EVENT]: WorkflowWaitEventAttributes;\n  [SpanType.GENERIC]: AIBaseAttributes;\n}\n\n/**\n * Union type for cases that need to handle any span type\n */\nexport type AnySpanAttributes = SpanTypeMap[keyof SpanTypeMap];\n\n// ============================================================================\n// Span Interfaces\n// ============================================================================\n\nexport interface SpanErrorInfo {\n  message: string;\n  id?: string;\n  domain?: string;\n  category?: string;\n  details?: Record<string, any>;\n}\n\n/**\n * Base Span interface\n */\ninterface BaseSpan<TType extends SpanType> {\n  /** Unique span identifier */\n  id: string;\n  /** OpenTelemetry-compatible trace ID (32 hex chars) - present on all spans */\n  traceId: string;\n  /** Name of the span */\n  name: string;\n  /** Type of the span */\n  type: TType;\n  /** Entity type that created the span */\n  entityType?: EntityType;\n  /** Entity id that created the span */\n  entityId?: string;\n  /** Entity name that created the span */\n  entityName?: string;\n  /** When span started */\n  startTime: Date;\n  /** When span ended */\n  endTime?: Date;\n  /** Span-type specific attributes */\n  attributes?: SpanTypeMap[TType];\n  /** User-defined metadata */\n  metadata?: Record<string, any>;\n  /** Labels used to categorize and filter traces. Only valid on root spans. */\n  tags?: string[];\n  /** Input passed at the start of the span */\n  input?: any;\n  /** Output generated at the end of the span */\n  output?: any;\n  /** Error information if span failed */\n  errorInfo?: SpanErrorInfo;\n  /** Is an event span? (event occurs at startTime, has no endTime) */\n  isEvent: boolean;\n}\n\n/**\n * Span interface, used internally for tracing\n */\nexport interface Span<TType extends SpanType> extends BaseSpan<TType> {\n  /** Is an internal span? (spans internal to the operation of mastra) */\n  isInternal: boolean;\n  /** Parent span reference (undefined for root spans) */\n  parent?: AnySpan;\n  /** Pointer to the ObservabilityInstance instance */\n  observabilityInstance: ObservabilityInstance;\n  /** Trace-level state shared across all spans in this trace */\n  traceState?: TraceState;\n\n  // Methods for span lifecycle\n  /** End the span */\n  end(options?: EndSpanOptions<TType>): void;\n\n  /** Record an error for the span, optionally end the span as well */\n  error(options: ErrorSpanOptions<TType>): void;\n\n  /** Update span attributes */\n  update(options: UpdateSpanOptions<TType>): void;\n\n  /** Create child span - can be any span type independent of parent */\n  createChildSpan(options: ChildSpanOptions<SpanType.MODEL_GENERATION>): AIModelGenerationSpan;\n  createChildSpan<TChildType extends SpanType>(options: ChildSpanOptions<TChildType>): Span<TChildType>;\n\n  /** Create event span - can be any span type independent of parent */\n  createEventSpan<TChildType extends SpanType>(options: ChildEventOptions<TChildType>): Span<TChildType>;\n\n  /** Returns `TRUE` if the span is the root span of a trace */\n  get isRootSpan(): boolean;\n\n  /** Returns `TRUE` if the span is a valid span (not a NO-OP Span) */\n  get isValid(): boolean;\n\n  /** Get the closest parent spanId that isn't an internal span */\n  getParentSpanId(includeInternalSpans?: boolean): string | undefined;\n\n  /** Find the closest parent span of a specific type by walking up the parent chain */\n  findParent<T extends SpanType>(spanType: T): Span<T> | undefined;\n\n  /** Returns a lightweight span ready for export */\n  exportSpan(includeInternalSpans?: boolean): ExportedSpan<TType> | undefined;\n\n  /** Returns the traceId on span, unless NoOpSpan, then undefined */\n  get externalTraceId(): string | undefined;\n\n  /**\n   * Execute an async function within this span's tracing context.\n   *\n   * When a bridge is configured, this enables auto-instrumented operations\n   * (HTTP requests, database queries, etc.) to be properly nested under this\n   * span in the external tracing system.\n   *\n   * @param fn - The async function to execute within the span context\n   * @returns The result of the function execution\n   *\n   * @example\n   * ```typescript\n   * const result = await modelSpan.executeInContext(async () => {\n   *   return model.generateText(...);\n   * });\n   * ```\n   */\n  executeInContext<T>(fn: () => Promise<T>): Promise<T>;\n\n  /**\n   * Execute a synchronous function within this span's tracing context.\n   *\n   * When a bridge is configured, this enables auto-instrumented operations\n   * (HTTP requests, database queries, etc.) to be properly nested under this\n   * span in the external tracing system.\n   *\n   * @param fn - The synchronous function to execute within the span context\n   * @returns The result of the function execution\n   *\n   * @example\n   * ```typescript\n   * const result = modelSpan.executeInContextSync(() => {\n   *   return model.streamText(...);\n   * });\n   * ```\n   */\n  executeInContextSync<T>(fn: () => T): T;\n}\n\nexport interface BridgeSpanContext {\n  /**\n   * Execute an async function within this span's tracing context.\n   *\n   * When a bridge is configured, this enables auto-instrumented operations\n   * (HTTP requests, database queries, etc.) to be properly nested under this\n   * span in the external tracing system.\n   *\n   * @param fn - The async function to execute within the span context\n   * @returns The result of the function execution\n   *\n   * @example\n   * ```typescript\n   * const result = await modelSpan.executeInContext(async () => {\n   *   return model.generateText(...);\n   * });\n   * ```\n   */\n  executeInContext<T>(fn: () => Promise<T>): Promise<T>;\n\n  /**\n   * Execute a synchronous function within this span's tracing context.\n   *\n   * When a bridge is configured, this enables auto-instrumented operations\n   * (HTTP requests, database queries, etc.) to be properly nested under this\n   * span in the external tracing system.\n   *\n   * @param fn - The synchronous function to execute within the span context\n   * @returns The result of the function execution\n   *\n   * @example\n   * ```typescript\n   * const result = modelSpan.executeInContextSync(() => {\n   *   return model.streamText(...);\n   * });\n   * ```\n   */\n  executeInContextSync<T>(fn: () => T): T;\n}\n\n/**\n * Specialized span interface for MODEL_GENERATION spans\n * Provides access to creating a ModelSpanTracker for tracking MODEL_STEP and MODEL_CHUNK spans\n */\nexport interface AIModelGenerationSpan extends Span<SpanType.MODEL_GENERATION> {\n  /** Create a ModelSpanTracker for tracking model execution steps and chunks */\n  createTracker(): IModelSpanTracker | undefined;\n}\n\n/**\n * Exported Span interface, used for tracing exporters\n */\nexport interface ExportedSpan<TType extends SpanType> extends BaseSpan<TType> {\n  /** Parent span id reference (undefined for root spans) */\n  parentSpanId?: string;\n  /** `TRUE` if the span is the root span of a trace */\n  isRootSpan: boolean;\n  /**\n   * Tags for this trace (only present on root spans).\n   * Tags are string labels used to categorize and filter traces.\n   */\n  tags?: string[];\n}\n\n/**\n * Options for ending a model generation span\n */\nexport interface EndGenerationOptions extends EndSpanOptions<SpanType.MODEL_GENERATION> {\n  /** Raw usage data from AI SDK - will be converted to UsageStats with cache token details */\n  usage?: LanguageModelUsage;\n  /** Provider-specific metadata for extracting cache tokens */\n  providerMetadata?: ProviderMetadata;\n}\n\nexport interface IModelSpanTracker {\n  getTracingContext(): TracingContext;\n  reportGenerationError(options: ErrorSpanOptions<SpanType.MODEL_GENERATION>): void;\n  endGeneration(options?: EndGenerationOptions): void;\n  wrapStream<T extends { pipeThrough: Function }>(stream: T): T;\n  startStep(payload?: StepStartPayload): void;\n}\n\n/**\n * Union type for cases that need to handle any span\n */\nexport type AnySpan = Span<keyof SpanTypeMap>;\n\n/**\n * Union type for cases that need to handle any exported span\n */\nexport type AnyExportedSpan = ExportedSpan<keyof SpanTypeMap>;\n\n// ============================================================================\n// Tracing Interfaces\n// ============================================================================\n\n/**\n * Primary interface for Observability\n */\nexport interface ObservabilityInstance {\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<ObservabilityInstanceConfig>;\n\n  /**\n   * Get all exporters\n   */\n  getExporters(): readonly ObservabilityExporter[];\n\n  /**\n   * Get all span output processors\n   */\n  getSpanOutputProcessors(): readonly SpanOutputProcessor[];\n\n  /**\n   * Get the logger instance (for exporters and other components)\n   */\n  getLogger(): IMastraLogger;\n\n  /**\n   * Get the bridge instance if configured\n   */\n  getBridge(): ObservabilityBridge | undefined;\n\n  /**\n   * Start a new span of a specific SpanType\n   */\n  startSpan<TType extends SpanType>(options: StartSpanOptions<TType>): Span<TType>;\n\n  /**\n   * Rebuild a span from exported data for lifecycle operations.\n   * Used by durable execution engines (e.g., Inngest) to end/update spans\n   * that were created in a previous durable operation.\n   *\n   * @param cached - The exported span data to rebuild from\n   * @returns A span that can have end()/update()/error() called on it\n   */\n  rebuildSpan<TType extends SpanType>(cached: ExportedSpan<TType>): Span<TType>;\n\n  /**\n   * Shutdown tracing and clean up resources\n   */\n  shutdown(): Promise<void>;\n\n  /**\n   * Override setLogger to add tracing specific initialization log\n   */\n  __setLogger(logger: IMastraLogger): void;\n}\n\n// ============================================================================\n// Span Create/Update/Error Option Types\n// ============================================================================\n\ninterface CreateBaseOptions<TType extends SpanType> {\n  /** Span attributes */\n  attributes?: SpanTypeMap[TType];\n  /** Span metadata */\n  metadata?: Record<string, any>;\n  /** Span name */\n  name: string;\n  /** Span type */\n  type: TType;\n  /** Entity type that created the span */\n  entityType?: EntityType;\n  /** Entity id that created the span */\n  entityId?: string;\n  /** Entity name that created the span */\n  entityName?: string;\n  /** Policy-level tracing configuration */\n  tracingPolicy?: TracingPolicy;\n  /** Request Context for metadata extraction */\n  requestContext?: RequestContext;\n}\n\n/**\n * Options for creating new spans\n */\nexport interface CreateSpanOptions<TType extends SpanType> extends CreateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n  /** Output data (for event spans) */\n  output?: any;\n  /** Labels used to categorize and filter traces. Only valid on root spans. */\n  tags?: string[];\n  /** Parent span */\n  parent?: AnySpan;\n  /** Is an event span? */\n  isEvent?: boolean;\n  /**\n   * Trace ID to use for this span (1-32 hexadecimal characters).\n   * Only used for root spans without a parent.\n   */\n  traceId?: string;\n  /**\n   * Span ID to use for this span (1-16 hexadecimal characters).\n   * Only used when rebuilding a span from cached data.\n   */\n  spanId?: string;\n  /**\n   * Parent span ID to use for this span (1-16 hexadecimal characters).\n   * Only used for root spans without a parent.\n   */\n  parentSpanId?: string;\n  /**\n   * Start time for this span.\n   * Only used when rebuilding a span from cached data.\n   */\n  startTime?: Date;\n  /** Trace-level state shared across all spans in this trace */\n  traceState?: TraceState;\n}\n\n/**\n * Options for starting new spans\n */\nexport interface StartSpanOptions<TType extends SpanType> extends CreateSpanOptions<TType> {\n  /**\n   * Options passed when using a custom sampler strategy\n   */\n  customSamplerOptions?: CustomSamplerOptions;\n  /** Tracing options for this execution */\n  tracingOptions?: TracingOptions;\n}\n\n/**\n * Options for new child spans\n */\nexport interface ChildSpanOptions<TType extends SpanType> extends CreateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n}\n\n/**\n * Options for new child events\n * Event spans have no input, and no endTime\n */\nexport interface ChildEventOptions<TType extends SpanType> extends CreateBaseOptions<TType> {\n  /** Output data */\n  output?: any;\n}\n\ninterface UpdateBaseOptions<TType extends SpanType> {\n  /** Span attributes */\n  attributes?: Partial<SpanTypeMap[TType]>;\n  /** Span metadata */\n  metadata?: Record<string, any>;\n}\n\nexport interface EndSpanOptions<TType extends SpanType> extends UpdateBaseOptions<TType> {\n  /** Output data */\n  output?: any;\n}\n\nexport interface UpdateSpanOptions<TType extends SpanType> extends UpdateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n  /** Output data */\n  output?: any;\n}\n\nexport interface ErrorSpanOptions<TType extends SpanType> extends UpdateBaseOptions<TType> {\n  /** The error associated with the issue */\n  error: MastraError | Error;\n  /** End the span when true */\n  endSpan?: boolean;\n}\n\nexport interface GetOrCreateSpanOptions<TType extends SpanType> {\n  type: TType;\n  name: string;\n  entityType?: EntityType;\n  entityId?: string;\n  entityName?: string;\n  input?: any;\n  attributes?: SpanTypeMap[TType];\n  metadata?: Record<string, any>;\n  tracingPolicy?: TracingPolicy;\n  tracingOptions?: TracingOptions;\n  tracingContext?: TracingContext;\n  requestContext?: RequestContext;\n  mastra?: Mastra;\n}\n\n// ============================================================================\n// Lifecycle Types\n// ============================================================================\n\nexport interface ObservabilityEntrypoint {\n  shutdown(): Promise<void>;\n\n  setMastraContext(options: { mastra: Mastra }): void;\n\n  setLogger(options: { logger: IMastraLogger }): void;\n\n  getSelectedInstance(options: ConfigSelectorOptions): ObservabilityInstance | undefined;\n\n  // Registry management methods\n  registerInstance(name: string, instance: ObservabilityInstance, isDefault?: boolean): void;\n  getInstance(name: string): ObservabilityInstance | undefined;\n  getDefaultInstance(): ObservabilityInstance | undefined;\n  listInstances(): ReadonlyMap<string, ObservabilityInstance>;\n  unregisterInstance(name: string): boolean;\n  hasInstance(name: string): boolean;\n  setConfigSelector(selector: ConfigSelector): void;\n  clear(): void;\n}\n\n/**\n * Bitwise options to set different types of spans as internal in\n * a workflow or agent execution.\n */\nexport enum InternalSpans {\n  /** No spans are marked internal */\n  NONE = 0,\n  /** Workflow spans are marked internal */\n  WORKFLOW = 1 << 0, // 0001\n  /** Agent spans are marked internal */\n  AGENT = 1 << 1, // 0010\n  /** Tool spans are marked internal */\n  TOOL = 1 << 2, // 0100\n  /** Model spans are marked internal */\n  MODEL = 1 << 3, // 1000\n\n  /** All spans are marked internal */\n  ALL = (1 << 4) - 1, // 1111 (all bits set up to 3)\n}\n\n/**\n * Policy-level tracing configuration applied when creating\n * a workflow or agent. Unlike TracingOptions, which are\n * provided at execution time, policies define persistent rules\n * for how spans are treated across all executions of the\n * workflow/agent.\n */\nexport interface TracingPolicy {\n  /**\n   * Bitwise options to set different types of spans as Internal in\n   * a workflow or agent execution. Internal spans are hidden by\n   * default in exported traces.\n   */\n  internal?: InternalSpans;\n}\n\n/**\n * Trace-level state computed once at the start of a trace\n * and shared by all spans within that trace.\n */\nexport interface TraceState {\n  /**\n   * RequestContext keys to extract as metadata for all spans in this trace.\n   * Computed by merging the tracing config's requestContextKeys\n   * with the per-request requestContextKeys.\n   */\n  requestContextKeys: string[];\n  /**\n   * When true, input data will be hidden from all spans in this trace.\n   */\n  hideInput?: boolean;\n  /**\n   * When true, output data will be hidden from all spans in this trace.\n   */\n  hideOutput?: boolean;\n}\n\n/**\n * Options passed when starting a new agent or workflow execution\n */\nexport interface TracingOptions {\n  /** Metadata to add to the root trace span */\n  metadata?: Record<string, any>;\n  /**\n   * Additional RequestContext keys to extract as metadata for this trace.\n   * These keys are added to the requestContextKeys config.\n   * Supports dot notation for nested values (e.g., 'user.id', 'session.data.experimentId').\n   */\n  requestContextKeys?: string[];\n  /**\n   * Trace ID to use for this execution (1-32 hexadecimal characters).\n   * If provided, this trace will be part of the specified trace rather than starting a new one.\n   */\n  traceId?: string;\n  /**\n   * Parent span ID to use for this execution (1-16 hexadecimal characters).\n   * If provided, the root span will be created as a child of this span.\n   */\n  parentSpanId?: string;\n  /**\n   * Tags to apply to this trace.\n   * Tags are string labels that can be used to categorize and filter traces\n   * Note: Tags are only applied to the root span of a trace.\n   */\n  tags?: string[];\n  /**\n   * When true, input data will be hidden from all spans in this trace.\n   * Useful for protecting sensitive data from being logged.\n   */\n  hideInput?: boolean;\n  /**\n   * When true, output data will be hidden from all spans in this trace.\n   * Useful for protecting sensitive data from being logged.\n   */\n  hideOutput?: boolean;\n}\n\nexport interface SpanIds {\n  traceId: string;\n  spanId: string;\n  parentSpanId?: string;\n}\n\n/**\n * Context for tracing that flows through workflow and agent execution\n */\nexport interface TracingContext {\n  /** Current Span for creating child spans and adding metadata */\n  currentSpan?: AnySpan;\n}\n\n/**\n * Properties returned to the user for working with traces externally.\n */\nexport type TracingProperties = {\n  /** Trace ID used on the execution (if the execution was traced). */\n  traceId?: string;\n};\n\n// ============================================================================\n// Registry Config Interfaces\n// ============================================================================\n\n/**\n * Options for controlling serialization of span data.\n * These options control how input, output, and attributes are cleaned before export.\n */\nexport interface SerializationOptions {\n  /**\n   * Maximum length for string values\n   * @default 1024\n   */\n  maxStringLength?: number;\n  /**\n   * Maximum depth for nested objects\n   * @default 6\n   */\n  maxDepth?: number;\n  /**\n   * Maximum number of items in arrays\n   * @default 50\n   */\n  maxArrayLength?: number;\n  /**\n   * Maximum number of keys in objects\n   * @default 50\n   */\n  maxObjectKeys?: number;\n}\n\n/**\n * Configuration for a single observability instance\n */\nexport interface ObservabilityInstanceConfig {\n  /** Unique identifier for this config in the observability registry */\n  name: string;\n  /** Service name for observability */\n  serviceName: string;\n  /** Sampling strategy - controls whether tracing is collected (defaults to ALWAYS) */\n  sampling?: SamplingStrategy;\n  /** Custom exporters */\n  exporters?: ObservabilityExporter[];\n  /** Custom processors */\n  spanOutputProcessors?: SpanOutputProcessor[];\n  /** OpenTelemetry bridge for integration with existing OTEL infrastructure */\n  bridge?: ObservabilityBridge;\n  /** Set to `true` if you want to see spans internal to the operation of mastra */\n  includeInternalSpans?: boolean;\n  /**\n   * RequestContext keys to automatically extract as metadata for all spans\n   * created with this observability configuration.\n   * Supports dot notation for nested values.\n   */\n  requestContextKeys?: string[];\n  /**\n   * Options for controlling serialization of span data (input/output/attributes).\n   * Use these to customize truncation limits for large payloads.\n   */\n  serializationOptions?: SerializationOptions;\n}\n\n/**\n * Complete Observability registry configuration\n */\nexport interface ObservabilityRegistryConfig {\n  /** Enables default exporters, with sampling: always, and sensitive data filtering */\n  default?: {\n    enabled?: boolean;\n  };\n  /** Map of tracing instance names to their configurations or pre-instantiated instances */\n  configs?: Record<string, Omit<ObservabilityInstanceConfig, 'name'> | ObservabilityInstance>;\n  /** Optional selector function to choose which tracing instance to use */\n  configSelector?: ConfigSelector;\n}\n\n// ============================================================================\n// Sampling Strategy Interfaces\n// ============================================================================\n\n/**\n * Sampling strategy types\n */\nexport enum SamplingStrategyType {\n  ALWAYS = 'always',\n  NEVER = 'never',\n  RATIO = 'ratio',\n  CUSTOM = 'custom',\n}\n\n/**\n * Sampling strategy configuration\n */\nexport type SamplingStrategy =\n  | { type: SamplingStrategyType.ALWAYS }\n  | { type: SamplingStrategyType.NEVER }\n  | { type: SamplingStrategyType.RATIO; probability: number }\n  | { type: SamplingStrategyType.CUSTOM; sampler: (options?: CustomSamplerOptions) => boolean };\n\n/**\n * Options passed when using a custom sampler strategy\n */\nexport interface CustomSamplerOptions {\n  requestContext?: RequestContext;\n  metadata?: Record<string, any>;\n}\n\n// ============================================================================\n// Exporter and Processor Interfaces\n// ============================================================================\n\n/**\n * Tracing event types\n */\nexport enum TracingEventType {\n  SPAN_STARTED = 'span_started',\n  SPAN_UPDATED = 'span_updated',\n  SPAN_ENDED = 'span_ended',\n}\n\n/**\n * Tracing events that can be exported\n */\nexport type TracingEvent =\n  | { type: TracingEventType.SPAN_STARTED; exportedSpan: AnyExportedSpan }\n  | { type: TracingEventType.SPAN_UPDATED; exportedSpan: AnyExportedSpan }\n  | { type: TracingEventType.SPAN_ENDED; exportedSpan: AnyExportedSpan };\n\nexport interface InitExporterOptions {\n  mastra?: Mastra;\n  config?: ObservabilityInstanceConfig;\n}\n\nexport interface InitBridgeOptions {\n  mastra?: Mastra;\n  config?: ObservabilityInstanceConfig;\n}\n\n/**\n * Interface for tracing exporters\n */\nexport interface ObservabilityExporter {\n  /** Exporter name */\n  name: string;\n\n  /** Initialize exporter with tracing configuration and/or access to Mastra */\n  init?(options: InitExporterOptions): void;\n\n  /** Sets logger instance on the exporter.  */\n  __setLogger?(logger: IMastraLogger): void;\n\n  /** Export tracing events */\n  exportTracingEvent(event: TracingEvent): Promise<void>;\n\n  addScoreToTrace?({\n    traceId,\n    spanId,\n    score,\n    reason,\n    scorerName,\n    metadata,\n  }: {\n    traceId: string;\n    spanId?: string;\n    score: number;\n    reason?: string;\n    scorerName: string;\n    metadata?: Record<string, any>;\n  }): Promise<void>;\n\n  /** Shutdown exporter */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Interface for observability bridges\n */\nexport interface ObservabilityBridge {\n  /** Bridge name */\n  name: string;\n\n  /** Initialize bridge with observability configuration and/or access to Mastra */\n  init?(options: InitBridgeOptions): void;\n\n  /** Sets logger instance on the bridge  */\n  __setLogger?(logger: IMastraLogger): void;\n\n  /**\n   * Export Mastra tracing events to OTEL infrastructure\n   * Called for SPAN_STARTED, SPAN_UPDATED, SPAN_ENDED events\n   *\n   * @param event - Tracing event with exported span\n   */\n  exportTracingEvent(event: TracingEvent): Promise<void>;\n\n  /**\n   * Execute an async function within the tracing context of a Mastra span.\n   * This enables auto-instrumented operations (HTTP, DB) to have correct parent spans\n   * in the external tracing system (e.g., OpenTelemetry, DataDog, etc.).\n   *\n   * @param spanId - The ID of the Mastra span to use as context\n   * @param fn - The async function to execute within the span context\n   * @returns The result of the function execution\n   */\n  executeInContext?<T>(spanId: string, fn: () => Promise<T>): Promise<T>;\n\n  /**\n   * Execute a synchronous function within the tracing context of a Mastra span.\n   * This enables auto-instrumented operations (HTTP, DB) to have correct parent spans\n   * in the external tracing system (e.g., OpenTelemetry, DataDog, etc.).\n   *\n   * @param spanId - The ID of the Mastra span to use as context\n   * @param fn - The synchronous function to execute within the span context\n   * @returns The result of the function execution\n   */\n  executeInContextSync?<T>(spanId: string, fn: () => T): T;\n\n  /**\n   * Create a span in the bridge's tracing system.\n   * Called during Mastra span construction to get bridge-generated identifiers.\n   *\n   * @param options - Span creation options from Mastra\n   * @returns Span identifiers (spanId, traceId, parentSpanId) from bridge, or undefined if creation fails\n   */\n  createSpan(options: CreateSpanOptions<SpanType>): SpanIds | undefined;\n\n  /** Shutdown bridge and cleanup resources */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Interface for span processors\n */\nexport interface SpanOutputProcessor {\n  /** Processor name */\n  name: string;\n  /** Process span before export */\n  process(span?: AnySpan): AnySpan | undefined;\n  /** Shutdown processor */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Function type for formatting exported spans at the exporter level.\n *\n * This allows customization of how spans appear in vendor-specific observability platforms\n * (e.g., Langfuse, Braintrust). Unlike SpanOutputProcessor which operates on the internal\n * Span object before export, this formatter operates on the ExportedSpan data structure\n * after the span has been prepared for export.\n *\n * Formatters can be synchronous or asynchronous, enabling use cases like:\n * - Extract plain text from structured AI SDK messages for better readability\n * - Transform input/output format for specific vendor requirements\n * - Add or remove fields based on the target platform\n * - Redact or transform sensitive data in a vendor-specific way\n * - Enrich spans with data from external APIs (async)\n * - Perform database lookups to add context (async)\n *\n * @param span - The exported span to format\n * @returns The formatted span (sync) or a Promise resolving to the formatted span (async)\n *\n * @example\n * ```typescript\n * // Synchronous formatter that extracts plain text from AI messages\n * const plainTextFormatter: CustomSpanFormatter = (span) => {\n *   if (span.type === SpanType.AGENT_RUN && Array.isArray(span.input)) {\n *     const userMessage = span.input.find(m => m.role === 'user');\n *     return {\n *       ...span,\n *       input: userMessage?.content ?? span.input,\n *     };\n *   }\n *   return span;\n * };\n *\n * // Async formatter that enriches spans with external data\n * const enrichmentFormatter: CustomSpanFormatter = async (span) => {\n *   const userData = await fetchUserData(span.metadata?.userId);\n *   return {\n *     ...span,\n *     metadata: { ...span.metadata, userName: userData.name },\n *   };\n * };\n *\n * // Use with an exporter\n * new BraintrustExporter({\n *   customSpanFormatter: plainTextFormatter,\n * });\n * ```\n */\nexport type CustomSpanFormatter = (span: AnyExportedSpan) => AnyExportedSpan | Promise<AnyExportedSpan>;\n\n// ============================================================================\n// Tracing Config Selector Interfaces\n// ============================================================================\n\n/**\n *  Options passed when using a custom tracing config selector\n */\nexport interface ConfigSelectorOptions {\n  /** Request Context */\n  requestContext?: RequestContext;\n}\n\n/**\n * Function to select which tracing instance to use for a given span\n * Returns the name of the tracing instance, or undefined to use default\n */\nexport type ConfigSelector = (\n  options: ConfigSelectorOptions,\n  availableConfigs: ReadonlyMap<string, ObservabilityInstance>,\n) => string | undefined;\n","import type { Mastra } from '..';\nimport type { IMastraLogger } from '../logger';\nimport type { ObservabilityInstance, ConfigSelectorOptions, ObservabilityEntrypoint, ConfigSelector } from './types';\n\nexport class NoOpObservability implements ObservabilityEntrypoint {\n  setMastraContext(_options: { mastra: Mastra }): void {\n    return;\n  }\n\n  setLogger(_options: { logger: IMastraLogger }): void {\n    return;\n  }\n\n  getSelectedInstance(_options: ConfigSelectorOptions): ObservabilityInstance | undefined {\n    return;\n  }\n\n  registerInstance(_name: string, _instance: ObservabilityInstance, _isDefault = false): void {\n    return;\n  }\n\n  getInstance(_name: string): ObservabilityInstance | undefined {\n    return;\n  }\n\n  getDefaultInstance(): ObservabilityInstance | undefined {\n    return;\n  }\n\n  listInstances(): ReadonlyMap<string, ObservabilityInstance> {\n    return new Map();\n  }\n\n  unregisterInstance(_name: string): boolean {\n    return false;\n  }\n\n  hasInstance(_name: string): boolean {\n    return false;\n  }\n\n  setConfigSelector(_selector: ConfigSelector): void {\n    return;\n  }\n\n  clear(): void {\n    return;\n  }\n\n  async shutdown(): Promise<void> {\n    return;\n  }\n}\n","import type { Span, SpanType, GetOrCreateSpanOptions, AnySpan } from './types';\n\n/**\n * Creates or gets a child span from existing tracing context or starts a new trace.\n * This helper consolidates the common pattern of creating spans that can either be:\n * 1. Children of an existing span (when tracingContext.currentSpan exists)\n * 2. New root spans (when no current span exists)\n *\n * @param options - Configuration object for span creation\n * @returns The created Span or undefined if tracing is disabled\n */\nexport function getOrCreateSpan<T extends SpanType>(options: GetOrCreateSpanOptions<T>): Span<T> | undefined {\n  const { type, attributes, tracingContext, requestContext, tracingOptions, ...rest } = options;\n\n  const metadata = {\n    ...(rest.metadata ?? {}),\n    ...(tracingOptions?.metadata ?? {}),\n  };\n\n  // If we have a current span, create a child span\n  if (tracingContext?.currentSpan) {\n    return tracingContext.currentSpan.createChildSpan({\n      type,\n      attributes,\n      ...rest,\n      metadata,\n    });\n  }\n\n  // Otherwise, try to create a new root span\n  const instance = options.mastra?.observability?.getSelectedInstance({ requestContext });\n\n  return instance?.startSpan<T>({\n    type,\n    attributes,\n    ...rest,\n    metadata,\n    requestContext,\n    tracingOptions,\n    traceId: tracingOptions?.traceId,\n    parentSpanId: tracingOptions?.parentSpanId,\n    customSamplerOptions: {\n      requestContext,\n      metadata,\n    },\n  });\n}\n\n/**\n * Execute an async function within the span's tracing context if available.\n * Falls back to direct execution if no span exists.\n *\n * When a bridge is configured, this enables auto-instrumented operations\n * (HTTP requests, database queries, etc.) to be properly nested under the\n * current span in the external tracing system.\n *\n * @param span - The span to use as context (or undefined to execute without context)\n * @param fn - The async function to execute\n * @returns The result of the function execution\n *\n * @example\n * ```typescript\n * const result = await executeWithContext(llmSpan, async () =>\n *   model.generateText(args)\n * );\n * ```\n */\nexport async function executeWithContext<T>(params: { span?: AnySpan; fn: () => Promise<T> }): Promise<T> {\n  const { span, fn } = params;\n\n  if (span?.executeInContext) {\n    return span.executeInContext(fn);\n  }\n\n  return fn();\n}\n\n/**\n * Execute a synchronous function within the span's tracing context if available.\n * Falls back to direct execution if no span exists.\n *\n * When a bridge is configured, this enables auto-instrumented operations\n * (HTTP requests, database queries, etc.) to be properly nested under the\n * current span in the external tracing system.\n *\n * @param span - The span to use as context (or undefined to execute without context)\n * @param fn - The synchronous function to execute\n * @returns The result of the function execution\n *\n * @example\n * ```typescript\n * const result = executeWithContextSync(llmSpan, () =>\n *   model.streamText(args)\n * );\n * ```\n */\nexport function executeWithContextSync<T>(params: { span?: AnySpan; fn: () => T }): T {\n  const { span, fn } = params;\n\n  if (span?.executeInContextSync) {\n    return span.executeInContextSync(fn);\n  }\n\n  return fn();\n}\n","/**\n * Tracing Context Integration\n *\n * This module provides automatic tracing context propagation throughout Mastra's execution contexts.\n * It uses JavaScript Proxies to transparently wrap Mastra, Agent, and Workflow instances so that\n * tracing context is automatically injected without requiring manual passing by users.\n */\n\nimport type { MastraPrimitives } from '../action';\nimport type { Agent } from '../agent';\nimport type { Mastra } from '../mastra';\nimport type { Workflow } from '../workflows';\nimport type { TracingContext, AnySpan } from './types';\n\nconst AGENT_GETTERS = ['getAgent', 'getAgentById'];\nconst AGENT_METHODS_TO_WRAP = ['generate', 'stream', 'generateLegacy', 'streamLegacy'];\n\nconst WORKFLOW_GETTERS = ['getWorkflow', 'getWorkflowById'];\nconst WORKFLOW_METHODS_TO_WRAP = ['execute', 'createRun', 'createRun'];\n\n/**\n * Helper function to detect NoOp spans to avoid unnecessary wrapping\n */\nfunction isNoOpSpan(span: AnySpan): boolean {\n  // Check if this is a NoOp span implementation\n  return span.constructor.name === 'NoOpSpan' || (span as any).__isNoOp === true;\n}\n\n/**\n * Checks to see if a passed object is an actual instance of Mastra\n * (for the purposes of wrapping it for Tracing)\n */\nexport function isMastra<T extends Mastra | (Mastra & MastraPrimitives) | MastraPrimitives>(mastra: T): boolean {\n  const hasAgentGetters = AGENT_GETTERS.every(method => typeof (mastra as any)?.[method] === 'function');\n  const hasWorkflowGetters = WORKFLOW_GETTERS.every(method => typeof (mastra as any)?.[method] === 'function');\n\n  return hasAgentGetters && hasWorkflowGetters;\n}\n\n/**\n * Creates a tracing-aware Mastra proxy that automatically injects\n * tracing context into agent and workflow method calls\n */\nexport function wrapMastra<T extends Mastra | (Mastra & MastraPrimitives) | MastraPrimitives>(\n  mastra: T,\n  tracingContext: TracingContext,\n): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return mastra;\n  }\n\n  // Check if this object has the methods we want to wrap - if not, return as is\n  if (!isMastra(mastra)) {\n    return mastra;\n  }\n\n  try {\n    return new Proxy(mastra, {\n      get(target, prop) {\n        try {\n          if (AGENT_GETTERS.includes(prop as string)) {\n            return (...args: any[]) => {\n              const agent = (target as any)[prop](...args);\n              return wrapAgent(agent, tracingContext);\n            };\n          }\n\n          // Wrap workflow getters\n          if (WORKFLOW_GETTERS.includes(prop as string)) {\n            return (...args: any[]) => {\n              const workflow = (target as any)[prop](...args);\n              return wrapWorkflow(workflow, tracingContext);\n            };\n          }\n\n          // Pass through all other methods unchanged - bind functions to preserve 'this' context\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('Tracing: Failed to wrap method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('Tracing: Failed to create proxy, using original Mastra instance', error);\n    return mastra;\n  }\n}\n\n/**\n * Creates a tracing-aware Agent proxy that automatically injects\n * tracing context into generation method calls\n */\nfunction wrapAgent<T extends Agent>(agent: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return agent;\n  }\n\n  try {\n    return new Proxy(agent, {\n      get(target, prop) {\n        try {\n          if (AGENT_METHODS_TO_WRAP.includes(prop as string)) {\n            return (input: any, options: any = {}) => {\n              return (target as any)[prop](input, {\n                ...options,\n                tracingContext,\n              });\n            };\n          }\n\n          // Bind functions to preserve 'this' context for private member access\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('Tracing: Failed to wrap agent method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('Tracing: Failed to create agent proxy, using original instance', error);\n    return agent;\n  }\n}\n\n/**\n * Creates a tracing-aware Workflow proxy that automatically injects\n * tracing context into execution method calls\n */\nfunction wrapWorkflow<T extends Workflow>(workflow: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return workflow;\n  }\n\n  try {\n    return new Proxy(workflow, {\n      get(target, prop) {\n        try {\n          // Wrap workflow execution methods with tracing context\n          if (WORKFLOW_METHODS_TO_WRAP.includes(prop as string)) {\n            // Handle createRun and createRun methods differently\n            if (prop === 'createRun' || prop === 'createRun') {\n              return async (options: any = {}) => {\n                const run = await (target as any)[prop](options);\n                return run ? wrapRun(run, tracingContext) : run;\n              };\n            }\n\n            // Handle other methods like execute\n            return (input: any, options: any = {}) => {\n              return (target as any)[prop](input, {\n                ...options,\n                tracingContext,\n              });\n            };\n          }\n\n          // Bind functions to preserve 'this' context for private member access\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('Tracing: Failed to wrap workflow method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('Tracing: Failed to create workflow proxy, using original instance', error);\n    return workflow;\n  }\n}\n\n/**\n * Creates a tracing-aware Run proxy that automatically injects\n * tracing context into start method calls\n */\nfunction wrapRun<T extends object>(run: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return run;\n  }\n\n  try {\n    return new Proxy(run, {\n      get(target, prop) {\n        try {\n          if (prop === 'start') {\n            return (startOptions: any = {}) => {\n              return (target as any).start({\n                ...startOptions,\n                tracingContext: startOptions.tracingContext ?? tracingContext,\n              });\n            };\n          }\n\n          // Pass through all other properties and methods unchanged\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('Tracing: Failed to wrap run method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('Tracing: Failed to create run proxy, using original instance', error);\n    return run;\n  }\n}\n"]}