'use strict';

var chunkPS5SHNDR_cjs = require('./chunk-PS5SHNDR.cjs');
var chunkLJOQ7WYC_cjs = require('./chunk-LJOQ7WYC.cjs');
var chunkJ4KVR4DZ_cjs = require('./chunk-J4KVR4DZ.cjs');
var chunk4U7ZLI36_cjs = require('./chunk-4U7ZLI36.cjs');
var chunkOZ75PBBK_cjs = require('./chunk-OZ75PBBK.cjs');
var chunkSMM2C4KH_cjs = require('./chunk-SMM2C4KH.cjs');
var chunkDGV2FWB4_cjs = require('./chunk-DGV2FWB4.cjs');
var chunkAF74UXR5_cjs = require('./chunk-AF74UXR5.cjs');
var EventEmitter = require('events');
var crypto = require('crypto');
var zod = require('zod');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var EventEmitter__default = /*#__PURE__*/_interopDefault(EventEmitter);

var StepExecutor = class extends chunkDGV2FWB4_cjs.MastraBase {
  mastra;
  constructor({ mastra }) {
    super({ name: "StepExecutor", component: chunkAF74UXR5_cjs.RegisteredLogger.WORKFLOW });
    this.mastra = mastra;
  }
  __registerMastra(mastra) {
    this.mastra = mastra;
  }
  async execute(params) {
    const { step, stepResults, runId, requestContext, retryCount = 0, perStep } = params;
    const abortController = params.abortController ?? new AbortController();
    let suspended;
    let bailed;
    const startedAt = Date.now();
    const { inputData, validationError } = await chunkPS5SHNDR_cjs.validateStepInput({
      prevOutput: typeof params.foreachIdx === "number" ? params.input?.[params.foreachIdx] : params.input,
      step,
      validateInputs: params.validateInputs ?? true
    });
    let stepInfo = {
      ...stepResults[step.id],
      startedAt,
      payload: (typeof params.foreachIdx === "number" ? params.input : inputData) ?? {}
    };
    if (params.resumeData) {
      delete stepInfo.suspendPayload?.["__workflow_meta"];
      stepInfo.resumePayload = params.resumeData;
      stepInfo.resumedAt = Date.now();
    }
    let suspendDataToUse = params.stepResults[step.id]?.status === "suspended" ? params.stepResults[step.id]?.suspendPayload : void 0;
    if (suspendDataToUse && "__workflow_meta" in suspendDataToUse) {
      const { __workflow_meta, ...userSuspendData } = suspendDataToUse;
      suspendDataToUse = userSuspendData;
    }
    try {
      if (validationError) {
        throw validationError;
      }
      const stepOutput = await step.execute(
        chunkPS5SHNDR_cjs.createDeprecationProxy(
          {
            workflowId: params.workflowId,
            runId,
            mastra: this.mastra,
            requestContext,
            inputData,
            state: params.state,
            setState: async (state) => {
              params.state = state;
            },
            retryCount,
            resumeData: params.resumeData,
            suspendData: suspendDataToUse,
            getInitData: () => stepResults?.input,
            getStepResult: chunkPS5SHNDR_cjs.getStepResult.bind(this, stepResults),
            suspend: async (suspendPayload) => {
              const { suspendData, validationError: validationError2 } = await chunkPS5SHNDR_cjs.validateStepSuspendData({
                suspendData: suspendPayload,
                step,
                validateInputs: params.validateInputs ?? true
              });
              if (validationError2) {
                throw validationError2;
              }
              suspended = { payload: { ...suspendData, __workflow_meta: { runId, path: [step.id] } } };
            },
            bail: (result) => {
              bailed = { payload: result };
            },
            // TODO
            writer: void 0,
            abort: () => {
              abortController?.abort();
            },
            [chunkLJOQ7WYC_cjs.PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new chunkPS5SHNDR_cjs.EventEmitterPubSub(params.emitter),
            [chunkLJOQ7WYC_cjs.STREAM_FORMAT_SYMBOL]: void 0,
            // TODO
            engine: {},
            abortSignal: abortController?.signal,
            // TODO
            tracingContext: {}
          },
          {
            paramName: "runCount",
            deprecationMessage: chunkPS5SHNDR_cjs.runCountDeprecationMessage,
            logger: this.logger
          }
        )
      );
      const isNestedWorkflowStep = step.component === "WORKFLOW";
      const nestedWflowStepPaused = isNestedWorkflowStep && perStep;
      const endedAt = Date.now();
      let finalResult;
      if (suspended) {
        finalResult = {
          ...stepInfo,
          status: "suspended",
          suspendedAt: endedAt,
          ...stepOutput ? { suspendOutput: stepOutput } : {}
        };
        if (suspended.payload) {
          finalResult.suspendPayload = suspended.payload;
        }
      } else if (bailed) {
        finalResult = {
          ...stepInfo,
          // @ts-ignore
          status: "bailed",
          endedAt,
          output: bailed.payload
        };
      } else if (nestedWflowStepPaused) {
        finalResult = {
          ...stepInfo,
          status: "paused"
        };
      } else {
        finalResult = {
          ...stepInfo,
          status: "success",
          endedAt,
          output: stepOutput
        };
      }
      return finalResult;
    } catch (error) {
      const endedAt = Date.now();
      const errorInstance = chunk4U7ZLI36_cjs.getErrorFromUnknown(error, {
        serializeStack: false,
        fallbackMessage: "Unknown step execution error"
      });
      return {
        ...stepInfo,
        status: "failed",
        endedAt,
        error: errorInstance
      };
    }
  }
  async evaluateConditions(params) {
    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;
    const abortController = params.abortController ?? new AbortController();
    const ee = new EventEmitter__default.default();
    const results = await Promise.all(
      step.conditions.map((condition) => {
        try {
          return this.evaluateCondition({
            workflowId: params.workflowId,
            condition,
            runId,
            requestContext,
            inputData: params.input,
            state: params.state,
            retryCount,
            resumeData: params.resumeData,
            abortController,
            stepResults,
            emitter: ee,
            iterationCount: 0
          });
        } catch (e) {
          this.mastra?.getLogger()?.error("error evaluating condition", e);
          return false;
        }
      })
    );
    const idxs = results.reduce((acc, result, idx) => {
      if (result) {
        acc.push(idx);
      }
      return acc;
    }, []);
    return idxs;
  }
  async evaluateCondition({
    workflowId,
    condition,
    runId,
    inputData,
    resumeData,
    stepResults,
    state,
    requestContext,
    emitter,
    abortController,
    retryCount = 0,
    iterationCount
  }) {
    return condition(
      chunkPS5SHNDR_cjs.createDeprecationProxy(
        {
          workflowId,
          runId,
          mastra: this.mastra,
          requestContext,
          inputData,
          state,
          retryCount,
          resumeData,
          getInitData: () => stepResults?.input,
          getStepResult: chunkPS5SHNDR_cjs.getStepResult.bind(this, stepResults),
          bail: (_result) => {
            throw new Error("Not implemented");
          },
          // TODO
          writer: void 0,
          abort: () => {
            abortController?.abort();
          },
          [chunkLJOQ7WYC_cjs.PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new chunkPS5SHNDR_cjs.EventEmitterPubSub(emitter),
          [chunkLJOQ7WYC_cjs.STREAM_FORMAT_SYMBOL]: void 0,
          // TODO
          engine: {},
          abortSignal: abortController?.signal,
          // TODO
          tracingContext: {},
          iterationCount
        },
        {
          paramName: "runCount",
          deprecationMessage: chunkPS5SHNDR_cjs.runCountDeprecationMessage,
          logger: this.logger
        }
      )
    );
  }
  async resolveSleep(params) {
    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;
    const abortController = params.abortController ?? new AbortController();
    const ee = new EventEmitter__default.default();
    if (step.duration) {
      return step.duration;
    }
    if (!step.fn) {
      return 0;
    }
    try {
      return await step.fn(
        chunkPS5SHNDR_cjs.createDeprecationProxy(
          {
            workflowId: params.workflowId,
            runId,
            mastra: this.mastra,
            requestContext,
            inputData: params.input,
            // TODO: implement state
            state: {},
            setState: async (_state) => {
            },
            retryCount,
            resumeData: params.resumeData,
            getInitData: () => stepResults?.input,
            getStepResult: chunkPS5SHNDR_cjs.getStepResult.bind(this, stepResults),
            suspend: async (_suspendPayload) => {
              throw new Error("Not implemented");
            },
            bail: (_result) => {
              throw new Error("Not implemented");
            },
            abort: () => {
              abortController?.abort();
            },
            // TODO
            writer: void 0,
            [chunkLJOQ7WYC_cjs.PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new chunkPS5SHNDR_cjs.EventEmitterPubSub(ee),
            [chunkLJOQ7WYC_cjs.STREAM_FORMAT_SYMBOL]: void 0,
            // TODO
            engine: {},
            abortSignal: abortController?.signal,
            // TODO
            tracingContext: {}
          },
          {
            paramName: "runCount",
            deprecationMessage: chunkPS5SHNDR_cjs.runCountDeprecationMessage,
            logger: this.logger
          }
        )
      );
    } catch (e) {
      this.mastra?.getLogger()?.error("error evaluating condition", e);
      return 0;
    }
  }
  async resolveSleepUntil(params) {
    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;
    const abortController = params.abortController ?? new AbortController();
    const ee = new EventEmitter__default.default();
    if (step.date) {
      return step.date.getTime() - Date.now();
    }
    if (!step.fn) {
      return 0;
    }
    try {
      const result = await step.fn(
        chunkPS5SHNDR_cjs.createDeprecationProxy(
          {
            workflowId: params.workflowId,
            runId,
            mastra: this.mastra,
            requestContext,
            inputData: params.input,
            // TODO: implement state
            state: {},
            setState: async (_state) => {
            },
            retryCount,
            resumeData: params.resumeData,
            getInitData: () => stepResults?.input,
            getStepResult: chunkPS5SHNDR_cjs.getStepResult.bind(this, stepResults),
            suspend: async (_suspendPayload) => {
              throw new Error("Not implemented");
            },
            bail: (_result) => {
              throw new Error("Not implemented");
            },
            abort: () => {
              abortController?.abort();
            },
            // TODO
            writer: void 0,
            [chunkLJOQ7WYC_cjs.PUBSUB_SYMBOL]: this.mastra?.pubsub ?? new chunkPS5SHNDR_cjs.EventEmitterPubSub(ee),
            [chunkLJOQ7WYC_cjs.STREAM_FORMAT_SYMBOL]: void 0,
            // TODO
            engine: {},
            abortSignal: abortController?.signal,
            // TODO
            tracingContext: {}
          },
          {
            paramName: "runCount",
            deprecationMessage: chunkPS5SHNDR_cjs.runCountDeprecationMessage,
            logger: this.logger
          }
        )
      );
      return result.getTime() - Date.now();
    } catch (e) {
      this.mastra?.getLogger()?.error("error evaluating condition", e);
      return 0;
    }
  }
};

// src/events/processor.ts
var EventProcessor = class {
  mastra;
  __registerMastra(mastra) {
    this.mastra = mastra;
  }
  constructor({ mastra }) {
    this.mastra = mastra;
  }
};
async function processWorkflowLoop({
  workflowId,
  prevResult,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  resumeData,
  parentWorkflow,
  requestContext,
  retryCount = 0,
  perStep
}, {
  pubsub,
  stepExecutor,
  step,
  stepResult
}) {
  const loopCondition = await stepExecutor.evaluateCondition({
    workflowId,
    condition: step.condition,
    runId,
    stepResults,
    // TODO: implement state
    state: {},
    emitter: new EventEmitter__default.default(),
    // TODO
    requestContext: new chunkSMM2C4KH_cjs.RequestContext(),
    // TODO
    inputData: prevResult?.status === "success" ? prevResult.output : void 0,
    resumeData,
    abortController: new AbortController(),
    retryCount,
    iterationCount: 0
    //TODO: implement
  });
  if (step.loopType === "dountil") {
    if (loopCondition) {
      await pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult: stepResult,
          resumeData,
          activeSteps,
          requestContext,
          perStep
        }
      });
    } else {
      await pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult: stepResult,
          resumeData,
          activeSteps,
          requestContext,
          retryCount,
          perStep
        }
      });
    }
  } else {
    if (loopCondition) {
      await pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult: stepResult,
          resumeData,
          activeSteps,
          requestContext,
          retryCount,
          perStep
        }
      });
    } else {
      await pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult: stepResult,
          resumeData,
          activeSteps,
          requestContext,
          perStep
        }
      });
    }
  }
}
async function processWorkflowForEach({
  workflowId,
  prevResult,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  timeTravel,
  resumeData,
  parentWorkflow,
  requestContext,
  perStep
}, {
  pubsub,
  mastra,
  step
}) {
  const currentResult = stepResults[step.step.id];
  const idx = currentResult?.output?.length ?? 0;
  const targetLen = prevResult?.output?.length ?? 0;
  if (idx >= targetLen && currentResult.output.filter((r) => r !== null).length >= targetLen) {
    await pubsub.publish("workflows", {
      type: "workflow.step.run",
      runId,
      data: {
        parentWorkflow,
        workflowId,
        runId,
        executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1] + 1]),
        resumeSteps,
        stepResults,
        timeTravel,
        prevResult: currentResult,
        resumeData,
        activeSteps,
        requestContext,
        perStep
      }
    });
    return;
  } else if (idx >= targetLen) {
    return;
  }
  const workflowsStore = await mastra.getStorage()?.getStore("workflows");
  if (executionPath.length === 1 && idx === 0) {
    const concurrency = Math.min(step.opts.concurrency ?? 1, targetLen);
    const dummyResult = Array.from({ length: concurrency }, () => null);
    await workflowsStore?.updateWorkflowResults({
      workflowName: workflowId,
      runId,
      stepId: step.step.id,
      result: {
        status: "success",
        output: dummyResult,
        startedAt: Date.now(),
        payload: prevResult?.output
      },
      requestContext
    });
    for (let i = 0; i < concurrency; i++) {
      await pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath: [executionPath[0], i],
          resumeSteps,
          stepResults,
          timeTravel,
          prevResult,
          resumeData,
          activeSteps,
          requestContext,
          perStep
        }
      });
    }
    return;
  }
  currentResult.output.push(null);
  await workflowsStore?.updateWorkflowResults({
    workflowName: workflowId,
    runId,
    stepId: step.step.id,
    result: {
      status: "success",
      output: currentResult.output,
      startedAt: Date.now(),
      payload: prevResult?.output
    },
    requestContext
  });
  await pubsub.publish("workflows", {
    type: "workflow.step.run",
    runId,
    data: {
      parentWorkflow,
      workflowId,
      runId,
      executionPath: [executionPath[0], idx],
      resumeSteps,
      timeTravel,
      stepResults,
      prevResult,
      resumeData,
      activeSteps,
      requestContext,
      perStep
    }
  });
}
async function processWorkflowParallel({
  workflowId,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  timeTravel,
  prevResult,
  resumeData,
  parentWorkflow,
  requestContext,
  perStep
}, {
  pubsub,
  step
}) {
  for (let i = 0; i < step.steps.length; i++) {
    const nestedStep = step.steps[i];
    if (nestedStep?.type === "step") {
      activeSteps[nestedStep.step.id] = true;
      if (perStep) {
        break;
      }
    }
  }
  await Promise.all(
    step.steps?.filter((step2) => activeSteps[step2.step.id]).map(async (_step, idx) => {
      return pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          workflowId,
          runId,
          executionPath: executionPath.concat([idx]),
          resumeSteps,
          stepResults,
          prevResult,
          resumeData,
          timeTravel,
          parentWorkflow,
          activeSteps,
          requestContext,
          perStep
        }
      });
    })
  );
}
async function processWorkflowConditional({
  workflowId,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  timeTravel,
  prevResult,
  resumeData,
  parentWorkflow,
  requestContext,
  perStep
}, {
  pubsub,
  stepExecutor,
  step
}) {
  const idxs = await stepExecutor.evaluateConditions({
    workflowId,
    step,
    runId,
    stepResults,
    // TODO: implement state
    state: {},
    emitter: new EventEmitter__default.default(),
    // TODO
    requestContext: new chunkSMM2C4KH_cjs.RequestContext(),
    // TODO
    input: prevResult?.status === "success" ? prevResult.output : void 0,
    resumeData
  });
  const truthyIdxs = {};
  for (let i = 0; i < idxs.length; i++) {
    truthyIdxs[idxs[i]] = true;
  }
  let onlyStepToRun;
  if (perStep) {
    const stepsToRun = step.steps.filter((_, idx) => truthyIdxs[idx]);
    onlyStepToRun = stepsToRun[0];
  }
  if (onlyStepToRun) {
    activeSteps[onlyStepToRun.step.id] = true;
    const stepIndex = step.steps.findIndex((step2) => step2.step.id === onlyStepToRun.step.id);
    await pubsub.publish("workflows", {
      type: "workflow.step.run",
      runId,
      data: {
        workflowId,
        runId,
        executionPath: executionPath.concat([stepIndex]),
        resumeSteps,
        stepResults,
        timeTravel,
        prevResult,
        resumeData,
        parentWorkflow,
        activeSteps,
        requestContext,
        perStep
      }
    });
  } else {
    await Promise.all(
      step.steps.map(async (step2, idx) => {
        if (truthyIdxs[idx]) {
          if (step2?.type === "step") {
            activeSteps[step2.step.id] = true;
          }
          return pubsub.publish("workflows", {
            type: "workflow.step.run",
            runId,
            data: {
              workflowId,
              runId,
              executionPath: executionPath.concat([idx]),
              resumeSteps,
              stepResults,
              timeTravel,
              prevResult,
              resumeData,
              parentWorkflow,
              activeSteps,
              requestContext,
              perStep
            }
          });
        } else {
          return pubsub.publish("workflows", {
            type: "workflow.step.end",
            runId,
            data: {
              workflowId,
              runId,
              executionPath: executionPath.concat([idx]),
              resumeSteps,
              stepResults,
              prevResult: { status: "skipped" },
              resumeData,
              parentWorkflow,
              activeSteps,
              requestContext,
              perStep
            }
          });
        }
      })
    );
  }
}
async function processWorkflowWaitForEvent(workflowData, {
  pubsub,
  eventName,
  currentState
}) {
  const executionPath = currentState?.waitingPaths[eventName];
  if (!executionPath) {
    return;
  }
  const currentStep = getStep(workflowData.workflow, executionPath);
  const prevResult = {
    status: "success",
    output: currentState?.context[currentStep?.id ?? "input"]?.payload
  };
  await pubsub.publish("workflows", {
    type: "workflow.step.run",
    runId: workflowData.runId,
    data: {
      workflowId: workflowData.workflowId,
      runId: workflowData.runId,
      executionPath,
      resumeSteps: [],
      resumeData: workflowData.resumeData,
      parentWorkflow: workflowData.parentWorkflow,
      stepResults: currentState?.context,
      prevResult,
      activeSteps: [],
      requestContext: currentState?.requestContext,
      perStep: workflowData.perStep
    }
  });
}
async function processWorkflowSleep({
  workflowId,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  timeTravel,
  prevResult,
  resumeData,
  parentWorkflow,
  requestContext,
  perStep
}, {
  pubsub,
  stepExecutor,
  step
}) {
  const startedAt = Date.now();
  await pubsub.publish(`workflow.events.v2.${runId}`, {
    type: "watch",
    runId,
    data: {
      type: "workflow-step-waiting",
      payload: {
        id: step.id,
        status: "waiting",
        payload: prevResult.status === "success" ? prevResult.output : void 0,
        startedAt
      }
    }
  });
  const duration = await stepExecutor.resolveSleep({
    workflowId,
    step,
    runId,
    stepResults,
    emitter: new EventEmitter__default.default(),
    // TODO
    requestContext: new chunkSMM2C4KH_cjs.RequestContext(),
    // TODO
    input: prevResult?.status === "success" ? prevResult.output : void 0,
    resumeData
  });
  setTimeout(
    async () => {
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-result",
          payload: {
            id: step.id,
            status: "success",
            payload: prevResult.status === "success" ? prevResult.output : void 0,
            output: prevResult.status === "success" ? prevResult.output : void 0,
            startedAt,
            endedAt: Date.now()
          }
        }
      });
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-finish",
          payload: {
            id: step.id,
            metadata: {}
          }
        }
      });
      await pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          workflowId,
          runId,
          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1] + 1]),
          resumeSteps,
          timeTravel,
          stepResults,
          prevResult,
          resumeData,
          parentWorkflow,
          activeSteps,
          requestContext,
          perStep
        }
      });
    },
    duration < 0 ? 0 : duration
  );
}
async function processWorkflowSleepUntil({
  workflowId,
  runId,
  executionPath,
  stepResults,
  activeSteps,
  resumeSteps,
  timeTravel,
  prevResult,
  resumeData,
  parentWorkflow,
  requestContext,
  perStep
}, {
  pubsub,
  stepExecutor,
  step
}) {
  const startedAt = Date.now();
  const duration = await stepExecutor.resolveSleepUntil({
    workflowId,
    step,
    runId,
    stepResults,
    emitter: new EventEmitter__default.default(),
    // TODO
    requestContext: new chunkSMM2C4KH_cjs.RequestContext(),
    // TODO
    input: prevResult?.status === "success" ? prevResult.output : void 0,
    resumeData
  });
  await pubsub.publish(`workflow.events.v2.${runId}`, {
    type: "watch",
    runId,
    data: {
      type: "workflow-step-waiting",
      payload: {
        id: step.id,
        status: "waiting",
        payload: prevResult.status === "success" ? prevResult.output : void 0,
        startedAt
      }
    }
  });
  setTimeout(
    async () => {
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-result",
          payload: {
            id: step.id,
            status: "success",
            payload: prevResult.status === "success" ? prevResult.output : void 0,
            output: prevResult.status === "success" ? prevResult.output : void 0,
            startedAt,
            endedAt: Date.now()
          }
        }
      });
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-finish",
          payload: {
            id: step.id,
            metadata: {}
          }
        }
      });
      await pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          workflowId,
          runId,
          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1] + 1]),
          resumeSteps,
          timeTravel,
          stepResults,
          prevResult,
          resumeData,
          parentWorkflow,
          activeSteps,
          requestContext,
          perStep
        }
      });
    },
    duration < 0 ? 0 : duration
  );
}

// src/workflows/evented/workflow-event-processor/index.ts
var WorkflowEventProcessor = class extends EventProcessor {
  stepExecutor;
  // Map of runId -> AbortController for active workflow runs
  abortControllers = /* @__PURE__ */ new Map();
  // Map of child runId -> parent runId for tracking nested workflows
  parentChildRelationships = /* @__PURE__ */ new Map();
  constructor({ mastra }) {
    super({ mastra });
    this.stepExecutor = new StepExecutor({ mastra });
  }
  /**
   * Get or create an AbortController for a workflow run
   */
  getOrCreateAbortController(runId) {
    let controller = this.abortControllers.get(runId);
    if (!controller) {
      controller = new AbortController();
      this.abortControllers.set(runId, controller);
    }
    return controller;
  }
  /**
   * Cancel a workflow run and all its nested child workflows
   */
  cancelRunAndChildren(runId) {
    const controller = this.abortControllers.get(runId);
    if (controller) {
      controller.abort();
    }
    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {
      if (parentRunId === runId) {
        this.cancelRunAndChildren(childRunId);
      }
    }
  }
  /**
   * Clean up abort controller and relationships when a workflow completes.
   * Also cleans up any orphaned child entries that reference this run as parent.
   */
  cleanupRun(runId) {
    this.abortControllers.delete(runId);
    this.parentChildRelationships.delete(runId);
    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {
      if (parentRunId === runId) {
        this.parentChildRelationships.delete(childRunId);
      }
    }
  }
  __registerMastra(mastra) {
    super.__registerMastra(mastra);
    this.stepExecutor.__registerMastra(mastra);
  }
  async errorWorkflow({
    parentWorkflow,
    workflowId,
    runId,
    resumeSteps,
    stepResults,
    resumeData,
    requestContext
  }, e) {
    await this.mastra.pubsub.publish("workflows", {
      type: "workflow.fail",
      runId,
      data: {
        workflowId,
        runId,
        executionPath: [],
        resumeSteps,
        stepResults,
        prevResult: { status: "failed", error: chunk4U7ZLI36_cjs.getErrorFromUnknown(e).toJSON() },
        requestContext,
        resumeData,
        activeSteps: {},
        parentWorkflow
      }
    });
  }
  async processWorkflowCancel({ workflowId, runId }) {
    this.cancelRunAndChildren(runId);
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    const currentState = await workflowsStore?.loadWorkflowSnapshot({
      workflowName: workflowId,
      runId
    });
    if (!currentState) {
      this.mastra.getLogger()?.warn("Canceling workflow without loaded state", { workflowId, runId });
    }
    await this.endWorkflow(
      {
        workflow: void 0,
        workflowId,
        runId,
        stepResults: currentState?.context ?? {},
        prevResult: { status: "canceled" },
        requestContext: currentState?.requestContext ?? {},
        executionPath: [],
        activeSteps: {},
        resumeSteps: [],
        resumeData: void 0,
        parentWorkflow: void 0
      },
      "canceled"
    );
  }
  async processWorkflowStart({
    workflow,
    parentWorkflow,
    workflowId,
    runId,
    resumeSteps,
    prevResult,
    resumeData,
    timeTravel,
    executionPath,
    stepResults,
    requestContext,
    perStep
  }) {
    this.getOrCreateAbortController(runId);
    if (parentWorkflow?.runId) {
      this.parentChildRelationships.set(runId, parentWorkflow.runId);
    }
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    const existingRun = await workflowsStore?.getWorkflowRunById({ runId, workflowName: workflow.id });
    const resourceId = existingRun?.resourceId;
    await workflowsStore?.persistWorkflowSnapshot({
      workflowName: workflow.id,
      runId,
      resourceId,
      snapshot: {
        activePaths: [],
        suspendedPaths: {},
        resumeLabels: {},
        waitingPaths: {},
        activeStepsPath: {},
        serializedStepGraph: workflow.serializedStepGraph,
        timestamp: Date.now(),
        runId,
        context: stepResults ?? {
          input: prevResult?.status === "success" ? prevResult.output : void 0
        },
        status: "running",
        value: {}
      }
    });
    await this.mastra.pubsub.publish("workflows", {
      type: "workflow.step.run",
      runId,
      data: {
        parentWorkflow,
        workflowId,
        runId,
        executionPath: executionPath ?? [0],
        resumeSteps,
        stepResults: stepResults ?? {
          input: prevResult?.status === "success" ? prevResult.output : void 0
        },
        prevResult,
        timeTravel,
        requestContext,
        resumeData,
        activeSteps: {},
        perStep
      }
    });
  }
  async endWorkflow(args, status = "success") {
    const { workflowId, runId, prevResult, perStep } = args;
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    await workflowsStore?.updateWorkflowState({
      workflowName: workflowId,
      runId,
      opts: {
        status: perStep && status === "success" ? "paused" : status,
        result: prevResult
      }
    });
    if (perStep) {
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-paused",
          payload: {}
        }
      });
    }
    await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
      type: "watch",
      runId,
      data: {
        type: "workflow-finish",
        payload: {
          runId
        }
      }
    });
    await this.mastra.pubsub.publish("workflows", {
      type: "workflow.end",
      runId,
      data: { ...args, workflow: void 0 }
    });
  }
  async processWorkflowEnd(args) {
    const {
      resumeSteps,
      prevResult,
      resumeData,
      parentWorkflow,
      activeSteps,
      requestContext,
      runId,
      timeTravel,
      perStep
    } = args;
    this.cleanupRun(runId);
    if (parentWorkflow) {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          workflowId: parentWorkflow.workflowId,
          runId: parentWorkflow.runId,
          executionPath: parentWorkflow.executionPath,
          resumeSteps,
          stepResults: parentWorkflow.stepResults,
          prevResult,
          resumeData,
          activeSteps,
          parentWorkflow: parentWorkflow.parentWorkflow,
          parentContext: parentWorkflow,
          requestContext,
          timeTravel,
          perStep
        }
      });
    }
    await this.mastra.pubsub.publish("workflows-finish", {
      type: "workflow.end",
      runId,
      data: { ...args, workflow: void 0 }
    });
  }
  async processWorkflowSuspend(args) {
    const { resumeSteps, prevResult, resumeData, parentWorkflow, activeSteps, runId, requestContext, timeTravel } = args;
    if (parentWorkflow) {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          workflowId: parentWorkflow.workflowId,
          runId: parentWorkflow.runId,
          executionPath: parentWorkflow.executionPath,
          resumeSteps,
          stepResults: parentWorkflow.stepResults,
          prevResult: {
            ...prevResult,
            suspendPayload: {
              ...prevResult.suspendPayload,
              __workflow_meta: {
                runId,
                path: parentWorkflow?.stepId ? [parentWorkflow.stepId].concat(prevResult.suspendPayload?.__workflow_meta?.path ?? []) : prevResult.suspendPayload?.__workflow_meta?.path ?? []
              }
            }
          },
          timeTravel,
          resumeData,
          activeSteps,
          requestContext,
          parentWorkflow: parentWorkflow.parentWorkflow,
          parentContext: parentWorkflow
        }
      });
    }
    await this.mastra.pubsub.publish("workflows-finish", {
      type: "workflow.suspend",
      runId,
      data: { ...args, workflow: void 0 }
    });
  }
  async processWorkflowFail(args) {
    const {
      workflowId,
      runId,
      resumeSteps,
      prevResult,
      resumeData,
      parentWorkflow,
      activeSteps,
      requestContext,
      timeTravel
    } = args;
    this.cleanupRun(runId);
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    await workflowsStore?.updateWorkflowState({
      workflowName: workflowId,
      runId,
      opts: {
        status: "failed",
        error: prevResult.error
      }
    });
    if (parentWorkflow) {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          workflowId: parentWorkflow.workflowId,
          runId: parentWorkflow.runId,
          executionPath: parentWorkflow.executionPath,
          resumeSteps,
          stepResults: parentWorkflow.stepResults,
          prevResult,
          timeTravel,
          resumeData,
          activeSteps,
          requestContext,
          parentWorkflow: parentWorkflow.parentWorkflow,
          parentContext: parentWorkflow
        }
      });
    }
    await this.mastra.pubsub.publish("workflows-finish", {
      type: "workflow.fail",
      runId,
      data: { ...args, workflow: void 0 }
    });
  }
  async processWorkflowStepRun({
    workflow,
    workflowId,
    runId,
    executionPath,
    stepResults,
    activeSteps,
    resumeSteps,
    timeTravel,
    prevResult,
    resumeData,
    parentWorkflow,
    requestContext,
    retryCount = 0,
    perStep
  }) {
    let stepGraph = workflow.stepGraph;
    if (!executionPath?.length) {
      return this.errorWorkflow(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext
        },
        new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_WORKFLOW",
          text: `Execution path is empty: ${JSON.stringify(executionPath)}`,
          domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
          category: "SYSTEM" /* SYSTEM */
        })
      );
    }
    let step = stepGraph[executionPath[0]];
    if (!step) {
      return this.errorWorkflow(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext
        },
        new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_WORKFLOW",
          text: `Step not found in step graph: ${JSON.stringify(executionPath)}`,
          domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
          category: "SYSTEM" /* SYSTEM */
        })
      );
    }
    if ((step.type === "parallel" || step.type === "conditional") && executionPath.length > 1) {
      step = step.steps[executionPath[1]];
    } else if (step.type === "parallel") {
      return processWorkflowParallel(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          timeTravel,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext,
          perStep
        },
        {
          pubsub: this.mastra.pubsub,
          step
        }
      );
    } else if (step?.type === "conditional") {
      return processWorkflowConditional(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          timeTravel,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext,
          perStep
        },
        {
          pubsub: this.mastra.pubsub,
          stepExecutor: this.stepExecutor,
          step
        }
      );
    } else if (step?.type === "sleep") {
      return processWorkflowSleep(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          timeTravel,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext,
          perStep
        },
        {
          pubsub: this.mastra.pubsub,
          stepExecutor: this.stepExecutor,
          step
        }
      );
    } else if (step?.type === "sleepUntil") {
      return processWorkflowSleepUntil(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          timeTravel,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext,
          perStep
        },
        {
          pubsub: this.mastra.pubsub,
          stepExecutor: this.stepExecutor,
          step
        }
      );
    } else if (step?.type === "foreach" && executionPath.length === 1) {
      return processWorkflowForEach(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          timeTravel,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext,
          perStep
        },
        {
          pubsub: this.mastra.pubsub,
          mastra: this.mastra,
          step
        }
      );
    }
    if (!isExecutableStep(step)) {
      return this.errorWorkflow(
        {
          workflowId,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          prevResult,
          resumeData,
          parentWorkflow,
          requestContext
        },
        new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_WORKFLOW",
          text: `Step is not executable: ${step?.type} -- ${JSON.stringify(executionPath)}`,
          domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
          category: "SYSTEM" /* SYSTEM */
        })
      );
    }
    activeSteps[step.step.id] = true;
    const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
    if (step.step instanceof EventedWorkflow) {
      if (resumeSteps?.length > 1) {
        const stepData = stepResults[step.step.id];
        const nestedRunId = stepData?.suspendPayload?.__workflow_meta?.runId;
        if (!nestedRunId) {
          return this.errorWorkflow(
            {
              workflowId,
              runId,
              executionPath,
              stepResults,
              activeSteps,
              resumeSteps,
              prevResult,
              resumeData,
              parentWorkflow,
              requestContext
            },
            new chunk4U7ZLI36_cjs.MastraError({
              id: "MASTRA_WORKFLOW",
              text: `Nested workflow run id not found: ${JSON.stringify(stepResults)}`,
              domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
              category: "SYSTEM" /* SYSTEM */
            })
          );
        }
        const snapshot = await workflowsStore?.loadWorkflowSnapshot({
          workflowName: step.step.id,
          runId: nestedRunId
        });
        const nestedStepResults = snapshot?.context;
        const nestedSteps = resumeSteps.slice(1);
        await this.mastra.pubsub.publish("workflows", {
          type: "workflow.resume",
          runId,
          data: {
            workflowId: step.step.id,
            parentWorkflow: {
              stepId: step.step.id,
              workflowId,
              runId,
              executionPath,
              resumeSteps,
              stepResults,
              input: prevResult,
              parentWorkflow
            },
            executionPath: snapshot?.suspendedPaths?.[nestedSteps[0]],
            runId: nestedRunId,
            resumeSteps: nestedSteps,
            stepResults: nestedStepResults,
            prevResult,
            resumeData,
            activeSteps,
            requestContext,
            perStep
          }
        });
      } else if (timeTravel && timeTravel.steps?.length > 1 && timeTravel.steps[0] === step.step.id) {
        const snapshot = await workflowsStore?.loadWorkflowSnapshot({
          workflowName: step.step.id,
          runId
        }) ?? { context: {} };
        const timeTravelParams = chunkPS5SHNDR_cjs.createTimeTravelExecutionParams({
          steps: timeTravel.steps.slice(1),
          inputData: timeTravel.inputData,
          resumeData: timeTravel.resumeData,
          context: timeTravel.nestedStepResults?.[step.step.id] ?? {},
          nestedStepsContext: timeTravel.nestedStepResults ?? {},
          snapshot,
          graph: step.step.buildExecutionGraph(),
          perStep
        });
        const nestedPrevStep = getStep(step.step, timeTravelParams.executionPath);
        const nestedPrevResult = timeTravelParams.stepResults[nestedPrevStep?.id ?? "input"];
        await this.mastra.pubsub.publish("workflows", {
          type: "workflow.start",
          runId,
          data: {
            workflowId: step.step.id,
            parentWorkflow: {
              stepId: step.step.id,
              workflowId,
              runId,
              executionPath,
              resumeSteps,
              stepResults,
              timeTravel,
              input: prevResult,
              parentWorkflow
            },
            executionPath: timeTravelParams.executionPath,
            runId: crypto.randomUUID(),
            stepResults: timeTravelParams.stepResults,
            prevResult: { status: "success", output: nestedPrevResult?.payload },
            timeTravel: timeTravelParams,
            activeSteps,
            requestContext,
            perStep
          }
        });
      } else {
        await this.mastra.pubsub.publish("workflows", {
          type: "workflow.start",
          runId,
          data: {
            workflowId: step.step.id,
            parentWorkflow: {
              stepId: step.step.id,
              workflowId,
              runId,
              executionPath,
              resumeSteps,
              stepResults,
              input: prevResult,
              parentWorkflow
            },
            executionPath: [0],
            runId: crypto.randomUUID(),
            resumeSteps,
            prevResult,
            resumeData,
            activeSteps,
            requestContext,
            perStep
          }
        });
      }
      return;
    }
    if (step.type === "step") {
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-start",
          payload: {
            id: step.step.id,
            startedAt: Date.now(),
            payload: prevResult.status === "success" ? prevResult.output : void 0,
            status: "running"
          }
        }
      });
    }
    const ee = new EventEmitter__default.default();
    ee.on("watch", async (event) => {
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: event
      });
    });
    const rc = new chunkSMM2C4KH_cjs.RequestContext();
    for (const [key, value] of Object.entries(requestContext)) {
      rc.set(key, value);
    }
    const { resumeData: timeTravelResumeData, validationError: timeTravelResumeValidationError } = await chunkPS5SHNDR_cjs.validateStepResumeData({
      resumeData: timeTravel?.stepResults[step.step.id]?.status === "suspended" ? timeTravel?.resumeData : void 0,
      step: step.step
    });
    let resumeDataToUse;
    if (timeTravelResumeData && !timeTravelResumeValidationError) {
      resumeDataToUse = timeTravelResumeData;
    } else if (timeTravelResumeData && timeTravelResumeValidationError) {
      this.mastra.getLogger()?.warn("Time travel resume data validation failed", {
        stepId: step.step.id,
        error: timeTravelResumeValidationError.message
      });
    } else if (resumeSteps?.length > 0 && resumeSteps?.[0] === step.step.id) {
      resumeDataToUse = resumeData;
    }
    const abortController = this.getOrCreateAbortController(runId);
    const stepResult = await this.stepExecutor.execute({
      workflowId,
      step: step.step,
      runId,
      stepResults,
      // TODO: implement state
      state: {},
      emitter: ee,
      requestContext: rc,
      input: prevResult?.output,
      resumeData: resumeDataToUse,
      retryCount,
      foreachIdx: step.type === "foreach" ? executionPath[1] : void 0,
      validateInputs: workflow.options.validateInputs,
      abortController,
      perStep
    });
    requestContext = Object.fromEntries(rc.entries());
    if (stepResult.status === "bailed") {
      stepResult.status = "success";
      await this.endWorkflow({
        workflow,
        resumeData,
        parentWorkflow,
        workflowId,
        runId,
        executionPath,
        resumeSteps,
        stepResults: {
          ...stepResults,
          [step.step.id]: stepResult
        },
        prevResult: stepResult,
        activeSteps,
        requestContext,
        perStep
      });
      return;
    }
    if (stepResult.status === "failed") {
      const retries = step.step.retries ?? workflow.retryConfig.attempts ?? 0;
      if (retryCount >= retries) {
        await this.mastra.pubsub.publish("workflows", {
          type: "workflow.step.end",
          runId,
          data: {
            parentWorkflow,
            workflowId,
            runId,
            executionPath,
            resumeSteps,
            stepResults,
            prevResult: stepResult,
            activeSteps,
            requestContext
          }
        });
      } else {
        return this.mastra.pubsub.publish("workflows", {
          type: "workflow.step.run",
          runId,
          data: {
            parentWorkflow,
            workflowId,
            runId,
            executionPath,
            resumeSteps,
            stepResults,
            timeTravel,
            prevResult,
            activeSteps,
            requestContext,
            retryCount: retryCount + 1
          }
        });
      }
    }
    if (step.type === "loop") {
      await processWorkflowLoop(
        {
          workflowId,
          prevResult: stepResult,
          runId,
          executionPath,
          stepResults,
          activeSteps,
          resumeSteps,
          resumeData,
          parentWorkflow,
          requestContext,
          retryCount: retryCount + 1
        },
        {
          pubsub: this.mastra.pubsub,
          stepExecutor: this.stepExecutor,
          step,
          stepResult
        }
      );
    } else {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          timeTravel,
          //timeTravel is passed in as workflow.step.end ends the step, not the workflow, the timeTravel info is passed to the next step to run.
          stepResults,
          prevResult: stepResult,
          activeSteps,
          requestContext,
          perStep
        }
      });
    }
  }
  async processWorkflowStepEnd({
    workflow,
    workflowId,
    runId,
    executionPath,
    resumeSteps,
    timeTravel,
    prevResult,
    parentWorkflow,
    stepResults,
    activeSteps,
    parentContext,
    requestContext,
    perStep
  }) {
    let step = workflow.stepGraph[executionPath[0]];
    if ((step?.type === "parallel" || step?.type === "conditional") && executionPath.length > 1) {
      step = step.steps[executionPath[1]];
    }
    if (!step) {
      return this.errorWorkflow(
        {
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          prevResult,
          stepResults,
          activeSteps,
          requestContext
        },
        new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_WORKFLOW",
          text: `Step not found: ${JSON.stringify(executionPath)}`,
          domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
          category: "SYSTEM" /* SYSTEM */
        })
      );
    }
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    if (step.type === "foreach") {
      const snapshot = await workflowsStore?.loadWorkflowSnapshot({
        workflowName: workflowId,
        runId
      });
      const currentIdx = executionPath[1];
      const currentResult = snapshot?.context?.[step.step.id]?.output;
      let newResult = prevResult;
      if (currentIdx !== void 0) {
        if (currentResult) {
          currentResult[currentIdx] = prevResult.output;
          newResult = { ...prevResult, output: currentResult };
        } else {
          newResult = { ...prevResult, output: [prevResult.output] };
        }
      }
      const newStepResults = await workflowsStore?.updateWorkflowResults({
        workflowName: workflow.id,
        runId,
        stepId: step.step.id,
        result: newResult,
        requestContext
      });
      if (!newStepResults) {
        return;
      }
      stepResults = newStepResults;
    } else if (isExecutableStep(step)) {
      delete activeSteps[step.step.id];
      if (parentContext) {
        prevResult = stepResults[step.step.id] = {
          ...prevResult,
          payload: parentContext.input?.output ?? {}
        };
      }
      const newStepResults = await workflowsStore?.updateWorkflowResults({
        workflowName: workflow.id,
        runId,
        stepId: step.step.id,
        result: prevResult,
        requestContext
      });
      if (!newStepResults) {
        return;
      }
      stepResults = newStepResults;
    }
    if (!prevResult?.status || prevResult.status === "failed") {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.fail",
        runId,
        data: {
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          parentWorkflow,
          stepResults,
          timeTravel,
          prevResult,
          activeSteps,
          requestContext
        }
      });
      return;
    } else if (prevResult.status === "suspended") {
      const suspendedPaths = {};
      const suspendedStep = getStep(workflow, executionPath);
      if (suspendedStep) {
        suspendedPaths[suspendedStep.id] = executionPath;
      }
      await workflowsStore?.updateWorkflowState({
        workflowName: workflowId,
        runId,
        opts: {
          status: "suspended",
          result: prevResult,
          suspendedPaths
        }
      });
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.suspend",
        runId,
        data: {
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          parentWorkflow,
          stepResults,
          prevResult,
          activeSteps,
          requestContext,
          timeTravel
        }
      });
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-suspended",
          payload: {
            id: step?.step?.id,
            ...prevResult,
            suspendedAt: Date.now(),
            suspendPayload: prevResult.suspendPayload
          }
        }
      });
      return;
    }
    if (step?.type === "step") {
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-step-result",
          payload: {
            id: step.step.id,
            ...prevResult
          }
        }
      });
      if (prevResult.status === "success") {
        await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
          type: "watch",
          runId,
          data: {
            type: "workflow-step-finish",
            payload: {
              id: step.step.id,
              metadata: {}
            }
          }
        });
      }
    }
    step = workflow.stepGraph[executionPath[0]];
    if (perStep) {
      if (parentWorkflow && executionPath[0] < workflow.stepGraph.length - 1) {
        const { endedAt, output, status, ...nestedPrevResult } = prevResult;
        await this.endWorkflow({
          workflow,
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult: { ...nestedPrevResult, status: "paused" },
          activeSteps,
          requestContext,
          perStep
        });
      } else {
        await this.endWorkflow({
          workflow,
          parentWorkflow,
          workflowId,
          runId,
          executionPath,
          resumeSteps,
          stepResults,
          prevResult,
          activeSteps,
          requestContext,
          perStep
        });
      }
    } else if ((step?.type === "parallel" || step?.type === "conditional") && executionPath.length > 1) {
      let skippedCount = 0;
      const allResults = step.steps.reduce(
        (acc, step2) => {
          if (isExecutableStep(step2)) {
            const res = stepResults?.[step2.step.id];
            if (res && res.status === "success") {
              acc[step2.step.id] = res?.output;
            } else if (res?.status === "skipped") {
              skippedCount++;
            }
          }
          return acc;
        },
        {}
      );
      const keys = Object.keys(allResults);
      if (keys.length + skippedCount < step.steps.length) {
        return;
      }
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.end",
        runId,
        data: {
          parentWorkflow,
          workflowId,
          runId,
          executionPath: executionPath.slice(0, -1),
          resumeSteps,
          stepResults,
          prevResult: { status: "success", output: allResults },
          activeSteps,
          requestContext,
          timeTravel
        }
      });
    } else if (step?.type === "foreach") {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          workflowId,
          runId,
          executionPath: executionPath.slice(0, -1),
          resumeSteps,
          parentWorkflow,
          stepResults,
          prevResult: { ...prevResult, output: prevResult?.payload },
          activeSteps,
          requestContext,
          timeTravel
        }
      });
    } else if (executionPath[0] >= workflow.stepGraph.length - 1) {
      await this.endWorkflow({
        workflow,
        parentWorkflow,
        workflowId,
        runId,
        executionPath,
        resumeSteps,
        stepResults,
        prevResult,
        activeSteps,
        requestContext
      });
    } else {
      await this.mastra.pubsub.publish("workflows", {
        type: "workflow.step.run",
        runId,
        data: {
          workflowId,
          runId,
          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1] + 1]),
          resumeSteps,
          parentWorkflow,
          stepResults,
          prevResult,
          activeSteps,
          requestContext,
          timeTravel
        }
      });
    }
  }
  async loadData({
    workflowId,
    runId
  }) {
    const workflowsStore = await this.mastra.getStorage()?.getStore("workflows");
    const snapshot = await workflowsStore?.loadWorkflowSnapshot({
      workflowName: workflowId,
      runId
    });
    return snapshot;
  }
  async process(event, ack) {
    const { type, data } = event;
    const workflowData = data;
    const currentState = await this.loadData({
      workflowId: workflowData.workflowId,
      runId: workflowData.runId
    });
    if (currentState?.status === "canceled" && type !== "workflow.end" && type !== "workflow.cancel") {
      return;
    }
    if (type.startsWith("workflow.user-event.")) {
      await processWorkflowWaitForEvent(
        {
          ...workflowData,
          workflow: this.mastra.getWorkflow(workflowData.workflowId)
        },
        {
          pubsub: this.mastra.pubsub,
          eventName: type.split(".").slice(2).join("."),
          currentState
        }
      );
      return;
    }
    let workflow;
    if (this.mastra.__hasInternalWorkflow(workflowData.workflowId)) {
      workflow = this.mastra.__getInternalWorkflow(workflowData.workflowId);
    } else if (workflowData.parentWorkflow) {
      workflow = getNestedWorkflow(this.mastra, workflowData.parentWorkflow);
    } else {
      workflow = this.mastra.getWorkflow(workflowData.workflowId);
    }
    if (!workflow) {
      return this.errorWorkflow(
        workflowData,
        new chunk4U7ZLI36_cjs.MastraError({
          id: "MASTRA_WORKFLOW",
          text: `Workflow not found: ${workflowData.workflowId}`,
          domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
          category: "SYSTEM" /* SYSTEM */
        })
      );
    }
    if (type === "workflow.start" || type === "workflow.resume") {
      const { runId } = workflowData;
      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: {
          type: "workflow-start",
          payload: {
            runId
          }
        }
      });
    }
    switch (type) {
      case "workflow.cancel":
        await this.processWorkflowCancel({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.start":
        await this.processWorkflowStart({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.resume":
        await this.processWorkflowStart({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.end":
        await this.processWorkflowEnd({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.step.end":
        await this.processWorkflowStepEnd({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.step.run":
        await this.processWorkflowStepRun({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.suspend":
        await this.processWorkflowSuspend({
          workflow,
          ...workflowData
        });
        break;
      case "workflow.fail":
        await this.processWorkflowFail({
          workflow,
          ...workflowData
        });
        break;
    }
    try {
      await ack?.();
    } catch (e) {
      this.mastra.getLogger()?.error("Error acking event", e);
    }
  }
};

// src/workflows/evented/workflow.ts
function cloneWorkflow(workflow, opts) {
  const wf = new chunkPS5SHNDR_cjs.Workflow({
    id: opts.id,
    inputSchema: workflow.inputSchema,
    outputSchema: workflow.outputSchema,
    steps: workflow.stepDefs,
    mastra: workflow.mastra,
    options: workflow.options
  });
  wf.setStepFlow(workflow.stepGraph);
  wf.commit();
  return wf;
}
function cloneStep(step, opts) {
  return {
    id: opts.id,
    description: step.description,
    inputSchema: step.inputSchema,
    outputSchema: step.outputSchema,
    suspendSchema: step.suspendSchema,
    resumeSchema: step.resumeSchema,
    stateSchema: step.stateSchema,
    execute: step.execute,
    retries: step.retries,
    scorers: step.scorers,
    component: step.component
  };
}
function isAgent(input) {
  return input instanceof chunkPS5SHNDR_cjs.Agent;
}
function isToolStep(input) {
  return input instanceof chunkOZ75PBBK_cjs.Tool;
}
function isStepParams(input) {
  return input !== null && typeof input === "object" && "id" in input && "execute" in input && !(input instanceof chunkPS5SHNDR_cjs.Agent) && !(input instanceof chunkOZ75PBBK_cjs.Tool);
}
function isProcessor(obj) {
  return obj !== null && typeof obj === "object" && "id" in obj && typeof obj.id === "string" && !(obj instanceof chunkPS5SHNDR_cjs.Agent) && !(obj instanceof chunkOZ75PBBK_cjs.Tool) && (typeof obj.processInput === "function" || typeof obj.processInputStep === "function" || typeof obj.processOutputStream === "function" || typeof obj.processOutputResult === "function" || typeof obj.processOutputStep === "function");
}
function createStep(params, agentOrToolOptions) {
  if (isAgent(params)) {
    return createStepFromAgent(params, agentOrToolOptions);
  }
  if (isToolStep(params)) {
    return createStepFromTool(params, agentOrToolOptions);
  }
  if (isProcessor(params)) {
    return createStepFromProcessor(params);
  }
  if (isStepParams(params)) {
    return createStepFromParams(params);
  }
  throw new Error("Invalid input: expected StepParams, Agent, ToolStep, or Processor");
}
function createStepFromParams(params) {
  return {
    id: params.id,
    description: params.description,
    inputSchema: params.inputSchema,
    stateSchema: params.stateSchema,
    outputSchema: params.outputSchema,
    resumeSchema: params.resumeSchema,
    suspendSchema: params.suspendSchema,
    scorers: params.scorers,
    retries: params.retries,
    execute: params.execute.bind(params)
  };
}
function createStepFromAgent(params, agentOrToolOptions) {
  const options = agentOrToolOptions ?? {};
  const outputSchema = options?.structuredOutput?.schema ?? zod.z.object({ text: zod.z.string() });
  const { retries, scorers, ...agentOptions } = options ?? {};
  return {
    id: params.id,
    description: params.getDescription(),
    inputSchema: zod.z.object({
      prompt: zod.z.string()
    }),
    outputSchema,
    retries,
    scorers,
    execute: async ({
      inputData,
      runId,
      [chunkLJOQ7WYC_cjs.PUBSUB_SYMBOL]: pubsub,
      requestContext,
      tracingContext,
      abortSignal,
      abort
    }) => {
      let streamPromise = {};
      streamPromise.promise = new Promise((resolve, reject) => {
        streamPromise.resolve = resolve;
        streamPromise.reject = reject;
      });
      const { fullStream } = await params.streamLegacy(inputData.prompt, {
        ...agentOptions ?? {},
        tracingContext,
        requestContext,
        onFinish: (result) => {
          streamPromise.resolve(result.text);
        },
        abortSignal
      });
      if (abortSignal.aborted) {
        return abort();
      }
      const toolData = {
        name: params.name,
        args: inputData
      };
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: { type: "tool-call-streaming-start", ...toolData ?? {} }
      });
      for await (const chunk of fullStream) {
        if (chunk.type === "text-delta") {
          await pubsub.publish(`workflow.events.v2.${runId}`, {
            type: "watch",
            runId,
            data: { type: "tool-call-delta", ...toolData ?? {}, argsTextDelta: chunk.textDelta }
          });
        }
      }
      await pubsub.publish(`workflow.events.v2.${runId}`, {
        type: "watch",
        runId,
        data: { type: "tool-call-streaming-finish", ...toolData ?? {} }
      });
      return {
        text: await streamPromise.promise
      };
    },
    component: params.component
  };
}
function createStepFromTool(params, agentOrToolOptions) {
  const toolOpts = agentOrToolOptions;
  if (!params.inputSchema || !params.outputSchema) {
    throw new Error("Tool must have input and output schemas defined");
  }
  return {
    id: params.id,
    description: params.description,
    inputSchema: params.inputSchema,
    outputSchema: params.outputSchema,
    resumeSchema: params.resumeSchema,
    suspendSchema: params.suspendSchema,
    retries: toolOpts?.retries,
    scorers: toolOpts?.scorers,
    execute: async ({ inputData, mastra, requestContext, suspend, resumeData, runId, workflowId, state, setState }) => {
      if (!params.execute) {
        throw new Error(`Tool ${params.id} does not have an execute function`);
      }
      const context = {
        mastra,
        requestContext,
        tracingContext: { currentSpan: void 0 },
        // TODO: Pass proper tracing context when evented workflows support tracing
        workflow: {
          runId,
          workflowId,
          state,
          setState,
          suspend,
          resumeData
        }
      };
      return params.execute(inputData, context);
    },
    component: "TOOL"
  };
}
function createStepFromProcessor(processor) {
  const getProcessorEntityType = (phase) => {
    switch (phase) {
      case "input":
        return "input_processor" /* INPUT_PROCESSOR */;
      case "inputStep":
        return "input_step_processor" /* INPUT_STEP_PROCESSOR */;
      case "outputStream":
      case "outputResult":
        return "output_processor" /* OUTPUT_PROCESSOR */;
      case "outputStep":
        return "output_step_processor" /* OUTPUT_STEP_PROCESSOR */;
      default:
        return "output_processor" /* OUTPUT_PROCESSOR */;
    }
  };
  const getSpanNamePrefix = (phase) => {
    switch (phase) {
      case "input":
        return "input processor";
      case "inputStep":
        return "input step processor";
      case "outputStream":
        return "output stream processor";
      case "outputResult":
        return "output processor";
      case "outputStep":
        return "output step processor";
      default:
        return "processor";
    }
  };
  const hasPhaseMethod = (phase) => {
    switch (phase) {
      case "input":
        return !!processor.processInput;
      case "inputStep":
        return !!processor.processInputStep;
      case "outputStream":
        return !!processor.processOutputStream;
      case "outputResult":
        return !!processor.processOutputResult;
      case "outputStep":
        return !!processor.processOutputStep;
      default:
        return false;
    }
  };
  return {
    id: `processor:${processor.id}`,
    description: processor.name ?? `Processor ${processor.id}`,
    inputSchema: chunkPS5SHNDR_cjs.ProcessorStepSchema,
    outputSchema: chunkPS5SHNDR_cjs.ProcessorStepOutputSchema,
    execute: async ({ inputData, requestContext, tracingContext }) => {
      const input = inputData;
      const {
        phase,
        messages,
        messageList,
        stepNumber,
        systemMessages,
        part,
        streamParts,
        state,
        finishReason,
        toolCalls,
        text,
        retryCount,
        // inputStep phase fields for model/tools configuration
        model,
        tools,
        toolChoice,
        activeTools,
        providerOptions,
        modelSettings,
        structuredOutput,
        steps
      } = input;
      const abort = (reason, options) => {
        throw new chunkPS5SHNDR_cjs.TripWire(reason || `Tripwire triggered by ${processor.id}`, options, processor.id);
      };
      if (!hasPhaseMethod(phase)) {
        return input;
      }
      const currentSpan = tracingContext?.currentSpan;
      const parentSpan = phase === "inputStep" || phase === "outputStep" ? currentSpan?.findParent("model_step" /* MODEL_STEP */) || currentSpan : currentSpan?.findParent("agent_run" /* AGENT_RUN */) || currentSpan;
      const processorSpan = phase !== "outputStream" ? parentSpan?.createChildSpan({
        type: "processor_run" /* PROCESSOR_RUN */,
        name: `${getSpanNamePrefix(phase)}: ${processor.id}`,
        entityType: getProcessorEntityType(phase),
        entityId: processor.id,
        entityName: processor.name ?? processor.id,
        input: { phase, messageCount: messages?.length },
        attributes: {
          processorExecutor: "workflow",
          // Read processorIndex from processor (set in combineProcessorsIntoWorkflow)
          processorIndex: processor.processorIndex
        }
      }) : void 0;
      const processorTracingContext = processorSpan ? { currentSpan: processorSpan } : tracingContext;
      const baseContext = {
        abort,
        retryCount: retryCount ?? 0,
        requestContext,
        tracingContext: processorTracingContext
      };
      const passThrough = {
        phase,
        // Auto-create MessageList from messages if not provided
        // This enables running processor workflows from the UI where messageList can't be serialized
        messageList: messageList ?? (Array.isArray(messages) ? new chunkJ4KVR4DZ_cjs.MessageList().add(messages, "input").addSystem(systemMessages ?? []) : void 0),
        stepNumber,
        systemMessages,
        streamParts,
        state,
        finishReason,
        toolCalls,
        text,
        retryCount,
        // inputStep phase fields for model/tools configuration
        model,
        tools,
        toolChoice,
        activeTools,
        providerOptions,
        modelSettings,
        structuredOutput,
        steps
      };
      const executePhaseWithSpan = async (fn) => {
        try {
          const result = await fn();
          processorSpan?.end({ output: result });
          return result;
        } catch (error) {
          if (error instanceof chunkPS5SHNDR_cjs.TripWire) {
            processorSpan?.end({ output: { tripwire: error.message } });
          } else {
            processorSpan?.error({ error, endSpan: true });
          }
          throw error;
        }
      };
      return executePhaseWithSpan(async () => {
        switch (phase) {
          case "input": {
            if (processor.processInput) {
              if (!passThrough.messageList) {
                throw new chunk4U7ZLI36_cjs.MastraError({
                  category: "USER" /* USER */,
                  domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                  id: "PROCESSOR_MISSING_MESSAGE_LIST",
                  text: `Processor ${processor.id} requires messageList or messages for processInput phase`
                });
              }
              const idsBeforeProcessing = messages.map((m) => m.id);
              const check = passThrough.messageList.makeMessageSourceChecker();
              const result = await processor.processInput({
                ...baseContext,
                messages,
                messageList: passThrough.messageList,
                systemMessages: systemMessages ?? []
              });
              if (result instanceof chunkJ4KVR4DZ_cjs.MessageList) {
                if (result !== passThrough.messageList) {
                  throw new chunk4U7ZLI36_cjs.MastraError({
                    category: "USER" /* USER */,
                    domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                    id: "PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST",
                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`
                  });
                }
                return {
                  ...passThrough,
                  messages: result.get.all.db(),
                  systemMessages: result.getAllSystemMessages()
                };
              } else if (Array.isArray(result)) {
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  result,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "input"
                );
                return { ...passThrough, messages: result };
              } else if (result && "messages" in result && "systemMessages" in result) {
                const typedResult = result;
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  typedResult.messages,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "input"
                );
                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);
                return {
                  ...passThrough,
                  messages: typedResult.messages,
                  systemMessages: typedResult.systemMessages
                };
              }
              return { ...passThrough, messages };
            }
            return { ...passThrough, messages };
          }
          case "inputStep": {
            if (processor.processInputStep) {
              if (!passThrough.messageList) {
                throw new chunk4U7ZLI36_cjs.MastraError({
                  category: "USER" /* USER */,
                  domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                  id: "PROCESSOR_MISSING_MESSAGE_LIST",
                  text: `Processor ${processor.id} requires messageList or messages for processInputStep phase`
                });
              }
              const idsBeforeProcessing = messages.map((m) => m.id);
              const check = passThrough.messageList.makeMessageSourceChecker();
              const result = await processor.processInputStep({
                ...baseContext,
                messages,
                messageList: passThrough.messageList,
                stepNumber: stepNumber ?? 0,
                systemMessages: systemMessages ?? [],
                // Pass model/tools configuration fields - types match ProcessInputStepArgs
                model,
                tools,
                toolChoice,
                activeTools,
                providerOptions,
                modelSettings,
                structuredOutput,
                steps: steps ?? []
              });
              const validatedResult = await chunkPS5SHNDR_cjs.ProcessorRunner.validateAndFormatProcessInputStepResult(result, {
                messageList: passThrough.messageList,
                processor,
                stepNumber: stepNumber ?? 0
              });
              if (validatedResult.messages) {
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  validatedResult.messages,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check
                );
              }
              if (validatedResult.systemMessages) {
                passThrough.messageList.replaceAllSystemMessages(validatedResult.systemMessages);
              }
              return { ...passThrough, messages, ...validatedResult };
            }
            return { ...passThrough, messages };
          }
          case "outputStream": {
            if (processor.processOutputStream) {
              const spanKey = `__outputStreamSpan_${processor.id}`;
              const mutableState = state ?? {};
              let processorSpan2 = mutableState[spanKey];
              if (!processorSpan2 && parentSpan) {
                processorSpan2 = parentSpan.createChildSpan({
                  type: "processor_run" /* PROCESSOR_RUN */,
                  name: `output stream processor: ${processor.id}`,
                  entityType: "output_processor" /* OUTPUT_PROCESSOR */,
                  entityId: processor.id,
                  entityName: processor.name ?? processor.id,
                  input: { phase, streamParts: [] },
                  attributes: {
                    processorExecutor: "workflow",
                    processorIndex: processor.processorIndex
                  }
                });
                mutableState[spanKey] = processorSpan2;
              }
              if (processorSpan2) {
                processorSpan2.input = {
                  phase,
                  streamParts: streamParts ?? [],
                  totalChunks: (streamParts ?? []).length
                };
              }
              const processorTracingContext2 = processorSpan2 ? { currentSpan: processorSpan2 } : baseContext.tracingContext;
              let result;
              try {
                result = await processor.processOutputStream({
                  ...baseContext,
                  tracingContext: processorTracingContext2,
                  part,
                  streamParts: streamParts ?? [],
                  state: mutableState,
                  messageList: passThrough.messageList
                  // Optional for stream processing
                });
                if (part && part.type === "finish") {
                  processorSpan2?.end({ output: result });
                  delete mutableState[spanKey];
                }
              } catch (error) {
                if (error instanceof chunkPS5SHNDR_cjs.TripWire) {
                  processorSpan2?.end({ output: { tripwire: error.message } });
                } else {
                  processorSpan2?.error({ error, endSpan: true });
                }
                delete mutableState[spanKey];
                throw error;
              }
              return { ...passThrough, state: mutableState, part: result };
            }
            return { ...passThrough, part };
          }
          case "outputResult": {
            if (processor.processOutputResult) {
              if (!passThrough.messageList) {
                throw new chunk4U7ZLI36_cjs.MastraError({
                  category: "USER" /* USER */,
                  domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                  id: "PROCESSOR_MISSING_MESSAGE_LIST",
                  text: `Processor ${processor.id} requires messageList or messages for processOutputResult phase`
                });
              }
              const idsBeforeProcessing = messages.map((m) => m.id);
              const check = passThrough.messageList.makeMessageSourceChecker();
              const result = await processor.processOutputResult({
                ...baseContext,
                messages,
                messageList: passThrough.messageList
              });
              if (result instanceof chunkJ4KVR4DZ_cjs.MessageList) {
                if (result !== passThrough.messageList) {
                  throw new chunk4U7ZLI36_cjs.MastraError({
                    category: "USER" /* USER */,
                    domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                    id: "PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST",
                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`
                  });
                }
                return {
                  ...passThrough,
                  messages: result.get.all.db(),
                  systemMessages: result.getAllSystemMessages()
                };
              } else if (Array.isArray(result)) {
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  result,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "response"
                );
                return { ...passThrough, messages: result };
              } else if (result && "messages" in result && "systemMessages" in result) {
                const typedResult = result;
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  typedResult.messages,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "response"
                );
                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);
                return {
                  ...passThrough,
                  messages: typedResult.messages,
                  systemMessages: typedResult.systemMessages
                };
              }
              return { ...passThrough, messages };
            }
            return { ...passThrough, messages };
          }
          case "outputStep": {
            if (processor.processOutputStep) {
              if (!passThrough.messageList) {
                throw new chunk4U7ZLI36_cjs.MastraError({
                  category: "USER" /* USER */,
                  domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                  id: "PROCESSOR_MISSING_MESSAGE_LIST",
                  text: `Processor ${processor.id} requires messageList or messages for processOutputStep phase`
                });
              }
              const idsBeforeProcessing = messages.map((m) => m.id);
              const check = passThrough.messageList.makeMessageSourceChecker();
              const result = await processor.processOutputStep({
                ...baseContext,
                messages,
                messageList: passThrough.messageList,
                stepNumber: stepNumber ?? 0,
                finishReason,
                toolCalls,
                text,
                systemMessages: systemMessages ?? [],
                steps: steps ?? []
              });
              if (result instanceof chunkJ4KVR4DZ_cjs.MessageList) {
                if (result !== passThrough.messageList) {
                  throw new chunk4U7ZLI36_cjs.MastraError({
                    category: "USER" /* USER */,
                    domain: "MASTRA_WORKFLOW" /* MASTRA_WORKFLOW */,
                    id: "PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST",
                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`
                  });
                }
                return {
                  ...passThrough,
                  messages: result.get.all.db(),
                  systemMessages: result.getAllSystemMessages()
                };
              } else if (Array.isArray(result)) {
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  result,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "response"
                );
                return { ...passThrough, messages: result };
              } else if (result && "messages" in result && "systemMessages" in result) {
                const typedResult = result;
                chunkPS5SHNDR_cjs.ProcessorRunner.applyMessagesToMessageList(
                  typedResult.messages,
                  passThrough.messageList,
                  idsBeforeProcessing,
                  check,
                  "response"
                );
                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);
                return {
                  ...passThrough,
                  messages: typedResult.messages,
                  systemMessages: typedResult.systemMessages
                };
              }
              return { ...passThrough, messages };
            }
            return { ...passThrough, messages };
          }
          default:
            return { ...passThrough, messages };
        }
      });
    },
    component: "PROCESSOR"
  };
}
function createWorkflow(params) {
  const eventProcessor = new WorkflowEventProcessor({ mastra: params.mastra });
  const executionEngine = new EventedExecutionEngine({
    mastra: params.mastra,
    eventProcessor,
    options: {
      validateInputs: params.options?.validateInputs ?? true,
      shouldPersistSnapshot: params.options?.shouldPersistSnapshot ?? (() => true),
      tracingPolicy: params.options?.tracingPolicy,
      onFinish: params.options?.onFinish,
      onError: params.options?.onError
    }
  });
  return new EventedWorkflow({
    ...params,
    executionEngine
  });
}
var EventedWorkflow = class extends chunkPS5SHNDR_cjs.Workflow {
  constructor(params) {
    super(params);
    this.engineType = "evented";
  }
  __registerMastra(mastra) {
    super.__registerMastra(mastra);
    this.executionEngine.__registerMastra(mastra);
  }
  async createRun(options) {
    const runIdToUse = options?.runId || crypto.randomUUID();
    const run = this.runs.get(runIdToUse) ?? new EventedRun({
      workflowId: this.id,
      runId: runIdToUse,
      resourceId: options?.resourceId,
      executionEngine: this.executionEngine,
      executionGraph: this.executionGraph,
      serializedStepGraph: this.serializedStepGraph,
      mastra: this.mastra,
      retryConfig: this.retryConfig,
      cleanup: () => this.runs.delete(runIdToUse),
      workflowSteps: this.steps,
      validateInputs: this.options?.validateInputs,
      workflowEngineType: this.engineType
    });
    this.runs.set(runIdToUse, run);
    const shouldPersistSnapshot = this.options?.shouldPersistSnapshot?.({
      workflowStatus: run.workflowRunStatus,
      stepResults: {}
    });
    const existingRun = await this.getWorkflowRunById(runIdToUse, {
      withNestedWorkflows: false
    });
    const existsInStorage = existingRun && !existingRun.isFromInMemory;
    if (!existsInStorage && shouldPersistSnapshot) {
      const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
      await workflowsStore?.persistWorkflowSnapshot({
        workflowName: this.id,
        runId: runIdToUse,
        resourceId: options?.resourceId,
        snapshot: {
          runId: runIdToUse,
          status: "pending",
          value: {},
          context: {},
          activePaths: [],
          serializedStepGraph: this.serializedStepGraph,
          activeStepsPath: {},
          suspendedPaths: {},
          resumeLabels: {},
          waitingPaths: {},
          result: void 0,
          error: void 0,
          // @ts-ignore
          timestamp: Date.now()
        }
      });
    }
    return run;
  }
};
var EventedRun = class extends chunkPS5SHNDR_cjs.Run {
  constructor(params) {
    super(params);
    this.serializedStepGraph = params.serializedStepGraph;
  }
  /**
   * Set up abort signal handler to publish workflow.cancel event when abortController.abort() is called.
   * This ensures consistent cancellation behavior whether abort() is called directly or via cancel().
   */
  setupAbortHandler() {
    const abortHandler = () => {
      this.mastra?.pubsub.publish("workflows", {
        type: "workflow.cancel",
        runId: this.runId,
        data: {
          workflowId: this.workflowId,
          runId: this.runId
        }
      }).catch((err) => {
        this.mastra?.getLogger()?.error(`Failed to publish workflow.cancel for runId ${this.runId}:`, err);
      });
    };
    this.abortController.signal.addEventListener("abort", abortHandler, { once: true });
  }
  async start({
    inputData,
    initialState,
    requestContext,
    perStep
  }) {
    if (this.serializedStepGraph.length === 0) {
      throw new Error(
        "Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc."
      );
    }
    if (!this.executionGraph.steps) {
      throw new Error("Uncommitted step flow changes detected. Call .commit() to register the steps.");
    }
    requestContext = requestContext ?? new chunkSMM2C4KH_cjs.RequestContext();
    const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
    await workflowsStore?.persistWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId,
      resourceId: this.resourceId,
      snapshot: {
        runId: this.runId,
        serializedStepGraph: this.serializedStepGraph,
        status: "running",
        value: {},
        context: {},
        requestContext: Object.fromEntries(requestContext.entries()),
        activePaths: [],
        activeStepsPath: {},
        suspendedPaths: {},
        resumeLabels: {},
        waitingPaths: {},
        timestamp: Date.now()
      }
    });
    const inputDataToUse = await this._validateInput(inputData ?? {});
    const initialStateToUse = await this._validateInitialState(initialState ?? {});
    if (!this.mastra?.pubsub) {
      throw new Error("Mastra instance with pubsub is required for workflow execution");
    }
    this.setupAbortHandler();
    const result = await this.executionEngine.execute({
      workflowId: this.workflowId,
      runId: this.runId,
      graph: this.executionGraph,
      serializedStepGraph: this.serializedStepGraph,
      input: inputDataToUse,
      initialState: initialStateToUse,
      pubsub: this.mastra.pubsub,
      retryConfig: this.retryConfig,
      requestContext,
      abortController: this.abortController,
      perStep
    });
    if (result.status !== "suspended") {
      this.cleanup?.();
    }
    return result;
  }
  /**
   * Starts the workflow execution without waiting for completion (fire-and-forget).
   * Returns immediately with the runId. The workflow executes in the background via pubsub.
   * Use this when you don't need to wait for the result or want to avoid polling failures.
   */
  async startAsync({
    inputData,
    initialState,
    requestContext,
    perStep
  }) {
    if (this.serializedStepGraph.length === 0) {
      throw new Error(
        "Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc."
      );
    }
    if (!this.executionGraph.steps) {
      throw new Error("Uncommitted step flow changes detected. Call .commit() to register the steps.");
    }
    requestContext = requestContext ?? new chunkSMM2C4KH_cjs.RequestContext();
    const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
    await workflowsStore?.persistWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId,
      resourceId: this.resourceId,
      snapshot: {
        runId: this.runId,
        serializedStepGraph: this.serializedStepGraph,
        status: "running",
        value: {},
        context: {},
        requestContext: Object.fromEntries(requestContext.entries()),
        activePaths: [],
        activeStepsPath: {},
        suspendedPaths: {},
        resumeLabels: {},
        waitingPaths: {},
        timestamp: Date.now()
      }
    });
    const inputDataToUse = await this._validateInput(inputData ?? {});
    const initialStateToUse = await this._validateInitialState(initialState ?? {});
    if (!this.mastra?.pubsub) {
      throw new Error("Mastra instance with pubsub is required for workflow execution");
    }
    await this.mastra.pubsub.publish("workflows", {
      type: "workflow.start",
      runId: this.runId,
      data: {
        workflowId: this.workflowId,
        runId: this.runId,
        prevResult: { status: "success", output: inputDataToUse },
        requestContext: Object.fromEntries(requestContext.entries()),
        initialState: initialStateToUse,
        perStep
      }
    });
    return { runId: this.runId };
  }
  // TODO: stream
  async resume(params) {
    let steps = [];
    if (typeof params.step === "string") {
      steps = params.step.split(".");
    } else {
      steps = (Array.isArray(params.step) ? params.step : [params.step]).map(
        (step) => typeof step === "string" ? step : step?.id
      );
    }
    if (steps.length === 0) {
      throw new Error("No steps provided to resume");
    }
    const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
    if (!workflowsStore) {
      throw new Error("Cannot resume workflow: workflows store is required");
    }
    const snapshot = await workflowsStore.loadWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId
    });
    if (!snapshot) {
      throw new Error(`Cannot resume workflow: no snapshot found for runId ${this.runId}`);
    }
    const resumePath = snapshot.suspendedPaths?.[steps[0]];
    if (!resumePath) {
      throw new Error(
        `No resume path found for step ${JSON.stringify(steps)}, currently suspended paths are ${JSON.stringify(snapshot.suspendedPaths)}`
      );
    }
    console.dir(
      { resume: { requestContextObj: snapshot.requestContext, requestContext: params.requestContext } },
      { depth: null }
    );
    const requestContextObj = snapshot.requestContext ?? {};
    const requestContext = new chunkSMM2C4KH_cjs.RequestContext();
    for (const [key, value] of Object.entries(requestContextObj)) {
      requestContext.set(key, value);
    }
    if (params.requestContext) {
      for (const [key, value] of params.requestContext.entries()) {
        requestContext.set(key, value);
      }
    }
    const suspendedStep = this.workflowSteps[steps?.[0] ?? ""];
    const resumeDataToUse = await this._validateResumeData(params.resumeData, suspendedStep);
    if (!this.mastra?.pubsub) {
      throw new Error("Mastra instance with pubsub is required for workflow execution");
    }
    this.setupAbortHandler();
    const executionResultPromise = this.executionEngine.execute({
      workflowId: this.workflowId,
      runId: this.runId,
      graph: this.executionGraph,
      serializedStepGraph: this.serializedStepGraph,
      input: snapshot?.context?.input,
      resume: {
        steps,
        stepResults: snapshot?.context,
        resumePayload: resumeDataToUse,
        resumePath
      },
      pubsub: this.mastra.pubsub,
      requestContext,
      abortController: this.abortController,
      perStep: params.perStep
    }).then((result) => {
      if (result.status !== "suspended") {
        this.closeStreamAction?.().catch(() => {
        });
      }
      return result;
    });
    this.executionResults = executionResultPromise;
    return executionResultPromise;
  }
  watch(cb) {
    const watchCb = async (event, ack) => {
      if (event.runId !== this.runId) {
        return;
      }
      cb(event.data);
      await ack?.();
    };
    this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {
    });
    return () => {
      this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {
      });
    };
  }
  async watchAsync(cb) {
    const watchCb = async (event, ack) => {
      if (event.runId !== this.runId) {
        return;
      }
      cb(event.data);
      await ack?.();
    };
    await this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {
    });
    return async () => {
      await this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {
      });
    };
  }
  async cancel() {
    const workflowsStore = await this.mastra?.getStorage()?.getStore("workflows");
    await workflowsStore?.updateWorkflowState({
      workflowName: this.workflowId,
      runId: this.runId,
      opts: {
        status: "canceled"
      }
    });
    this.abortController.abort();
  }
};

// src/workflows/evented/workflow-event-processor/utils.ts
function getNestedWorkflow(mastra, { workflowId, executionPath, parentWorkflow }) {
  let workflow = null;
  if (parentWorkflow) {
    const nestedWorkflow = getNestedWorkflow(mastra, parentWorkflow);
    if (!nestedWorkflow) {
      return null;
    }
    workflow = nestedWorkflow;
  }
  workflow = workflow ?? mastra.getWorkflow(workflowId);
  const stepGraph = workflow.stepGraph;
  let parentStep = stepGraph[executionPath[0]];
  if (parentStep?.type === "parallel" || parentStep?.type === "conditional") {
    parentStep = parentStep.steps[executionPath[1]];
  }
  if (parentStep?.type === "step" || parentStep?.type === "loop") {
    return parentStep.step;
  }
  return null;
}
function getStep(workflow, executionPath) {
  let idx = 0;
  const stepGraph = workflow.stepGraph;
  let parentStep = stepGraph[executionPath[0]];
  if (parentStep?.type === "parallel" || parentStep?.type === "conditional") {
    parentStep = parentStep.steps[executionPath[1]];
    idx++;
  } else if (parentStep?.type === "foreach") {
    return parentStep.step;
  }
  if (!(parentStep?.type === "step" || parentStep?.type === "loop")) {
    return null;
  }
  if (parentStep instanceof EventedWorkflow) {
    return getStep(parentStep, executionPath.slice(idx + 1));
  }
  return parentStep.step;
}
function isExecutableStep(step) {
  return step.type === "step" || step.type === "loop" || step.type === "foreach";
}

// src/workflows/evented/execution-engine.ts
var EventedExecutionEngine = class extends chunkPS5SHNDR_cjs.ExecutionEngine {
  eventProcessor;
  constructor({
    mastra,
    eventProcessor,
    options
  }) {
    super({ mastra, options });
    this.eventProcessor = eventProcessor;
  }
  __registerMastra(mastra) {
    this.mastra = mastra;
    this.eventProcessor.__registerMastra(mastra);
  }
  /**
   * Executes a workflow run with the provided execution graph and input
   * @param graph The execution graph to execute
   * @param input The input data for the workflow
   * @returns A promise that resolves to the workflow output
   */
  async execute(params) {
    const pubsub = this.mastra?.pubsub;
    if (!pubsub) {
      throw new Error("No Pubsub adapter configured on the Mastra instance");
    }
    if (params.resume) {
      const prevStep = getStep(this.mastra.getWorkflow(params.workflowId), params.resume.resumePath);
      const prevResult = params.resume.stepResults[prevStep?.id ?? "input"];
      await pubsub.publish("workflows", {
        type: "workflow.resume",
        runId: params.runId,
        data: {
          workflowId: params.workflowId,
          runId: params.runId,
          executionPath: params.resume.resumePath,
          stepResults: params.resume.stepResults,
          resumeSteps: params.resume.steps,
          prevResult: { status: "success", output: prevResult?.payload },
          resumeData: params.resume.resumePayload,
          requestContext: Object.fromEntries(params.requestContext.entries()),
          format: params.format,
          perStep: params.perStep
        }
      });
    } else if (params.timeTravel) {
      const prevStep = getStep(this.mastra.getWorkflow(params.workflowId), params.timeTravel.executionPath);
      const prevResult = params.timeTravel.stepResults[prevStep?.id ?? "input"];
      await pubsub.publish("workflows", {
        type: "workflow.start",
        runId: params.runId,
        data: {
          workflowId: params.workflowId,
          runId: params.runId,
          executionPath: params.timeTravel.executionPath,
          stepResults: params.timeTravel.stepResults,
          timeTravel: params.timeTravel,
          prevResult: { status: "success", output: prevResult?.payload },
          requestContext: Object.fromEntries(params.requestContext.entries()),
          format: params.format,
          perStep: params.perStep
        }
      });
    } else {
      await pubsub.publish("workflows", {
        type: "workflow.start",
        runId: params.runId,
        data: {
          workflowId: params.workflowId,
          runId: params.runId,
          prevResult: { status: "success", output: params.input },
          requestContext: Object.fromEntries(params.requestContext.entries()),
          format: params.format,
          perStep: params.perStep
        }
      });
    }
    const resultData = await new Promise((resolve, reject) => {
      const finishCb = async (event, ack) => {
        if (event.runId !== params.runId) {
          await ack?.();
          return;
        }
        if (["workflow.end", "workflow.fail", "workflow.suspend"].includes(event.type)) {
          await ack?.();
          await pubsub.unsubscribe("workflows-finish", finishCb);
          if (event.type === "workflow.fail" && event.data.stepResults) {
            event.data.stepResults = chunkPS5SHNDR_cjs.hydrateSerializedStepErrors(event.data.stepResults);
          }
          resolve(event.data);
          return;
        }
        await ack?.();
      };
      pubsub.subscribe("workflows-finish", finishCb).catch((err) => {
        this.mastra?.getLogger()?.error("Failed to subscribe to workflows-finish:", err);
        reject(err);
      });
    });
    let callbackArg;
    if (resultData.prevResult.status === "failed") {
      callbackArg = {
        status: "failed",
        error: resultData.prevResult.error,
        steps: resultData.stepResults
      };
    } else if (resultData.prevResult.status === "suspended") {
      callbackArg = {
        status: "suspended",
        steps: resultData.stepResults
      };
    } else if (resultData.prevResult.status === "paused" || params.perStep) {
      callbackArg = {
        status: "paused",
        steps: resultData.stepResults
      };
    } else {
      callbackArg = {
        status: resultData.prevResult.status,
        result: resultData.prevResult?.output,
        steps: resultData.stepResults
      };
    }
    if (callbackArg.status !== "paused") {
      await this.invokeLifecycleCallbacks({
        status: callbackArg.status,
        result: callbackArg.result,
        error: callbackArg.error,
        steps: callbackArg.steps,
        tripwire: void 0,
        runId: params.runId,
        workflowId: params.workflowId,
        resourceId: void 0,
        input: params.input,
        requestContext: params.requestContext,
        state: {}
      });
    }
    let result;
    if (resultData.prevResult.status === "suspended") {
      const suspendedSteps = Object.entries(resultData.stepResults).map(([_stepId, stepResult]) => {
        if (stepResult.status === "suspended") {
          return stepResult.suspendPayload?.__workflow_meta?.path ?? [];
        }
        return null;
      }).filter(Boolean);
      result = {
        ...callbackArg,
        suspended: suspendedSteps
      };
    } else {
      result = callbackArg;
    }
    return result;
  }
};

exports.EventedExecutionEngine = EventedExecutionEngine;
exports.EventedRun = EventedRun;
exports.EventedWorkflow = EventedWorkflow;
exports.StepExecutor = StepExecutor;
exports.WorkflowEventProcessor = WorkflowEventProcessor;
exports.cloneStep = cloneStep;
exports.cloneWorkflow = cloneWorkflow;
exports.createStep = createStep;
exports.createWorkflow = createWorkflow;
//# sourceMappingURL=chunk-S7MI4RFN.cjs.map
//# sourceMappingURL=chunk-S7MI4RFN.cjs.map