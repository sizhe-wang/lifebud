'use strict';

var chunkS65YV6YB_cjs = require('./chunk-S65YV6YB.cjs');
var chunkVW7YQWDW_cjs = require('./chunk-VW7YQWDW.cjs');
var zod = require('zod');

var createdAtField = zod.z.date().describe("Database record creation time");
var updatedAtField = zod.z.date().describe("Database record last update time");
var dbTimestamps = {
  createdAt: createdAtField,
  updatedAt: updatedAtField.nullable()
};
var paginationArgsSchema = zod.z.object({
  page: zod.z.coerce.number().int().min(0).optional().default(0).describe("Zero-indexed page number"),
  perPage: zod.z.coerce.number().int().min(1).max(100).optional().default(10).describe("Number of items per page")
}).describe("Pagination options for list queries");
var paginationInfoSchema = zod.z.object({
  total: zod.z.number().describe("Total number of items available"),
  page: zod.z.number().describe("Current page"),
  perPage: zod.z.union([zod.z.number(), zod.z.literal(false)]).describe("Number of items per page, or false if pagination is disabled"),
  hasMore: zod.z.boolean().describe("True if more pages are available")
});
var dateRangeSchema = zod.z.object({
  start: zod.z.coerce.date().optional().describe("Start of date range (inclusive by default)"),
  end: zod.z.coerce.date().optional().describe("End of date range (inclusive by default)"),
  startExclusive: zod.z.boolean().optional().describe("When true, excludes the start date from results (uses > instead of >=)"),
  endExclusive: zod.z.boolean().optional().describe("When true, excludes the end date from results (uses < instead of <=)")
}).describe("Date range filter for timestamps");
var sortDirectionSchema = zod.z.enum(["ASC", "DESC"]).describe("Sort direction: 'ASC' | 'DESC'");
var entityTypeField = zod.z.nativeEnum(chunkS65YV6YB_cjs.EntityType).describe(`Entity type (e.g., 'agent' | 'processor' | 'tool' | 'workflow')`);
var entityIdField = zod.z.string().describe('ID of the entity (e.g., "weatherAgent", "orderWorkflow")');
var entityNameField = zod.z.string().describe("Name of the entity");
var userIdField = zod.z.string().describe("Human end-user who triggered execution");
var organizationIdField = zod.z.string().describe("Multi-tenant organization/account");
var resourceIdField = zod.z.string().describe("Broader resource context (Mastra memory compatibility)");
var runIdField = zod.z.string().describe("Unique execution run identifier");
var sessionIdField = zod.z.string().describe("Session identifier for grouping traces");
var threadIdField = zod.z.string().describe("Conversation thread identifier");
var requestIdField = zod.z.string().describe("HTTP request ID for log correlation");
var environmentField = zod.z.string().describe(`Environment (e.g., "production" | "staging" | "development")`);
var sourceField = zod.z.string().describe(`Source of execution (e.g., "local" | "cloud" | "ci")`);
var serviceNameField = zod.z.string().describe("Name of the service");

// src/evals/types.ts
var scoringSourceSchema = zod.z.enum(["LIVE", "TEST"]);
var scoringEntityTypeSchema = zod.z.enum(["AGENT", "WORKFLOW", ...Object.values(chunkS65YV6YB_cjs.SpanType)]);
var scoringPromptsSchema = zod.z.object({
  description: zod.z.string(),
  prompt: zod.z.string()
});
var recordSchema = zod.z.record(zod.z.string(), zod.z.unknown());
var optionalRecordSchema = recordSchema.optional();
var scoringInputSchema = zod.z.object({
  runId: zod.z.string().optional(),
  input: zod.z.unknown().optional(),
  output: zod.z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema
  // Note: tracingContext is not serializable, so we don't include it in the schema
  // It's added at runtime when needed
});
var scoringHookInputSchema = zod.z.object({
  runId: zod.z.string().optional(),
  scorer: recordSchema,
  input: zod.z.unknown(),
  output: zod.z.unknown(),
  metadata: optionalRecordSchema,
  additionalContext: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema,
  requestContext: optionalRecordSchema,
  structuredOutput: zod.z.boolean().optional(),
  traceId: zod.z.string().optional(),
  spanId: zod.z.string().optional(),
  resourceId: zod.z.string().optional(),
  threadId: zod.z.string().optional()
  // Note: tracingContext is not serializable, so we don't include it in the schema
});
var scoringExtractStepResultSchema = optionalRecordSchema;
var scoringValueSchema = zod.z.number();
var scoreResultSchema = zod.z.object({
  result: optionalRecordSchema,
  score: scoringValueSchema,
  prompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultSchema = scoringInputSchema.extend({
  runId: zod.z.string(),
  // Required in this context
  extractStepResult: optionalRecordSchema,
  extractPrompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultSchema.extend({
  score: zod.z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema.extend({
  reason: zod.z.string().optional(),
  reasonPrompt: zod.z.string().optional()
});
var scoreRowDataSchema = zod.z.object({
  id: zod.z.string(),
  scorerId: zod.z.string(),
  entityId: zod.z.string(),
  // From ScoringInputWithExtractStepResultAndScoreAndReason
  runId: zod.z.string(),
  input: zod.z.unknown().optional(),
  output: zod.z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema,
  extractStepResult: optionalRecordSchema,
  extractPrompt: zod.z.string().optional(),
  score: zod.z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: zod.z.string().optional(),
  reason: zod.z.string().optional(),
  reasonPrompt: zod.z.string().optional(),
  // From ScoringHookInput
  scorer: recordSchema,
  metadata: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema.optional(),
  structuredOutput: zod.z.boolean().optional(),
  traceId: zod.z.string().optional(),
  spanId: zod.z.string().optional(),
  resourceId: zod.z.string().optional(),
  threadId: zod.z.string().optional(),
  // Additional ScoreRowData fields
  preprocessStepResult: optionalRecordSchema,
  preprocessPrompt: zod.z.string().optional(),
  generateScorePrompt: zod.z.string().optional(),
  generateReasonPrompt: zod.z.string().optional(),
  // Timestamps
  ...dbTimestamps
});
var saveScorePayloadSchema = scoreRowDataSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var listScoresResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  scores: zod.z.array(scoreRowDataSchema)
});

// src/storage/domains/observability/types.ts
var createOmitKeys = (shape) => Object.fromEntries(Object.keys(shape).map((k) => [k, true]));
var traceIdField = zod.z.string().describe("Unique trace identifier");
var spanIdField = zod.z.string().describe("Unique span identifier within a trace");
var spanNameField = zod.z.string().describe("Human-readable span name");
var parentSpanIdField = zod.z.string().describe("Parent span reference (null = root span)");
var spanTypeField = zod.z.nativeEnum(chunkS65YV6YB_cjs.SpanType).describe("Span type (e.g., WORKFLOW_RUN, AGENT_RUN, TOOL_CALL, etc.)");
var attributesField = zod.z.record(zod.z.unknown()).describe("Span-type specific attributes (e.g., model, tokens, tools)");
var metadataField = zod.z.record(zod.z.unknown()).describe("User-defined metadata for custom filtering");
var tagsField = zod.z.array(zod.z.string()).describe("Labels for filtering traces (only on the root span)");
var scopeField = zod.z.record(zod.z.unknown()).describe('Arbitrary package/app version info (e.g., {"core": "1.0.0", "memory": "1.0.0", "gitSha": "abcd1234"})');
var linksField = zod.z.array(zod.z.unknown()).describe("References to related spans in other traces");
var inputField = zod.z.unknown().describe("Input data passed to the span");
var outputField = zod.z.unknown().describe("Output data returned from the span");
var errorField = zod.z.unknown().describe("Error info - presence indicates failure (status derived from this)");
var isEventField = zod.z.boolean().describe("Whether this is an event (point-in-time) vs a span (duration)");
var startedAtField = zod.z.date().describe("When the span started");
var endedAtField = zod.z.date().describe("When the span ended (null = running, status derived from this)");
var TraceStatus = /* @__PURE__ */ ((TraceStatus2) => {
  TraceStatus2["SUCCESS"] = "success";
  TraceStatus2["ERROR"] = "error";
  TraceStatus2["RUNNING"] = "running";
  return TraceStatus2;
})(TraceStatus || {});
var traceStatusField = zod.z.nativeEnum(TraceStatus).describe("Current status of the trace");
var hasChildErrorField = zod.z.preprocess((v) => {
  if (v === "true") return true;
  if (v === "false") return false;
  return v;
}, zod.z.boolean()).describe("True if any span in the trace encountered an error");
var sharedFields = {
  // Entity identification - first-class fields for filtering (e.g., agent, workflow, tool)
  entityType: entityTypeField.nullish(),
  entityId: entityIdField.nullish(),
  entityName: entityNameField.nullish(),
  // Identity & tenancy - for multi-tenant applications
  userId: userIdField.nullish(),
  organizationId: organizationIdField.nullish(),
  resourceId: resourceIdField.nullish(),
  // Correlation IDs - for linking related operations
  runId: runIdField.nullish(),
  sessionId: sessionIdField.nullish(),
  threadId: threadIdField.nullish(),
  requestId: requestIdField.nullish(),
  // Deployment context - these fields only exist on the root span
  environment: environmentField.nullish(),
  source: sourceField.nullish(),
  serviceName: serviceNameField.nullish(),
  scope: scopeField.nullish(),
  // Filterable data - user-defined metadata and tags (tags only on root span)
  metadata: metadataField.nullish(),
  tags: tagsField.nullish()
};
var spanIds = {
  traceId: traceIdField,
  spanId: spanIdField
};
var spanIdsSchema = zod.z.object({
  ...spanIds
});
var omitDbTimestamps = createOmitKeys(dbTimestamps);
var omitSpanIds = createOmitKeys(spanIds);
var spanRecordSchema = zod.z.object({
  // Required identifiers
  ...spanIds,
  name: spanNameField,
  spanType: spanTypeField,
  isEvent: isEventField,
  startedAt: startedAtField,
  // Shared fields
  parentSpanId: parentSpanIdField.nullish(),
  ...sharedFields,
  // Additional span-specific nullish fields
  attributes: attributesField.nullish(),
  links: linksField.nullish(),
  input: inputField.nullish(),
  output: outputField.nullish(),
  error: errorField.nullish(),
  endedAt: endedAtField.nullish(),
  // Database timestamps
  ...dbTimestamps
}).describe("Span record data");
var createSpanRecordSchema = spanRecordSchema.omit(omitDbTimestamps);
var createSpanArgsSchema = zod.z.object({
  span: createSpanRecordSchema
}).describe("Arguments for creating a single span");
var batchCreateSpansArgsSchema = zod.z.object({
  records: zod.z.array(createSpanRecordSchema)
}).describe("Arguments for batch creating spans");
var getSpanArgsSchema = zod.z.object({
  traceId: traceIdField.min(1),
  spanId: spanIdField.min(1)
}).describe("Arguments for getting a single span");
var getSpanResponseSchema = zod.z.object({
  span: spanRecordSchema
});
var getRootSpanArgsSchema = zod.z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a root span");
var getRootSpanResponseSchema = zod.z.object({
  span: spanRecordSchema
});
var getTraceArgsSchema = zod.z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a single trace");
var getTraceResponseSchema = zod.z.object({
  traceId: traceIdField,
  spans: zod.z.array(spanRecordSchema)
});
var tracesFilterSchema = zod.z.object({
  // Date range filters
  startedAt: dateRangeSchema.optional().describe("Filter by span start time range"),
  endedAt: dateRangeSchema.optional().describe("Filter by span end time range"),
  // Span type filter
  spanType: spanTypeField.optional(),
  // Shared fields
  ...sharedFields,
  // Filter-specific derived status fields
  status: traceStatusField.optional(),
  hasChildError: hasChildErrorField.optional()
}).describe("Filters for querying traces");
var tracesOrderByFieldSchema = zod.z.enum(["startedAt", "endedAt"]).describe("Field to order by: 'startedAt' | 'endedAt'");
var tracesOrderBySchema = zod.z.object({
  field: tracesOrderByFieldSchema.default("startedAt").describe("Field to order by"),
  direction: sortDirectionSchema.default("DESC").describe("Sort direction")
}).describe("Order by configuration");
var listTracesArgsSchema = zod.z.object({
  filters: tracesFilterSchema.optional().describe("Optional filters to apply"),
  pagination: paginationArgsSchema.default({}).describe("Pagination settings"),
  orderBy: tracesOrderBySchema.default({}).describe("Ordering configuration (defaults to startedAt desc)")
}).describe("Arguments for listing traces");
var listTracesResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  spans: zod.z.array(spanRecordSchema)
});
var updateSpanRecordSchema = createSpanRecordSchema.omit(omitSpanIds);
var updateSpanArgsSchema = zod.z.object({
  spanId: spanIdField,
  traceId: traceIdField,
  updates: updateSpanRecordSchema.partial()
}).describe("Arguments for updating a single span");
var batchUpdateSpansArgsSchema = zod.z.object({
  records: zod.z.array(
    zod.z.object({
      traceId: traceIdField,
      spanId: spanIdField,
      updates: updateSpanRecordSchema.partial()
    })
  )
}).describe("Arguments for batch updating spans");
var batchDeleteTracesArgsSchema = zod.z.object({
  traceIds: zod.z.array(traceIdField)
}).describe("Arguments for batch deleting traces");
var listScoresBySpanResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  scores: zod.z.array(scoreRowDataSchema)
});
var scoreTracesRequestSchema = zod.z.object({
  scorerName: zod.z.string().min(1),
  targets: zod.z.array(
    zod.z.object({
      traceId: traceIdField,
      spanId: spanIdField.optional()
    })
  ).min(1)
});
var scoreTracesResponseSchema = zod.z.object({
  status: zod.z.string(),
  message: zod.z.string(),
  traceCount: zod.z.number()
});

// src/storage/types.ts
function getInnerType(schema, typeName) {
  const schemaAny = schema;
  if (typeName === "ZodNullable" || typeName === "ZodOptional" || typeName === "ZodDefault") {
    return schemaAny._zod?.def?.innerType ?? schemaAny._def?.innerType;
  }
  if (typeName === "ZodEffects") {
    return schemaAny._zod?.def?.schema ?? schemaAny._def?.schema;
  }
  if (typeName === "ZodBranded") {
    return schemaAny._zod?.def?.type ?? schemaAny._def?.type;
  }
  return void 0;
}
function unwrapSchema(schema) {
  let current = schema;
  let nullable = false;
  while (true) {
    const typeName = chunkVW7YQWDW_cjs.getZodTypeName(current);
    if (typeName === "ZodNullable") {
      nullable = true;
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodOptional") {
      nullable = true;
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodDefault") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodEffects") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    if (typeName === "ZodBranded") {
      const inner = getInnerType(current, typeName);
      if (inner) {
        current = inner;
        continue;
      }
    }
    break;
  }
  return { base: current, nullable };
}
function getZodChecks(schema) {
  const schemaAny = schema;
  if (schemaAny._zod?.def?.checks) {
    return schemaAny._zod.def.checks;
  }
  if (schemaAny._def?.checks) {
    return schemaAny._def.checks;
  }
  return [];
}
function zodToStorageType(schema) {
  const typeName = chunkVW7YQWDW_cjs.getZodTypeName(schema);
  if (typeName === "ZodString") {
    const checks = getZodChecks(schema);
    if (checks.some((c) => c.kind === "uuid")) {
      return "uuid";
    }
    return "text";
  }
  if (typeName === "ZodNativeEnum" || typeName === "ZodEnum") {
    return "text";
  }
  if (typeName === "ZodNumber") {
    const checks = getZodChecks(schema);
    return checks.some((c) => c.kind === "int") ? "integer" : "float";
  }
  if (typeName === "ZodBigInt") {
    return "bigint";
  }
  if (typeName === "ZodDate") {
    return "timestamp";
  }
  if (typeName === "ZodBoolean") {
    return "boolean";
  }
  return "jsonb";
}
function buildStorageSchema(zObject) {
  const shape = zObject.shape;
  const result = {};
  for (const [key, field] of Object.entries(shape)) {
    const { base, nullable } = unwrapSchema(field);
    result[key] = {
      type: zodToStorageType(base),
      nullable
    };
  }
  return result;
}

// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_RESOURCES = "mastra_resources";
var TABLE_SCORERS = "mastra_scorers";
var TABLE_SPANS = "mastra_ai_spans";
var TABLE_AGENTS = "mastra_agents";
var SCORERS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerId: { type: "text" },
  traceId: { type: "text", nullable: true },
  spanId: { type: "text", nullable: true },
  runId: { type: "text" },
  scorer: { type: "jsonb" },
  preprocessStepResult: { type: "jsonb", nullable: true },
  extractStepResult: { type: "jsonb", nullable: true },
  analyzeStepResult: { type: "jsonb", nullable: true },
  score: { type: "float" },
  reason: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  preprocessPrompt: { type: "text", nullable: true },
  extractPrompt: { type: "text", nullable: true },
  generateScorePrompt: { type: "text", nullable: true },
  generateReasonPrompt: { type: "text", nullable: true },
  analyzePrompt: { type: "text", nullable: true },
  // Deprecated
  reasonPrompt: { type: "text", nullable: true },
  input: { type: "jsonb" },
  output: { type: "jsonb" },
  // MESSAGE OUTPUT
  additionalContext: { type: "jsonb", nullable: true },
  // DATA FROM THE CONTEXT PARAM ON AN AGENT
  requestContext: { type: "jsonb", nullable: true },
  // THE EVALUATE Request Context FOR THE RUN
  /**
   * Things you can evaluate
   */
  entityType: { type: "text", nullable: true },
  // WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entity: { type: "jsonb", nullable: true },
  // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entityId: { type: "text", nullable: true },
  source: { type: "text" },
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  createdAt: { type: "timestamp" },
  updatedAt: { type: "timestamp" }
};
var SPAN_SCHEMA = buildStorageSchema(spanRecordSchema);
var OLD_SPAN_SCHEMA = {
  // Composite primary key of traceId and spanId
  traceId: { type: "text", nullable: false },
  spanId: { type: "text", nullable: false },
  parentSpanId: { type: "text", nullable: true },
  name: { type: "text", nullable: false },
  scope: { type: "jsonb", nullable: true },
  // Mastra package info {"core-version": "0.1.0"}
  spanType: { type: "text", nullable: false },
  // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.
  attributes: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  links: { type: "jsonb", nullable: true },
  input: { type: "jsonb", nullable: true },
  output: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  // When the span started
  endedAt: { type: "timestamp", nullable: true },
  // When the span ended
  createdAt: { type: "timestamp", nullable: false },
  // The time the database record was created
  updatedAt: { type: "timestamp", nullable: true },
  // The time the database record was last updated
  isEvent: { type: "boolean", nullable: false }
};
var AGENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  instructions: { type: "text", nullable: false },
  // System instructions for the agent
  model: { type: "jsonb", nullable: false },
  // Model configuration (provider, name, etc.)
  tools: { type: "jsonb", nullable: true },
  // Serialized tool references/configurations
  defaultOptions: { type: "jsonb", nullable: true },
  // Default options for generate/stream calls
  workflows: { type: "jsonb", nullable: true },
  // Workflow references (IDs or configurations)
  agents: { type: "jsonb", nullable: true },
  // Sub-agent references (IDs or configurations)
  inputProcessors: { type: "jsonb", nullable: true },
  // Input processor configurations
  outputProcessors: { type: "jsonb", nullable: true },
  // Output processor configurations
  memory: { type: "jsonb", nullable: true },
  // Memory configuration
  scorers: { type: "jsonb", nullable: true },
  // Scorer configurations
  metadata: { type: "jsonb", nullable: true },
  // Additional metadata for the agent
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var TABLE_SCHEMAS = {
  [TABLE_WORKFLOW_SNAPSHOT]: {
    workflow_name: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    resourceId: { type: "text", nullable: true },
    snapshot: {
      type: "jsonb"
    },
    createdAt: {
      type: "timestamp"
    },
    updatedAt: {
      type: "timestamp"
    }
  },
  [TABLE_SCORERS]: SCORERS_SCHEMA,
  [TABLE_THREADS]: {
    id: { type: "text", nullable: false, primaryKey: true },
    resourceId: { type: "text", nullable: false },
    title: { type: "text", nullable: false },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_MESSAGES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    thread_id: { type: "text", nullable: false },
    content: { type: "text", nullable: false },
    role: { type: "text", nullable: false },
    type: { type: "text", nullable: false },
    createdAt: { type: "timestamp", nullable: false },
    resourceId: { type: "text", nullable: true }
  },
  [TABLE_SPANS]: SPAN_SCHEMA,
  [TABLE_TRACES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    parentSpanId: { type: "text", nullable: true },
    name: { type: "text", nullable: false },
    traceId: { type: "text", nullable: false },
    scope: { type: "text", nullable: false },
    kind: { type: "integer", nullable: false },
    attributes: { type: "jsonb", nullable: true },
    status: { type: "jsonb", nullable: true },
    events: { type: "jsonb", nullable: true },
    links: { type: "jsonb", nullable: true },
    other: { type: "text", nullable: true },
    startTime: { type: "bigint", nullable: false },
    endTime: { type: "bigint", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  },
  [TABLE_RESOURCES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    workingMemory: { type: "text", nullable: true },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_AGENTS]: AGENTS_SCHEMA
};

exports.AGENTS_SCHEMA = AGENTS_SCHEMA;
exports.OLD_SPAN_SCHEMA = OLD_SPAN_SCHEMA;
exports.SCORERS_SCHEMA = SCORERS_SCHEMA;
exports.SPAN_SCHEMA = SPAN_SCHEMA;
exports.TABLE_AGENTS = TABLE_AGENTS;
exports.TABLE_MESSAGES = TABLE_MESSAGES;
exports.TABLE_RESOURCES = TABLE_RESOURCES;
exports.TABLE_SCHEMAS = TABLE_SCHEMAS;
exports.TABLE_SCORERS = TABLE_SCORERS;
exports.TABLE_SPANS = TABLE_SPANS;
exports.TABLE_THREADS = TABLE_THREADS;
exports.TABLE_TRACES = TABLE_TRACES;
exports.TABLE_WORKFLOW_SNAPSHOT = TABLE_WORKFLOW_SNAPSHOT;
exports.TraceStatus = TraceStatus;
exports.batchCreateSpansArgsSchema = batchCreateSpansArgsSchema;
exports.batchDeleteTracesArgsSchema = batchDeleteTracesArgsSchema;
exports.batchUpdateSpansArgsSchema = batchUpdateSpansArgsSchema;
exports.buildStorageSchema = buildStorageSchema;
exports.createSpanArgsSchema = createSpanArgsSchema;
exports.createSpanRecordSchema = createSpanRecordSchema;
exports.createdAtField = createdAtField;
exports.dateRangeSchema = dateRangeSchema;
exports.dbTimestamps = dbTimestamps;
exports.entityIdField = entityIdField;
exports.entityNameField = entityNameField;
exports.entityTypeField = entityTypeField;
exports.environmentField = environmentField;
exports.getRootSpanArgsSchema = getRootSpanArgsSchema;
exports.getRootSpanResponseSchema = getRootSpanResponseSchema;
exports.getSpanArgsSchema = getSpanArgsSchema;
exports.getSpanResponseSchema = getSpanResponseSchema;
exports.getTraceArgsSchema = getTraceArgsSchema;
exports.getTraceResponseSchema = getTraceResponseSchema;
exports.listScoresBySpanResponseSchema = listScoresBySpanResponseSchema;
exports.listScoresResponseSchema = listScoresResponseSchema;
exports.listTracesArgsSchema = listTracesArgsSchema;
exports.listTracesResponseSchema = listTracesResponseSchema;
exports.organizationIdField = organizationIdField;
exports.paginationArgsSchema = paginationArgsSchema;
exports.paginationInfoSchema = paginationInfoSchema;
exports.requestIdField = requestIdField;
exports.resourceIdField = resourceIdField;
exports.runIdField = runIdField;
exports.saveScorePayloadSchema = saveScorePayloadSchema;
exports.scoreResultSchema = scoreResultSchema;
exports.scoreRowDataSchema = scoreRowDataSchema;
exports.scoreTracesRequestSchema = scoreTracesRequestSchema;
exports.scoreTracesResponseSchema = scoreTracesResponseSchema;
exports.scoringEntityTypeSchema = scoringEntityTypeSchema;
exports.scoringExtractStepResultSchema = scoringExtractStepResultSchema;
exports.scoringHookInputSchema = scoringHookInputSchema;
exports.scoringInputSchema = scoringInputSchema;
exports.scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema;
exports.scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndScoreAndReasonSchema;
exports.scoringInputWithExtractStepResultSchema = scoringInputWithExtractStepResultSchema;
exports.scoringPromptsSchema = scoringPromptsSchema;
exports.scoringSourceSchema = scoringSourceSchema;
exports.scoringValueSchema = scoringValueSchema;
exports.serviceNameField = serviceNameField;
exports.sessionIdField = sessionIdField;
exports.sortDirectionSchema = sortDirectionSchema;
exports.sourceField = sourceField;
exports.spanIdField = spanIdField;
exports.spanIds = spanIds;
exports.spanIdsSchema = spanIdsSchema;
exports.spanRecordSchema = spanRecordSchema;
exports.threadIdField = threadIdField;
exports.traceIdField = traceIdField;
exports.tracesFilterSchema = tracesFilterSchema;
exports.tracesOrderByFieldSchema = tracesOrderByFieldSchema;
exports.tracesOrderBySchema = tracesOrderBySchema;
exports.updateSpanArgsSchema = updateSpanArgsSchema;
exports.updateSpanRecordSchema = updateSpanRecordSchema;
exports.updatedAtField = updatedAtField;
exports.userIdField = userIdField;
//# sourceMappingURL=chunk-U6CL7U6Y.cjs.map
//# sourceMappingURL=chunk-U6CL7U6Y.cjs.map