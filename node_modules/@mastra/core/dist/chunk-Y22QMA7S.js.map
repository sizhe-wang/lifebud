{"version":3,"sources":["../src/request-context/index.ts"],"names":[],"mappings":";AAgBO,IAAM,sBAAA,GAAyB;AAc/B,IAAM,oBAAA,GAAuB;AAE7B,IAAM,iBAAN,MAA6E;AAAA,EAC1E,QAAA,uBAAe,GAAA,EAAqB;AAAA,EAE5C,YACE,QAAA,EAGA;AACA,IAAA,IAAA,CAAK,QAAA,GAAW,IAAI,GAAA,CAAI,QAAQ,CAAA;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,GAAA,CACL,KACA,KAAA,EACM;AAEN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAA,EAAe,KAAK,CAAA;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,IAGL,GAAA,EAAW;AACX,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAa,CAAA;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,IAA0E,GAAA,EAAiB;AAChG,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAG,CAAA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKO,OAA6E,GAAA,EAAiB;AACnG,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,GAAG,CAAA;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKO,KAAA,GAAc;AACnB,IAAA,IAAA,CAAK,SAAS,KAAA,EAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKO,IAAA,GAAqF;AAC1F,IAAA,OAAO,IAAA,CAAK,SAAS,IAAA,EAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,MAAA,GAAgG;AACrG,IAAA,OAAO,IAAA,CAAK,SAAS,MAAA,EAAO;AAAA,EAG9B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAA,GAEL;AACA,IAAA,OAAO,IAAA,CAAK,SAAS,OAAA,EAAQ;AAAA,EAG/B;AAAA;AAAA;AAAA;AAAA,EAKO,IAAA,GAAe;AACpB,IAAA,OAAO,KAAK,QAAA,CAAS,IAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,QACL,UAAA,EAKM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,UAA8E,CAAA;AAAA,EACtG;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAA,GAA8B;AACnC,IAAA,OAAO,MAAA,CAAO,WAAA,CAAY,IAAA,CAAK,QAAQ,CAAA;AAAA,EACzC;AACF","file":"chunk-Y22QMA7S.js","sourcesContent":["type RecordToTuple<T> = {\n  [K in keyof T]: [K, T[K]];\n}[keyof T][];\n\n/**\n * Reserved key for setting resourceId from middleware.\n * When set in RequestContext, this takes precedence over client-provided values\n * for security (prevents attackers from hijacking another user's memory).\n *\n * @example\n * ```typescript\n * // In your auth middleware:\n * const requestContext = c.get('requestContext');\n * requestContext.set(MASTRA_RESOURCE_ID_KEY, authenticatedUser.id);\n * ```\n */\nexport const MASTRA_RESOURCE_ID_KEY = 'mastra__resourceId';\n\n/**\n * Reserved key for setting threadId from middleware.\n * When set in RequestContext, this takes precedence over client-provided values\n * for security (prevents attackers from hijacking another user's memory).\n *\n * @example\n * ```typescript\n * // In your auth middleware:\n * const requestContext = c.get('requestContext');\n * requestContext.set(MASTRA_THREAD_ID_KEY, threadId);\n * ```\n */\nexport const MASTRA_THREAD_ID_KEY = 'mastra__threadId';\n\nexport class RequestContext<Values extends Record<string, any> | unknown = unknown> {\n  private registry = new Map<string, unknown>();\n\n  constructor(\n    iterable?: Values extends Record<string, any>\n      ? RecordToTuple<Partial<Values>>\n      : Iterable<readonly [string, unknown]>,\n  ) {\n    this.registry = new Map(iterable);\n  }\n\n  /**\n   * set a value with strict typing if `Values` is a Record and the key exists in it.\n   */\n  public set<K extends Values extends Record<string, any> ? keyof Values : string>(\n    key: K,\n    value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  ): void {\n    // The type assertion `key as string` is safe because K always extends string ultimately.\n    this.registry.set(key as string, value);\n  }\n\n  /**\n   * Get a value with its type\n   */\n  public get<\n    K extends Values extends Record<string, any> ? keyof Values : string,\n    R = Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  >(key: K): R {\n    return this.registry.get(key as string) as R;\n  }\n\n  /**\n   * Check if a key exists in the container\n   */\n  public has<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.has(key);\n  }\n\n  /**\n   * Delete a value by key\n   */\n  public delete<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.delete(key);\n  }\n\n  /**\n   * Clear all values from the container\n   */\n  public clear(): void {\n    this.registry.clear();\n  }\n\n  /**\n   * Get all keys in the container\n   */\n  public keys(): IterableIterator<Values extends Record<string, any> ? keyof Values : string> {\n    return this.registry.keys() as IterableIterator<Values extends Record<string, any> ? keyof Values : string>;\n  }\n\n  /**\n   * Get all values in the container\n   */\n  public values(): IterableIterator<Values extends Record<string, any> ? Values[keyof Values] : unknown> {\n    return this.registry.values() as IterableIterator<\n      Values extends Record<string, any> ? Values[keyof Values] : unknown\n    >;\n  }\n\n  /**\n   * Get all entries in the container.\n   * Returns a discriminated union of tuples for proper type narrowing when iterating.\n   */\n  public entries(): IterableIterator<\n    Values extends Record<string, any> ? { [K in keyof Values]: [K, Values[K]] }[keyof Values] : [string, unknown]\n  > {\n    return this.registry.entries() as IterableIterator<\n      Values extends Record<string, any> ? { [K in keyof Values]: [K, Values[K]] }[keyof Values] : [string, unknown]\n    >;\n  }\n\n  /**\n   * Get the size of the container\n   */\n  public size(): number {\n    return this.registry.size;\n  }\n\n  /**\n   * Execute a function for each entry in the container.\n   * The callback receives properly typed key-value pairs.\n   */\n  public forEach<K extends Values extends Record<string, any> ? keyof Values : string>(\n    callbackfn: (\n      value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : unknown) : unknown,\n      key: K,\n      map: Map<string, unknown>,\n    ) => void,\n  ): void {\n    this.registry.forEach(callbackfn as (value: unknown, key: string, map: Map<string, unknown>) => void);\n  }\n\n  /**\n   * Custom JSON serialization method\n   * Converts the internal Map to a plain object for proper JSON serialization\n   */\n  public toJSON(): Record<string, any> {\n    return Object.fromEntries(this.registry);\n  }\n}\n"]}