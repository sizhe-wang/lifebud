# Workflows API Reference

> API reference for workflows - 20 entries


---

## Reference: Workflow.branch()

> Documentation for the `Workflow.branch()` method in workflows, which creates conditional branches between steps.

The `.branch()` method creates conditional branches between workflow steps, allowing for different paths to be taken based on the result of a previous step.

## Usage example

```typescript
workflow.branch([
  [async ({ context }) => true, step1],
  [async ({ context }) => false, step2],
]);
```

## Parameters

## Returns

## Related

- [Conditional Branching Logic](https://mastra.ai/docs/v1/workflows/control-flow#conditional-logic-with-branch)
- [Control Flow](https://mastra.ai/docs/v1/workflows/control-flow)

---

## Reference: Run.cancel()

> Documentation for the `Run.cancel()` method in workflows, which cancels a workflow run.

The `.cancel()` method cancels a workflow run, stopping execution and cleaning up resources.

This method aborts any running steps and updates the workflow status to 'canceled'. It works for both actively running workflows and suspended/waiting workflows.

## Usage example

```typescript
const run = await workflow.createRun();

await run.cancel();
// Returns: { message: 'Workflow run canceled' }
```

## Parameters

## Returns

## How cancellation works

When called, the workflow will:
1. **Trigger the abort signal** - Uses the standard Web API AbortSignal to notify running steps
2. **Prevent subsequent steps** - No further steps will be executed

## Abort signal behavior

Steps that check the `abortSignal` parameter can respond to cancellation:
- Steps can listen to the 'abort' event: `abortSignal.addEventListener('abort', callback)`
- Steps can check if already aborted: `if (abortSignal.aborted) { ... }`
- Useful for cancelling timeouts, network requests, or long-running operations

**Note:** Steps must actively check the abort signal to be canceled mid-execution. Steps that don't check the signal will run to completion, but subsequent steps won't execute.

## Extended usage examples

### Cancelling a workflow on error

```typescript
const run = await workflow.createRun();

try {
  const result = await run.start({ inputData: { value: "initial data" } });
} catch (error) {
  await run.cancel();
}
```

### Creating a step that responds to cancellation

```typescript
const step = createStep({
  id: 'long-running-step',
  execute: async ({ inputData, abortSignal, abort }) => {
    const timeout = new Promise((resolve) => {
      const timer = setTimeout(() => resolve('done'), 10000);
      
      // Clean up if canceled
      abortSignal.addEventListener('abort', () => {
        clearTimeout(timer);
        resolve('canceled');
      });
    });
    
    const result = await timeout;
    
    // Check if aborted after async operation
    if (abortSignal.aborted) {
      return abort(); // Stop execution
    }
    
    return { result };
  }
});
```

## Related

- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview#running-workflows)
- [Workflow.createRun()](../workflow-methods/create-run)

---

## Reference: Workflow.commit()

> Documentation for the `Workflow.commit()` method in workflows, which finalizes the workflow and returns the final result.

The `.commit()` method finalizes the workflow and returns the final result.

## Usage example

```typescript
workflow.then(step1).commit();
```

## Returns

## Related

- [Control Flow](https://mastra.ai/docs/v1/workflows/control-flow)

---

## Reference: Workflow.createRun()

> Documentation for the `Workflow.createRun()` method in workflows, which creates a new workflow run instance.

The `.createRun()` method creates a new workflow run instance, allowing you to execute the workflow with specific input data. This is the current API that returns a `Run` instance.

## Usage example

```typescript
await workflow.createRun();
```

## Parameters

## Returns

## Extended usage example

```typescript
const workflow = mastra.getWorkflow("workflow");

const run = await workflow.createRun();

const result = await run.start({
  inputData: {
    value: 10,
  },
});
```

## Using resourceId

The `resourceId` parameter associates a workflow run with a specific resource, such as a user or tenant. This is useful for multi-tenant applications or when you need to track which user initiated a workflow.

```typescript
const workflow = mastra.getWorkflow("workflow");

// Create a run associated with a specific user
const run = await workflow.createRun({
  resourceId: "user-123",
});

const result = await run.start({
  inputData: {
    value: 10,
  },
});

// Later, retrieve the run and access the resourceId
const storedRun = await workflow.getWorkflowRunById(run.runId);
console.log(storedRun.resourceId); // "user-123"
```

## Related

- [Run Class](../run)
- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview)

---

## Reference: Workflow.dountil()

> Documentation for the `Workflow.dountil()` method in workflows, which creates a loop that executes a step until a condition is met.

The `.dountil()` method executes a step until a condition is met. It always runs the step at least once before evaluating the condition. The first time the condition is evaluated, `iterationCount` is `1`.

## Usage example

```typescript
workflow.dountil(step1, async ({ inputData }) => true);
```

## Parameters

## Returns

## Related

- [Control Flow](https://mastra.ai/docs/v1/workflows/control-flow)

- [ExecuteParams](../step#executeparams)

---

## Reference: Workflow.dowhile()

> Documentation for the `Workflow.dowhile()` method in workflows, which creates a loop that executes a step while a condition is met.

The `.dowhile()` method executes a step while a condition is met. It always runs the step at least once before evaluating the condition. The first time the condition is evaluated, `iterationCount` is `1`.

## Usage example

```typescript
workflow.dowhile(step1, async ({ inputData }) => true);
```

## Parameters

## Returns

## Related

- [Control Flow](https://mastra.ai/docs/v1/workflows/control-flow)

- [ExecuteParams](../step#executeparams)

---

## Reference: Workflow.foreach()

> Documentation for the `Workflow.foreach()` method in workflows, which creates a loop that executes a step for each item in an array.

The `.foreach()` method creates a loop that executes a step for each item in an array. It always returns an array containing the output from each iteration, preserving the original order.

## Usage example

```typescript
workflow.foreach(step1, { concurrency: 2 });
```

## Parameters

## Returns

## Behavior

### Execution and waiting

The `.foreach()` method processes all items before the next step executes. The step following `.foreach()` only runs after every iteration has completed, regardless of concurrency settings. With `concurrency: 1` (default), items process sequentially. With higher concurrency, items process in parallel batches, but the next step still waits for all batches to finish.

If you need to run multiple operations per item, use a nested workflow as the step. This keeps all operations for each item together and is cleaner than chaining multiple `.foreach()` calls. See [Nested workflows inside foreach](https://mastra.ai/docs/v1/workflows/control-flow#nested-workflows-inside-foreach) for examples.

### Output structure

`.foreach()` always outputs an array. Each element in the output array corresponds to the result of processing the element at the same index in the input array.

```typescript
// Input: [{ value: 1 }, { value: 2 }, { value: 3 }]
// Step adds 10 to each value
// Output: [{ value: 11 }, { value: 12 }, { value: 13 }]
```

### Using `.then()` after `.foreach()`

When you chain `.then()` after `.foreach()`, the next step receives the entire output array as its input. This allows you to aggregate or process all results together.

```typescript
workflow
  .foreach(processItemStep)    // Output: array of processed items
  .then(aggregateStep)         // Input: the entire array
  .commit();
```

### Using `.map()` after `.foreach()`

Use `.map()` to transform the array output before passing it to the next step:

```typescript
workflow
  .foreach(processItemStep)
  .map(async ({ inputData }) => ({
    total: inputData.reduce((sum, item) => sum + item.value, 0),
    count: inputData.length
  }))
  .then(nextStep)
  .commit();
```

### Chaining multiple `.foreach()` calls

When you chain `.foreach()` calls, each operates on the array from the previous step:

```typescript
workflow
  .foreach(stepA)    // If input is [a, b, c], output is [A, B, C]
  .foreach(stepB)    // Operates on [A, B, C], output is [A', B', C']
  .commit();
```

If a step inside `.foreach()` returns an array, the output becomes an array of arrays. Use `.map()` with `.flat()` to flatten:

```typescript
workflow
  .foreach(chunkStep)           // Output: [[chunk1, chunk2], [chunk3, chunk4]]
  .map(async ({ inputData }) => inputData.flat())  // Output: [chunk1, chunk2, chunk3, chunk4]
  .foreach(embedStep)
  .commit();
```

## Related

- [Looping with foreach](https://mastra.ai/docs/v1/workflows/control-flow#looping-with-foreach)

---

## Reference: Workflow.map()

> Documentation for the `Workflow.map()` method in workflows, which maps output data from a previous step to the input of a subsequent step.

The `.map()` method maps output data from a previous step to the input of a subsequent step, allowing you to transform data between steps.

## Usage example

```typescript
workflow.map(async ({ inputData }) => `${inputData.value} - map`
```

## Parameters

## Returns

## Using `inputData`

Use `inputData` to access the full output of the previous step.

```typescript {3} filename="src/mastra/workflows/test-workflow.ts"
  .then(step1)
  .map(({ inputData }) => {
    console.log(inputData);
  })
```

## Using `getStepResult()`

Use `getStepResult()` to access the full output of a specific step by referencing the step's instance.

```typescript {3} filename="src/mastra/workflows/test-workflow.ts"
  .then(step1)
  .map(async ({ getStepResult }) => {
    console.log(getStepResult(step1));
  })
```

## Using `getInitData()`

Use `getInitData()` to access the initial input data provided to the workflow.

```typescript {3} filename="src/mastra/workflows/test-workflow.ts"
  .then(step1)
  .map(async ({ getInitData }) => {
      console.log(getInitData());
  })
```

## Using `mapVariable()`

The object form of `.map()` provides an alternative declarative syntax for mapping fields. Instead of writing a function, you define an object where each key is a new field name and each value uses `mapVariable()` to extract data from previous steps or workflow input.
Import `mapVariable()` from the workflows module:

```typescript filename="src/mastra/workflows/test-workflow.ts"
import { mapVariable } from "@mastra/core/workflows";
```

### Extracting fields from step outputs

Use `mapVariable()` with `step` to extract a specific field from a step's output and map it to a new field name. The `path` parameter specifies which field to extract.
In this example, the `value` field from `step1`'s output is extracted and mapped to a new field called `details`:

```typescript {3-6} filename="src/mastra/workflows/test-workflow.ts"
  .then(step1)
  .map({
    details: mapVariable({
      step: step1,
      path: "value"
    })
  })
```

### Extracting fields from workflow input

Use `mapVariable()` with `initData` to extract a specific field from the workflow's initial input data. This is useful when you need to pass the original workflow input to a later step.
In this example, the `value` field from the workflow's input is extracted and mapped to a field called `details`:

```typescript {6-9} filename="src/mastra/workflows/test-workflow.ts"
export const testWorkflow = createWorkflow({...});

testWorkflow
  .then(step1)
  .map({
    details: mapVariable({
      initData: testWorkflow,
      path: "value"
    })
  })
```

## Related

- [Input Data Mapping](https://mastra.ai/docs/v1/workflows/control-flow#input-data-mapping)

---

## Reference: Workflow.parallel()

> Documentation for the `Workflow.parallel()` method in workflows, which executes multiple steps in parallel.

The `.parallel()` method executes multiple steps in parallel.

## Usage example

```typescript
workflow.parallel([step1, step2]);
```

## Parameters

## Returns

## Related

- [Simultaneous steps with parallel](https://mastra.ai/docs/v1/workflows/control-flow#simultaneous-steps-with-parallel)

---

## Reference: Run.restart()

> Documentation for the `Run.restart()` method in workflows, which restarts an active workflow run that lost connection to the server.

The `.restart()` method restarts an active workflow run that lost connection to the server, allowing you to continue execution from the moment it lost connection (the last active step).

## Usage example

```typescript
const run = await workflow.createRun();

const result = await run.start({ inputData: { value: "initial data" } });

const restartedResult = await run.restart();
```

## Parameters

## Returns

## Related

- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview#running-workflows)
- [Restart workflows](https://mastra.ai/docs/v1/workflows/overview#restarting-active-workflow-runs)
- [Workflow.createRun()](../workflow-methods/create-run)

---

## Reference: Run.resume()

> Documentation for the `Run.resume()` method in workflows, which resumes a suspended workflow run with new data.

The `.resume()` method resumes a suspended workflow run with new data, allowing you to continue execution from a specific step.

## Usage example

```typescript
const run = await workflow.createRun();

const result = await run.start({ inputData: { value: "initial data" } });

if (result.status === "suspended") {
  const resumedResults = await run.resume({
    resumeData: { value: "resume data" },
  });
}
```

## Parameters

## Returns

## Extended usage example

```typescript
if (result.status === "suspended") {
  const resumedResults = await run.resume({
    step: result.suspended[0],
    resumeData: { value: "resume data" },
  });
}
```

> **Note**: When exactly one step is suspended, you can omit the `step` parameter and the workflow will automatically resume that step. For workflows with multiple suspended steps, you must explicitly specify which step to resume.

## Related

- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview#running-workflows)
- [Workflow.createRun()](../workflow-methods/create-run)
- [Suspend and resume](https://mastra.ai/docs/v1/workflows/suspend-and-resume)
- [Human in the loop](https://mastra.ai/docs/v1/workflows/human-in-the-loop)

---

## Reference: Run Class

> Documentation for the Run class in Mastra, which represents a workflow execution instance.

The `Run` class represents a workflow execution instance, providing methods to start, resume, stream, and monitor workflow execution.

## Usage example

```typescript
const run = await workflow.createRun();

const result = await run.start({
  inputData: { value: "initial data" },
});

if (result.status === "suspended") {
  const resumedResult = await run.resume({
    resumeData: { value: "resume data" },
  });
}
```

## Run Methods

## Run Status

A workflow run's `status` indicates its current execution state. The possible values are:

## Related

- [Run.start()](./run-methods/start)
- [Run.resume()](./run-methods/resume)
- [Run.cancel()](./run-methods/cancel)
- [Run.restart()](./run-methods/restart)
- [Run.timeTravel()](./run-methods/timeTravel)
- [Run.stream()](https://mastra.ai/docs/v1/streaming/workflow-streaming)
- [Run.timeTravelStream()](../streaming/workflows/timeTravelStream)

---

## Reference: Workflow.sleep()

> Documentation for the `Workflow.sleep()` method in workflows, which pauses execution for a specified number of milliseconds.

The `.sleep()` method pauses execution for a specified number of milliseconds. It accepts either a static number or a callback function for dynamic delays.

## Usage example

```typescript
workflow.sleep(5000);
```

## Parameters

## Returns

## Extended usage example

```typescript
import { createWorkflow, createStep } from "@mastra/core/workflows";

const step1 = createStep({...});
const step2 = createStep({...});

export const testWorkflow = createWorkflow({...})
  .then(step1)
  .sleep(async ({ inputData }) => {
    const { delayInMs } = inputData;
    return delayInMs;
  })
  .then(step2)
  .commit();
```

---

## Reference: Workflow.sleepUntil()

> Documentation for the `Workflow.sleepUntil()` method in workflows, which pauses execution until a specified date.

The `.sleepUntil()` method pauses execution until a specified date.

## Usage example

```typescript
workflow.sleepUntil(new Date(Date.now() + 5000));
```

## Parameters

## Returns

## Extended usage example

```typescript
import { createWorkflow, createStep } from "@mastra/core/workflows";

const step1 = createStep({...});
const step2 = createStep({...});

export const testWorkflow = createWorkflow({...})
  .then(step1)
  .sleepUntil(async ({ inputData }) => {
    const { delayInMs } = inputData;
    return new Date(Date.now() + delayInMs);
  })
  .then(step2)
  .commit();
```

---

## Reference: Run.start()

> Documentation for the `Run.start()` method in workflows, which starts a workflow run with input data.

The `.start()` method starts a workflow run with input data, allowing you to execute the workflow from the beginning.

## Usage example

```typescript
const run = await workflow.createRun();

const result = await run.start({
  inputData: {
    value: "initial data",
  },
});
```

## Parameters

## Returns

## Extended usage example

```typescript
import { RequestContext } from "@mastra/core/request-context";

const run = await workflow.createRun();

const requestContext = new RequestContext();
requestContext.set("variable", false);

const result = await run.start({
  inputData: {
    value: "initial data",
  },
  requestContext,
});
```

## Related

- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview#running-workflows)
- [Workflow.createRun()](../workflow-methods/create-run)

---

## Reference: Run.startAsync()

> Documentation for the `Run.startAsync()` method in workflows, which starts a workflow run without waiting for completion (fire-and-forget).

The `.startAsync()` method starts a workflow run without waiting for completion. It returns immediately with the `runId`, allowing the workflow to execute in the background. This is useful for long-running workflows, scheduled tasks, or when you want to avoid blocking on workflow completion.

## Usage example

```typescript
const run = await workflow.createRun();

// Fire-and-forget - returns immediately
const { runId } = await run.startAsync({
  inputData: {
    value: "initial data",
  },
});

// Optionally poll for completion later
const result = await workflow.getWorkflowRunExecutionResult(runId);
```

## Parameters

## Returns

## When to use startAsync()

Use `startAsync()` instead of `start()` when:

- **Long-running workflows**: The workflow may take minutes or hours to complete
- **Scheduled/cron triggers**: You want to trigger a workflow without blocking the scheduler
- **Avoiding polling failures**: With Inngest workflows, `start()` polls for completion which can fail and cause retries. `startAsync()` avoids this issue
- **Background processing**: You want to queue work and handle results asynchronously

## Checking workflow status

After calling `startAsync()`, you can check the workflow status using:

```typescript
// Get the execution result (including step outputs)
const result = await workflow.getWorkflowRunExecutionResult(runId);

if (result?.status === 'success') {
  console.log('Workflow completed:', result.steps);
} else if (result?.status === 'failed') {
  console.log('Workflow failed:', result.error);
} else if (result?.status === 'running') {
  console.log('Workflow still running...');
}
```

## Related

- [Run.start()](./start) - Start a workflow and wait for completion
- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview)
- [Workflow.createRun()](../workflow-methods/create-run)

---

## Reference: Step Class

> Documentation for the Step class in Mastra, which defines individual units of work within a workflow.

The Step class defines individual units of work within a workflow, encapsulating execution logic, data validation, and input/output handling.
It can take either a tool or an agent as a parameter to automatically create a step from them.

## Usage example

```typescript title="src/mastra/workflows/test-workflow.ts"
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number(),
  }),
  outputSchema: z.object({
    value: z.number(),
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value,
    };
  },
});
```

## Creating steps from agents

You can create a step directly from an agent. The step will use the agent's name as its ID.

### Basic agent step

```typescript title="src/mastra/workflows/test-workflow.ts"
import { testAgent } from "../agents/test-agent";

const agentStep = createStep(testAgent);
// inputSchema: { prompt: string }
// outputSchema: { text: string }
```

### Agent step with structured output

Pass `structuredOutput` to have the agent return typed structured data:

```typescript title="src/mastra/workflows/test-workflow.ts"
const articleSchema = z.object({
  title: z.string(),
  summary: z.string(),
  tags: z.array(z.string()),
});

const agentStep = createStep(testAgent, {
  structuredOutput: { schema: articleSchema },
});
// inputSchema: { prompt: string }
// outputSchema: { title: string, summary: string, tags: string[] }
```

### Agent step options

## Constructor Parameters

### ExecuteParams

## Related

- [Workflow state](https://mastra.ai/docs/v1/workflows/workflow-state)
- [Control flow](https://mastra.ai/docs/v1/workflows/control-flow)
- [Using agents and tools](https://mastra.ai/docs/v1/workflows/agents-and-tools)

---

## Reference: Workflow.then()

> Documentation for the `Workflow.then()` method in workflows, which creates sequential dependencies between steps.

The `.then()` method creates a sequential dependency between workflow steps, ensuring steps execute in a specific order.

## Usage example

```typescript
workflow.then(step1).then(step2);
```

## Parameters

## Returns

## Related

- [Control flow](https://mastra.ai/docs/v1/workflows/control-flow)

---

## Reference: Run.timeTravel()

> Documentation for the `Run.timeTravel()` method in workflows, which re-executes a workflow from a specific step.

The `.timeTravel()` method re-executes a workflow starting from any specific step, using either stored snapshot data or custom context you provide. This is useful for debugging failed workflows, testing individual steps with different inputs, or recovering from errors without re-running the entire workflow.

## Usage example

```typescript
const run = await workflow.createRun();

const result = await run.timeTravel({
  step: "step2",
  inputData: { value: 10 },
});
```

## Parameters

## Returns

## Extended usage examples

### Time travel with custom context

```typescript
const result = await run.timeTravel({
  step: "step2",
  context: {
    step1: {
      status: "success",
      payload: { value: 0 },
      output: { step1Result: 2 },
      startedAt: Date.now(),
      endedAt: Date.now(),
    },
  },
});
```

### Time travel to nested workflow step

```typescript
// Using dot notation
const result = await run.timeTravel({
  step: "nestedWorkflow.step3",
  inputData: { value: 10 },
});

// Using array of step IDs
const result = await run.timeTravel({
  step: ["nestedWorkflow", "step3"],
  inputData: { value: 10 },
});
```

### Time travel with initial state

```typescript
const result = await run.timeTravel({
  step: "step2",
  inputData: { value: 10 },
  initialState: {
    counter: 5,
    metadata: { source: "time-travel" },
  },
});
```

### Time travel with nested workflows context

```typescript
const result = await run.timeTravel({
  step: "nestedWorkflow.step3",
  context: {
    step1: {
      status: "success",
      payload: { value: 0 },
      output: { step1Result: 2 },
      startedAt: Date.now(),
      endedAt: Date.now(),
    },
    nestedWorkflow: {
      status: "running",
      payload: { step1Result: 2 },
      startedAt: Date.now(),
    },
  },
  nestedStepsContext: {
    nestedWorkflow: {
      step2: {
        status: "success",
        payload: { step1Result: 2 },
        output: { step2Result: 3 },
        startedAt: Date.now(),
        endedAt: Date.now(),
      },
    },
  },
});
```

## Notes

- Time travel requires storage to be configured since it relies on persisted workflow snapshots
- When re-executing a workflow, the workflow loads the existing snapshot from storage (if available)
- Step results before the target step are reconstructed from the snapshot or provided context
- Execution begins from the specified step with the provided or reconstructed input data
- The workflow continues to completion from that point forward
- Time travel can be used on workflows that have not been run yet by providing custom context or input data for the step to start from.

## Related

- [Time Travel](https://mastra.ai/docs/v1/workflows/time-travel)
- [Workflows overview](https://mastra.ai/docs/v1/workflows/overview#running-workflows)
- [Workflow.createRun()](../workflow-methods/create-run)
- [Snapshots](https://mastra.ai/docs/v1/workflows/snapshots)
- [Suspend & Resume](https://mastra.ai/docs/v1/workflows/suspend-and-resume)

---

## Reference: Workflow Class

> Documentation for the `Workflow` class in Mastra, which enables you to create state machines for complex sequences of operations with conditional branching and data validation.

The `Workflow` class enables you to create state machines for complex sequences of operations with conditional branching and data validation.

## Usage example

```typescript title="src/mastra/workflows/test-workflow.ts"
import { createWorkflow } from "@mastra/core/workflows";
import { z } from "zod";

export const workflow = createWorkflow({
  id: "test-workflow",
  inputSchema: z.object({
    value: z.string(),
  }),
  outputSchema: z.object({
    value: z.string(),
  }),
});
```

## Constructor parameters

### WorkflowOptions

### WorkflowFinishCallbackResult

The result object passed to `onFinish` callbacks.

### WorkflowErrorCallbackInfo

The error info object passed to `onError` callbacks.

## Running with initial state

When starting a workflow run, you can pass `initialState` to set the starting values for the workflow's state:

```typescript
const run = await workflow.createRun();

const result = await run.start({
  inputData: { value: "hello" },
  initialState: {
    counter: 0,
    items: [],
  },
});
```

The `initialState` object should match the structure defined in the workflow's `stateSchema`. See [Workflow State](https://mastra.ai/docs/v1/workflows/workflow-state) for more details.

## Workflow status

A workflow's `status` indicates its current execution state. The possible values are:

### Handling tripwire status

When a workflow contains an agent step that triggers a tripwire, the workflow returns with `status: 'tripwire'` and includes tripwire details:

```typescript
const run = await workflow.createRun();
const result = await run.start({ inputData: { message: "Hello" } });

if (result.status === "tripwire") {
  console.log("Workflow terminated by tripwire:", result.tripwire?.reason);
  console.log("Processor ID:", result.tripwire?.processorId);
  console.log("Retry requested:", result.tripwire?.retry);
}
```

This is distinct from `status: 'failed'` which indicates an unexpected error. A tripwire status means a processor intentionally stopped execution (e.g., for content moderation).

## Related

- [Step Class](./step)
- [Workflow State](https://mastra.ai/docs/v1/workflows/workflow-state)
- [Control flow](https://mastra.ai/docs/v1/workflows/control-flow)