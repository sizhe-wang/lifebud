{"version":3,"sources":["../../../src/evals/scoreTraces/scoreTraces.ts","../../../src/evals/scoreTraces/utils.ts","../../../src/evals/scoreTraces/scoreTracesWorkflow.ts"],"names":["span"],"mappings":"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","file":"index.js","sourcesContent":["import { MastraError } from '../../error';\nimport type { Mastra } from '../../mastra';\n\nexport async function scoreTraces({\n  scorerId,\n  targets,\n  mastra,\n}: {\n  scorerId: string;\n  targets: { traceId: string; spanId?: string }[];\n  mastra: Mastra;\n}) {\n  const workflow = mastra.__getInternalWorkflow('__batch-scoring-traces');\n  try {\n    const run = await workflow.createRun();\n\n    await run.start({ inputData: { targets, scorerId } });\n  } catch (error) {\n    const mastraError = new MastraError(\n      {\n        category: 'SYSTEM',\n        domain: 'SCORER',\n        id: 'MASTRA_SCORER_FAILED_TO_RUN_TRACE_SCORING',\n        details: {\n          scorerId,\n          targets: JSON.stringify(targets),\n        },\n      },\n      error,\n    );\n    mastra.getLogger()?.trackException(mastraError);\n    mastra.getLogger()?.error(mastraError.toString());\n  }\n}\n","import type { MastraDBMessage } from '../../agent';\nimport { SpanType } from '../../observability';\nimport type { SpanRecord, TraceRecord } from '../../storage';\nimport type { ScorerRunInputForAgent, ScorerRunOutputForAgent } from '../types';\n\n// Types for span input/output structures\ninterface SpanMessage {\n  role: string;\n  content: string | Array<{ type: string; text: string }>;\n}\n\ninterface SpanInputWithMessages {\n  messages: SpanMessage[];\n}\n\ninterface SpanOutputWithText {\n  text?: string;\n}\n\n// Type guards for span data\nfunction isSpanMessage(value: unknown): value is SpanMessage {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'role' in value &&\n    typeof (value as SpanMessage).role === 'string' &&\n    'content' in value\n  );\n}\n\nfunction hasMessagesArray(value: unknown): value is SpanInputWithMessages {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'messages' in value &&\n    Array.isArray((value as SpanInputWithMessages).messages)\n  );\n}\n\nfunction hasTextProperty(value: unknown): value is SpanOutputWithText {\n  return typeof value === 'object' && value !== null && 'text' in value;\n}\n\n// // Span tree structure for efficient lookups\ninterface SpanTree {\n  spanMap: Map<string, SpanRecord>;\n  childrenMap: Map<string, SpanRecord[]>;\n  rootSpans: SpanRecord[];\n}\n\n/**\n * Build a hierarchical span tree with efficient lookup maps\n */\nexport function buildSpanTree(spans: SpanRecord[]): SpanTree {\n  const spanMap = new Map<string, SpanRecord>();\n  const childrenMap = new Map<string, SpanRecord[]>();\n  const rootSpans: SpanRecord[] = [];\n\n  // First pass: build span map\n  for (const span of spans) {\n    spanMap.set(span.spanId, span);\n  }\n\n  // Second pass: build parent-child relationships\n  for (const span of spans) {\n    if (span.parentSpanId == null) {\n      // Root span (parentSpanId is null or undefined)\n      rootSpans.push(span);\n    } else {\n      const siblings = childrenMap.get(span.parentSpanId) || [];\n      siblings.push(span);\n      childrenMap.set(span.parentSpanId, siblings);\n    }\n  }\n\n  // Sort children by startedAt timestamp for temporal ordering\n  for (const children of childrenMap.values()) {\n    children.sort((a, b) => new Date(a.startedAt).getTime() - new Date(b.startedAt).getTime());\n  }\n\n  // Sort root spans by startedAt\n  rootSpans.sort((a, b) => new Date(a.startedAt).getTime() - new Date(b.startedAt).getTime());\n\n  return { spanMap, childrenMap, rootSpans };\n}\n\n/**\n * Extract children spans of a specific type\n */\nfunction getChildrenOfType<T extends SpanRecord>(spanTree: SpanTree, parentSpanId: string, spanType: SpanType): T[] {\n  const children = spanTree.childrenMap.get(parentSpanId) || [];\n  return children.filter(span => span.spanType === spanType) as T[];\n}\n\n/**\n * Normalize message content to string format\n * For arrays with multiple text parts, returns only the last text part (AI SDK convention)\n */\nfunction normalizeMessageContent(content: string | Array<{ type: string; text: string }>): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  // Extract text parts and return only the last one (AI SDK convention)\n  const textParts = content.filter(part => part.type === 'text');\n  return textParts.length > 0 ? textParts[textParts.length - 1]?.text || '' : '';\n}\n\n/**\n * Create MastraDBMessage directly from span message data\n */\nfunction createMastraDBMessage(\n  message: { role: string; content: string | Array<{ type: string; text: string }> },\n  createdAt: Date,\n  id: string = '',\n): MastraDBMessage {\n  const contentText = normalizeMessageContent(message.content);\n  const role = message.role as 'user' | 'assistant' | 'system';\n\n  return {\n    id,\n    role,\n    content: {\n      format: 2,\n      parts: [{ type: 'text', text: contentText }],\n      content: contentText,\n    },\n    createdAt: new Date(createdAt),\n  };\n}\n\n/**\n * Extract input messages from agent run span\n */\nfunction extractInputMessages(agentSpan: SpanRecord): MastraDBMessage[] {\n  const input = agentSpan.input;\n\n  // Handle different input formats\n  if (typeof input === 'string') {\n    return [\n      createMastraDBMessage(\n        {\n          role: 'user',\n          content: input,\n        },\n        agentSpan.startedAt,\n      ),\n    ];\n  }\n\n  if (Array.isArray(input)) {\n    const messages = input.filter(isSpanMessage) as SpanMessage[];\n    return messages.map(msg => createMastraDBMessage(msg, agentSpan.startedAt));\n  }\n\n  if (hasMessagesArray(input)) {\n    const messages = input.messages.filter(isSpanMessage) as SpanMessage[];\n    return messages.map(msg => createMastraDBMessage(msg, agentSpan.startedAt));\n  }\n  return [];\n}\n\n/**\n * Extract system messages from LLM span\n */\nfunction extractSystemMessages(llmSpan: SpanRecord): Array<{ role: 'system'; content: string }> {\n  const input = llmSpan.input;\n  if (!hasMessagesArray(input)) {\n    return [];\n  }\n  return input.messages\n    .filter((msg): msg is SpanMessage & { role: 'system' } => isSpanMessage(msg) && msg.role === 'system')\n    .map(msg => ({\n      role: 'system' as const,\n      content: normalizeMessageContent(msg.content),\n    }));\n}\n\n/**\n * Extract conversation history (remembered messages) from LLM span\n * Excludes system messages and the current input message\n */\nfunction extractRememberedMessages(llmSpan: SpanRecord, currentInputContent: string): MastraDBMessage[] {\n  const input = llmSpan.input;\n  if (!hasMessagesArray(input)) {\n    return [];\n  }\n  const filtered = input.messages.filter(isSpanMessage) as unknown as SpanMessage[];\n  const messages = filtered\n    .filter(msg => msg.role !== 'system')\n    .filter(msg => normalizeMessageContent(msg.content) !== currentInputContent);\n\n  return messages.map(msg => createMastraDBMessage(msg, llmSpan.startedAt));\n}\n\n/**\n * Reconstruct tool invocations from tool call spans\n */\nfunction reconstructToolInvocations(spanTree: SpanTree, parentSpanId: string) {\n  const toolSpans = getChildrenOfType<SpanRecord>(spanTree, parentSpanId, SpanType.TOOL_CALL);\n\n  return toolSpans.map(toolSpan => ({\n    toolCallId: toolSpan.spanId,\n    toolName: toolSpan.entityName ?? toolSpan.entityId ?? 'unknown',\n    toolId: toolSpan.entityId,\n    args: toolSpan.input || {},\n    result: toolSpan.output || {},\n    state: 'result' as const,\n  }));\n}\n\n/**\n * Validate trace structure and throw descriptive errors\n */\nexport function validateTrace(trace: TraceRecord): void {\n  if (!trace) {\n    throw new Error('Trace is null or undefined');\n  }\n\n  if (!trace.spans || !Array.isArray(trace.spans)) {\n    throw new Error('Trace must have a spans array');\n  }\n\n  if (trace.spans.length === 0) {\n    throw new Error('Trace has no spans');\n  }\n\n  // Check for circular references in parent-child relationships\n  const spanIds = new Set(trace.spans.map(span => span.spanId));\n  for (const span of trace.spans) {\n    if (span.parentSpanId && !spanIds.has(span.parentSpanId)) {\n      throw new Error(`Span ${span.spanId} references non-existent parent ${span.parentSpanId}`);\n    }\n  }\n}\n\n/**\n * Find the most recent model span that contains conversation history\n */\nfunction findPrimaryLLMSpan(spanTree: SpanTree, rootAgentSpan: SpanRecord): SpanRecord {\n  const directLLMSpans = getChildrenOfType<SpanRecord>(spanTree, rootAgentSpan.spanId, SpanType.MODEL_GENERATION);\n  if (directLLMSpans.length > 0) {\n    // There should only be one model generation span per agent run which is a direct child of the root agent span\n    return directLLMSpans[0]!;\n  }\n\n  throw new Error('No model generation span found in trace');\n}\n\n/**\n * Extract common trace validation and span tree building logic\n */\nfunction prepareTraceForTransformation(trace: TraceRecord) {\n  validateTrace(trace);\n  const spanTree = buildSpanTree(trace.spans);\n\n  // Find the root agent run span\n  const rootAgentSpan = spanTree.rootSpans.find(span => span.spanType === 'agent_run') as SpanRecord | undefined;\n\n  if (!rootAgentSpan) {\n    throw new Error('No root agent_run span found in trace');\n  }\n\n  return { spanTree, rootAgentSpan };\n}\n\nexport function transformTraceToScorerInputAndOutput(trace: TraceRecord): {\n  input: ScorerRunInputForAgent;\n  output: ScorerRunOutputForAgent;\n} {\n  const { spanTree, rootAgentSpan } = prepareTraceForTransformation(trace);\n\n  if (!rootAgentSpan.output) {\n    throw new Error('Root agent span has no output');\n  }\n\n  // Build input\n  const primaryLLMSpan = findPrimaryLLMSpan(spanTree, rootAgentSpan);\n  const inputMessages = extractInputMessages(rootAgentSpan);\n  const systemMessages = extractSystemMessages(primaryLLMSpan);\n\n  // Extract remembered messages from LLM span (excluding current input)\n  const currentInputContent = inputMessages[0]?.content.content || '';\n  const rememberedMessages = extractRememberedMessages(primaryLLMSpan, currentInputContent);\n\n  const input = {\n    inputMessages,\n    rememberedMessages,\n    systemMessages,\n    taggedSystemMessages: {}, // Todo: Support tagged system messages\n  };\n\n  // Build output\n  const toolInvocations = reconstructToolInvocations(spanTree, rootAgentSpan.spanId);\n  const responseText = hasTextProperty(rootAgentSpan.output) ? (rootAgentSpan.output.text ?? '') : '';\n\n  // Build parts array: tool invocations first, then text\n  const parts: Array<{ type: 'tool-invocation'; toolInvocation: any } | { type: 'text'; text: string }> = [];\n\n  // Add tool invocation parts\n  for (const toolInvocation of toolInvocations) {\n    parts.push({\n      type: 'tool-invocation',\n      toolInvocation,\n    });\n  }\n\n  // Add text part if present\n  if (responseText.trim()) {\n    parts.push({\n      type: 'text',\n      text: responseText,\n    });\n  }\n\n  const responseMessage: MastraDBMessage = {\n    id: '',\n    role: 'assistant',\n    content: {\n      format: 2,\n      parts: parts as any, // Type assertion needed due to providerMetadata optional field\n      content: responseText,\n      toolInvocations, // Always include, even if empty array\n    },\n    createdAt: new Date(rootAgentSpan.endedAt || rootAgentSpan.startedAt),\n  };\n\n  const output: MastraDBMessage[] = [responseMessage];\n\n  return {\n    input,\n    output,\n  };\n}\n","import pMap from 'p-map';\nimport z from 'zod';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../error';\nimport { InternalSpans } from '../../observability';\nimport type { TracingContext } from '../../observability';\nimport type { SpanRecord, TraceRecord, MastraStorage } from '../../storage';\nimport { createStep, createWorkflow } from '../../workflows/evented';\nimport type { MastraScorer, ScorerRun } from '../base';\nimport type { ScoreRowData } from '../types';\nimport { saveScorePayloadSchema } from '../types';\nimport { transformTraceToScorerInputAndOutput } from './utils';\n\nconst getTraceStep = createStep({\n  id: '__process-trace-scoring',\n  inputSchema: z.object({\n    targets: z.array(\n      z.object({\n        traceId: z.string(),\n        spanId: z.string().optional(),\n      }),\n    ),\n    scorerId: z.string(),\n  }),\n  outputSchema: z.any(),\n  execute: async ({ inputData, tracingContext, mastra }) => {\n    const logger = mastra.getLogger();\n    if (!logger) {\n      console.warn(\n        '[scoreTracesWorkflow] Logger not initialized: no debug or error logs will be recorded for scoring traces.',\n      );\n    }\n\n    const storage = mastra.getStorage();\n    if (!storage) {\n      const mastraError = new MastraError({\n        id: 'MASTRA_STORAGE_NOT_FOUND_FOR_TRACE_SCORING',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Storage not found for trace scoring',\n        details: {\n          scorerId: inputData.scorerId,\n        },\n      });\n      logger?.error(mastraError.toString());\n      logger?.trackException(mastraError);\n      return;\n    }\n\n    let scorer: MastraScorer | undefined;\n    try {\n      scorer = mastra.getScorerById(inputData.scorerId);\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_SCORER_NOT_FOUND_FOR_TRACE_SCORING',\n          domain: ErrorDomain.SCORER,\n          category: ErrorCategory.SYSTEM,\n          text: `Scorer not found for trace scoring`,\n          details: {\n            scorerId: inputData.scorerId,\n          },\n        },\n        error,\n      );\n      logger?.error(mastraError.toString());\n      logger?.trackException(mastraError);\n      return;\n    }\n\n    await pMap(\n      inputData.targets,\n      async target => {\n        try {\n          await runScorerOnTarget({ storage, scorer, target, tracingContext });\n        } catch (error) {\n          const mastraError = new MastraError(\n            {\n              id: 'MASTRA_SCORER_FAILED_TO_RUN_SCORER_ON_TRACE',\n              domain: ErrorDomain.SCORER,\n              category: ErrorCategory.SYSTEM,\n              details: {\n                scorerId: scorer.id,\n                spanId: target.spanId || '',\n                traceId: target.traceId,\n              },\n            },\n            error,\n          );\n          logger?.error(mastraError.toString());\n          logger?.trackException(mastraError);\n        }\n      },\n      { concurrency: 3 },\n    );\n  },\n});\n\nexport async function runScorerOnTarget({\n  storage,\n  scorer,\n  target,\n  tracingContext,\n}: {\n  storage: MastraStorage;\n  scorer: MastraScorer;\n  target: { traceId: string; spanId?: string };\n  tracingContext: TracingContext;\n}) {\n  // TODO: add storage api to get a single span\n  const observabilityStore = await storage.getStore('observability');\n  if (!observabilityStore) {\n    throw new MastraError({\n      id: 'MASTRA_OBSERVABILITY_STORAGE_NOT_AVAILABLE',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: 'Observability storage domain is not available',\n    });\n  }\n  const trace = await observabilityStore.getTrace({ traceId: target.traceId });\n  if (!trace) {\n    throw new Error(`Trace not found for scoring, traceId: ${target.traceId}`);\n  }\n\n  let span: SpanRecord | undefined;\n  if (target.spanId) {\n    span = trace.spans.find(span => span.spanId === target.spanId);\n  } else {\n    span = trace.spans.find(span => span.parentSpanId === null);\n  }\n\n  if (!span) {\n    throw new Error(\n      `Span not found for scoring, traceId: ${target.traceId}, spanId: ${target.spanId ?? 'Not provided'}`,\n    );\n  }\n\n  const scorerRun = buildScorerRun({\n    scorerType: scorer.type === 'agent' ? 'agent' : undefined,\n    tracingContext,\n    trace,\n    targetSpan: span,\n  });\n\n  const result = await scorer.run(scorerRun);\n  const scorerResult = {\n    ...result,\n    scorer: {\n      id: scorer.id,\n      name: scorer.name || scorer.id,\n      description: scorer.description,\n    },\n    traceId: target.traceId,\n    spanId: target.spanId,\n    entityId: span.entityId || span.entityName || 'unknown',\n    entityType: span.spanType,\n    entity: { traceId: span.traceId, spanId: span.spanId },\n    source: 'TEST',\n    scorerId: scorer.id,\n  };\n\n  const savedScoreRecord = await validateAndSaveScore({ storage, scorerResult });\n  await attachScoreToSpan({ storage, span, scoreRecord: savedScoreRecord });\n}\n\nasync function validateAndSaveScore({ storage, scorerResult }: { storage: MastraStorage; scorerResult: ScorerRun }) {\n  const scoresStore = await storage.getStore('scores');\n  if (!scoresStore) {\n    throw new MastraError({\n      id: 'MASTRA_SCORES_STORAGE_NOT_AVAILABLE',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: 'Scores storage domain is not available',\n    });\n  }\n  const payloadToSave = saveScorePayloadSchema.parse(scorerResult);\n  const result = await scoresStore.saveScore(payloadToSave);\n  return result.score;\n}\n\nfunction buildScorerRun({\n  scorerType,\n  tracingContext,\n  trace,\n  targetSpan,\n}: {\n  scorerType?: string;\n  tracingContext: TracingContext;\n  trace: TraceRecord;\n  targetSpan: SpanRecord;\n}) {\n  let runPayload: ScorerRun;\n  if (scorerType === 'agent') {\n    const { input, output } = transformTraceToScorerInputAndOutput(trace);\n    runPayload = {\n      input,\n      output,\n    };\n  } else {\n    runPayload = { input: targetSpan.input, output: targetSpan.output };\n  }\n\n  runPayload.tracingContext = tracingContext;\n  return runPayload;\n}\n\nasync function attachScoreToSpan({\n  storage,\n  span,\n  scoreRecord,\n}: {\n  storage: MastraStorage;\n  span: SpanRecord;\n  scoreRecord: ScoreRowData;\n}) {\n  const observabilityStore = await storage.getStore('observability');\n  if (!observabilityStore) {\n    throw new MastraError({\n      id: 'MASTRA_OBSERVABILITY_STORAGE_NOT_AVAILABLE',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: 'Observability storage domain is not available',\n    });\n  }\n  const existingLinks = span.links || [];\n  const link = {\n    type: 'score',\n    scoreId: scoreRecord.id,\n    scorerName: scoreRecord.scorer.id,\n    score: scoreRecord.score,\n    createdAt: scoreRecord.createdAt,\n  };\n  await observabilityStore.updateSpan({\n    spanId: span.spanId,\n    traceId: span.traceId,\n    updates: { links: [...existingLinks, link] },\n  });\n}\n\nexport const scoreTracesWorkflow = createWorkflow({\n  id: '__batch-scoring-traces',\n  inputSchema: z.object({\n    targets: z.array(\n      z.object({\n        traceId: z.string(),\n        spanId: z.string().optional(),\n      }),\n    ),\n    scorerId: z.string(),\n  }),\n  outputSchema: z.any(),\n  steps: [getTraceStep],\n  options: {\n    tracingPolicy: {\n      internal: InternalSpans.ALL,\n    },\n    validateInputs: false,\n  },\n});\n\nscoreTracesWorkflow.then(getTraceStep).commit();\n"]}