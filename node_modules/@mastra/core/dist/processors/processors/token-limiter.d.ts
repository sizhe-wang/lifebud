import type { TiktokenBPE } from 'js-tiktoken/lite';
import type { MastraDBMessage } from '../../agent/message-list/index.js';
import type { ChunkType } from '../../stream/index.js';
import type { ProcessInputArgs, ProcessInputResult, Processor } from '../index.js';
/**
 * Configuration options for TokenLimiter processor
 */
export interface TokenLimiterOptions {
    /** Maximum number of tokens to allow */
    limit: number;
    /** Optional encoding to use (defaults to o200k_base which is used by gpt-4o) */
    encoding?: TiktokenBPE;
    /**
     * Strategy when token limit is reached:
     * - 'truncate': Stop emitting chunks (default)
     * - 'abort': Call abort() to stop the stream
     */
    strategy?: 'truncate' | 'abort';
    /**
     * Whether to count tokens from the beginning of the stream or just the current part
     * - 'cumulative': Count all tokens from the start (default)
     * - 'part': Only count tokens in the current part
     */
    countMode?: 'cumulative' | 'part';
}
/**
 * Processor that limits the number of tokens in messages.
 *
 * Can be used as:
 * - Input processor: Filters historical messages to fit within context window, prioritizing recent messages
 * - Output processor: Limits generated response tokens via streaming (processOutputStream) or non-streaming (processOutputResult)
 */
export declare class TokenLimiterProcessor implements Processor<'token-limiter', {
    systemTokens: number;
    limit: number;
}> {
    readonly id = "token-limiter";
    readonly name = "Token Limiter";
    private encoder;
    private maxTokens;
    private strategy;
    private countMode;
    private static readonly TOKENS_PER_MESSAGE;
    private static readonly TOKENS_PER_CONVERSATION;
    constructor(options: number | TokenLimiterOptions);
    /**
     * Process input messages to limit them to the configured token limit.
     * This filters historical messages to fit within the token budget,
     * prioritizing the most recent messages.
     *
     * Uses messageList.get.all.db() to access ALL messages (memory + input),
     * not just the input messages passed in the messages parameter.
     * System messages are accessed via args.systemMessages (they're stored separately).
     * Removes filtered messages directly from messageList and returns it.
     */
    processInput(args: ProcessInputArgs): Promise<ProcessInputResult>;
    /**
     * Count tokens for a system message (CoreMessageV4 from args.systemMessages).
     * This method only accepts system messages with string content and will throw otherwise.
     */
    private countCoreSystemMessageTokens;
    /**
     * Count tokens for an input message, including overhead for message structure
     */
    private countInputMessageTokens;
    processOutputStream(args: {
        part: ChunkType;
        streamParts: ChunkType[];
        state: Record<string, any>;
        abort: (reason?: string) => never;
    }): Promise<ChunkType | null>;
    private countTokensInChunk;
    /**
     * Process the final result (non-streaming)
     * Truncates the text content if it exceeds the token limit
     */
    processOutputResult(args: {
        messages: MastraDBMessage[];
        abort: (reason?: string) => never;
    }): Promise<MastraDBMessage[]>;
    /**
     * Get the maximum token limit
     */
    getMaxTokens(): number;
}
//# sourceMappingURL=token-limiter.d.ts.map