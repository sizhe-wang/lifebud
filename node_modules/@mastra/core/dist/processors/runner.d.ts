import type { StepResult } from '../_types/@internal_ai-sdk-v5/dist/index.js';
import type { MastraDBMessage } from '../agent/message-list/index.js';
import { MessageList } from '../agent/message-list/index.js';
import type { TripWireOptions } from '../agent/trip-wire.js';
import type { IMastraLogger } from '../logger/index.js';
import { SpanType } from '../observability/index.js';
import type { Span, TracingContext } from '../observability/index.js';
import type { RequestContext } from '../request-context/index.js';
import type { ChunkType } from '../stream/index.js';
import type { MastraModelOutput } from '../stream/base/output.js';
import type { ProcessInputStepResult, Processor, ProcessorMessageResult, ProcessorWorkflow, RunProcessInputStepArgs, RunProcessInputStepResult, ToolCallInfo } from './index.js';
/**
 * Implementation of processor state management
 */
/**
 * Tracks state for stream processing across chunks.
 * Used by both legacy processors and workflow processors.
 */
export declare class ProcessorState<OUTPUT = undefined> {
    private accumulatedText;
    customState: Record<string, unknown>;
    streamParts: ChunkType<OUTPUT>[];
    span?: Span<SpanType.PROCESSOR_RUN>;
    constructor(options?: {
        processorName?: string;
        tracingContext?: TracingContext;
        processorIndex?: number;
        createSpan?: boolean;
    });
    addPart(part: ChunkType<OUTPUT>): void;
}
/**
 * Union type for processor or workflow that can be used as a processor
 */
type ProcessorOrWorkflow = Processor | ProcessorWorkflow;
export declare class ProcessorRunner {
    readonly inputProcessors: ProcessorOrWorkflow[];
    readonly outputProcessors: ProcessorOrWorkflow[];
    private readonly logger;
    private readonly agentName;
    constructor({ inputProcessors, outputProcessors, logger, agentName, }: {
        inputProcessors?: ProcessorOrWorkflow[];
        outputProcessors?: ProcessorOrWorkflow[];
        logger: IMastraLogger;
        agentName: string;
    });
    /**
     * Execute a workflow as a processor and handle the result.
     * Returns the processed messages and any tripwire information.
     */
    private executeWorkflowAsProcessor;
    runOutputProcessors(messageList: MessageList, tracingContext?: TracingContext, requestContext?: RequestContext, retryCount?: number): Promise<MessageList>;
    /**
     * Process a stream part through all output processors with state management
     */
    processPart<OUTPUT>(part: ChunkType<OUTPUT>, processorStates: Map<string, ProcessorState<OUTPUT>>, tracingContext?: TracingContext, requestContext?: RequestContext, messageList?: MessageList, retryCount?: number): Promise<{
        part: ChunkType<OUTPUT> | null | undefined;
        blocked: boolean;
        reason?: string;
        tripwireOptions?: TripWireOptions<unknown>;
        processorId?: string;
    }>;
    runOutputProcessorsForStream<OUTPUT = undefined>(streamResult: MastraModelOutput<OUTPUT>, tracingContext?: TracingContext): Promise<ReadableStream<any>>;
    runInputProcessors(messageList: MessageList, tracingContext?: TracingContext, requestContext?: RequestContext, retryCount?: number): Promise<MessageList>;
    /**
     * Run processInputStep for all processors that implement it.
     * Called at each step of the agentic loop, before the LLM is invoked.
     *
     * Unlike processInput which runs once at the start, this runs at every step
     * (including tool call continuations). This is useful for:
     * - Transforming message types between steps (e.g., AI SDK 'reasoning' -> Anthropic 'thinking')
     * - Modifying messages based on step context
     * - Implementing per-step message transformations
     *
     * @param args.messages - The current messages to be sent to the LLM (MastraDBMessage format)
     * @param args.messageList - MessageList instance for managing message sources
     * @param args.stepNumber - The current step number (0-indexed)
     * @param args.tracingContext - Optional tracing context for observability
     * @param args.requestContext - Optional runtime context with execution metadata
     *
     * @returns The processed MessageList
     */
    runProcessInputStep(args: RunProcessInputStepArgs): Promise<RunProcessInputStepResult>;
    /**
     * Type guard to check if result is { messages, systemMessages }
     */
    private isProcessInputResultWithSystemMessages;
    /**
     * Run processOutputStep for all processors that implement it.
     * Called after each LLM response in the agentic loop, before tool execution.
     *
     * Unlike processOutputResult which runs once at the end, this runs at every step.
     * This is the ideal place to implement guardrails that can trigger retries.
     *
     * @param args.messages - The current messages including the LLM response
     * @param args.messageList - MessageList instance for managing message sources
     * @param args.stepNumber - The current step number (0-indexed)
     * @param args.finishReason - The finish reason from the LLM
     * @param args.toolCalls - Tool calls made in this step (if any)
     * @param args.text - Generated text from this step
     * @param args.tracingContext - Optional tracing context for observability
     * @param args.requestContext - Optional runtime context with execution metadata
     * @param args.retryCount - Number of times processors have triggered retry
     *
     * @returns The processed MessageList
     */
    runProcessOutputStep(args: {
        steps: Array<StepResult<any>>;
        messages: MastraDBMessage[];
        messageList: MessageList;
        stepNumber: number;
        finishReason?: string;
        toolCalls?: ToolCallInfo[];
        text?: string;
        tracingContext?: TracingContext;
        requestContext?: RequestContext;
        retryCount?: number;
    }): Promise<MessageList>;
    static applyMessagesToMessageList(messages: MastraDBMessage[], messageList: MessageList, idsBeforeProcessing: string[], check: ReturnType<MessageList['makeMessageSourceChecker']>, defaultSource?: 'input' | 'response'): void;
    static validateAndFormatProcessInputStepResult(result: ProcessInputStepResult | Awaited<ProcessorMessageResult> | undefined | void, { messageList, processor, stepNumber, }: {
        messageList: MessageList;
        processor: Processor;
        stepNumber: number;
    }): Promise<RunProcessInputStepResult>;
}
export {};
//# sourceMappingURL=runner.d.ts.map