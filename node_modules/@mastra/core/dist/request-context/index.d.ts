type RecordToTuple<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T][];
/**
 * Reserved key for setting resourceId from middleware.
 * When set in RequestContext, this takes precedence over client-provided values
 * for security (prevents attackers from hijacking another user's memory).
 *
 * @example
 * ```typescript
 * // In your auth middleware:
 * const requestContext = c.get('requestContext');
 * requestContext.set(MASTRA_RESOURCE_ID_KEY, authenticatedUser.id);
 * ```
 */
export declare const MASTRA_RESOURCE_ID_KEY = "mastra__resourceId";
/**
 * Reserved key for setting threadId from middleware.
 * When set in RequestContext, this takes precedence over client-provided values
 * for security (prevents attackers from hijacking another user's memory).
 *
 * @example
 * ```typescript
 * // In your auth middleware:
 * const requestContext = c.get('requestContext');
 * requestContext.set(MASTRA_THREAD_ID_KEY, threadId);
 * ```
 */
export declare const MASTRA_THREAD_ID_KEY = "mastra__threadId";
export declare class RequestContext<Values extends Record<string, any> | unknown = unknown> {
    private registry;
    constructor(iterable?: Values extends Record<string, any> ? RecordToTuple<Partial<Values>> : Iterable<readonly [string, unknown]>);
    /**
     * set a value with strict typing if `Values` is a Record and the key exists in it.
     */
    set<K extends Values extends Record<string, any> ? keyof Values : string>(key: K, value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown): void;
    /**
     * Get a value with its type
     */
    get<K extends Values extends Record<string, any> ? keyof Values : string, R = Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown>(key: K): R;
    /**
     * Check if a key exists in the container
     */
    has<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean;
    /**
     * Delete a value by key
     */
    delete<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean;
    /**
     * Clear all values from the container
     */
    clear(): void;
    /**
     * Get all keys in the container
     */
    keys(): IterableIterator<Values extends Record<string, any> ? keyof Values : string>;
    /**
     * Get all values in the container
     */
    values(): IterableIterator<Values extends Record<string, any> ? Values[keyof Values] : unknown>;
    /**
     * Get all entries in the container.
     * Returns a discriminated union of tuples for proper type narrowing when iterating.
     */
    entries(): IterableIterator<Values extends Record<string, any> ? {
        [K in keyof Values]: [K, Values[K]];
    }[keyof Values] : [string, unknown]>;
    /**
     * Get the size of the container
     */
    size(): number;
    /**
     * Execute a function for each entry in the container.
     * The callback receives properly typed key-value pairs.
     */
    forEach<K extends Values extends Record<string, any> ? keyof Values : string>(callbackfn: (value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : unknown) : unknown, key: K, map: Map<string, unknown>) => void): void;
    /**
     * Custom JSON serialization method
     * Converts the internal Map to a plain object for proper JSON serialization
     */
    toJSON(): Record<string, any>;
}
export {};
//# sourceMappingURL=index.d.ts.map