'use strict';

var chunk4U7ZLI36_cjs = require('../chunk-4U7ZLI36.cjs');
var chunkDGV2FWB4_cjs = require('../chunk-DGV2FWB4.cjs');
var chunkAF74UXR5_cjs = require('../chunk-AF74UXR5.cjs');

// src/server/auth.ts
var MastraAuthProvider = class extends chunkDGV2FWB4_cjs.MastraBase {
  protected;
  public;
  constructor(options) {
    super({ component: "AUTH", name: options?.name });
    if (options?.authorizeUser) {
      this.authorizeUser = options.authorizeUser.bind(this);
    }
    this.protected = options?.protected;
    this.public = options?.public;
  }
  registerOptions(opts) {
    if (opts?.authorizeUser) {
      this.authorizeUser = opts.authorizeUser.bind(this);
    }
    if (opts?.protected) {
      this.protected = opts.protected;
    }
    if (opts?.public) {
      this.public = opts.public;
    }
  }
};

// src/server/composite-auth.ts
var CompositeAuth = class extends MastraAuthProvider {
  providers;
  constructor(providers) {
    super();
    this.providers = providers;
  }
  async authenticateToken(token, request) {
    for (const provider of this.providers) {
      try {
        const user = await provider.authenticateToken(token, request);
        if (user) {
          return user;
        }
      } catch {
      }
    }
    return null;
  }
  async authorizeUser(user, request) {
    for (const provider of this.providers) {
      const authorized = await provider.authorizeUser(user, request);
      if (authorized) {
        return true;
      }
    }
    return false;
  }
};

// src/server/base.ts
var MastraServerBase = class extends chunkDGV2FWB4_cjs.MastraBase {
  #app;
  constructor({ app, name }) {
    super({ component: chunkAF74UXR5_cjs.RegisteredLogger.SERVER, name: name ?? "Server" });
    this.#app = app;
    this.logger.debug(`Server app set`);
  }
  /**
   * Get the app instance.
   *
   * Returns the server app that was passed to the constructor. This allows users
   * to access the underlying server framework's app for direct operations
   * like calling routes via app.fetch() (Hono) or using the app for testing.
   *
   * @template T - The expected type of the app (defaults to TApp)
   * @returns The app instance cast to T. Callers are responsible for ensuring T matches the actual app type.
   *
   * @example
   * ```typescript
   * const app = adapter.getApp<Hono>();
   * const response = await app.fetch(new Request('http://localhost/api/agents'));
   * ```
   */
  getApp() {
    return this.#app;
  }
  /**
   * Protected getter for subclasses to access the app.
   * This allows subclasses to use `this.app` naturally.
   */
  get app() {
    return this.#app;
  }
};

// src/server/simple-auth.ts
var DEFAULT_HEADERS = ["Authorization", "X-Playground-Access"];
var SimpleAuth = class extends MastraAuthProvider {
  tokens;
  headers;
  users;
  constructor(options) {
    super(options);
    this.tokens = options.tokens;
    this.users = Object.values(this.tokens);
    this.headers = [...DEFAULT_HEADERS].concat(options.headers || []);
  }
  async authenticateToken(token, request) {
    const requestTokens = this.getTokensFromHeaders(token, request);
    for (const requestToken of requestTokens) {
      const tokenToUser = this.tokens[requestToken];
      if (tokenToUser) {
        return tokenToUser;
      }
    }
    return null;
  }
  async authorizeUser(user, _request) {
    return this.users.includes(user);
  }
  stripBearerPrefix(token) {
    return token.startsWith("Bearer ") ? token.slice(7) : token;
  }
  getTokensFromHeaders(token, request) {
    const tokens = [token];
    for (const headerName of this.headers) {
      const headerValue = request.header(headerName);
      if (headerValue) {
        tokens.push(this.stripBearerPrefix(headerValue));
      }
    }
    return tokens;
  }
};

// src/server/index.ts
function validateOptions(path, options) {
  const opts = options;
  if (opts.method === void 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", missing "method" property`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  if (opts.handler === void 0 && opts.createHandler === void 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", you must define a "handler" or "createHandler" property`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  if (opts.handler !== void 0 && opts.createHandler !== void 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: "MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS",
      text: `Invalid options for route "${path}", you can only define one of the following properties: "handler" or "createHandler"`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
}
function registerApiRoute(path, options) {
  if (path.startsWith("/api/")) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: "MASTRA_SERVER_API_PATH_RESERVED",
      text: `Path must not start with "/api", it's reserved for internal API routes`,
      domain: "MASTRA_SERVER" /* MASTRA_SERVER */,
      category: "USER" /* USER */
    });
  }
  validateOptions(path, options);
  return {
    path,
    method: options.method,
    handler: options.handler,
    createHandler: options.createHandler,
    openapi: options.openapi,
    middleware: options.middleware,
    requiresAuth: options.requiresAuth
  };
}
function defineAuth(config) {
  return config;
}

exports.CompositeAuth = CompositeAuth;
exports.MastraAuthProvider = MastraAuthProvider;
exports.MastraServerBase = MastraServerBase;
exports.SimpleAuth = SimpleAuth;
exports.defineAuth = defineAuth;
exports.registerApiRoute = registerApiRoute;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map