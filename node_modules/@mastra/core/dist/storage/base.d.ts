import { MastraBase } from '../base.js';
import type { AgentsStorage, ScoresStorage, WorkflowsStorage, MemoryStorage, ObservabilityStorage } from './domains/index.js';
export type StorageDomains = {
    workflows: WorkflowsStorage;
    scores: ScoresStorage;
    memory: MemoryStorage;
    observability?: ObservabilityStorage;
    agents?: AgentsStorage;
};
/**
 * Normalizes perPage input for pagination queries.
 *
 * @param perPageInput - The raw perPage value from the user
 * @param defaultValue - The default perPage value to use when undefined (typically 40 for messages, 100 for threads)
 * @returns A numeric perPage value suitable for queries (false becomes MAX_SAFE_INTEGER, negative values fall back to default)
 */
export declare function normalizePerPage(perPageInput: number | false | undefined, defaultValue: number): number;
/**
 * Calculates pagination offset and prepares perPage value for response.
 * When perPage is false (fetch all), offset is always 0 regardless of page.
 *
 * @param page - The page number (0-indexed)
 * @param perPageInput - The original perPage input (number, false for all, or undefined)
 * @param normalizedPerPage - The normalized perPage value (from normalizePerPage)
 * @returns Object with offset for query and perPage for response
 */
export declare function calculatePagination(page: number, perPageInput: number | false | undefined, normalizedPerPage: number): {
    offset: number;
    perPage: number | false;
};
/**
 * Configuration for individual domain overrides.
 * Each domain can be sourced from a different storage adapter.
 */
export type MastraStorageDomains = Partial<StorageDomains>;
/**
 * Configuration options for MastraStorage.
 *
 * Can be used in two ways:
 * 1. By store implementations: `{ id, name, disableInit? }` - stores set `this.stores` directly
 * 2. For composition: `{ id, default?, domains?, disableInit? }` - compose domains from multiple stores
 */
export interface MastraStorageConfig {
    /**
     * Unique identifier for this storage instance.
     */
    id: string;
    /**
     * Name of the storage adapter (used for logging).
     * Required for store implementations extending MastraStorage.
     */
    name?: string;
    /**
     * Default storage adapter to use for domains not explicitly specified.
     * If provided, domains from this storage will be used as fallbacks.
     */
    default?: MastraStorage;
    /**
     * Individual domain overrides. Each domain can come from a different storage adapter.
     * These take precedence over the default storage.
     *
     * @example
     * ```typescript
     * domains: {
     *   memory: pgStore.stores?.memory,
     *   workflows: libsqlStore.stores?.workflows,
     * }
     * ```
     */
    domains?: MastraStorageDomains;
    /**
     * When true, automatic initialization (table creation/migrations) is disabled.
     * This is useful for CI/CD pipelines where you want to:
     * 1. Run migrations explicitly during deployment (not at runtime)
     * 2. Use different credentials for schema changes vs runtime operations
     *
     * When disableInit is true:
     * - The storage will not automatically create/alter tables on first use
     * - You must call `storage.init()` explicitly in your CI/CD scripts
     *
     * @example
     * // In CI/CD script:
     * const storage = new PostgresStore({ ...config, disableInit: false });
     * await storage.init(); // Explicitly run migrations
     *
     * // In runtime application:
     * const storage = new PostgresStore({ ...config, disableInit: true });
     * // No auto-init, tables must already exist
     */
    disableInit?: boolean;
}
/**
 * Base class for all Mastra storage adapters.
 *
 * Can be used in two ways:
 *
 * 1. **Extended by store implementations** (PostgresStore, LibSQLStore, etc.):
 *    Store implementations extend this class and set `this.stores` with their domain implementations.
 *
 * 2. **Directly instantiated for composition**:
 *    Compose domains from multiple storage backends using `default` and `domains` options.
 *
 * All domain-specific operations should be accessed through `getStore()`:
 *
 * @example
 * ```typescript
 * // Composition: mix domains from different stores
 * const storage = new MastraStorage({
 *   id: 'composite',
 *   default: pgStore,
 *   domains: {
 *     memory: libsqlStore.stores?.memory,
 *   },
 * });
 *
 * // Access domains
 * const memory = await storage.getStore('memory');
 * await memory?.saveThread({ thread });
 * ```
 */
export declare class MastraStorage extends MastraBase {
    protected hasInitialized: null | Promise<boolean>;
    protected shouldCacheInit: boolean;
    id: string;
    stores?: StorageDomains;
    /**
     * When true, automatic initialization (table creation/migrations) is disabled.
     */
    disableInit: boolean;
    constructor(config: MastraStorageConfig);
    /**
     * Get a domain-specific storage interface.
     *
     * @param storeName - The name of the domain to access ('memory', 'workflows', 'scores', 'observability', 'agents')
     * @returns The domain storage interface, or undefined if not available
     *
     * @example
     * ```typescript
     * const memory = await storage.getStore('memory');
     * if (memory) {
     *   await memory.saveThread({ thread });
     * }
     * ```
     */
    getStore<K extends keyof StorageDomains>(storeName: K): Promise<StorageDomains[K] | undefined>;
    /**
     * Initialize all domain stores.
     * This creates necessary tables, indexes, and performs any required migrations.
     */
    init(): Promise<void>;
}
//# sourceMappingURL=base.d.ts.map