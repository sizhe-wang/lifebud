import type { z } from 'zod';
import type { SerializedError } from '../error/index.js';
import type { MastraDBMessage, StorageThreadType } from '../memory/types.js';
import type { StepResult, WorkflowRunState, WorkflowRunStatus } from '../workflows/index.js';
export type StoragePagination = {
    page: number;
    perPage: number | false;
};
export type StorageColumnType = 'text' | 'timestamp' | 'uuid' | 'jsonb' | 'integer' | 'float' | 'bigint' | 'boolean';
export interface StorageColumn {
    type: StorageColumnType;
    primaryKey?: boolean;
    nullable?: boolean;
    references?: {
        table: string;
        column: string;
    };
}
export interface WorkflowRuns {
    runs: WorkflowRun[];
    total: number;
}
export interface StorageWorkflowRun {
    workflow_name: string;
    run_id: string;
    resourceId?: string;
    snapshot: WorkflowRunState | string;
    createdAt: Date;
    updatedAt: Date;
}
export interface WorkflowRun {
    workflowName: string;
    runId: string;
    snapshot: WorkflowRunState | string;
    createdAt: Date;
    updatedAt: Date;
    resourceId?: string;
}
export type PaginationInfo = {
    total: number;
    page: number;
    /**
     * Number of items per page, or `false` to fetch all records without pagination limit.
     * When `false`, all matching records are returned in a single response.
     */
    perPage: number | false;
    hasMore: boolean;
};
export type MastraMessageFormat = 'v1' | 'v2';
export type StorageListMessagesInput = {
    threadId: string | string[];
    resourceId?: string;
    include?: {
        id: string;
        threadId?: string;
        withPreviousMessages?: number;
        withNextMessages?: number;
    }[];
    /**
     * Number of items per page, or `false` to fetch all records without pagination limit.
     * Defaults to 40 if not specified.
     */
    perPage?: number | false;
    /**
     * Zero-indexed page number for pagination.
     * Defaults to 0 if not specified.
     */
    page?: number;
    filter?: {
        dateRange?: {
            start?: Date;
            end?: Date;
            /**
             * When true, excludes the start date from results (uses > instead of >=).
             * Useful for cursor-based pagination to avoid duplicates.
             * @default false
             */
            startExclusive?: boolean;
            /**
             * When true, excludes the end date from results (uses < instead of <=).
             * Useful for cursor-based pagination to avoid duplicates.
             * @default false
             */
            endExclusive?: boolean;
        };
    };
    orderBy?: StorageOrderBy<'createdAt'>;
};
export type StorageListMessagesOutput = PaginationInfo & {
    messages: MastraDBMessage[];
};
export type StorageListWorkflowRunsInput = {
    workflowName?: string;
    fromDate?: Date;
    toDate?: Date;
    /**
     * Number of items per page, or `false` to fetch all records without pagination limit.
     * When undefined, returns all workflow runs without pagination.
     * When both perPage and page are provided, pagination is applied.
     */
    perPage?: number | false;
    /**
     * Zero-indexed page number for pagination.
     * When both perPage and page are provided, pagination is applied.
     * When either is undefined, all results are returned.
     */
    page?: number;
    resourceId?: string;
    status?: WorkflowRunStatus;
};
export type StorageListThreadsByResourceIdInput = {
    resourceId: string;
    /**
     * Number of items per page, or `false` to fetch all records without pagination limit.
     * Defaults to 100 if not specified.
     */
    perPage?: number | false;
    /**
     * Zero-indexed page number for pagination.
     * Defaults to 0 if not specified.
     */
    page?: number;
    orderBy?: StorageOrderBy;
};
export type StorageListThreadsByResourceIdOutput = PaginationInfo & {
    threads: StorageThreadType[];
};
/**
 * Metadata stored on cloned threads to track their origin
 */
export type ThreadCloneMetadata = {
    /** ID of the thread this was cloned from */
    sourceThreadId: string;
    /** Timestamp when the clone was created */
    clonedAt: Date;
    /** ID of the last message included in the clone (if messages were copied) */
    lastMessageId?: string;
};
/**
 * Input options for cloning a thread
 */
export type StorageCloneThreadInput = {
    /** ID of the thread to clone */
    sourceThreadId: string;
    /** ID for the new cloned thread (if not provided, a random UUID will be generated) */
    newThreadId?: string;
    /** Resource ID for the new thread (defaults to source thread's resourceId) */
    resourceId?: string;
    /** Title for the new cloned thread */
    title?: string;
    /** Additional metadata to merge with clone metadata */
    metadata?: Record<string, unknown>;
    /** Options for filtering which messages to include */
    options?: {
        /** Maximum number of messages to copy (from most recent) */
        messageLimit?: number;
        /** Filter messages by date range or specific IDs */
        messageFilter?: {
            /** Only include messages created on or after this date */
            startDate?: Date;
            /** Only include messages created on or before this date */
            endDate?: Date;
            /** Only include messages with these specific IDs */
            messageIds?: string[];
        };
    };
};
/**
 * Output from cloning a thread
 */
export type StorageCloneThreadOutput = {
    /** The newly created cloned thread */
    thread: StorageThreadType;
    /** The messages that were copied to the new thread */
    clonedMessages: MastraDBMessage[];
};
export type StorageResourceType = {
    id: string;
    workingMemory?: string;
    metadata?: Record<string, unknown>;
    createdAt: Date;
    updatedAt: Date;
};
export type StorageMessageType = {
    id: string;
    thread_id: string;
    content: string;
    role: string;
    type: string;
    createdAt: Date;
    resourceId: string | null;
};
export interface StorageOrderBy<TField extends ThreadOrderBy = ThreadOrderBy> {
    field?: TField;
    direction?: ThreadSortDirection;
}
export interface ThreadSortOptions {
    orderBy?: ThreadOrderBy;
    sortDirection?: ThreadSortDirection;
}
export type ThreadOrderBy = 'createdAt' | 'updatedAt';
export type ThreadSortDirection = 'ASC' | 'DESC';
/**
 * Scorer reference with optional sampling configuration
 */
export interface StorageScorerConfig {
    /** Sampling configuration for this scorer */
    sampling?: {
        type: 'ratio' | 'count';
        rate?: number;
        count?: number;
    };
}
/**
 * Stored agent configuration type.
 * Primitives (tools, workflows, agents, memory, scorers) are stored as references
 * that get resolved from Mastra's registries at runtime.
 */
export interface StorageAgentType {
    id: string;
    name: string;
    description?: string;
    instructions: string;
    /** Model configuration (provider, name, etc.) */
    model: Record<string, unknown>;
    /** Array of tool keys to resolve from Mastra's tool registry */
    tools?: string[];
    /** Default options for generate/stream calls */
    defaultOptions?: Record<string, unknown>;
    /** Array of workflow keys to resolve from Mastra's workflow registry */
    workflows?: string[];
    /** Array of agent keys to resolve from Mastra's agent registry */
    agents?: string[];
    /** Input processor configurations */
    inputProcessors?: Record<string, unknown>[];
    /** Output processor configurations */
    outputProcessors?: Record<string, unknown>[];
    /** Memory key to resolve from Mastra's memory registry */
    memory?: string;
    /** Scorer keys with optional sampling config, to resolve from Mastra's scorer registry */
    scorers?: Record<string, StorageScorerConfig>;
    /** Additional metadata for the agent */
    metadata?: Record<string, unknown>;
    createdAt: Date;
    updatedAt: Date;
}
export type StorageCreateAgentInput = Omit<StorageAgentType, 'createdAt' | 'updatedAt'>;
export type StorageUpdateAgentInput = {
    id: string;
    name?: string;
    description?: string;
    instructions?: string;
    model?: Record<string, unknown>;
    /** Array of tool keys to resolve from Mastra's tool registry */
    tools?: string[];
    defaultOptions?: Record<string, unknown>;
    /** Array of workflow keys to resolve from Mastra's workflow registry */
    workflows?: string[];
    /** Array of agent keys to resolve from Mastra's agent registry */
    agents?: string[];
    inputProcessors?: Record<string, unknown>[];
    outputProcessors?: Record<string, unknown>[];
    /** Memory key to resolve from Mastra's memory registry */
    memory?: string;
    /** Scorer keys with optional sampling config */
    scorers?: Record<string, StorageScorerConfig>;
    metadata?: Record<string, unknown>;
};
export type StorageListAgentsInput = {
    /**
     * Number of items per page, or `false` to fetch all records without pagination limit.
     * Defaults to 100 if not specified.
     */
    perPage?: number | false;
    /**
     * Zero-indexed page number for pagination.
     * Defaults to 0 if not specified.
     */
    page?: number;
    orderBy?: StorageOrderBy;
};
export type StorageListAgentsOutput = PaginationInfo & {
    agents: StorageAgentType[];
};
export interface CreateIndexOptions {
    name: string;
    table: string;
    columns: string[];
    unique?: boolean;
    concurrent?: boolean;
    /**
     * SQL WHERE clause for creating partial indexes.
     * @internal Reserved for internal use only. Callers must pre-validate this value.
     * DDL statements cannot use parameterized queries for WHERE clauses, so this value
     * is concatenated directly into the SQL. Any user-facing usage must validate input.
     */
    where?: string;
    method?: 'btree' | 'hash' | 'gin' | 'gist' | 'spgist' | 'brin';
    opclass?: string;
    storage?: Record<string, any>;
    tablespace?: string;
}
export interface IndexInfo {
    name: string;
    table: string;
    columns: string[];
    unique: boolean;
    size: string;
    definition: string;
}
export interface StorageIndexStats extends IndexInfo {
    scans: number;
    tuples_read: number;
    tuples_fetched: number;
    last_used?: Date;
    method?: string;
}
export interface UpdateWorkflowStateOptions {
    status: WorkflowRunStatus;
    result?: StepResult<any, any, any, any>;
    error?: SerializedError;
    suspendedPaths?: Record<string, number[]>;
    waitingPaths?: Record<string, number[]>;
}
/**
 * Converts a zod schema into a database schema
 * @param zObject A zod schema object
 * @returns database schema record with StorageColumns
 */
export declare function buildStorageSchema<Shape extends z.ZodRawShape>(zObject: z.ZodObject<Shape>): Record<keyof Shape & string, StorageColumn>;
//# sourceMappingURL=types.d.ts.map