import type { ScoreRowData } from '../evals/types.js';
import type { TABLE_NAMES } from './constants.js';
import type { StorageColumn } from './types.js';
/**
 * Canonical store names for type safety.
 * Provides autocomplete suggestions while still accepting any string.
 */
export type StoreName = 'PG' | 'MSSQL' | 'LIBSQL' | 'MONGODB' | 'CLICKHOUSE' | 'CLOUDFLARE' | 'CLOUDFLARE_D1' | 'DYNAMODB' | 'LANCE' | 'UPSTASH' | 'ASTRA' | 'CHROMA' | 'COUCHBASE' | 'OPENSEARCH' | 'PINECONE' | 'QDRANT' | 'S3' | 'TURBOPUFFER' | 'VECTORIZE' | (string & {});
export declare function safelyParseJSON(input: any): any;
/**
 * Options for transforming storage rows
 */
export interface TransformRowOptions {
    /**
     * Preferred source fields for timestamps (e.g., { createdAt: 'createdAtZ' } means use createdAtZ if available, else createdAt)
     */
    preferredTimestampFields?: Record<string, string>;
    /**
     * Convert timestamp strings to Date objects (default: false for backwards compatibility)
     */
    convertTimestamps?: boolean;
    /**
     * Pattern to treat as null (e.g., '_null_' for ClickHouse)
     */
    nullValuePattern?: string;
    /**
     * Custom field mappings from source to target (e.g., { entity: 'entityData' } for DynamoDB)
     */
    fieldMappings?: Record<string, string>;
}
/**
 * Generic schema-driven row transformer.
 * Uses TABLE_SCHEMAS to determine field types and apply appropriate transformations:
 * - 'jsonb' fields: parsed from JSON strings using safelyParseJSON
 * - 'timestamp' fields: optionally converted to Date objects
 *
 * @param row - The raw row from storage
 * @param tableName - The table name to look up schema from TABLE_SCHEMAS
 * @param options - Optional configuration for store-specific behavior
 * @returns Transformed row with proper types
 */
export declare function transformRow<T = Record<string, any>>(row: Record<string, any>, tableName: TABLE_NAMES, options?: TransformRowOptions): T;
/**
 * Transform a raw score row from storage to ScoreRowData.
 * Convenience wrapper around transformRow for the scores table (TABLE_SCORERS).
 *
 * @param row - The raw row from storage
 * @param options - Optional configuration for store-specific behavior
 * @returns Transformed ScoreRowData
 */
export declare function transformScoreRow(row: Record<string, any>, options?: TransformRowOptions): ScoreRowData;
/**
 * Generates a standardized error ID for storage and vector operations.
 *
 * Formats:
 * - Storage: MASTRA_STORAGE_{STORE}_{OPERATION}_{STATUS}
 * - Vector:  MASTRA_VECTOR_{STORE}_{OPERATION}_{STATUS}
 *
 * This function auto-normalizes inputs to UPPER_SNAKE_CASE for flexibility.
 * The store parameter is type-checked against canonical store names for IDE autocomplete.
 *
 * @param type - The operation type ('storage' or 'vector')
 * @param store - The store adapter name (type-checked canonical names)
 * @param operation - The operation that failed (e.g., 'LIST_THREADS_BY_RESOURCE_ID', 'QUERY')
 * @param status - The status/error type (e.g., 'FAILED', 'INVALID_THREAD_ID', 'DUPLICATE_KEY')
 *
 * @example
 * ```ts
 * // Storage operations
 * createStoreErrorId('storage', 'PG', 'LIST_THREADS_BY_RESOURCE_ID', 'FAILED')
 * // Returns: 'MASTRA_STORAGE_PG_LIST_THREADS_BY_RESOURCE_ID_FAILED'
 *
 * // Vector operations
 * createStoreErrorId('vector', 'CHROMA', 'QUERY', 'FAILED')
 * // Returns: 'MASTRA_VECTOR_CHROMA_QUERY_FAILED'
 *
 * // Auto-normalizes any casing
 * createStoreErrorId('storage', 'PG', 'listMessagesById', 'failed')
 * // Returns: 'MASTRA_STORAGE_PG_LIST_MESSAGES_BY_ID_FAILED'
 * ```
 */
export declare function createStoreErrorId(type: 'storage' | 'vector', store: StoreName, operation: string, status: string): Uppercase<string>;
export declare function createStorageErrorId(store: StoreName, operation: string, status: string): Uppercase<string>;
export declare function createVectorErrorId(store: StoreName, operation: string, status: string): Uppercase<string>;
export declare function getSqlType(type: StorageColumn['type']): string;
export declare function getDefaultValue(type: StorageColumn['type']): string;
export declare function ensureDate(date: Date | string | undefined): Date | undefined;
export declare function serializeDate(date: Date | string | undefined): string | undefined;
/**
 * Date range filter configuration for in-memory filtering operations.
 */
export interface DateRangeFilter {
    start?: Date | string;
    end?: Date | string;
    startExclusive?: boolean;
    endExclusive?: boolean;
}
/**
 * Filter an array of items by date range. Used by in-memory storage adapters.
 *
 * This provides a consistent implementation of date range filtering with
 * support for inclusive/exclusive bounds across all storage adapters.
 *
 * @param items - Array of items to filter
 * @param getCreatedAt - Function to extract the createdAt date from an item
 * @param dateRange - Optional date range filter configuration
 * @returns Filtered array of items
 *
 * @example
 * ```ts
 * const filtered = filterByDateRange(
 *   messages,
 *   (msg) => new Date(msg.createdAt),
 *   { start: new Date('2024-01-01'), startExclusive: true }
 * );
 * ```
 */
export declare function filterByDateRange<T>(items: T[], getCreatedAt: (item: T) => Date, dateRange?: DateRangeFilter): T[];
//# sourceMappingURL=utils.d.ts.map