import type { Mastra } from '../mastra/index.js';
import type { SchemaWithValidation } from '../stream/base/schema.js';
import type { MCPToolProperties, ToolAction, ToolExecutionContext } from './types.js';
/**
 * A type-safe tool that agents and workflows can call to perform specific actions.
 *
 * @template TSchemaIn - Input schema type
 * @template TSchemaOut - Output schema type
 * @template TSuspendSchema - Suspend operation schema type
 * @template TResumeSchema - Resume operation schema type
 * @template TContext - Execution context type
 *
 * @example Basic tool with validation
 * ```typescript
 * const weatherTool = createTool({
 *   id: 'get-weather',
 *   description: 'Get weather for a location',
 *   inputSchema: z.object({
 *     location: z.string(),
 *     units: z.enum(['celsius', 'fahrenheit']).optional()
 *   }),
 *   execute: async (inputData) => {
 *     return await fetchWeather(inputData.location, inputData.units);
 *   }
 * });
 * ```
 *
 * @example Tool requiring approval
 * ```typescript
 * const deleteFileTool = createTool({
 *   id: 'delete-file',
 *   description: 'Delete a file',
 *   requireApproval: true,
 *   inputSchema: z.object({ filepath: z.string() }),
 *   execute: async (inputData) => {
 *     await fs.unlink(inputData.filepath);
 *     return { deleted: true };
 *   }
 * });
 * ```
 *
 * @example Tool with Mastra integration
 * ```typescript
 * const saveTool = createTool({
 *   id: 'save-data',
 *   description: 'Save data to storage',
 *   inputSchema: z.object({ key: z.string(), value: z.any() }),
 *   execute: async (inputData, context) => {
 *     const storage = context?.mastra?.getStorage();
 *     await storage?.set(inputData.key, inputData.value);
 *     return { saved: true };
 *   }
 * });
 * ```
 */
export declare class Tool<TSchemaIn = unknown, TSchemaOut = unknown, TSuspendSchema = unknown, TResumeSchema = unknown, TContext extends ToolExecutionContext<TSuspendSchema, TResumeSchema> = ToolExecutionContext<TSuspendSchema, TResumeSchema>, TId extends string = string> implements ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId> {
    /** Unique identifier for the tool */
    id: TId;
    /** Description of what the tool does */
    description: string;
    /** Schema for validating input parameters */
    inputSchema?: SchemaWithValidation<TSchemaIn>;
    /** Schema for validating output structure */
    outputSchema?: SchemaWithValidation<TSchemaOut>;
    /** Schema for suspend operation data */
    suspendSchema?: SchemaWithValidation<TSuspendSchema>;
    /** Schema for resume operation data */
    resumeSchema?: SchemaWithValidation<TResumeSchema>;
    /**
     * Tool execution function
     * @param inputData - The raw, validated input data
     * @param context - Optional execution context with metadata
     * @returns Promise resolving to tool output or a ValidationError if input validation fails
     */
    execute?: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>['execute'];
    /** Parent Mastra instance for accessing shared resources */
    mastra?: Mastra;
    /**
     * Whether the tool requires explicit user approval before execution
     * @example
     * ```typescript
     * // For destructive operations
     * requireApproval: true
     * ```
     */
    requireApproval?: boolean;
    /**
     * Provider-specific options passed to the model when this tool is used.
     * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.
     * @example
     * ```typescript
     * providerOptions: {
     *   anthropic: {
     *     cacheControl: { type: 'ephemeral' }
     *   }
     * }
     * ```
     */
    providerOptions?: Record<string, Record<string, unknown>>;
    /**
     * Optional MCP-specific properties including annotations and metadata.
     * Only relevant when the tool is being used in an MCP context.
     * @example
     * ```typescript
     * mcp: {
     *   annotations: {
     *     title: 'Weather Lookup',
     *     readOnlyHint: true,
     *     destructiveHint: false
     *   },
     *   _meta: {
     *     version: '1.0.0',
     *     author: 'team@example.com'
     *   }
     * }
     * ```
     */
    mcp?: MCPToolProperties;
    /**
     * Creates a new Tool instance with input validation wrapper.
     *
     * @param opts - Tool configuration and execute function
     * @example
     * ```typescript
     * const tool = new Tool({
     *   id: 'my-tool',
     *   description: 'Does something useful',
     *   inputSchema: z.object({ name: z.string() }),
     *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })
     * });
     * ```
     */
    constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId>);
}
/**
 * Creates a type-safe tool with automatic input validation.
 *
 * @template TSchemaIn - Input schema type
 * @template TSchemaOut - Output schema type
 * @template TSuspendSchema - Suspend operation schema type
 * @template TResumeSchema - Resume operation schema type
 * @template TContext - Execution context type
 * @template TExecute - Execute function type
 *
 * @param opts - Tool configuration including schemas and execute function
 * @returns Type-safe Tool instance with conditional typing based on schemas
 *
 * @example Simple tool
 * ```typescript
 * const greetTool = createTool({
 *   id: 'greet',
 *   description: 'Say hello',
 *   execute: async () => ({ message: 'Hello!' })
 * });
 * ```
 *
 * @example Tool with input validation
 * ```typescript
 * const calculateTool = createTool({
 *   id: 'calculate',
 *   description: 'Perform calculations',
 *   inputSchema: z.object({
 *     operation: z.enum(['add', 'subtract']),
 *     a: z.number(),
 *     b: z.number()
 *   }),
 *   execute: async (inputData) => {
 *     const result = inputData.operation === 'add'
 *       ? inputData.a + inputData.b
 *       : inputData.a - inputData.b;
 *     return { result };
 *   }
 * });
 * ```
 *
 * @example Tool with output schema
 * ```typescript
 * const userTool = createTool({
 *   id: 'get-user',
 *   description: 'Get user data',
 *   inputSchema: z.object({ userId: z.string() }),
 *   outputSchema: z.object({
 *     id: z.string(),
 *     name: z.string(),
 *     email: z.string()
 *   }),
 *   execute: async (inputData) => {
 *     return await fetchUser(inputData.userId);
 *   }
 * });
 * ```
 *
 * @example Tool with external API
 * ```typescript
 * const weatherTool = createTool({
 *   id: 'weather',
 *   description: 'Get weather data',
 *   inputSchema: z.object({
 *     city: z.string(),
 *     units: z.enum(['metric', 'imperial']).default('metric')
 *   }),
 *   execute: async (inputData) => {
 *     const response = await fetch(
 *       `https://api.weather.com/v1/weather?q=${inputData.city}&units=${inputData.units}`
 *     );
 *     return response.json();
 *   }
 * });
 * ```
 */
export declare function createTool<TId extends string = string, TSchemaIn = unknown, TSchemaOut = unknown, TSuspend = unknown, TResume = unknown, TContext extends ToolExecutionContext<TSuspend, TResume> = ToolExecutionContext<TSuspend, TResume>>(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId>): Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId>;
//# sourceMappingURL=tool.d.ts.map