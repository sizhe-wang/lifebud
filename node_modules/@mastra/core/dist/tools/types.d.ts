import type { WritableStream } from 'node:stream/web';
import type { Tool, ToolV5, FlexibleSchema, ToolCallOptions, ToolExecutionOptions, Schema } from '../_types/@internal_external-types/dist/index.js';
import type { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';
import type { ElicitRequest, ElicitResult } from '@modelcontextprotocol/sdk/types.js';
import type { MastraUnion } from '../action/index.js';
import type { Mastra } from '../mastra/index.js';
import type { TracingContext } from '../observability/index.js';
import type { RequestContext } from '../request-context/index.js';
import type { SchemaWithValidation } from '../stream/base/schema.js';
import type { SuspendOptions, OutputWriter } from '../workflows/index.js';
import type { ToolStream } from './stream.js';
import type { ValidationError } from './validation.js';
export type VercelTool = Tool;
export type VercelToolV5 = ToolV5;
export type ToolInvocationOptions = ToolExecutionOptions | ToolCallOptions;
/**
 * MCP-specific context properties available during tool execution in MCP environments.
 */
export interface AgentToolExecutionContext<TSuspend, TResume> {
    toolCallId: string;
    messages: any[];
    suspend: (suspendPayload: TSuspend, suspendOptions?: SuspendOptions) => Promise<void>;
    threadId?: string;
    resourceId?: string;
    resumeData?: TResume;
    writableStream?: WritableStream<any>;
}
export interface WorkflowToolExecutionContext<TSuspend, TResume> {
    runId: string;
    workflowId: string;
    state: any;
    setState: (state: any) => void;
    suspend: (suspendPayload: TSuspend, suspendOptions?: SuspendOptions) => Promise<void>;
    resumeData?: TResume;
}
export interface MCPToolExecutionContext {
    /** MCP protocol context passed by the server */
    extra: RequestHandlerExtra<any, any>;
    /** Elicitation handler for interactive user input during tool execution */
    elicitation: {
        sendRequest: (request: ElicitRequest['params']) => Promise<ElicitResult>;
    };
}
/**
 * Extended version of ToolInvocationOptions that includes Mastra-specific properties
 * for suspend/resume functionality, stream writing, and tracing context.
 *
 * This is used by CoreTool/InternalCoreTool for AI SDK compatibility (AI SDK expects this signature).
 * Mastra v1.0 tools (ToolAction) use ToolExecutionContext instead.
 *
 * CoreToolBuilder acts as the adapter layer:
 * - Receives: AI SDK calls with MastraToolInvocationOptions
 * - Converts to: ToolExecutionContext for Mastra tool execution
 * - Returns: Results back to AI SDK
 */
export type MastraToolInvocationOptions = ToolInvocationOptions & {
    suspend?: (suspendPayload: any, suspendOptions?: SuspendOptions) => Promise<any>;
    resumeData?: any;
    outputWriter?: OutputWriter;
    tracingContext?: TracingContext;
    /**
     * Optional MCP-specific context passed when tool is executed in MCP server.
     * This is populated by the MCP server and passed through to the tool's execution context.
     */
    mcp?: MCPToolExecutionContext;
};
/**
 * The type of tool registered with the MCP server.
 * This is used to categorize tools in the MCP Server playground.
 * If not specified, it defaults to a regular tool.
 */
export type MCPToolType = 'agent' | 'workflow';
/**
 * MCP Tool Annotations for describing tool behavior and UI presentation.
 * These annotations are part of the MCP protocol and are used by clients
 * like OpenAI Apps SDK to control tool card display and permission hints.
 *
 * @see https://spec.modelcontextprotocol.io/specification/2025-03-26/server/tools/#tool-annotations
 */
export interface ToolAnnotations {
    /**
     * A human-readable title for the tool.
     * Used for display purposes in UI components.
     */
    title?: string;
    /**
     * If true, the tool does not modify its environment.
     * This hint indicates the tool only reads data and has no side effects.
     * @default false
     */
    readOnlyHint?: boolean;
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     * This hint helps clients determine if confirmation should be required.
     * @default true
     */
    destructiveHint?: boolean;
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on its environment.
     * This hint indicates idempotent behavior.
     * @default false
     */
    idempotentHint?: boolean;
    /**
     * If true, this tool may interact with an "open world" of external
     * entities (e.g., web search, external APIs).
     * If false, the tool's domain is closed and fully defined.
     * @default true
     */
    openWorldHint?: boolean;
}
export interface MCPToolProperties {
    /**
     * The type of tool registered with the MCP server.
     * This is used to categorize tools in the MCP Server playground.
     * If not specified, it defaults to a regular tool.
     */
    toolType?: MCPToolType;
    /**
     * MCP tool annotations for describing tool behavior and UI presentation.
     * These are exposed via MCP protocol and used by clients like OpenAI Apps SDK.
     * @see https://spec.modelcontextprotocol.io/specification/2025-03-26/server/tools/#tool-annotations
     */
    annotations?: ToolAnnotations;
    /**
     * Arbitrary metadata that will be passed through to MCP clients.
     * This field allows custom metadata to be attached to tools for
     * client-specific functionality.
     */
    _meta?: Record<string, unknown>;
}
/**
 * CoreTool is the AI SDK-compatible tool format used when passing tools to the AI SDK.
 * This matches the AI SDK's Tool interface.
 *
 * CoreToolBuilder converts Mastra tools (ToolAction) to this format and handles the
 * signature transformation from Mastra's (inputData, context) to AI SDK format (params, options).
 *
 * Key differences from ToolAction:
 * - Uses 'parameters' instead of 'inputSchema' (AI SDK naming)
 * - Execute signature: (params, options: MastraToolInvocationOptions) (AI SDK format)
 * - Supports FlexibleSchema | Schema for broader AI SDK compatibility
 */
export type CoreTool = {
    description?: string;
    parameters: FlexibleSchema<any> | Schema;
    outputSchema?: FlexibleSchema<any> | Schema;
    execute?: (params: any, options: MastraToolInvocationOptions) => Promise<any>;
    /**
     * Provider-specific options passed to the model when this tool is used.
     */
    providerOptions?: Record<string, Record<string, unknown>>;
    /**
     * Optional MCP-specific properties.
     * Only populated when the tool is being used in an MCP context.
     */
    mcp?: MCPToolProperties;
} & ({
    type?: 'function' | undefined;
    id?: string;
} | {
    type: 'provider-defined';
    id: `${string}.${string}`;
    args: Record<string, unknown>;
});
/**
 * InternalCoreTool is identical to CoreTool but with stricter typing.
 * Used internally where we know the schema has already been converted to AI SDK Schema format.
 *
 * The only difference: parameters must be Schema (not FlexibleSchema | Schema)
 */
export type InternalCoreTool = {
    description?: string;
    parameters: Schema;
    outputSchema?: Schema;
    execute?: (params: any, options: MastraToolInvocationOptions) => Promise<any>;
    /**
     * Provider-specific options passed to the model when this tool is used.
     */
    providerOptions?: Record<string, Record<string, unknown>>;
    /**
     * Optional MCP-specific properties.
     * Only populated when the tool is being used in an MCP context.
     */
    mcp?: MCPToolProperties;
} & ({
    type?: 'function' | undefined;
    id?: string;
} | {
    type: 'provider-defined';
    id: `${string}.${string}`;
    args: Record<string, unknown>;
});
export interface ToolExecutionContext<TSuspend = unknown, TResume = unknown> {
    mastra?: MastraUnion;
    requestContext?: RequestContext;
    tracingContext?: TracingContext;
    abortSignal?: AbortSignal;
    writer?: ToolStream;
    agent?: AgentToolExecutionContext<TSuspend, TResume>;
    workflow?: WorkflowToolExecutionContext<TSuspend, TResume>;
    mcp?: MCPToolExecutionContext;
}
export interface ToolAction<TSchemaIn, TSchemaOut, TSuspend = unknown, TResume = unknown, TContext extends ToolExecutionContext<TSuspend, TResume> = ToolExecutionContext<TSuspend, TResume>, TId extends string = string> {
    id: TId;
    description: string;
    inputSchema?: SchemaWithValidation<TSchemaIn>;
    outputSchema?: SchemaWithValidation<TSchemaOut>;
    suspendSchema?: SchemaWithValidation<TSuspend>;
    resumeSchema?: SchemaWithValidation<TResume>;
    /**
     * Optional MCP-specific properties.
     * Only populated when the tool is being used in an MCP context.
     */
    mcp?: MCPToolProperties;
    execute?: (inputData: TSchemaIn, context: TContext) => Promise<TSchemaOut | ValidationError>;
    mastra?: Mastra;
    requireApproval?: boolean;
    /**
     * Provider-specific options passed to the model when this tool is used.
     * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.
     * @example
     * ```typescript
     * providerOptions: {
     *   anthropic: {
     *     cacheControl: { type: 'ephemeral' }
     *   }
     * }
     * ```
     */
    providerOptions?: Record<string, Record<string, unknown>>;
    onInputStart?: (options: ToolCallOptions) => void | PromiseLike<void>;
    onInputDelta?: (options: {
        inputTextDelta: string;
    } & ToolCallOptions) => void | PromiseLike<void>;
    onInputAvailable?: (options: {
        input: TSchemaIn;
    } & ToolCallOptions) => void | PromiseLike<void>;
    onOutput?: (options: {
        output: TSchemaOut;
        toolName: string;
    } & Omit<ToolCallOptions, 'messages'>) => void | PromiseLike<void>;
}
//# sourceMappingURL=types.d.ts.map