{"version":3,"sources":["../../src/vector/vector.ts"],"names":["MastraBase","MastraError"],"mappings":"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","file":"index.cjs","sourcesContent":["import type {\n  EmbeddingModel as EmbeddingModelV1,\n  ProviderOptions as ProviderOptionsV1,\n  TelemetrySettings as TelemetrySettingsV1,\n} from '@internal/ai-sdk-v4';\nimport type {\n  EmbeddingModelV2,\n  TelemetrySettings as TelemetrySettingsV5,\n  ProviderOptions as ProviderOptionsV5,\n} from '@internal/ai-sdk-v5';\nimport type {\n  EmbeddingModelV3,\n  TelemetrySettings as TelemetrySettingsV6,\n  ProviderOptions as ProviderOptionsV6,\n} from '@internal/ai-v6';\nimport { MastraBase } from '../base';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { VectorFilter } from './filter';\nimport type {\n  CreateIndexParams,\n  UpsertVectorParams,\n  QueryVectorParams,\n  IndexStats,\n  QueryResult,\n  UpdateVectorParams,\n  DeleteVectorParams,\n  DeleteVectorsParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n} from './types';\n\n/** Legacy embedding model (V1) - use embedV1 function */\nexport type MastraLegacyEmbeddingModel<T> = EmbeddingModelV1<T>;\n\n/** Modern embedding model (V2/V3) - use embedV2 for V2 models, embedV3 for V3 models */\nexport type MastraSupportedEmbeddingModel<T> = EmbeddingModelV2<T> | EmbeddingModelV3;\n\n/** All supported embedding model types */\nexport type MastraEmbeddingModel<T> = MastraLegacyEmbeddingModel<T> | MastraSupportedEmbeddingModel<T>;\n\nexport type MastraEmbeddingOptions = {\n  maxRetries?: number;\n\n  headers?: Record<string, string>;\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  telemetry?: TelemetrySettingsV1 | TelemetrySettingsV5 | TelemetrySettingsV6;\n\n  providerOptions?: ProviderOptionsV1 | ProviderOptionsV5 | ProviderOptionsV6;\n\n  maxParallelCalls?: number;\n};\n\n/** Specification versions for supported (modern) embedding models */\nexport const supportedEmbeddingModelSpecifications = ['v2', 'v3'] as const;\n\n/**\n * Type guard to check if an embedding model is a supported modern version (V2 or V3).\n * Use embedV2 for V2 models, embedV3 for V3 models, and embedV1 for legacy V1 models.\n */\nexport const isSupportedEmbeddingModel = <T>(\n  model: MastraEmbeddingModel<T>,\n): model is MastraSupportedEmbeddingModel<T> => {\n  return supportedEmbeddingModelSpecifications.includes(\n    model.specificationVersion as (typeof supportedEmbeddingModelSpecifications)[number],\n  );\n};\n\nexport abstract class MastraVector<Filter = VectorFilter> extends MastraBase {\n  id: string;\n\n  constructor({ id }: { id: string }) {\n    if (!id || typeof id !== 'string' || id.trim() === '') {\n      throw new MastraError({\n        id: 'VECTOR_INVALID_ID',\n        text: 'Vector id must be provided and cannot be empty',\n        domain: ErrorDomain.MASTRA_VECTOR,\n        category: ErrorCategory.USER,\n      });\n    }\n    super({ name: 'MastraVector', component: 'VECTOR' });\n    this.id = id;\n  }\n\n  get indexSeparator(): string {\n    return '_';\n  }\n\n  abstract query(params: QueryVectorParams<Filter>): Promise<QueryResult[]>;\n  // Adds type checks for positional arguments if used\n  abstract upsert(params: UpsertVectorParams): Promise<string[]>;\n  // Adds type checks for positional arguments if used\n  abstract createIndex(params: CreateIndexParams): Promise<void>;\n\n  abstract listIndexes(): Promise<string[]>;\n\n  abstract describeIndex(params: DescribeIndexParams): Promise<IndexStats>;\n\n  abstract deleteIndex(params: DeleteIndexParams): Promise<void>;\n\n  abstract updateVector(params: UpdateVectorParams<Filter>): Promise<void>;\n\n  abstract deleteVector(params: DeleteVectorParams): Promise<void>;\n\n  /**\n   * Delete multiple vectors by IDs or metadata filter.\n   *\n   * This enables bulk deletion and source-based vector management.\n   * Implementations should throw MastraError with appropriate error code\n   * if the operation is not supported.\n   *\n   * @param params - Parameters including indexName and either ids or filter (mutually exclusive)\n   * @throws {MastraError} If operation is not supported or parameters are invalid\n   *\n   * @example\n   * ```ts\n   * // Delete all chunks from a document\n   * await vectorStore.deleteVectors({\n   *   indexName: 'docs',\n   *   filter: { source_id: 'manual.pdf' }\n   * });\n   *\n   * // Delete multiple vectors by ID\n   * await vectorStore.deleteVectors({\n   *   indexName: 'docs',\n   *   ids: ['vec_1', 'vec_2', 'vec_3']\n   * });\n   *\n   * // Delete old temporary documents\n   * await vectorStore.deleteVectors({\n   *   indexName: 'docs',\n   *   filter: {\n   *     $and: [\n   *       { bucket: 'temp' },\n   *       { indexed_at: { $lt: '2025-01-01' } }\n   *     ]\n   *   }\n   * });\n   * ```\n   */\n  abstract deleteVectors(params: DeleteVectorsParams<Filter>): Promise<void>;\n\n  protected async validateExistingIndex(indexName: string, dimension: number, metric: string) {\n    let info: IndexStats;\n    try {\n      info = await this.describeIndex({ indexName });\n    } catch (infoError) {\n      const mastraError = new MastraError(\n        {\n          id: 'VECTOR_VALIDATE_INDEX_FETCH_FAILED',\n          text: `Index \"${indexName}\" already exists, but failed to fetch index info for dimension check.`,\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.SYSTEM,\n          details: { indexName },\n        },\n        infoError,\n      );\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    }\n    const existingDim = info?.dimension;\n    const existingMetric = info?.metric;\n    if (existingDim === dimension) {\n      this.logger?.info(\n        `Index \"${indexName}\" already exists with ${existingDim} dimensions and metric ${existingMetric}, skipping creation.`,\n      );\n      if (existingMetric !== metric) {\n        this.logger?.warn(\n          `Attempted to create index with metric \"${metric}\", but index already exists with metric \"${existingMetric}\". To use a different metric, delete and recreate the index.`,\n        );\n      }\n    } else if (info) {\n      const mastraError = new MastraError({\n        id: 'VECTOR_VALIDATE_INDEX_DIMENSION_MISMATCH',\n        text: `Index \"${indexName}\" already exists with ${existingDim} dimensions, but ${dimension} dimensions were requested`,\n        domain: ErrorDomain.MASTRA_VECTOR,\n        category: ErrorCategory.USER,\n        details: { indexName, existingDim, requestedDim: dimension },\n      });\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    } else {\n      const mastraError = new MastraError({\n        id: 'VECTOR_VALIDATE_INDEX_NO_DIMENSION',\n        text: `Index \"${indexName}\" already exists, but could not retrieve its dimensions for validation.`,\n        domain: ErrorDomain.MASTRA_VECTOR,\n        category: ErrorCategory.SYSTEM,\n        details: { indexName },\n      });\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    }\n  }\n}\n"]}