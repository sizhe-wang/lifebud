import type { EmbeddingModel as EmbeddingModelV1, ProviderOptions as ProviderOptionsV1, TelemetrySettings as TelemetrySettingsV1 } from '../_types/@internal_ai-sdk-v4/dist/index.js';
import type { EmbeddingModelV2, TelemetrySettings as TelemetrySettingsV5, ProviderOptions as ProviderOptionsV5 } from '../_types/@internal_ai-sdk-v5/dist/index.js';
import type { EmbeddingModelV3, TelemetrySettings as TelemetrySettingsV6, ProviderOptions as ProviderOptionsV6 } from '@internal/ai-v6';
import { MastraBase } from '../base.js';
import type { VectorFilter } from './filter/index.js';
import type { CreateIndexParams, UpsertVectorParams, QueryVectorParams, IndexStats, QueryResult, UpdateVectorParams, DeleteVectorParams, DeleteVectorsParams, DescribeIndexParams, DeleteIndexParams } from './types.js';
/** Legacy embedding model (V1) - use embedV1 function */
export type MastraLegacyEmbeddingModel<T> = EmbeddingModelV1<T>;
/** Modern embedding model (V2/V3) - use embedV2 for V2 models, embedV3 for V3 models */
export type MastraSupportedEmbeddingModel<T> = EmbeddingModelV2<T> | EmbeddingModelV3;
/** All supported embedding model types */
export type MastraEmbeddingModel<T> = MastraLegacyEmbeddingModel<T> | MastraSupportedEmbeddingModel<T>;
export type MastraEmbeddingOptions = {
    maxRetries?: number;
    headers?: Record<string, string>;
    /**
     * Optional telemetry configuration (experimental).
     */
    telemetry?: TelemetrySettingsV1 | TelemetrySettingsV5 | TelemetrySettingsV6;
    providerOptions?: ProviderOptionsV1 | ProviderOptionsV5 | ProviderOptionsV6;
    maxParallelCalls?: number;
};
/** Specification versions for supported (modern) embedding models */
export declare const supportedEmbeddingModelSpecifications: readonly ["v2", "v3"];
/**
 * Type guard to check if an embedding model is a supported modern version (V2 or V3).
 * Use embedV2 for V2 models, embedV3 for V3 models, and embedV1 for legacy V1 models.
 */
export declare const isSupportedEmbeddingModel: <T>(model: MastraEmbeddingModel<T>) => model is MastraSupportedEmbeddingModel<T>;
export declare abstract class MastraVector<Filter = VectorFilter> extends MastraBase {
    id: string;
    constructor({ id }: {
        id: string;
    });
    get indexSeparator(): string;
    abstract query(params: QueryVectorParams<Filter>): Promise<QueryResult[]>;
    abstract upsert(params: UpsertVectorParams): Promise<string[]>;
    abstract createIndex(params: CreateIndexParams): Promise<void>;
    abstract listIndexes(): Promise<string[]>;
    abstract describeIndex(params: DescribeIndexParams): Promise<IndexStats>;
    abstract deleteIndex(params: DeleteIndexParams): Promise<void>;
    abstract updateVector(params: UpdateVectorParams<Filter>): Promise<void>;
    abstract deleteVector(params: DeleteVectorParams): Promise<void>;
    /**
     * Delete multiple vectors by IDs or metadata filter.
     *
     * This enables bulk deletion and source-based vector management.
     * Implementations should throw MastraError with appropriate error code
     * if the operation is not supported.
     *
     * @param params - Parameters including indexName and either ids or filter (mutually exclusive)
     * @throws {MastraError} If operation is not supported or parameters are invalid
     *
     * @example
     * ```ts
     * // Delete all chunks from a document
     * await vectorStore.deleteVectors({
     *   indexName: 'docs',
     *   filter: { source_id: 'manual.pdf' }
     * });
     *
     * // Delete multiple vectors by ID
     * await vectorStore.deleteVectors({
     *   indexName: 'docs',
     *   ids: ['vec_1', 'vec_2', 'vec_3']
     * });
     *
     * // Delete old temporary documents
     * await vectorStore.deleteVectors({
     *   indexName: 'docs',
     *   filter: {
     *     $and: [
     *       { bucket: 'temp' },
     *       { indexed_at: { $lt: '2025-01-01' } }
     *     ]
     *   }
     * });
     * ```
     */
    abstract deleteVectors(params: DeleteVectorsParams<Filter>): Promise<void>;
    protected validateExistingIndex(indexName: string, dimension: number, metric: string): Promise<void>;
}
//# sourceMappingURL=vector.d.ts.map