import EventEmitter from 'node:events';
import { MastraBase } from '../../base.js';
import type { RequestContext } from '../../di/index.js';
import type { PubSub } from '../../events/pubsub.js';
import type { Mastra } from '../../mastra/index.js';
import type { LoopConditionFunction, Step } from '../step.js';
import type { StepFlowEntry, StepResult } from '../types.js';
export declare class StepExecutor extends MastraBase {
    protected mastra?: Mastra;
    constructor({ mastra }: {
        mastra?: Mastra;
    });
    __registerMastra(mastra: Mastra): void;
    execute(params: {
        workflowId: string;
        step: Step<any, any, any, any>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        emitter: EventEmitter;
        requestContext: RequestContext;
        retryCount?: number;
        foreachIdx?: number;
        validateInputs?: boolean;
        abortController?: AbortController;
        perStep?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    evaluateConditions(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'conditional';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        emitter: {
            runtime: PubSub;
            events: PubSub;
        };
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number[]>;
    evaluateCondition({ workflowId, condition, runId, inputData, resumeData, stepResults, state, requestContext, emitter, abortController, retryCount, iterationCount, }: {
        workflowId: string;
        condition: LoopConditionFunction<any, any, any, any, any, any>;
        runId: string;
        inputData?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        emitter: EventEmitter;
        requestContext: RequestContext;
        abortController: AbortController;
        retryCount?: number;
        iterationCount: number;
    }): Promise<boolean>;
    resolveSleep(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'sleep';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        emitter: {
            runtime: PubSub;
            events: PubSub;
        };
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number>;
    resolveSleepUntil(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'sleepUntil';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        emitter: {
            runtime: PubSub;
            events: PubSub;
        };
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number>;
}
//# sourceMappingURL=step-executor.d.ts.map