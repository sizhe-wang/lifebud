import { EventProcessor } from '../../../events/processor.js';
import type { Event } from '../../../events/types.js';
import type { Mastra } from '../../../mastra/index.js';
import type { StepResult, TimeTravelExecutionParams, WorkflowRunState } from '../../../workflows/types.js';
import type { Workflow } from '../../../workflows/workflow.js';
export type ProcessorArgs = {
    activeSteps: Record<string, boolean>;
    workflow: Workflow;
    workflowId: string;
    runId: string;
    executionPath: number[];
    stepResults: Record<string, StepResult<any, any, any, any>>;
    resumeSteps: string[];
    prevResult: StepResult<any, any, any, any>;
    requestContext: Record<string, any>;
    timeTravel?: TimeTravelExecutionParams;
    resumeData?: any;
    parentWorkflow?: ParentWorkflow;
    parentContext?: {
        workflowId: string;
        input: any;
    };
    retryCount?: number;
    perStep?: boolean;
};
export type ParentWorkflow = {
    workflowId: string;
    runId: string;
    executionPath: number[];
    resume: boolean;
    stepResults: Record<string, StepResult<any, any, any, any>>;
    parentWorkflow?: ParentWorkflow;
    stepId: string;
};
export declare class WorkflowEventProcessor extends EventProcessor {
    private stepExecutor;
    private abortControllers;
    private parentChildRelationships;
    constructor({ mastra }: {
        mastra: Mastra;
    });
    /**
     * Get or create an AbortController for a workflow run
     */
    private getOrCreateAbortController;
    /**
     * Cancel a workflow run and all its nested child workflows
     */
    private cancelRunAndChildren;
    /**
     * Clean up abort controller and relationships when a workflow completes.
     * Also cleans up any orphaned child entries that reference this run as parent.
     */
    private cleanupRun;
    __registerMastra(mastra: Mastra): void;
    private errorWorkflow;
    protected processWorkflowCancel({ workflowId, runId }: ProcessorArgs): Promise<void>;
    protected processWorkflowStart({ workflow, parentWorkflow, workflowId, runId, resumeSteps, prevResult, resumeData, timeTravel, executionPath, stepResults, requestContext, perStep, }: ProcessorArgs): Promise<void>;
    protected endWorkflow(args: ProcessorArgs, status?: 'success' | 'failed' | 'canceled' | 'paused'): Promise<void>;
    protected processWorkflowEnd(args: ProcessorArgs): Promise<void>;
    protected processWorkflowSuspend(args: ProcessorArgs): Promise<void>;
    protected processWorkflowFail(args: ProcessorArgs): Promise<void>;
    protected processWorkflowStepRun({ workflow, workflowId, runId, executionPath, stepResults, activeSteps, resumeSteps, timeTravel, prevResult, resumeData, parentWorkflow, requestContext, retryCount, perStep, }: ProcessorArgs): Promise<void>;
    protected processWorkflowStepEnd({ workflow, workflowId, runId, executionPath, resumeSteps, timeTravel, prevResult, parentWorkflow, stepResults, activeSteps, parentContext, requestContext, perStep, }: ProcessorArgs): Promise<void>;
    loadData({ workflowId, runId, }: {
        workflowId: string;
        runId: string;
    }): Promise<WorkflowRunState | null | undefined>;
    process(event: Event, ack?: () => Promise<void>): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map