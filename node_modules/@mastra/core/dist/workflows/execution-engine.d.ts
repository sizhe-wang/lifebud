import { MastraBase } from '../base.js';
import type { RequestContext } from '../di/index.js';
import type { PubSub } from '../events/pubsub.js';
import type { IMastraLogger } from '../logger/index.js';
import type { Mastra } from '../mastra/index.js';
import type { Span, SpanType, TracingPolicy } from '../observability/index.js';
import type { OutputWriter, SerializedStepFlowEntry, StepResult, WorkflowRunStatus, WorkflowFinishCallbackResult, WorkflowErrorCallbackInfo } from './types.js';
import type { RestartExecutionParams, StepFlowEntry, TimeTravelExecutionParams } from '.';
/**
 * Represents an execution graph for a workflow
 */
export interface ExecutionGraph<TEngineType = any> {
    id: string;
    steps: StepFlowEntry<TEngineType>[];
}
export interface ExecutionEngineOptions {
    tracingPolicy?: TracingPolicy;
    validateInputs: boolean;
    shouldPersistSnapshot: (params: {
        stepResults: Record<string, StepResult<any, any, any, any>>;
        workflowStatus: WorkflowRunStatus;
    }) => boolean;
    /**
     * Called when workflow execution completes (success, failed, suspended, or tripwire).
     * Errors thrown in this callback are caught and logged, not propagated.
     */
    onFinish?: (result: WorkflowFinishCallbackResult) => Promise<void> | void;
    /**
     * Called only when workflow execution fails (failed or tripwire status).
     * Errors thrown in this callback are caught and logged, not propagated.
     */
    onError?: (errorInfo: WorkflowErrorCallbackInfo) => Promise<void> | void;
}
/**
 * Execution engine abstract class for building and executing workflow graphs
 * Providers will implement this class to provide their own execution logic
 */
export declare abstract class ExecutionEngine extends MastraBase {
    mastra?: Mastra;
    options: ExecutionEngineOptions;
    constructor({ mastra, options }: {
        mastra?: Mastra;
        options: ExecutionEngineOptions;
    });
    __registerMastra(mastra: Mastra): void;
    getLogger(): IMastraLogger;
    /**
     * Invokes the onFinish and onError lifecycle callbacks if they are defined.
     * Errors in callbacks are caught and logged, not propagated.
     * @param result The workflow result containing status, result, error, steps, tripwire info, and context
     */
    invokeLifecycleCallbacks(result: {
        status: WorkflowRunStatus;
        result?: any;
        error?: any;
        steps: Record<string, StepResult<any, any, any, any>>;
        tripwire?: any;
        runId: string;
        workflowId: string;
        resourceId?: string;
        input?: any;
        requestContext: RequestContext;
        state: Record<string, any>;
    }): Promise<void>;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    abstract execute<TState, TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        disableScorers?: boolean;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        initialState?: TState;
        timeTravel?: TimeTravelExecutionParams;
        restart?: RestartExecutionParams;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
            forEachIndex?: number;
            label?: string;
        };
        pubsub: PubSub;
        requestContext: RequestContext;
        workflowSpan?: Span<SpanType.WORKFLOW_RUN>;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        abortController: AbortController;
        outputWriter?: OutputWriter;
        format?: 'legacy' | 'vnext' | undefined;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<TOutput>;
}
//# sourceMappingURL=execution-engine.d.ts.map