import type { RequestContext } from '../../di/index.js';
import type { PubSub } from '../../events/pubsub.js';
import type { TracingContext } from '../../observability/index.js';
import type { DefaultExecutionEngine } from '../default.js';
import type { ConditionFunction, LoopConditionFunction, Step } from '../step.js';
import type { DefaultEngineType, ExecutionContext, OutputWriter, RestartExecutionParams, SerializedStepFlowEntry, StepFlowEntry, StepResult, TimeTravelExecutionParams } from '../types.js';
export interface ExecuteParallelParams {
    workflowId: string;
    runId: string;
    resourceId?: string;
    entry: {
        type: 'parallel';
        steps: {
            type: 'step';
            step: Step;
        }[];
    };
    serializedStepGraph: SerializedStepFlowEntry[];
    prevStep: StepFlowEntry;
    stepResults: Record<string, StepResult<any, any, any, any>>;
    restart?: RestartExecutionParams;
    timeTravel?: TimeTravelExecutionParams;
    resume?: {
        steps: string[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resumePayload: any;
        resumePath: number[];
    };
    executionContext: ExecutionContext;
    tracingContext: TracingContext;
    pubsub: PubSub;
    abortController: AbortController;
    requestContext: RequestContext;
    outputWriter?: OutputWriter;
    disableScorers?: boolean;
    perStep?: boolean;
}
export declare function executeParallel(engine: DefaultExecutionEngine, params: ExecuteParallelParams): Promise<StepResult<any, any, any, any>>;
export interface ExecuteConditionalParams {
    workflowId: string;
    runId: string;
    resourceId?: string;
    serializedStepGraph: SerializedStepFlowEntry[];
    entry: {
        type: 'conditional';
        steps: {
            type: 'step';
            step: Step;
        }[];
        conditions: ConditionFunction<any, any, any, any, any, DefaultEngineType>[];
    };
    prevOutput: any;
    stepResults: Record<string, StepResult<any, any, any, any>>;
    resume?: {
        steps: string[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resumePayload: any;
        resumePath: number[];
    };
    restart?: RestartExecutionParams;
    timeTravel?: TimeTravelExecutionParams;
    executionContext: ExecutionContext;
    tracingContext: TracingContext;
    pubsub: PubSub;
    abortController: AbortController;
    requestContext: RequestContext;
    outputWriter?: OutputWriter;
    disableScorers?: boolean;
    perStep?: boolean;
}
export declare function executeConditional(engine: DefaultExecutionEngine, params: ExecuteConditionalParams): Promise<StepResult<any, any, any, any>>;
export interface ExecuteLoopParams {
    workflowId: string;
    runId: string;
    resourceId?: string;
    entry: {
        type: 'loop';
        step: Step;
        condition: LoopConditionFunction<any, any, any, any, any, DefaultEngineType>;
        loopType: 'dowhile' | 'dountil';
    };
    prevStep: StepFlowEntry;
    prevOutput: any;
    stepResults: Record<string, StepResult<any, any, any, any>>;
    restart?: RestartExecutionParams;
    timeTravel?: TimeTravelExecutionParams;
    resume?: {
        steps: string[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resumePayload: any;
        resumePath: number[];
    };
    executionContext: ExecutionContext;
    tracingContext: TracingContext;
    pubsub: PubSub;
    abortController: AbortController;
    requestContext: RequestContext;
    outputWriter?: OutputWriter;
    disableScorers?: boolean;
    serializedStepGraph: SerializedStepFlowEntry[];
    perStep?: boolean;
}
export declare function executeLoop(engine: DefaultExecutionEngine, params: ExecuteLoopParams): Promise<StepResult<any, any, any, any>>;
export interface ExecuteForeachParams {
    workflowId: string;
    runId: string;
    resourceId?: string;
    entry: {
        type: 'foreach';
        step: Step;
        opts: {
            concurrency: number;
        };
    };
    prevStep: StepFlowEntry;
    prevOutput: any;
    stepResults: Record<string, StepResult<any, any, any, any>>;
    restart?: RestartExecutionParams;
    timeTravel?: TimeTravelExecutionParams;
    resume?: {
        steps: string[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resumePayload: any;
        resumePath: number[];
        forEachIndex?: number;
    };
    executionContext: ExecutionContext;
    tracingContext: TracingContext;
    pubsub: PubSub;
    abortController: AbortController;
    requestContext: RequestContext;
    outputWriter?: OutputWriter;
    disableScorers?: boolean;
    serializedStepGraph: SerializedStepFlowEntry[];
    perStep?: boolean;
}
export declare function executeForeach(engine: DefaultExecutionEngine, params: ExecuteForeachParams): Promise<StepResult<any, any, any, any>>;
//# sourceMappingURL=control-flow.d.ts.map