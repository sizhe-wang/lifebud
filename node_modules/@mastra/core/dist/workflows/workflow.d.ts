import { ReadableStream } from 'node:stream/web';
import { z } from 'zod';
import type { MastraPrimitives } from '../action/index.js';
import { Agent } from '../agent/index.js';
import type { AgentExecutionOptions, AgentStreamOptions } from '../agent/index.js';
import { MastraBase } from '../base.js';
import { RequestContext } from '../di/index.js';
import type { MastraScorers } from '../evals/index.js';
import type { PubSub } from '../events/pubsub.js';
import type { Mastra } from '../mastra/index.js';
import type { TracingContext, TracingOptions, TracingPolicy } from '../observability/index.js';
import type { Processor } from '../processors/index.js';
import { ProcessorStepOutputSchema, ProcessorStepInputSchema } from '../processors/step-schema.js';
import type { StorageListWorkflowRunsInput } from '../storage/index.js';
import type { InferZodLikeSchema, OutputSchema, SchemaWithValidation } from '../stream/base/schema.js';
import { WorkflowRunOutput } from '../stream/RunOutput.js';
import { Tool } from '../tools/index.js';
import type { ToolExecutionContext } from '../tools/index.js';
import type { DynamicArgument } from '../types/index.js';
import { PUBSUB_SYMBOL } from './constants.js';
import type { ExecutionEngine, ExecutionGraph } from './execution-engine.js';
import type { ConditionFunction, ExecuteFunction, InnerOutput, LoopConditionFunction, Step, SuspendOptions } from './step.js';
import type { DefaultEngineType, DynamicMapping, ExtractSchemaFromStep, ExtractSchemaType, PathsToStringProps, SerializedStepFlowEntry, StepFlowEntry, StepResult, StepsRecord, StepWithComponent, StreamEvent, SubsetOf, TimeTravelContext, WorkflowConfig, WorkflowEngineType, WorkflowOptions, WorkflowResult, WorkflowType, WorkflowRunStatus, WorkflowState, WorkflowStateField, WorkflowStreamEvent, StepParams, OutputWriter } from './types.js';
export type AgentStepOptions<TOUTPUT> = Omit<AgentExecutionOptions<TOUTPUT> & AgentStreamOptions, 'format' | 'tracingContext' | 'requestContext' | 'abortSignal' | 'context' | 'onStepFinish' | 'output' | 'experimental_output' | 'resourceId' | 'threadId' | 'scorers'>;
export declare function mapVariable<TStep extends Step<string, any, any, any, any, any>>({ step, path, }: {
    step: TStep;
    path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '.';
}): {
    step: TStep;
    path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '.';
};
export declare function mapVariable<TWorkflow extends Workflow<any, any, any, any, any, any, any>>({ initData: TWorkflow, path, }: {
    initData: TWorkflow;
    path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TWorkflow, 'inputSchema'>>> | '.';
}): {
    initData: TWorkflow;
    path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TWorkflow, 'inputSchema'>>> | '.';
};
/**
 * Creates a step from explicit params (IMPORTANT: FIRST overload for best error messages when using .then in workflows)
 * @param params Configuration parameters for the step
 * @param params.id Unique identifier for the step
 * @param params.description Optional description of what the step does
 * @param params.inputSchema Zod schema defining the input structure
 * @param params.outputSchema Zod schema defining the output structure
 * @param params.execute Function that performs the step's operations
 * @returns A Step object that can be added to the workflow
 */
export declare function createStep<TStepId extends string, TStateSchema extends z.ZodTypeAny | undefined, TInputSchema extends z.ZodTypeAny, TOutputSchema extends z.ZodTypeAny, TResumeSchema extends z.ZodTypeAny | undefined = undefined, TSuspendSchema extends z.ZodTypeAny | undefined = undefined>(params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>): Step<TStepId, TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown, z.infer<TInputSchema>, z.infer<TOutputSchema>, TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown, TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown, DefaultEngineType>;
/**
 * Creates a step from an agent with structured output
 */
export declare function createStep<TStepId extends string, TStepOutput>(agent: Agent<TStepId, any>, agentOptions: AgentStepOptions<TStepOutput> & {
    structuredOutput: {
        schema: OutputSchema<TStepOutput>;
    };
    retries?: number;
    scorers?: DynamicArgument<MastraScorers>;
}): Step<TStepId, unknown, {
    prompt: string;
}, TStepOutput, unknown, unknown, DefaultEngineType>;
/**
 * Creates a step from an agent (defaults to { text: string } output)
 */
export declare function createStep<TStepId extends string, TStepInput extends {
    prompt: string;
}, TStepOutput extends {
    text: string;
}, TResume, TSuspend>(agent: Agent<TStepId, any>, agentOptions?: AgentStepOptions<TStepOutput> & {
    retries?: number;
    scorers?: DynamicArgument<MastraScorers>;
}): Step<TStepId, unknown, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType>;
/**
 * Creates a step from a tool
 */
export declare function createStep<TSchemaIn, TSuspend, TResume, TSchemaOut, TContext extends ToolExecutionContext<TSuspend, TResume>, TId extends string>(tool: Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId>, toolOptions?: {
    retries?: number;
    scorers?: DynamicArgument<MastraScorers>;
}): Step<TId, unknown, TSchemaIn, TSchemaOut, TSuspend, TResume, DefaultEngineType>;
/**
 * Creates a step from a Processor - wraps a Processor as a workflow step
 * Note: We require at least one processor method to distinguish from StepParams
 */
export declare function createStep<TProcessorId extends string>(processor: (Processor<TProcessorId> & {
    processInput: Function;
}) | (Processor<TProcessorId> & {
    processInputStream: Function;
}) | (Processor<TProcessorId> & {
    processInputStep: Function;
}) | (Processor<TProcessorId> & {
    processOutputStream: Function;
}) | (Processor<TProcessorId> & {
    processOutputResult: Function;
}) | (Processor<TProcessorId> & {
    processOutputStep: Function;
})): Step<`processor:${TProcessorId}`, unknown, z.infer<typeof ProcessorStepInputSchema>, z.infer<typeof ProcessorStepOutputSchema>, unknown, unknown, DefaultEngineType>;
/**
 * IMPORTANT: Fallback overload - provides better error messages when StepParams doesn't match
 * This should be LAST and will show clearer errors about what's wrong
 * This is a copy of first one, KEEP THIS IN SYNC!
 */
export declare function createStep<TStepId extends string, TStateSchema extends z.ZodTypeAny | undefined, TInputSchema extends z.ZodTypeAny, TOutputSchema extends z.ZodTypeAny, TResumeSchema extends z.ZodTypeAny | undefined = undefined, TSuspendSchema extends z.ZodTypeAny | undefined = undefined>(params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>): Step<TStepId, TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown, z.infer<TInputSchema>, z.infer<TOutputSchema>, TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown, TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown, DefaultEngineType>;
export declare function cloneStep<TStepId extends string>(step: Step<string, any, any, any, any, any, DefaultEngineType>, opts: {
    id: TStepId;
}): Step<TStepId, any, any, any, any, any, DefaultEngineType>;
/**
 * Type guard to check if an object is a Processor.
 * A Processor must have an 'id' property and at least one processor method.
 */
export declare function isProcessor(obj: unknown): obj is Processor;
export declare function createWorkflow<TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TSteps extends Step<string, any, any, any, any, any, DefaultEngineType>[] = Step[]>(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>): Workflow<DefaultEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TInput>;
export declare function cloneWorkflow<TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TSteps extends Step<string, any, any, any, any, any, DefaultEngineType>[] = Step<string, any, any, any, any, any, DefaultEngineType>[], TPrevSchema = TInput>(workflow: Workflow<DefaultEngineType, TSteps, string, TState, TInput, TOutput, TPrevSchema>, opts: {
    id: TWorkflowId;
}): Workflow<DefaultEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema>;
export declare class Workflow<TEngineType = DefaultEngineType, TSteps extends Step<string, any, any, any, any, any, TEngineType>[] = Step<string, unknown, unknown, unknown, unknown, unknown, TEngineType>[], TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TPrevSchema = TInput> extends MastraBase implements Step<TWorkflowId, TState, TInput, TOutput | undefined, any, any, DefaultEngineType> {
    #private;
    id: TWorkflowId;
    description?: string | undefined;
    inputSchema: SchemaWithValidation<TInput>;
    outputSchema: SchemaWithValidation<TOutput>;
    stateSchema?: SchemaWithValidation<TState>;
    steps: Record<string, StepWithComponent>;
    stepDefs?: TSteps;
    engineType: WorkflowEngineType;
    /** Type of workflow - 'processor' for processor workflows, 'default' otherwise */
    type: WorkflowType;
    committed: boolean;
    protected stepFlow: StepFlowEntry<TEngineType>[];
    protected serializedStepFlow: SerializedStepFlowEntry[];
    protected executionEngine: ExecutionEngine;
    protected executionGraph: ExecutionGraph;
    retryConfig: {
        attempts?: number;
        delay?: number;
    };
    constructor({ mastra, id, inputSchema, outputSchema, stateSchema, description, executionEngine, retryConfig, steps, options, type, }: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>);
    get runs(): Map<string, Run<TEngineType, TSteps, TState, TInput, TOutput>>;
    get mastra(): Mastra<Record<string, Agent<any, import("../agent").ToolsInput, undefined>>, Record<string, Workflow<any, any, any, any, any, any, any>>, Record<string, import("../vector").MastraVector<any>>, Record<string, import("../tts").MastraTTS>, import("../logger").IMastraLogger, Record<string, import("../mcp").MCPServerBase<any>>, Record<string, import("../evals").MastraScorer<any, any, any, any>>, Record<string, import("../tools").ToolAction<any, any, any, any, any, any>>, Record<string, Processor<any, unknown>>, Record<string, import("../memory").MastraMemory>> | undefined;
    get options(): Omit<WorkflowOptions, "validateInputs" | "shouldPersistSnapshot"> & Required<Pick<WorkflowOptions, "validateInputs" | "shouldPersistSnapshot">>;
    __registerMastra(mastra: Mastra): void;
    __registerPrimitives(p: MastraPrimitives): void;
    setStepFlow(stepFlow: StepFlowEntry<TEngineType>[]): void;
    /**
     * Adds a step to the workflow
     * @param step The step to add to the workflow
     * @returns The workflow instance for chaining
     *
     * The step's inputSchema must be satisfied by the previous step's output (or workflow input for first step).
     * This means: TPrevSchema must be assignable to TStepInput
     */
    then<TStepId extends string, TStepState, TStepInput, TSchemaOut>(step: Step<TStepId, unknown extends TStepState ? TStepState : SubsetOf<TStepState, TState>, TPrevSchema extends TStepInput ? TStepInput : TPrevSchema, TSchemaOut, any, any, TEngineType>): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TSchemaOut>;
    /**
     * Adds a sleep step to the workflow
     * @param duration The duration to sleep for
     * @returns The workflow instance for chaining
     */
    sleep(duration: number | ExecuteFunction<TState, TPrevSchema, number, any, any, TEngineType>): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema>;
    /**
     * Adds a sleep until step to the workflow
     * @param date The date to sleep until
     * @returns The workflow instance for chaining
     */
    sleepUntil(date: Date | ExecuteFunction<TState, TPrevSchema, Date, any, any, TEngineType>): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema>;
    /**
     * @deprecated waitForEvent has been removed. Please use suspend/resume instead.
     */
    waitForEvent<TStepState, TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut>(_event: string, _step: Step<TStepId, SubsetOf<TStepState, TState>, TStepInputSchema, TSchemaOut, any, any, TEngineType>, _opts?: {
        timeout?: number;
    }): void;
    map(mappingConfig: {
        [k: string]: {
            step: Step<string, any, any, any, any, any, TEngineType> | Step<string, any, any, any, any, any, TEngineType>[];
            path: string;
        } | {
            value: any;
            schema: SchemaWithValidation<any>;
        } | {
            initData: Workflow<TEngineType, any, any, any, any, any, any>;
            path: string;
        } | {
            requestContextPath: string;
            schema: SchemaWithValidation<any>;
        } | DynamicMapping<TPrevSchema, any>;
    } | ExecuteFunction<TState, TPrevSchema, any, any, any, TEngineType>, stepOptions?: {
        id?: string | null;
    }): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, any>;
    parallel<TParallelSteps extends readonly Step<string, any, TPrevSchema, any, any, any, TEngineType>[]>(steps: TParallelSteps & {
        [K in keyof TParallelSteps]: TParallelSteps[K] extends Step<string, infer S, TPrevSchema, infer O, any, // Don't infer TResume - causes issues with heterogeneous tuples
        any, // Don't infer TSuspend - causes issues with heterogeneous tuples
        TEngineType> ? Step<string, SubsetOf<S, TState>, TPrevSchema, O, any, any, TEngineType> : `Error: Expected Step with state schema that is a subset of workflow state`;
    }): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, { [K in keyof StepsRecord<TParallelSteps>]: InferZodLikeSchema<StepsRecord<TParallelSteps>[K]["outputSchema"]>; }>;
    branch<TBranchSteps extends Array<[
        ConditionFunction<TState, TPrevSchema, any, any, any, TEngineType>,
        Step<string, any, TPrevSchema, any, any, any, TEngineType>
    ]>>(steps: TBranchSteps): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, { [K in keyof StepsRecord<{ [K_1 in keyof TBranchSteps]: TBranchSteps[K_1][1]; }[number][]>]?: InferZodLikeSchema<StepsRecord<{ [K_1 in keyof TBranchSteps]: TBranchSteps[K_1][1]; }[number][]>[K]["outputSchema"]>; }>;
    dowhile<TStepState, TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut>(step: Step<TStepId, SubsetOf<TStepState, TState>, TStepInputSchema, TSchemaOut, any, any, TEngineType>, condition: LoopConditionFunction<TState, any, any, any, any, TEngineType>): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TSchemaOut>;
    dountil<TStepState, TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut>(step: Step<TStepId, SubsetOf<TStepState, TState>, TStepInputSchema, TSchemaOut, any, any, TEngineType>, condition: LoopConditionFunction<TState, any, any, any, any, TEngineType>): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TSchemaOut>;
    foreach<TPrevIsArray extends TPrevSchema extends any[] ? true : false, TStepState, TStepInputSchema extends TPrevSchema extends (infer TElement)[] ? TElement : never, TStepId extends string, TSchemaOut>(step: TPrevIsArray extends true ? Step<TStepId, SubsetOf<TStepState, TState>, TStepInputSchema, TSchemaOut, any, any, TEngineType> : 'Previous step must return an array type', opts?: {
        concurrency: number;
    }): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TSchemaOut[]>;
    /**
     * Builds the execution graph for this workflow
     * @returns The execution graph that can be used to execute the workflow
     */
    buildExecutionGraph(): ExecutionGraph;
    /**
     * Finalizes the workflow definition and prepares it for execution
     * This method should be called after all steps have been added to the workflow
     * @returns A built workflow instance ready for execution
     */
    commit(): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TOutput>;
    get stepGraph(): StepFlowEntry<TEngineType>[];
    get serializedStepGraph(): SerializedStepFlowEntry[];
    /**
     * Creates a new workflow run instance and stores a snapshot of the workflow in the storage
     * @param options Optional configuration for the run
     * @param options.runId Optional custom run ID, defaults to a random UUID
     * @param options.resourceId Optional resource ID to associate with this run
     * @param options.disableScorers Optional flag to disable scorers for this run
     * @returns A Run instance that can be used to execute the workflow
     */
    createRun(options?: {
        runId?: string;
        resourceId?: string;
        disableScorers?: boolean;
    }): Promise<Run<TEngineType, TSteps, TState, TInput, TOutput>>;
    listScorers({ requestContext, }?: {
        requestContext?: RequestContext;
    }): Promise<MastraScorers>;
    execute({ runId, inputData, resumeData, state, setState, suspend, restart, resume, timeTravel, [PUBSUB_SYMBOL]: pubsub, mastra, requestContext, abort, abortSignal, retryCount, tracingContext, outputWriter, validateInputs, perStep, }: {
        runId?: string;
        inputData: TInput;
        resumeData?: unknown;
        state: TState;
        setState: (state: TState) => Promise<void>;
        suspend: (suspendPayload: any, suspendOptions?: SuspendOptions) => InnerOutput | Promise<InnerOutput>;
        restart?: boolean;
        timeTravel?: {
            inputData?: TInput;
            steps: string[];
            nestedStepResults?: Record<string, Record<string, StepResult<any, any, any, any>>>;
            resumeData?: any;
        };
        resume?: {
            steps: string[];
            resumePayload: any;
            runId?: string;
            label?: string;
            forEachIndex?: number;
        };
        [PUBSUB_SYMBOL]: PubSub;
        mastra: Mastra;
        requestContext?: RequestContext;
        engine: DefaultEngineType;
        abortSignal: AbortSignal;
        bail: (result: any) => any;
        abort: () => any;
        retryCount?: number;
        tracingContext?: TracingContext;
        outputWriter?: OutputWriter;
        validateInputs?: boolean;
        perStep?: boolean;
    }): Promise<TOutput | undefined>;
    listWorkflowRuns(args?: StorageListWorkflowRunsInput): Promise<import("../storage").WorkflowRuns>;
    listActiveWorkflowRuns(): Promise<{
        runs: import("../storage").WorkflowRun[];
        total: number;
    }>;
    restartAllActiveWorkflowRuns(): Promise<void>;
    deleteWorkflowRunById(runId: string): Promise<void>;
    protected getWorkflowRunSteps({ runId, workflowId }: {
        runId: string;
        workflowId: string;
    }): Promise<Record<string, StepResult<any, any, any, any>>>;
    /**
     * Get a workflow run by ID with processed execution state and metadata.
     *
     * @param runId - The unique identifier of the workflow run
     * @param options - Configuration options for the result
     * @param options.withNestedWorkflows - Whether to include nested workflow steps (default: true)
     * @param options.fields - Specific fields to return (for performance optimization)
     * @returns The workflow run result with metadata and processed execution state, or null if not found
     */
    getWorkflowRunById(runId: string, options?: {
        withNestedWorkflows?: boolean;
        fields?: WorkflowStateField[];
    }): Promise<WorkflowState | null>;
}
/**
 * Represents a workflow run that can be executed
 */
export declare class Run<TEngineType = DefaultEngineType, TSteps extends Step<string, any, any, any, any, any, TEngineType>[] = Step<string, unknown, unknown, unknown, unknown, unknown, TEngineType>[], TState = unknown, TInput = unknown, TOutput = unknown> {
    #private;
    protected pubsub: PubSub;
    /**
     * Unique identifier for this workflow
     */
    readonly workflowId: string;
    /**
     * Unique identifier for this run
     */
    readonly runId: string;
    /**
     * Unique identifier for the resource this run is associated with
     */
    readonly resourceId?: string;
    /**
     * Whether to disable scorers for this run
     */
    readonly disableScorers?: boolean;
    /**
     * Options around how to trace this run
     */
    readonly tracingPolicy?: TracingPolicy;
    /**
     * Options around how to trace this run
     */
    readonly validateInputs?: boolean;
    /**
     * Internal state of the workflow run
     */
    protected state: Record<string, any>;
    /**
     * The execution engine for this run
     */
    executionEngine: ExecutionEngine;
    /**
     * The execution graph for this run
     */
    executionGraph: ExecutionGraph;
    /**
     * The serialized step graph for this run
     */
    serializedStepGraph: SerializedStepFlowEntry[];
    /**
     * The steps for this workflow
     */
    readonly workflowSteps: Record<string, StepWithComponent>;
    workflowRunStatus: WorkflowRunStatus;
    readonly workflowEngineType: WorkflowEngineType;
    get mastra(): Mastra<Record<string, Agent<any, import("../agent").ToolsInput, undefined>>, Record<string, Workflow<any, any, any, any, any, any, any>>, Record<string, import("../vector").MastraVector<any>>, Record<string, import("../tts").MastraTTS>, import("../logger").IMastraLogger, Record<string, import("../mcp").MCPServerBase<any>>, Record<string, import("../evals").MastraScorer<any, any, any, any>>, Record<string, import("../tools").ToolAction<any, any, any, any, any, any>>, Record<string, Processor<any, unknown>>, Record<string, import("../memory").MastraMemory>> | undefined;
    streamOutput?: WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    protected closeStreamAction?: () => Promise<void>;
    protected executionResults?: Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    protected stateSchema?: SchemaWithValidation<TState>;
    protected inputSchema?: SchemaWithValidation<TInput>;
    protected cleanup?: () => void;
    protected retryConfig?: {
        attempts?: number;
        delay?: number;
    };
    constructor(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        stateSchema?: SchemaWithValidation<TState>;
        inputSchema?: SchemaWithValidation<TInput>;
        executionEngine: ExecutionEngine;
        executionGraph: ExecutionGraph;
        mastra?: Mastra;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        cleanup?: () => void;
        serializedStepGraph: SerializedStepFlowEntry[];
        disableScorers?: boolean;
        tracingPolicy?: TracingPolicy;
        workflowSteps: Record<string, StepWithComponent>;
        validateInputs?: boolean;
        workflowEngineType: WorkflowEngineType;
    });
    get abortController(): AbortController;
    /**
     * Cancels the workflow execution.
     * This aborts any running execution and updates the workflow status to 'canceled' in storage.
     */
    cancel(): Promise<void>;
    protected _validateInput(inputData?: TInput): Promise<TInput | undefined>;
    protected _validateInitialState(initialState?: TState): Promise<TState | undefined>;
    protected _validateResumeData<TResume>(resumeData: TResume, suspendedStep?: StepWithComponent): Promise<TResume>;
    protected _validateTimetravelInputData<TInput>(inputData: TInput, step: Step<string, any, TInput, any, any, any, TEngineType>): Promise<TInput>;
    protected _start({ inputData, initialState, requestContext, outputWriter, tracingContext, tracingOptions, format, outputOptions, perStep, }: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & (TState extends unknown ? {
        initialState?: TState;
    } : {
        initialState: TState;
    }) & {
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        format?: 'legacy' | 'vnext' | undefined;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Starts the workflow execution with the provided input
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    start(args: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & (TState extends unknown ? {
        initialState?: TState;
    } : {
        initialState: TState;
    }) & {
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Starts the workflow execution without waiting for completion (fire-and-forget).
     * Returns immediately with the runId. The workflow executes in the background.
     * Use this when you don't need to wait for the result or want to avoid polling failures.
     * @param args The input data and configuration for the workflow
     * @returns A promise that resolves immediately with the runId
     */
    startAsync(args: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & (TState extends unknown ? {
        initialState?: TState;
    } : {
        initialState: TState;
    }) & {
        requestContext?: RequestContext;
        tracingOptions?: TracingOptions;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<{
        runId: string;
    }>;
    /**
     * Starts the workflow execution with the provided input as a stream
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    streamLegacy({ inputData, requestContext, onChunk, tracingContext, tracingOptions, }?: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & {
        requestContext?: RequestContext;
        tracingContext?: TracingContext;
        onChunk?: (chunk: StreamEvent) => Promise<unknown>;
        tracingOptions?: TracingOptions;
    }): {
        stream: ReadableStream<StreamEvent>;
        getWorkflowState: () => Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    };
    /**
     * Observe the workflow stream
     * @returns A readable stream of the workflow events
     */
    observeStreamLegacy(): {
        stream: ReadableStream<StreamEvent>;
    };
    /**
     * Observe the workflow stream
     * @returns A readable stream of the workflow events
     */
    observeStream(): ReadableStream<WorkflowStreamEvent>;
    /**
     * Starts the workflow execution with the provided input as a stream
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    stream({ inputData, requestContext, tracingContext, tracingOptions, closeOnSuspend, initialState, outputOptions, perStep, }: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & (TState extends unknown ? {
        initialState?: TState;
    } : {
        initialState: TState;
    }) & {
        requestContext?: RequestContext;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        closeOnSuspend?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Resumes the workflow execution with the provided input as a stream
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    resumeStream<TResume>({ step, resumeData, requestContext, tracingContext, tracingOptions, forEachIndex, outputOptions, perStep, }?: {
        resumeData?: TResume;
        step?: Step<string, any, any, any, TResume, any, TEngineType> | [
            ...Step<string, any, any, any, any, any, TEngineType>[],
            Step<string, any, any, any, TResume, any, TEngineType>
        ] | string | string[];
        requestContext?: RequestContext;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        forEachIndex?: number;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * @internal
     */
    watch(cb: (event: WorkflowStreamEvent) => void): () => void;
    /**
     * @internal
     */
    watchAsync(cb: (event: WorkflowStreamEvent) => void): Promise<() => void>;
    resume<TResume>(params: {
        resumeData?: TResume;
        step?: Step<string, any, any, any, TResume, any, TEngineType> | [
            ...Step<string, any, any, any, any, any, TEngineType>[],
            Step<string, any, any, any, TResume, any, TEngineType>
        ] | string | string[];
        label?: string;
        requestContext?: RequestContext;
        retryCount?: number;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputWriter?: OutputWriter;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        forEachIndex?: number;
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Restarts the workflow execution that was previously active
     * @returns A promise that resolves to the workflow output
     */
    restart(args?: {
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    protected _resume<TResume>(params: {
        resumeData?: TResume;
        step?: Step<string, any, any, TResume, any, any, TEngineType> | [
            ...Step<string, any, any, any, any, any, TEngineType>[],
            Step<string, any, any, TResume, any, any, TEngineType>
        ] | string | string[];
        label?: string;
        requestContext?: RequestContext;
        retryCount?: number;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputWriter?: OutputWriter;
        format?: 'legacy' | 'vnext' | undefined;
        isVNext?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        forEachIndex?: number;
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    protected _restart({ requestContext, outputWriter, tracingContext, tracingOptions, }: {
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    protected _timeTravel<TInput>({ inputData, resumeData, initialState, step: stepParam, context, nestedStepsContext, requestContext, outputWriter, tracingContext, tracingOptions, outputOptions, perStep, }: {
        inputData?: TInput;
        resumeData?: any;
        initialState?: TState;
        step: Step<string, any, TInput, any, any, any, TEngineType> | [...Step<string, any, any, any, any, any, TEngineType>[], Step<string, any, TInput, any, any, any, TEngineType>] | string | string[];
        context?: TimeTravelContext<any, any, any, any>;
        nestedStepsContext?: Record<string, TimeTravelContext<any, any, any, any>>;
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    timeTravel<TInput>(args: {
        inputData?: TInput;
        resumeData?: any;
        initialState?: TState;
        step: Step<string, any, TInput, any, any, any, TEngineType> | [...Step<string, any, any, any, any, any, TEngineType>[], Step<string, any, TInput, any, any, any, TEngineType>] | string | string[];
        context?: TimeTravelContext<any, any, any, any>;
        nestedStepsContext?: Record<string, TimeTravelContext<any, any, any, any>>;
        requestContext?: RequestContext;
        outputWriter?: OutputWriter;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    timeTravelStream<TTravelInput>({ inputData, resumeData, initialState, step, context, nestedStepsContext, requestContext, tracingContext, tracingOptions, outputOptions, perStep, }: {
        inputData?: TTravelInput;
        initialState?: TState;
        resumeData?: any;
        step: Step<string, any, any, any, any, any, TEngineType> | [...Step<string, any, any, any, any, any, TEngineType>[], Step<string, any, any, any, any, any, TEngineType>] | string | string[];
        context?: TimeTravelContext<any, any, any, any>;
        nestedStepsContext?: Record<string, TimeTravelContext<any, any, any, any>>;
        requestContext?: RequestContext;
        tracingContext?: TracingContext;
        tracingOptions?: TracingOptions;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
        perStep?: boolean;
    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * @access private
     * @returns The execution results of the workflow run
     */
    _getExecutionResults(): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>> | undefined;
}
//# sourceMappingURL=workflow.d.ts.map