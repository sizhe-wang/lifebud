import { getInputOptions, nodeModulesExtensionResolver } from './chunk-NGQZZ54Y.js';
import { getWorkspaceInformation, analyzeBundle, tsConfigPaths, aliasHono, extractMastraOption } from './chunk-HWSYWSD7.js';
import { slash, getPackageName } from './chunk-QAOUDKHK.js';
import { watch } from 'rollup';
import { dirname, posix } from 'path';
import * as pkg from 'empathic/package';
import { noopLogger } from '@mastra/core/logger';

async function getInputOptions2(entryFile, platform, env, { sourcemap = false } = {}) {
  const closestPkgJson = pkg.up({ cwd: dirname(entryFile) });
  const projectRoot = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());
  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: entryFile });
  const analyzeEntryResult = await analyzeBundle(
    [entryFile],
    entryFile,
    {
      outputDir: posix.join(process.cwd(), ".mastra", ".build"),
      projectRoot: workspaceRoot || process.cwd(),
      platform,
      isDev: true
    },
    noopLogger
  );
  const deps = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {
    const pkgName = getPackageName(dep);
    if (pkgName && workspaceMap.has(pkgName)) {
      deps.set(dep, metadata);
    }
  }
  const inputOptions = await getInputOptions(
    entryFile,
    {
      dependencies: deps,
      externalDependencies: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot, projectRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(aliasHono());
    inputOptions.plugins.push(nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption("server", entryFile, outputDir, logger);
  if (!result) {
    return null;
  }
  return result.getConfig();
}

export { createWatcher, getInputOptions2 as getInputOptions, getServerOptions };
//# sourceMappingURL=chunk-5FPJTHRK.js.map
//# sourceMappingURL=chunk-5FPJTHRK.js.map