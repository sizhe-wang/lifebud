'use strict';

var chunk7EPD2XJR_cjs = require('./chunk-7EPD2XJR.cjs');
var chunkT7NCLSYN_cjs = require('./chunk-T7NCLSYN.cjs');
var chunk5TYVF4KJ_cjs = require('./chunk-5TYVF4KJ.cjs');
var rollup = require('rollup');
var path = require('path');
var pkg = require('empathic/package');
var logger = require('@mastra/core/logger');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var pkg__namespace = /*#__PURE__*/_interopNamespace(pkg);

async function getInputOptions2(entryFile, platform, env, { sourcemap = false } = {}) {
  const closestPkgJson = pkg__namespace.up({ cwd: path.dirname(entryFile) });
  const projectRoot = closestPkgJson ? path.dirname(chunk5TYVF4KJ_cjs.slash(closestPkgJson)) : chunk5TYVF4KJ_cjs.slash(process.cwd());
  const { workspaceMap, workspaceRoot } = await chunkT7NCLSYN_cjs.getWorkspaceInformation({ mastraEntryFile: entryFile });
  const analyzeEntryResult = await chunkT7NCLSYN_cjs.analyzeBundle(
    [entryFile],
    entryFile,
    {
      outputDir: path.posix.join(process.cwd(), ".mastra", ".build"),
      projectRoot: workspaceRoot || process.cwd(),
      platform,
      isDev: true
    },
    logger.noopLogger
  );
  const deps = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {
    const pkgName = chunk5TYVF4KJ_cjs.getPackageName(dep);
    if (pkgName && workspaceMap.has(pkgName)) {
      deps.set(dep, metadata);
    }
  }
  const inputOptions = await chunk7EPD2XJR_cjs.getInputOptions(
    entryFile,
    {
      dependencies: deps,
      externalDependencies: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot, projectRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          chunkT7NCLSYN_cjs.tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(chunkT7NCLSYN_cjs.aliasHono());
    inputOptions.plugins.push(chunk7EPD2XJR_cjs.nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await rollup.watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await chunkT7NCLSYN_cjs.extractMastraOption("server", entryFile, outputDir, logger);
  if (!result) {
    return null;
  }
  return result.getConfig();
}

exports.createWatcher = createWatcher;
exports.getInputOptions = getInputOptions2;
exports.getServerOptions = getServerOptions;
//# sourceMappingURL=chunk-GU4OME5Q.cjs.map
//# sourceMappingURL=chunk-GU4OME5Q.cjs.map