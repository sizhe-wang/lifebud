> Configure storage for Mastra

# Storage

For Mastra to remember previous interactions, you must configure a storage adapter. Mastra is designed to work with your preferred database provider - choose from the [supported providers](#supported-providers) and pass it to your Mastra instance.

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  storage: new LibSQLStore({
    id: 'mastra-storage',
    url: "file:./mastra.db",
  }),
});
```
On first interaction, Mastra automatically creates the necessary tables following the [core schema](https://mastra.ai/reference/v1/storage/overview#core-schema). This includes tables for messages, threads, resources, workflows, traces, and evaluation datasets.

## Supported providers

Each provider page includes installation instructions, configuration parameters, and usage examples:

- [libSQL Storage](https://mastra.ai/reference/v1/storage/libsql)
- [PostgreSQL Storage](https://mastra.ai/reference/v1/storage/postgresql)
- [MongoDB Storage](https://mastra.ai/reference/v1/storage/mongodb)
- [Upstash Storage](https://mastra.ai/reference/v1/storage/upstash)
- [Cloudflare D1](https://mastra.ai/reference/v1/storage/cloudflare-d1)
- [Cloudflare Durable Objects](https://mastra.ai/reference/v1/storage/cloudflare)
- [Convex](https://mastra.ai/reference/v1/storage/convex)
- [DynamoDB](https://mastra.ai/reference/v1/storage/dynamodb)
- [LanceDB](https://mastra.ai/reference/v1/storage/lance)
- [Microsoft SQL Server](https://mastra.ai/reference/v1/storage/mssql)

> **Note:**
libSQL is the easiest way to get started because it doesn’t require running a separate database server

## Configuration scope

You can configure storage at two different scopes:

### Instance-level storage

Add storage to your Mastra instance so all agents, workflows, observability traces and scores share the same memory provider:

```typescript
import { Mastra } from "@mastra/core";
import { PostgresStore } from "@mastra/pg";

export const mastra = new Mastra({
  storage: new PostgresStore({
    id: 'mastra-storage',
    connectionString: process.env.DATABASE_URL,
  }),
});

// All agents automatically use this storage
const agent1 = new Agent({ id: "agent-1", memory: new Memory() });
const agent2 = new Agent({ id: "agent-2", memory: new Memory() });
```

This is useful when all primitives share the same storage backend and have similar performance, scaling, and operational requirements.

#### Composite storage

Add storage to your Mastra instance using `MastraStorage` and configure individual storage domains to use different storage providers.

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { MastraStorage } from "@mastra/core/storage";
import { MemoryLibSQL } from "@mastra/libsql";
import { WorkflowsPG } from "@mastra/pg";
import { ObservabilityStorageClickhouse } from "@mastra/clickhouse";

export const mastra = new Mastra({
  storage: new MastraStorage({
    id: "composite",
    domains: {
      memory: new MemoryLibSQL({ url: "file:./memory.db" }),
      workflows: new WorkflowsPG({ connectionString: process.env.DATABASE_URL }),
      observability: new ObservabilityStorageClickhouse({
        url: process.env.CLICKHOUSE_URL,
        username: process.env.CLICKHOUSE_USERNAME,
        password: process.env.CLICKHOUSE_PASSWORD,
      }),
    },
  }),
});
```

This is useful when different types of data have different performance or operational requirements, such as low-latency storage for memory, durable storage for workflows, and high-throughput storage for observability.

> **Note:**
See [Storage Domains](https://mastra.ai/reference/v1/storage/composite#storage-domains) for more information.

### Agent-level storage

Agent-level storage overrides storage configured at the instance-level. Add storage to a specific agent when you need data boundaries or compliance requirements:

```typescript title="src/mastra/agents/memory-agent.ts"
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { PostgresStore } from "@mastra/pg";

export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    storage: new PostgresStore({
      id: 'agent-storage',
      connectionString: process.env.AGENT_DATABASE_URL,
    }),
  }),
});
```

This is useful when different agents need to store data in separate databases for security, compliance, or organizational reasons.

## Threads and resources

Mastra organizes memory into threads using two identifiers:

- **Thread**: A conversation session containing a sequence of messages (e.g., `convo_123`)
- **Resource**: An identifier for the entity the thread belongs to, typically a user (e.g., `user_123`)

Both identifiers are required for agents to store and recall information:

```typescript
const stream = await agent.stream("message for agent", {
  memory: {
    thread: "convo_123",
    resource: "user_123",
  },
});
```

> **Note:**
[Studio](https://mastra.ai/docs/v1/getting-started/studio) automatically generates a thread and resource ID for you. Remember to  to pass these explicitly when calling `stream` or `generate` yourself.

### Thread title generation

Mastra can automatically generate descriptive thread titles based on the user's first message.

Use this option when implementing a ChatGPT-style chat interface to render a title alongside each thread in the conversation list (for example, in a sidebar) derived from the thread’s initial user message.

```typescript
export const testAgent = new Agent({
  id: "test-agent",
  memory: new Memory({
    options: {
      generateTitle: true,
    },
  }),
});
```

Title generation runs asynchronously after the agent responds and does not affect response time.

To optimize cost or behavior, provide a smaller `model` and custom `instructions`:

```typescript
export const testAgent = new Agent({
  id: "test-agent",
  memory: new Memory({
    options: {
      generateTitle: {
        model: "openai/gpt-4o-mini",
        instructions: "Generate a concise title based on the user's first message",
      },
    },
  }),
});
```

## Semantic recall

Semantic recall uses vector embeddings to retrieve relevant past messages based on meaning rather than recency. This requires a vector database instance, which can be configured at the instance or agent level.

The vector database doesn't have to be the same as your storage provider. For example, you might use PostgreSQL for storage and Pinecone for vectors:

```typescript
import { Mastra } from "@mastra/core";
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { PostgresStore } from "@mastra/pg";
import { PineconeVector } from "@mastra/pinecone";

// Instance-level vector configuration
export const mastra = new Mastra({
  storage: new PostgresStore({
    id: 'mastra-storage',
    connectionString: process.env.DATABASE_URL,
  }),
});

// Agent-level vector configuration
export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    vector: new PineconeVector({
      id: 'agent-vector',
      apiKey: process.env.PINECONE_API_KEY,
    }),
    options: {
      semanticRecall: {
        topK: 5,
        messageRange: 2,
      },
    },
  }),
});
```

We support all popular vector providers including [Pinecone](https://mastra.ai/reference/v1/vectors/pinecone), [Chroma](https://mastra.ai/reference/v1/vectors/chroma), [Qdrant](https://mastra.ai/reference/v1/vectors/qdrant), and many more.

For more information on configuring semantic recall, see the [Semantic Recall](./semantic-recall) documentation.