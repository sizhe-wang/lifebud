{"version":3,"sources":["../src/vector/filter.ts","../src/vector/sql-builder.ts","../src/vector/index.ts","../src/storage/db/utils.ts","../src/storage/db/index.ts","../src/storage/domains/agents/index.ts","../src/storage/domains/memory/index.ts","../src/storage/domains/observability/index.ts","../src/storage/domains/scores/index.ts","../src/storage/domains/workflows/index.ts","../src/storage/index.ts","../src/vector/prompt.ts"],"names":["result","conditions","operator","operatorValue","parseSqlIdentifier","buildCondition","createClient","MastraError","ErrorDomain","ErrorCategory","TABLE_SCHEMAS","createStorageErrorId","normalizePerPage","calculatePagination","TABLE_SPANS","coreTransformScoreRow","TABLE_WORKFLOW_SNAPSHOT"],"mappings":"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","file":"index.js","sourcesContent":["import { BaseFilterTranslator } from '@mastra/core/vector/filter';\nimport type { VectorFilter, OperatorSupport, OperatorValueMap, VectorFieldValue } from '@mastra/core/vector/filter';\n\ntype LibSQLOperatorValueMap = Omit<\n  OperatorValueMap,\n  '$regex' | '$options' | '$in' | '$all' | '$nin' | '$eq' | '$ne'\n> & {\n  $size: number;\n  $contains: VectorFieldValue | Record<string, unknown>;\n  $all: VectorFieldValue;\n  $in: VectorFieldValue;\n  $nin: VectorFieldValue;\n  $eq: VectorFieldValue;\n  $ne: VectorFieldValue;\n};\nexport type LibSQLVectorFilter = VectorFilter<keyof LibSQLOperatorValueMap, LibSQLOperatorValueMap>;\n\n/**\n * Translates MongoDB-style filters to LibSQL compatible filters.\n *\n * Key differences from MongoDB:\n *\n * Logical Operators ($and, $or, $nor):\n * - Can be used at the top level or nested within fields\n * - Can take either a single condition or an array of conditions\n *\n */\nexport class LibSQLFilterTranslator extends BaseFilterTranslator<LibSQLVectorFilter> {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      regex: [],\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: LibSQLVectorFilter): LibSQLVectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: LibSQLVectorFilter, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Direct regex pattern format is not supported in LibSQL');\n    }\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    // Handle regex\n    // TODO: Look more into regex support for LibSQL\n    // if (node instanceof RegExp) {\n    //   return withPath(this.translateRegexPattern(node.source, node.flags));\n    // }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    // if ('$options' in node && !('$regex' in node)) {\n    //   throw new Error('$options is not valid without $regex');\n    // }\n\n    // TODO: Look more into regex support for LibSQL\n    // // Handle special regex object format\n    // if ('$regex' in node) {\n    //   const options = (node as any).$options || '';\n    //   return withPath(this.translateRegexPattern(node.$regex, options));\n    // }\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      // // Skip options as they're handled with $regex\n      // if (key === '$options') continue;\n\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: LibSQLVectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  // TODO: Look more into regex support for LibSQL\n  // private translateRegexPattern(pattern: string, options: string = ''): any {\n  //   if (!options) return { $regex: pattern };\n\n  //   const flags = options\n  //     .split('')\n  //     .filter(f => 'imsux'.includes(f))\n  //     .join('');\n\n  //   return {\n  //     $regex: pattern,\n  //     $options: flags,\n  //   };\n  // }\n}\n","import type { InValue } from '@libsql/client';\nimport { parseFieldKey } from '@mastra/core/utils';\nimport type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n} from '@mastra/core/vector/filter';\nimport type { LibSQLVectorFilter } from './filter';\n\ntype OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | '$size';\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: () => any;\n};\n\ntype OperatorFn = (key: string, value?: any) => FilterOperator;\n\n// Helper functions to create operators\nconst createBasicOperator = (symbol: string) => {\n  return (key: string, value: any): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `CASE \n        WHEN ? IS NULL THEN json_extract(metadata, ${jsonPath}) IS ${symbol === '=' ? '' : 'NOT'} NULL\n        ELSE json_extract(metadata, ${jsonPath}) ${symbol} ?\n      END`,\n      needsValue: true,\n      transformValue: () => {\n        // Return the values directly, not in an object\n        return [value, value];\n      },\n    };\n  };\n};\nconst createNumericOperator = (symbol: string) => {\n  return (key: string, value: any): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n\n    // Check if the value is numeric or a string (like ISO date)\n    const isNumeric =\n      typeof value === 'number' || (typeof value === 'string' && !isNaN(Number(value)) && value.trim() !== '');\n\n    if (isNumeric) {\n      // For numeric values, cast to NUMERIC for proper comparison\n      return {\n        sql: `CAST(json_extract(metadata, ${jsonPath}) AS NUMERIC) ${symbol} ?`,\n        needsValue: true,\n      };\n    } else {\n      // For non-numeric strings (like ISO dates), compare as text\n      return {\n        sql: `CAST(json_extract(metadata, ${jsonPath}) AS TEXT) ${symbol} ?`,\n        needsValue: true,\n      };\n    }\n  };\n};\n\nconst validateJsonArray = (key: string) => {\n  const jsonPath = getJsonPath(key);\n  return `json_valid(json_extract(metadata, ${jsonPath}))\n   AND json_type(json_extract(metadata, ${jsonPath})) = 'array'`;\n};\n\nconst pattern = /json_extract\\(metadata, '\\$\\.(?:\"[^\"]*\"(?:\\.\"[^\"]*\")*|[^']+)'\\)/g;\n\nfunction buildElemMatchConditions(value: any) {\n  const conditions = Object.entries(value).map(([field, fieldValue]) => {\n    if (field.startsWith('$')) {\n      // Direct operators on array elements ($in, $gt, etc)\n      const { sql, values } = buildCondition('elem.value', { [field]: fieldValue }, '');\n      // Replace the metadata path with elem.value\n      const elemSql = sql.replace(pattern, 'elem.value');\n      return { sql: elemSql, values };\n    } else if (typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {\n      // Nested field with operators (count: { $gt: 20 })\n      const { sql, values } = buildCondition(field, fieldValue, '');\n      // Replace the field path with elem.value path\n      const jsonPath = parseJsonPathKey(field);\n      const elemSql = sql.replace(pattern, `json_extract(elem.value, '$.${jsonPath}')`);\n      return { sql: elemSql, values };\n    } else {\n      const jsonPath = parseJsonPathKey(field);\n      // Simple field equality (warehouse: 'A')\n      return {\n        sql: `json_extract(elem.value, '$.${jsonPath}') = ?`,\n        values: [fieldValue],\n      };\n    }\n  });\n\n  return conditions;\n}\n\n// Define all filter operators\nconst FILTER_OPERATORS: Record<OperatorType, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 0', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n\n  $nin: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 1', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) NOT IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n  $all: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    let sql: string;\n    const arrayValue = Array.isArray(value) ? value : [value];\n\n    if (arrayValue.length === 0) {\n      // If the array is empty, always return false (no matches)\n      sql = '1 = 0';\n    } else {\n      sql = `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT value\n            FROM json_each(?)\n            WHERE value NOT IN (\n              SELECT value\n              FROM json_each(json_extract(metadata, ${jsonPath}))\n            )\n          )\n        ELSE FALSE\n      END\n    )`;\n    }\n\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (arrayValue.length === 0) {\n          return [];\n        }\n        return [JSON.stringify(arrayValue)];\n      },\n    };\n  },\n  $elemMatch: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    if (typeof value !== 'object' || Array.isArray(value)) {\n      throw new Error('$elemMatch requires an object with conditions');\n    }\n\n    // For nested object conditions\n    const conditions = buildElemMatchConditions(value);\n\n    return {\n      sql: `(\n        CASE\n          WHEN ${validateJsonArray(key)} THEN\n            EXISTS (\n              SELECT 1\n              FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n              WHERE ${conditions.map(c => c.sql).join(' AND ')}\n            )\n          ELSE FALSE\n        END\n      )`,\n      needsValue: true,\n      transformValue: () => conditions.flatMap(c => c.values),\n    };\n  },\n\n  // Element Operators\n  $exists: (key: string) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) IS NOT NULL`,\n      needsValue: false,\n    };\n  },\n\n  // Logical Operators\n  $and: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $or: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: (key: string) => ({\n    sql: `NOT (${key})`,\n    needsValue: false,\n  }),\n  $size: (key: string, paramIndex: number) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `(\n    CASE\n      WHEN json_type(json_extract(metadata, ${jsonPath})) = 'array' THEN \n        json_array_length(json_extract(metadata, ${jsonPath})) = $${paramIndex}\n      ELSE FALSE\n    END\n  )`,\n      needsValue: true,\n    };\n  },\n  //   /**\n  //    * Regex Operators\n  //    * Supports case insensitive and multiline\n  //    */\n  //   $regex: (key: string): FilterOperator => ({\n  //     sql: `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"') = ?`,\n  //     needsValue: true,\n  //     transformValue: (value: any) => {\n  //       const pattern = typeof value === 'object' ? value.$regex : value;\n  //       const options = typeof value === 'object' ? value.$options || '' : '';\n  //       let sql = `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`;\n\n  //       // Handle multiline\n  //       //   if (options.includes('m')) {\n  //       //     sql = `REPLACE(${sql}, CHAR(10), '\\n')`;\n  //       //   }\n\n  //       //       let finalPattern = pattern;\n  //       // if (options) {\n  //       //   finalPattern = `(\\\\?${options})${pattern}`;\n  //       // }\n\n  //       //   // Handle case insensitivity\n  //       //   if (options.includes('i')) {\n  //       //     sql = `LOWER(${sql}) REGEXP LOWER(?)`;\n  //       //   } else {\n  //       //     sql = `${sql} REGEXP ?`;\n  //       //   }\n\n  //       if (options.includes('m')) {\n  //         sql = `EXISTS (\n  //         SELECT 1\n  //         FROM json_each(\n  //           json_array(\n  //             ${sql},\n  //             REPLACE(${sql}, CHAR(10), CHAR(13))\n  //           )\n  //         ) as lines\n  //         WHERE lines.value REGEXP ?\n  //       )`;\n  //       } else {\n  //         sql = `${sql} REGEXP ?`;\n  //       }\n\n  //       // Handle case insensitivity\n  //       if (options.includes('i')) {\n  //         sql = sql.replace('REGEXP ?', 'REGEXP LOWER(?)');\n  //         sql = sql.replace('value REGEXP', 'LOWER(value) REGEXP');\n  //       }\n\n  //       // Handle extended - allows whitespace and comments in pattern\n  //       if (options.includes('x')) {\n  //         // Remove whitespace and comments from pattern\n  //         const cleanPattern = pattern.replace(/\\s+|#.*$/gm, '');\n  //         return {\n  //           sql,\n  //           values: [cleanPattern],\n  //         };\n  //       }\n\n  //       return {\n  //         sql,\n  //         values: [pattern],\n  //       };\n  //     },\n  //   }),\n  $contains: (key: string, value: any) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    let sql;\n    if (Array.isArray(value)) {\n      sql = `(\n        SELECT ${validateJsonArray(jsonPathKey)}\n        AND EXISTS (\n          SELECT 1\n          FROM json_each(json_extract(metadata, '$.\"${jsonPathKey}\"')) as m\n          WHERE m.value IN (SELECT value FROM json_each(?))\n        )\n      )`;\n    } else if (typeof value === 'string') {\n      sql = `lower(json_extract(metadata, '$.\"${jsonPathKey}\"')) LIKE '%' || lower(?) || '%' ESCAPE '\\\\'`;\n    } else {\n      sql = `json_extract(metadata, '$.\"${jsonPathKey}\"') = ?`;\n    }\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (Array.isArray(value)) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'object' && value !== null) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'string') {\n          return [escapeLikePattern(value)];\n        }\n        return [value];\n      },\n    };\n  },\n  /**\n   * $objectContains: True JSON containment for advanced use (deep sub-object match).\n   * Usage: { field: { $objectContains: { ...subobject } } }\n   */\n  // $objectContains: (key: string) => ({\n  //   sql: '', // Will be overridden by transformValue\n  //   needsValue: true,\n  //   transformValue: (value: any) => ({\n  //     sql: `json_type(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')) = 'object'\n  //         AND json_patch(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"'), ?) = json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`,\n  //     values: [JSON.stringify(value)],\n  //   }),\n  // }),\n};\n\ninterface FilterResult {\n  sql: string;\n  values: InValue[];\n}\n\nfunction isFilterResult(obj: any): obj is FilterResult {\n  return obj && typeof obj === 'object' && typeof obj.sql === 'string' && Array.isArray(obj.values);\n}\n\nconst parseJsonPathKey = (key: string) => {\n  const parsedKey = parseFieldKey(key);\n  // Only add quotes around path segments if they contain dots\n  if (parsedKey.includes('.')) {\n    return parsedKey\n      .split('.')\n      .map(segment => `\"${segment}\"`)\n      .join('.');\n  }\n  return parsedKey;\n};\n\n// Helper to generate the correct JSON path format for LibSQL\nconst getJsonPath = (key: string) => {\n  const jsonPathKey = parseJsonPathKey(key);\n  // Always use quotes for consistency\n  return `'$.${jsonPathKey}'`;\n};\n\nfunction escapeLikePattern(str: string): string {\n  return str.replace(/([%_\\\\])/g, '\\\\$1');\n}\n\nexport function buildFilterQuery(filter: LibSQLVectorFilter): FilterResult {\n  if (!filter) {\n    return { sql: '', values: [] };\n  }\n\n  const values: InValue[] = [];\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => {\n      const condition = buildCondition(key, value, '');\n      values.push(...condition.values);\n      return condition.sql;\n    })\n    .join(' AND ');\n\n  return {\n    sql: conditions ? `WHERE ${conditions}` : '',\n    values,\n  };\n}\n\nfunction buildCondition(key: string, value: any, parentPath: string): FilterResult {\n  // Handle logical operators ($and/$or)\n  if (['$and', '$or', '$not', '$nor'].includes(key)) {\n    return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n  }\n\n  // If condition is not a FilterCondition object, assume it's an equality check\n  if (!value || typeof value !== 'object') {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) = ?`,\n      values: [value],\n    };\n  }\n\n  //TODO: Add regex support\n  //   if ('$regex' in value) {\n  //     return handleRegexOperator(key, value);\n  //   }\n\n  // Handle operator conditions\n  return handleOperator(key, value);\n}\n\n// function handleRegexOperator(key: string, value: any): FilterResult {\n//   const operatorFn = FILTER_OPERATORS['$regex']!;\n//   const operatorResult = operatorFn(key, value);\n//   const transformed = operatorResult.transformValue ? operatorResult.transformValue(value) : value;\n\n//   return {\n//     sql: transformed.sql,\n//     values: transformed.values,\n//   };\n// }\n\nfunction handleLogicalOperator(\n  key: '$and' | '$or' | '$not' | '$nor',\n  value: LibSQLVectorFilter[] | LibSQLVectorFilter,\n  parentPath: string,\n): FilterResult {\n  // Handle empty conditions\n  if (!value || (Array.isArray(value) && value.length === 0)) {\n    switch (key) {\n      case '$and':\n      case '$nor':\n        return { sql: 'true', values: [] };\n      case '$or':\n        return { sql: 'false', values: [] };\n      case '$not':\n        throw new Error('$not operator cannot be empty');\n      default:\n        return { sql: 'true', values: [] };\n    }\n  }\n\n  if (key === '$not') {\n    // For top-level $not\n    const entries = Object.entries(value);\n    const conditions = entries.map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key));\n    return {\n      sql: `NOT (${conditions.map(c => c.sql).join(' AND ')})`,\n      values: conditions.flatMap(c => c.values),\n    };\n  }\n\n  const values: InValue[] = [];\n  const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n  const conditions = Array.isArray(value)\n    ? value.map(f => {\n        const entries = !!f ? Object.entries(f) : [];\n        return entries.map(([k, v]) => buildCondition(k, v, key));\n      })\n    : [buildCondition(key, value, parentPath)];\n\n  const joined = conditions\n    .flat()\n    .map(c => {\n      values.push(...c.values);\n      return c.sql;\n    })\n    .join(` ${joinOperator} `);\n\n  return {\n    sql: key === '$nor' ? `NOT (${joined})` : `(${joined})`,\n    values,\n  };\n}\n\nfunction handleOperator(key: string, value: any): FilterResult {\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    const entries = Object.entries(value);\n    const results = entries.map(([operator, operatorValue]) =>\n      operator === '$not'\n        ? {\n            sql: `NOT (${Object.entries(operatorValue as Record<string, any>)\n              .map(([op, val]) => processOperator(key, op as OperatorType, val).sql)\n              .join(' AND ')})`,\n            values: Object.entries(operatorValue as Record<string, any>).flatMap(\n              ([op, val]) => processOperator(key, op as OperatorType, val).values,\n            ),\n          }\n        : processOperator(key, operator as OperatorType, operatorValue),\n    );\n\n    return {\n      sql: `(${results.map(r => r.sql).join(' AND ')})`,\n      values: results.flatMap(r => r.values),\n    };\n  }\n\n  // Handle single operator\n  const [[operator, operatorValue] = []] = Object.entries(value);\n  return processOperator(key, operator as OperatorType, operatorValue);\n}\n\nconst processOperator = (key: string, operator: OperatorType, operatorValue: any): FilterResult => {\n  if (!operator.startsWith('$') || !FILTER_OPERATORS[operator]) {\n    throw new Error(`Invalid operator: ${operator}`);\n  }\n  const operatorFn = FILTER_OPERATORS[operator]!;\n  const operatorResult = operatorFn(key, operatorValue);\n\n  if (!operatorResult.needsValue) {\n    return { sql: operatorResult.sql, values: [] };\n  }\n\n  const transformed = operatorResult.transformValue ? operatorResult.transformValue() : operatorValue;\n\n  if (isFilterResult(transformed)) {\n    return transformed;\n  }\n\n  return {\n    sql: operatorResult.sql,\n    values: Array.isArray(transformed) ? transformed : [transformed],\n  };\n};\n","import { createClient } from '@libsql/client';\nimport type { Client as TursoClient, InValue } from '@libsql/client';\n\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { createVectorErrorId } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { MastraVector } from '@mastra/core/vector';\nimport type {\n  IndexStats,\n  QueryResult,\n  QueryVectorParams,\n  CreateIndexParams,\n  UpsertVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n  DeleteVectorParams,\n  UpdateVectorParams,\n  DeleteVectorsParams,\n} from '@mastra/core/vector';\nimport type { LibSQLVectorFilter } from './filter';\nimport { LibSQLFilterTranslator } from './filter';\nimport { buildFilterQuery } from './sql-builder';\n\ninterface LibSQLQueryVectorParams extends QueryVectorParams<LibSQLVectorFilter> {\n  minScore?: number;\n}\n\nexport interface LibSQLVectorConfig {\n  /**\n   * The URL of the LibSQL database.\n   * Examples: 'file:./dev.db', 'file::memory:', 'libsql://your-db.turso.io'\n   */\n  url: string;\n  authToken?: string;\n  syncUrl?: string;\n  syncInterval?: number;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n}\n\nexport class LibSQLVector extends MastraVector<LibSQLVectorFilter> {\n  private turso: TursoClient;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  constructor({\n    url,\n    authToken,\n    syncUrl,\n    syncInterval,\n    maxRetries = 5,\n    initialBackoffMs = 100,\n    id,\n  }: LibSQLVectorConfig & { id: string }) {\n    super({ id });\n\n    this.turso = createClient({\n      url,\n      syncUrl,\n      authToken,\n      syncInterval,\n    });\n    this.maxRetries = maxRetries;\n    this.initialBackoffMs = initialBackoffMs;\n\n    if (url.includes(`file:`) || url.includes(`:memory:`)) {\n      this.turso\n        .execute('PRAGMA journal_mode=WAL;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n      this.turso\n        .execute('PRAGMA busy_timeout = 5000;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout=5000.', err));\n    }\n  }\n\n  private async executeWriteOperationWithRetry<T>(operation: () => Promise<T>, isTransaction = false): Promise<T> {\n    let attempts = 0;\n    let backoff = this.initialBackoffMs;\n    while (attempts < this.maxRetries) {\n      try {\n        return await operation();\n      } catch (error: any) {\n        if (\n          error.code === 'SQLITE_BUSY' ||\n          (error.message && error.message.toLowerCase().includes('database is locked'))\n        ) {\n          attempts++;\n          if (attempts >= this.maxRetries) {\n            this.logger.error(\n              `LibSQLVector: Operation failed after ${this.maxRetries} attempts due to: ${error.message}`,\n              error,\n            );\n            throw error;\n          }\n          this.logger.warn(\n            `LibSQLVector: Attempt ${attempts} failed due to ${isTransaction ? 'transaction ' : ''}database lock. Retrying in ${backoff}ms...`,\n          );\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          backoff *= 2;\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('LibSQLVector: Max retries reached, but no error was re-thrown from the loop.');\n  }\n\n  transformFilter(filter?: LibSQLVectorFilter) {\n    const translator = new LibSQLFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query({\n    indexName,\n    queryVector,\n    topK = 10,\n    filter,\n    includeVector = false,\n    minScore = -1, // Default to -1 to include all results (cosine similarity ranges from -1 to 1)\n  }: LibSQLQueryVectorParams): Promise<QueryResult[]> {\n    try {\n      if (!Number.isInteger(topK) || topK <= 0) {\n        throw new Error('topK must be a positive integer');\n      }\n      if (!Array.isArray(queryVector) || !queryVector.every(x => typeof x === 'number' && Number.isFinite(x))) {\n        throw new Error('queryVector must be an array of finite numbers');\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'QUERY', 'INVALID_ARGS'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n      const vectorStr = `[${queryVector.join(',')}]`;\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);\n      filterValues.push(minScore);\n      filterValues.push(topK);\n\n      const query = `\n      WITH vector_scores AS (\n        SELECT\n          vector_id as id,\n          (1-vector_distance_cos(embedding, '${vectorStr}')) as score,\n          metadata\n          ${includeVector ? ', vector_extract(embedding) as embedding' : ''}\n        FROM ${parsedIndexName}\n        ${filterQuery}\n      )\n      SELECT *\n      FROM vector_scores\n      WHERE score > ?\n      ORDER BY score DESC\n      LIMIT ?`;\n\n      const result = await this.turso.execute({\n        sql: query,\n        args: filterValues,\n      });\n\n      return result.rows.map(({ id, score, metadata, embedding }) => ({\n        id: id as string,\n        score: score as number,\n        metadata: JSON.parse((metadata as string) ?? '{}'),\n        ...(includeVector && embedding && { vector: JSON.parse(embedding as string) }),\n      }));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'QUERY', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  public upsert(args: UpsertVectorParams): Promise<string[]> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doUpsert(args), true);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'UPSERT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  private async doUpsert({ indexName, vectors, metadata, ids }: UpsertVectorParams): Promise<string[]> {\n    const tx = await this.turso.transaction('write');\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n      for (let i = 0; i < vectors.length; i++) {\n        const query = `\n            INSERT INTO ${parsedIndexName} (vector_id, embedding, metadata)\n            VALUES (?, vector32(?), ?)\n            ON CONFLICT(vector_id) DO UPDATE SET\n              embedding = vector32(?),\n              metadata = ?\n          `;\n        await tx.execute({\n          sql: query,\n          args: [\n            vectorIds[i] as InValue,\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n          ],\n        });\n      }\n      await tx.commit();\n      return vectorIds;\n    } catch (error) {\n      !tx.closed && (await tx.rollback());\n      if (error instanceof Error && error.message?.includes('dimensions are different')) {\n        const match = error.message.match(/dimensions are different: (\\d+) != (\\d+)/);\n        if (match) {\n          const [, actual, expected] = match;\n          throw new Error(\n            `Vector dimension mismatch: Index \"${indexName}\" expects ${expected} dimensions but got ${actual} dimensions. ` +\n              `Either use a matching embedding model or delete and recreate the index with the new dimension.`,\n          );\n        }\n      }\n      throw error;\n    }\n  }\n\n  public createIndex(args: CreateIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doCreateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'CREATE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName, dimension: args.dimension },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doCreateIndex({ indexName, dimension }: CreateIndexParams): Promise<void> {\n    if (!Number.isInteger(dimension) || dimension <= 0) {\n      throw new Error('Dimension must be a positive integer');\n    }\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `\n          CREATE TABLE IF NOT EXISTS ${parsedIndexName} (\n            id SERIAL PRIMARY KEY,\n            vector_id TEXT UNIQUE NOT NULL,\n            embedding F32_BLOB(${dimension}),\n            metadata TEXT DEFAULT '{}'\n          );\n        `,\n      args: [],\n    });\n    await this.turso.execute({\n      sql: `\n          CREATE INDEX IF NOT EXISTS ${parsedIndexName}_vector_idx\n          ON ${parsedIndexName} (libsql_vector_idx(embedding))\n        `,\n      args: [],\n    });\n  }\n\n  public deleteIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DROP TABLE IF EXISTS ${parsedIndexName}`,\n      args: [],\n    });\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const vectorTablesQuery = `\n        SELECT name FROM sqlite_master \n        WHERE type='table' \n        AND sql LIKE '%F32_BLOB%';\n      `;\n      const result = await this.turso.execute({\n        sql: vectorTablesQuery,\n        args: [],\n      });\n      return result.rows.map(row => row.name as string);\n    } catch (error: any) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'LIST_INDEXES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Retrieves statistics about a vector index.\n   *\n   * @param {string} indexName - The name of the index to describe\n   * @returns A promise that resolves to the index statistics including dimension, count and metric\n   */\n  async describeIndex({ indexName }: DescribeIndexParams): Promise<IndexStats> {\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      // Get table info including column info\n      const tableInfoQuery = `\n        SELECT sql \n        FROM sqlite_master \n        WHERE type='table' \n        AND name = ?;\n      `;\n      const tableInfo = await this.turso.execute({\n        sql: tableInfoQuery,\n        args: [parsedIndexName],\n      });\n\n      if (!tableInfo.rows[0]?.sql) {\n        throw new Error(`Table ${parsedIndexName} not found`);\n      }\n\n      // Extract dimension from F32_BLOB definition\n      const dimension = parseInt((tableInfo.rows[0].sql as string).match(/F32_BLOB\\((\\d+)\\)/)?.[1] || '0');\n\n      // Get row count\n      const countQuery = `\n        SELECT COUNT(*) as count\n        FROM ${parsedIndexName};\n      `;\n      const countResult = await this.turso.execute({\n        sql: countQuery,\n        args: [],\n      });\n\n      // LibSQL only supports cosine similarity currently\n      const metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine';\n\n      return {\n        dimension,\n        count: (countResult?.rows?.[0]?.count as number) ?? 0,\n        metric,\n      };\n    } catch (e: any) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DESCRIBE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName },\n        },\n        e,\n      );\n    }\n  }\n\n  /**\n   * Updates a vector by its ID with the provided vector and/or metadata.\n   *\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  public updateVector(args: UpdateVectorParams<LibSQLVectorFilter>): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doUpdateVector(args));\n  }\n\n  private async doUpdateVector(params: UpdateVectorParams<LibSQLVectorFilter>): Promise<void> {\n    const { indexName, update } = params;\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n    // Validate that both id and filter are not provided at the same time\n    if ('id' in params && params.id && 'filter' in params && params.filter) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'MUTUALLY_EXCLUSIVE'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'id and filter are mutually exclusive - provide only one',\n      });\n    }\n\n    if (!update.vector && !update.metadata) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'NO_PAYLOAD'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'No updates provided',\n      });\n    }\n\n    const updates: string[] = [];\n    const args: InValue[] = [];\n\n    if (update.vector) {\n      updates.push('embedding = vector32(?)');\n      args.push(JSON.stringify(update.vector));\n    }\n\n    if (update.metadata) {\n      updates.push('metadata = ?');\n      args.push(JSON.stringify(update.metadata));\n    }\n\n    if (updates.length === 0) {\n      return;\n    }\n\n    let whereClause: string;\n    let whereValues: InValue[];\n\n    // Type narrowing: check if updating by id or by filter\n    if ('id' in params && params.id) {\n      // Update by ID\n      whereClause = 'vector_id = ?';\n      whereValues = [params.id];\n    } else if ('filter' in params && params.filter) {\n      // Update by filter\n      const filter = params.filter;\n\n      if (!filter || Object.keys(filter).length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'EMPTY_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot update with empty filter',\n        });\n      }\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);\n\n      if (!filterSql || filterSql.trim() === '') {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'INVALID_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Filter produced empty WHERE clause',\n        });\n      }\n\n      // Guard against match-all patterns that would update all vectors\n      // Normalize SQL by removing WHERE prefix and extra whitespace for pattern matching\n      const normalizedCondition = filterSql\n        .replace(/^\\s*WHERE\\s+/i, '')\n        .trim()\n        .toLowerCase();\n      const matchAllPatterns = ['true', '1 = 1', '1=1'];\n\n      if (matchAllPatterns.includes(normalizedCondition)) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'MATCH_ALL_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName, filterSql: normalizedCondition },\n          text: 'Filter matches all vectors. Provide a specific filter to update targeted vectors.',\n        });\n      }\n\n      // buildFilterQuery already includes \"WHERE\" in the SQL, so we need to extract just the condition\n      whereClause = filterSql.replace(/^WHERE\\s+/i, '');\n      whereValues = filterValues;\n    } else {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'NO_TARGET'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Either id or filter must be provided',\n      });\n    }\n\n    const query = `\n      UPDATE ${parsedIndexName}\n      SET ${updates.join(', ')}\n      WHERE ${whereClause};\n    `;\n\n    try {\n      await this.turso.execute({\n        sql: query,\n        args: [...args, ...whereValues],\n      });\n    } catch (error) {\n      const errorDetails: Record<string, any> = { indexName };\n\n      if ('id' in params && params.id) {\n        errorDetails.id = params.id;\n      }\n\n      if ('filter' in params && params.filter) {\n        errorDetails.filter = JSON.stringify(params.filter);\n      }\n\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'UPDATE_VECTOR', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: errorDetails,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes a vector by its ID.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   * @throws Will throw an error if the deletion operation fails.\n   */\n  public deleteVector(args: DeleteVectorParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteVector(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTOR', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName: args.indexName,\n            ...(args.id && { id: args.id }),\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteVector({ indexName, id }: DeleteVectorParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DELETE FROM ${parsedIndexName} WHERE vector_id = ?`,\n      args: [id],\n    });\n  }\n\n  public deleteVectors(args: DeleteVectorsParams<LibSQLVectorFilter>): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doDeleteVectors(args));\n  }\n\n  private async doDeleteVectors({ indexName, filter, ids }: DeleteVectorsParams<LibSQLVectorFilter>): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n    // Validate that exactly one of filter or ids is provided\n    if (!filter && !ids) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'NO_TARGET'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Either filter or ids must be provided',\n      });\n    }\n\n    if (filter && ids) {\n      throw new MastraError({\n        id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'MUTUALLY_EXCLUSIVE'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName },\n        text: 'Cannot provide both filter and ids - they are mutually exclusive',\n      });\n    }\n\n    let query: string;\n    let values: InValue[];\n\n    if (ids) {\n      // Delete by IDs\n      if (ids.length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'EMPTY_IDS'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot delete with empty ids array',\n        });\n      }\n\n      const placeholders = ids.map(() => '?').join(', ');\n      query = `DELETE FROM ${parsedIndexName} WHERE vector_id IN (${placeholders})`;\n      values = ids;\n    } else {\n      // Delete by filter\n      // Safety check: Don't allow empty filters to prevent accidental deletion of all vectors\n      if (!filter || Object.keys(filter).length === 0) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'EMPTY_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Cannot delete with empty filter. Use deleteIndex to delete all vectors.',\n        });\n      }\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterSql, values: filterValues } = buildFilterQuery(translatedFilter);\n\n      if (!filterSql || filterSql.trim() === '') {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'INVALID_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName },\n          text: 'Filter produced empty WHERE clause',\n        });\n      }\n\n      // Guard against match-all patterns that would delete all vectors\n      // Normalize SQL by removing WHERE prefix and extra whitespace for pattern matching\n      const normalizedCondition = filterSql\n        .replace(/^\\s*WHERE\\s+/i, '')\n        .trim()\n        .toLowerCase();\n      const matchAllPatterns = ['true', '1 = 1', '1=1'];\n\n      if (matchAllPatterns.includes(normalizedCondition)) {\n        throw new MastraError({\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'MATCH_ALL_FILTER'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName, filterSql: normalizedCondition },\n          text: 'Filter matches all vectors. Use deleteIndex to delete all vectors from an index.',\n        });\n      }\n\n      // buildFilterQuery already includes \"WHERE\" in the SQL\n      query = `DELETE FROM ${parsedIndexName} ${filterSql}`;\n      values = filterValues;\n    }\n\n    try {\n      await this.turso.execute({\n        sql: query,\n        args: values,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'DELETE_VECTORS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n            ...(filter && { filter: JSON.stringify(filter) }),\n            ...(ids && { idsCount: ids.length }),\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  public truncateIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this._doTruncateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createVectorErrorId('LIBSQL', 'TRUNCATE_INDEX', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async _doTruncateIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    await this.turso.execute({\n      sql: `DELETE FROM ${parseSqlIdentifier(indexName, 'index name')}`,\n      args: [],\n    });\n  }\n}\n","import type { InValue } from '@libsql/client';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport { safelyParseJSON, TABLE_SCHEMAS } from '@mastra/core/storage';\nimport type { StorageColumn, TABLE_NAMES } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\n\n/**\n * Builds a SQL column list for SELECT statements, wrapping JSONB columns with json()\n * to convert binary JSONB to TEXT.\n *\n * The json() function handles both:\n * - Binary JSONB data (converts to TEXT)\n * - Legacy TEXT JSON data (returns as-is)\n *\n * Note: json_valid() was considered for guarding against malformed legacy TEXT,\n * but it doesn't work correctly with binary JSONB data (returns false for valid JSONB blobs).\n *\n * @param tableName - The table name to get the schema for\n * @returns A comma-separated column list with json() wrappers for JSONB columns\n */\nexport function buildSelectColumns(tableName: TABLE_NAMES): string {\n  const schema = TABLE_SCHEMAS[tableName];\n  return Object.keys(schema)\n    .map(col => {\n      const colDef = schema[col];\n      const parsedCol = parseSqlIdentifier(col, 'column name');\n      return colDef?.type === 'jsonb' ? `json(${parsedCol}) as ${parsedCol}` : parsedCol;\n    })\n    .join(', ');\n}\n\n/**\n * Checks if an error is a SQLite lock/busy error that should be retried\n */\nexport function isLockError(error: any): boolean {\n  return (\n    error.code === 'SQLITE_BUSY' ||\n    error.code === 'SQLITE_LOCKED' ||\n    error.message?.toLowerCase().includes('database is locked') ||\n    error.message?.toLowerCase().includes('database table is locked') ||\n    error.message?.toLowerCase().includes('table is locked') ||\n    (error.constructor.name === 'SqliteError' && error.message?.toLowerCase().includes('locked'))\n  );\n}\n\nexport function createExecuteWriteOperationWithRetry({\n  logger,\n  maxRetries,\n  initialBackoffMs,\n}: {\n  logger: IMastraLogger;\n  maxRetries: number;\n  initialBackoffMs: number;\n}) {\n  return async function executeWriteOperationWithRetry<T>(\n    operationFn: () => Promise<T>,\n    operationDescription: string,\n  ): Promise<T> {\n    let attempts = 0;\n    let backoff = initialBackoffMs;\n\n    while (attempts < maxRetries) {\n      try {\n        return await operationFn();\n      } catch (error: any) {\n        logger.debug(`LibSQLStore: Error caught in retry loop for ${operationDescription}`, {\n          errorType: error.constructor.name,\n          errorCode: error.code,\n          errorMessage: error.message,\n          attempts,\n          maxRetries,\n        });\n\n        if (isLockError(error)) {\n          attempts++;\n          if (attempts >= maxRetries) {\n            logger.error(\n              `LibSQLStore: Operation failed after ${maxRetries} attempts due to database lock: ${error.message}`,\n              { error, attempts, maxRetries },\n            );\n            throw error;\n          }\n          logger.warn(\n            `LibSQLStore: Attempt ${attempts} failed due to database lock during ${operationDescription}. Retrying in ${backoff}ms...`,\n            { errorMessage: error.message, attempts, backoff, maxRetries },\n          );\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          backoff *= 2;\n        } else {\n          logger.error(`LibSQLStore: Non-lock error during ${operationDescription}, not retrying`, { error });\n          throw error;\n        }\n      }\n    }\n    // TypeScript requires a return/throw here for type safety, but this is unreachable\n    // because the loop always exits via return (success) or throw (error)\n    throw new Error(`LibSQLStore: Unexpected exit from retry loop for ${operationDescription}`);\n  };\n}\n\nexport function prepareStatement({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const schema = TABLE_SCHEMAS[tableName];\n  const columnNames = Object.keys(record);\n  const columns = columnNames.map(col => parseSqlIdentifier(col, 'column name'));\n  const values = columnNames.map(col => {\n    const v = record[col];\n    if (typeof v === `undefined` || v === null) {\n      // returning an undefined value will cause libsql to throw\n      return null;\n    }\n    // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n    // Must check jsonb BEFORE Date, because JSON.stringify properly serializes Dates\n    const colDef = schema[col];\n    if (colDef?.type === 'jsonb') {\n      return JSON.stringify(v);\n    }\n    if (v instanceof Date) {\n      return v.toISOString();\n    }\n    return typeof v === 'object' ? JSON.stringify(v) : v;\n  });\n  const placeholders = columnNames\n    .map(col => {\n      const colDef = schema[col];\n      return colDef?.type === 'jsonb' ? 'jsonb(?)' : '?';\n    })\n    .join(', ');\n\n  return {\n    sql: `INSERT OR REPLACE INTO ${parsedTableName} (${columns.join(', ')}) VALUES (${placeholders})`,\n    args: values,\n  };\n}\n\nexport function prepareUpdateStatement({\n  tableName,\n  updates,\n  keys,\n}: {\n  tableName: TABLE_NAMES;\n  updates: Record<string, any>;\n  keys: Record<string, any>;\n}): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const schema = TABLE_SCHEMAS[tableName];\n\n  // Prepare SET clause\n  const updateColumnNames = Object.keys(updates);\n  const updateColumns = updateColumnNames.map(col => parseSqlIdentifier(col, 'column name'));\n  const updateValues = updateColumnNames.map(col => {\n    const colDef = schema[col];\n    const v = updates[col];\n    // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n    if (colDef?.type === 'jsonb') {\n      return transformToSqlValue(v, true);\n    }\n    return transformToSqlValue(v, false);\n  });\n  const setClause = updateColumns\n    .map((col, i) => {\n      const colDef = schema[updateColumnNames[i]!];\n      return colDef?.type === 'jsonb' ? `${col} = jsonb(?)` : `${col} = ?`;\n    })\n    .join(', ');\n\n  const whereClause = prepareWhereClause(keys, schema);\n\n  return {\n    sql: `UPDATE ${parsedTableName} SET ${setClause}${whereClause.sql}`,\n    args: [...updateValues, ...whereClause.args],\n  };\n}\n\nexport function transformToSqlValue(value: any, forceJsonStringify: boolean = false): InValue {\n  if (typeof value === 'undefined' || value === null) {\n    return null;\n  }\n  // For jsonb columns, always JSON.stringify (even primitives need to be valid JSON)\n  // Must check jsonb BEFORE Date, because JSON.stringify properly serializes Dates\n  if (forceJsonStringify) {\n    return JSON.stringify(value);\n  }\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  return typeof value === 'object' ? JSON.stringify(value) : value;\n}\n\nexport function prepareDeleteStatement({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const whereClause = prepareWhereClause(keys, TABLE_SCHEMAS[tableName]);\n\n  return {\n    sql: `DELETE FROM ${parsedTableName}${whereClause.sql}`,\n    args: whereClause.args,\n  };\n}\n\ntype WhereValue = InValue | { startAt?: InValue; endAt?: InValue };\n\nexport function prepareWhereClause(\n  filters: Record<string, WhereValue>,\n  schema: Record<string, StorageColumn>,\n): {\n  sql: string;\n  args: InValue[];\n} {\n  const conditions: string[] = [];\n  const args: InValue[] = [];\n\n  for (const [columnName, filterValue] of Object.entries(filters)) {\n    const column = schema[columnName];\n    if (!column) {\n      throw new Error(`Unknown column: ${columnName}`);\n    }\n\n    const parsedColumn = parseSqlIdentifier(columnName, 'column name');\n    const result = buildCondition(parsedColumn, filterValue);\n\n    conditions.push(result.condition);\n    args.push(...result.args);\n  }\n\n  return {\n    sql: conditions.length > 0 ? ` WHERE ${conditions.join(' AND ')}` : '',\n    args,\n  };\n}\n\nfunction buildCondition(columnName: string, filterValue: WhereValue): { condition: string; args: InValue[] } {\n  // Handle null values - IS NULL\n  if (filterValue === null) {\n    return { condition: `${columnName} IS NULL`, args: [] };\n  }\n\n  // Handle date range objects\n  if (typeof filterValue === 'object' && filterValue !== null && ('startAt' in filterValue || 'endAt' in filterValue)) {\n    return buildDateRangeCondition(columnName, filterValue);\n  }\n\n  // Handle exact match\n  return {\n    condition: `${columnName} = ?`,\n    args: [transformToSqlValue(filterValue)],\n  };\n}\n\nfunction buildDateRangeCondition(\n  columnName: string,\n  range: { startAt?: InValue; endAt?: InValue },\n): { condition: string; args: InValue[] } {\n  const conditions: string[] = [];\n  const args: InValue[] = [];\n\n  if (range.startAt !== undefined) {\n    conditions.push(`${columnName} >= ?`);\n    args.push(transformToSqlValue(range.startAt));\n  }\n\n  if (range.endAt !== undefined) {\n    conditions.push(`${columnName} <= ?`);\n    args.push(transformToSqlValue(range.endAt));\n  }\n\n  if (conditions.length === 0) {\n    throw new Error('Date range must specify at least startAt or endAt');\n  }\n\n  return {\n    condition: conditions.join(' AND '),\n    args,\n  };\n}\n\n/**\n * Transforms SQL row data back to a typed object format\n * Reverses the transformations done in prepareStatement\n */\nexport function transformFromSqlRow<T>({\n  tableName,\n  sqlRow,\n}: {\n  tableName: TABLE_NAMES;\n  sqlRow: Record<string, any>;\n}): T {\n  const result: Record<string, any> = {};\n  const jsonColumns = new Set(\n    Object.keys(TABLE_SCHEMAS[tableName])\n      .filter(key => TABLE_SCHEMAS[tableName][key]!.type === 'jsonb')\n      .map(key => key),\n  );\n  const dateColumns = new Set(\n    Object.keys(TABLE_SCHEMAS[tableName])\n      .filter(key => TABLE_SCHEMAS[tableName][key]!.type === 'timestamp')\n      .map(key => key),\n  );\n\n  for (const [key, value] of Object.entries(sqlRow)) {\n    if (value === null || value === undefined) {\n      result[key] = value;\n      continue;\n    }\n\n    if (dateColumns.has(key) && typeof value === 'string') {\n      result[key] = new Date(value);\n      continue;\n    }\n\n    if (jsonColumns.has(key) && typeof value === 'string') {\n      result[key] = safelyParseJSON(value);\n      continue;\n    }\n\n    result[key] = value;\n  }\n\n  return result as T;\n}\n","import { createClient } from '@libsql/client';\nimport type { Client, InValue } from '@libsql/client';\nimport { MastraBase } from '@mastra/core/base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  createStorageErrorId,\n  getSqlType,\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_SPANS,\n  TABLE_SCHEMAS,\n} from '@mastra/core/storage';\nimport type { TABLE_NAMES, StorageColumn } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport {\n  buildSelectColumns,\n  createExecuteWriteOperationWithRetry,\n  prepareDeleteStatement,\n  prepareStatement,\n  prepareUpdateStatement,\n} from './utils';\n\n/**\n * Base configuration options shared across LibSQL domain configurations\n */\nexport type LibSQLDomainBaseConfig = {\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n};\n\n/**\n * Configuration for LibSQL domains - accepts either credentials or an existing client\n */\nexport type LibSQLDomainConfig =\n  | (LibSQLDomainBaseConfig & {\n      /** The database connection URL (e.g., \"file:local.db\", \"libsql://...\", \"file::memory:\") */\n      url: string;\n      /** Optional authentication token for remote databases */\n      authToken?: string;\n    })\n  | (LibSQLDomainBaseConfig & {\n      /** An existing LibSQL client instance */\n      client: Client;\n    });\n\n/**\n * Resolves a LibSQLDomainConfig to a Client instance.\n * Creates a new client if credentials are provided, or returns the existing client.\n *\n * @param config - The domain configuration\n * @returns The resolved LibSQL client\n */\nexport function resolveClient(config: LibSQLDomainConfig): Client {\n  if ('client' in config) {\n    return config.client;\n  }\n  return createClient({\n    url: config.url,\n    ...(config.authToken ? { authToken: config.authToken } : {}),\n  });\n}\n\nexport class LibSQLDB extends MastraBase {\n  private client: Client;\n  maxRetries: number;\n  initialBackoffMs: number;\n  executeWriteOperationWithRetry: <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;\n\n  constructor({\n    client,\n    maxRetries,\n    initialBackoffMs,\n  }: {\n    client: Client;\n    maxRetries?: number;\n    initialBackoffMs?: number;\n  }) {\n    super({\n      component: 'STORAGE',\n      name: 'LIBSQL_DB_LAYER',\n    });\n\n    this.client = client;\n    this.maxRetries = maxRetries ?? 5;\n    this.initialBackoffMs = initialBackoffMs ?? 100;\n\n    this.executeWriteOperationWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    });\n  }\n\n  /**\n   * Checks if a column exists in the specified table.\n   *\n   * @param table - The name of the table to check\n   * @param column - The name of the column to look for\n   * @returns `true` if the column exists in the table, `false` otherwise\n   */\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    const sanitizedTable = parseSqlIdentifier(table, 'table name');\n    const result = await this.client.execute({\n      sql: `PRAGMA table_info(\"${sanitizedTable}\")`,\n    });\n    return result.rows?.some((row: any) => row.name === column);\n  }\n\n  /**\n   * Internal insert implementation without retry logic.\n   */\n  private async doInsert({\n    tableName,\n    record,\n  }: {\n    tableName: TABLE_NAMES;\n    record: Record<string, any>;\n  }): Promise<void> {\n    await this.client.execute(\n      prepareStatement({\n        tableName,\n        record,\n      }),\n    );\n  }\n\n  /**\n   * Inserts or replaces a record in the specified table with automatic retry on lock errors.\n   *\n   * @param args - The insert arguments\n   * @param args.tableName - The name of the table to insert into\n   * @param args.record - The record to insert (key-value pairs)\n   */\n  public insert(args: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doInsert(args), `insert into table ${args.tableName}`);\n  }\n\n  /**\n   * Internal update implementation without retry logic.\n   */\n  private async doUpdate({\n    tableName,\n    keys,\n    data,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Record<string, any>;\n    data: Record<string, any>;\n  }): Promise<void> {\n    await this.client.execute(prepareUpdateStatement({ tableName, updates: data, keys }));\n  }\n\n  /**\n   * Updates a record in the specified table with automatic retry on lock errors.\n   *\n   * @param args - The update arguments\n   * @param args.tableName - The name of the table to update\n   * @param args.keys - The key(s) identifying the record to update\n   * @param args.data - The fields to update (key-value pairs)\n   */\n  public update(args: { tableName: TABLE_NAMES; keys: Record<string, any>; data: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doUpdate(args), `update table ${args.tableName}`);\n  }\n\n  /**\n   * Internal batch insert implementation without retry logic.\n   */\n  private async doBatchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void> {\n    if (records.length === 0) return;\n    const batchStatements = records.map(r => prepareStatement({ tableName, record: r }));\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Inserts multiple records in a single batch transaction with automatic retry on lock errors.\n   *\n   * @param args - The batch insert arguments\n   * @param args.tableName - The name of the table to insert into\n   * @param args.records - Array of records to insert\n   * @throws {MastraError} When the batch insert fails after retries\n   */\n  public async batchInsert(args: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchInsert(args),\n      `batch insert into table ${args.tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_INSERT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName: args.tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal batch update implementation without retry logic.\n   * Each record can be updated based on single or composite keys.\n   */\n  private async doBatchUpdate({\n    tableName,\n    updates,\n  }: {\n    tableName: TABLE_NAMES;\n    updates: Array<{\n      keys: Record<string, any>;\n      data: Record<string, any>;\n    }>;\n  }): Promise<void> {\n    if (updates.length === 0) return;\n\n    const batchStatements = updates.map(({ keys, data }) =>\n      prepareUpdateStatement({\n        tableName,\n        updates: data,\n        keys,\n      }),\n    );\n\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Updates multiple records in a single batch transaction with automatic retry on lock errors.\n   * Each record can be updated based on single or composite keys.\n   *\n   * @param args - The batch update arguments\n   * @param args.tableName - The name of the table to update\n   * @param args.updates - Array of update operations, each containing keys and data\n   * @throws {MastraError} When the batch update fails after retries\n   */\n  public async batchUpdate(args: {\n    tableName: TABLE_NAMES;\n    updates: Array<{\n      keys: Record<string, any>;\n      data: Record<string, any>;\n    }>;\n  }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchUpdate(args),\n      `batch update in table ${args.tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_UPDATE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName: args.tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal batch delete implementation without retry logic.\n   * Each record can be deleted based on single or composite keys.\n   */\n  private async doBatchDelete({\n    tableName,\n    keys,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Array<Record<string, any>>;\n  }): Promise<void> {\n    if (keys.length === 0) return;\n\n    const batchStatements = keys.map(keyObj =>\n      prepareDeleteStatement({\n        tableName,\n        keys: keyObj,\n      }),\n    );\n\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  /**\n   * Deletes multiple records in a single batch transaction with automatic retry on lock errors.\n   * Each record can be deleted based on single or composite keys.\n   *\n   * @param args - The batch delete arguments\n   * @param args.tableName - The name of the table to delete from\n   * @param args.keys - Array of key objects identifying records to delete\n   * @throws {MastraError} When the batch delete fails after retries\n   */\n  public async batchDelete({\n    tableName,\n    keys,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Array<Record<string, any>>;\n  }): Promise<void> {\n    return this.executeWriteOperationWithRetry(\n      () => this.doBatchDelete({ tableName, keys }),\n      `batch delete from table ${tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_DELETE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Internal single-record delete implementation without retry logic.\n   */\n  private async doDelete({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<void> {\n    await this.client.execute(prepareDeleteStatement({ tableName, keys }));\n  }\n\n  /**\n   * Deletes a single record from the specified table with automatic retry on lock errors.\n   *\n   * @param args - The delete arguments\n   * @param args.tableName - The name of the table to delete from\n   * @param args.keys - The key(s) identifying the record to delete\n   * @throws {MastraError} When the delete fails after retries\n   */\n  public async delete(args: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doDelete(args), `delete from table ${args.tableName}`).catch(\n      error => {\n        throw new MastraError(\n          {\n            id: createStorageErrorId('LIBSQL', 'DELETE', 'FAILED'),\n            domain: ErrorDomain.STORAGE,\n            category: ErrorCategory.THIRD_PARTY,\n            details: {\n              tableName: args.tableName,\n            },\n          },\n          error,\n        );\n      },\n    );\n  }\n\n  /**\n   * Selects a single record from the specified table by key(s).\n   * Returns the most recently created record if multiple matches exist.\n   * Automatically parses JSON string values back to objects/arrays.\n   *\n   * @typeParam R - The expected return type of the record\n   * @param args - The select arguments\n   * @param args.tableName - The name of the table to select from\n   * @param args.keys - The key(s) identifying the record to select\n   * @returns The matching record or `null` if not found\n   */\n  async select<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    const columns = buildSelectColumns(tableName);\n\n    const parsedKeys = Object.keys(keys).map(key => parseSqlIdentifier(key, 'column name'));\n\n    const conditions = parsedKeys.map(key => `${key} = ?`).join(' AND ');\n    const values = Object.values(keys);\n\n    const result = await this.client.execute({\n      sql: `SELECT ${columns} FROM ${parsedTableName} WHERE ${conditions} ORDER BY createdAt DESC LIMIT 1`,\n      args: values,\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    // Checks whether the string looks like a JSON object ({}) or array ([])\n    // If the string starts with { or [, it assumes it's JSON and parses it\n    // Otherwise, it just returns, preventing unintended number conversions\n    const parsed = Object.fromEntries(\n      Object.entries(row || {}).map(([k, v]) => {\n        try {\n          return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n        } catch {\n          return [k, v];\n        }\n      }),\n    );\n\n    return parsed as R;\n  }\n\n  /**\n   * Selects multiple records from the specified table with optional filtering, ordering, and pagination.\n   *\n   * @typeParam R - The expected return type of each record\n   * @param args - The select arguments\n   * @param args.tableName - The name of the table to select from\n   * @param args.whereClause - Optional WHERE clause with SQL string and arguments\n   * @param args.orderBy - Optional ORDER BY clause (e.g., \"createdAt DESC\")\n   * @param args.offset - Optional offset for pagination\n   * @param args.limit - Optional limit for pagination\n   * @param args.args - Optional additional query arguments\n   * @returns Array of matching records\n   */\n  async selectMany<R>({\n    tableName,\n    whereClause,\n    orderBy,\n    offset,\n    limit,\n    args,\n  }: {\n    tableName: TABLE_NAMES;\n    whereClause?: { sql: string; args: InValue[] };\n    orderBy?: string;\n    offset?: number;\n    limit?: number;\n    args?: any[];\n  }): Promise<R[]> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    const columns = buildSelectColumns(tableName);\n\n    let statement = `SELECT ${columns} FROM ${parsedTableName}`;\n\n    if (whereClause?.sql) {\n      statement += ` ${whereClause.sql}`;\n    }\n\n    if (orderBy) {\n      statement += ` ORDER BY ${orderBy}`;\n    }\n\n    if (limit) {\n      statement += ` LIMIT ${limit}`;\n    }\n\n    if (offset) {\n      statement += ` OFFSET ${offset}`;\n    }\n\n    const result = await this.client.execute({\n      sql: statement,\n      args: [...(whereClause?.args ?? []), ...(args ?? [])],\n    });\n\n    // Parse JSON columns (same as select())\n    return (result.rows ?? []).map(row => {\n      return Object.fromEntries(\n        Object.entries(row || {}).map(([k, v]) => {\n          try {\n            return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n          } catch {\n            return [k, v];\n          }\n        }),\n      );\n    }) as R[];\n  }\n\n  /**\n   * Returns the total count of records matching the optional WHERE clause.\n   *\n   * @param args - The count arguments\n   * @param args.tableName - The name of the table to count from\n   * @param args.whereClause - Optional WHERE clause with SQL string and arguments\n   * @returns The total count of matching records\n   */\n  async selectTotalCount({\n    tableName,\n    whereClause,\n  }: {\n    tableName: TABLE_NAMES;\n    whereClause?: { sql: string; args: InValue[] };\n  }): Promise<number> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    const statement = `SELECT COUNT(*) as count FROM ${parsedTableName} ${whereClause ? `${whereClause.sql}` : ''}`;\n\n    const result = await this.client.execute({\n      sql: statement,\n      args: whereClause?.args ?? [],\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return 0;\n    }\n\n    return (result.rows[0]?.count as number) ?? 0;\n  }\n\n  /**\n   * Maps a storage column type to its SQLite equivalent.\n   */\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'bigint':\n        return 'INTEGER'; // SQLite uses INTEGER for all integer sizes\n      case 'timestamp':\n        return 'TEXT'; // Store timestamps as ISO strings in SQLite\n      case 'float':\n        return 'REAL'; // SQLite's floating point type\n      case 'boolean':\n        return 'INTEGER'; // SQLite uses 0/1 for booleans\n      case 'jsonb':\n        return 'TEXT'; // SQLite: column stores TEXT, we use jsonb()/json() functions for binary optimization\n      default:\n        return getSqlType(type); // text, integer, uuid all map correctly\n    }\n  }\n\n  /**\n   * Creates a table if it doesn't exist based on the provided schema.\n   *\n   * @param args - The create table arguments\n   * @param args.tableName - The name of the table to create\n   * @param args.schema - The schema definition for the table columns\n   */\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n      // Build column definitions\n      const columnDefinitions = Object.entries(schema).map(([colName, colDef]) => {\n        const type = this.getSqlType(colDef.type);\n        const nullable = colDef.nullable === false ? 'NOT NULL' : '';\n        const primaryKey = colDef.primaryKey ? 'PRIMARY KEY' : '';\n        return `\"${colName}\" ${type} ${nullable} ${primaryKey}`.trim();\n      });\n\n      // Add table-level constraints\n      const tableConstraints: string[] = [];\n      if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n        tableConstraints.push('UNIQUE (workflow_name, run_id)');\n      }\n\n      const allDefinitions = [...columnDefinitions, ...tableConstraints].join(',\\n  ');\n\n      const sql = `CREATE TABLE IF NOT EXISTS ${parsedTableName} (\\n  ${allDefinitions}\\n)`;\n\n      await this.client.execute(sql);\n      this.logger.debug(`LibSQLDB: Created table ${tableName}`);\n\n      // Run migrations for Spans table to add any new columns\n      if (tableName === TABLE_SPANS) {\n        await this.migrateSpansTable();\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { tableName },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Migrates the spans table schema from OLD_SPAN_SCHEMA to current SPAN_SCHEMA.\n   * This adds new columns that don't exist in old schema.\n   */\n  private async migrateSpansTable(): Promise<void> {\n    const schema = TABLE_SCHEMAS[TABLE_SPANS];\n\n    try {\n      // Add any columns from current schema that don't exist in the database\n      for (const [columnName, columnDef] of Object.entries(schema)) {\n        const columnExists = await this.hasColumn(TABLE_SPANS, columnName);\n        if (!columnExists) {\n          const sqlType = this.getSqlType(columnDef.type);\n          // For new columns, use nullable (no default needed) since existing rows will have NULL\n          const alterSql = `ALTER TABLE \"${TABLE_SPANS}\" ADD COLUMN \"${columnName}\" ${sqlType}`;\n          await this.client.execute(alterSql);\n          this.logger.debug(`LibSQLDB: Added column '${columnName}' to ${TABLE_SPANS}`);\n        }\n      }\n\n      this.logger.info(`LibSQLDB: Migration completed for ${TABLE_SPANS}`);\n    } catch (error) {\n      // Log warning but don't fail - migrations should be best-effort\n      this.logger.warn(`LibSQLDB: Failed to migrate spans table ${TABLE_SPANS}:`, error);\n    }\n  }\n\n  /**\n   * Gets a default value for a column type (used when adding NOT NULL columns).\n   */\n  private getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'boolean':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      case 'timestamp':\n        return 'DEFAULT CURRENT_TIMESTAMP';\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  /**\n   * Alters an existing table to add missing columns.\n   * Used for schema migrations when new columns are added.\n   *\n   * @param args - The alter table arguments\n   * @param args.tableName - The name of the table to alter\n   * @param args.schema - The full schema definition for the table\n   * @param args.ifNotExists - Array of column names to add if they don't exist\n   */\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    try {\n      // Get existing columns\n      const tableInfo = await this.client.execute({\n        sql: `PRAGMA table_info(\"${parsedTableName}\")`,\n      });\n      const existingColumns = new Set((tableInfo.rows || []).map((row: any) => row.name?.toLowerCase()));\n\n      // Add missing columns\n      for (const columnName of ifNotExists) {\n        if (!existingColumns.has(columnName.toLowerCase()) && schema[columnName]) {\n          const columnDef = schema[columnName];\n          const sqlType = this.getSqlType(columnDef.type);\n          const defaultValue = this.getDefaultValue(columnDef.type);\n\n          // SQLite doesn't support ADD COLUMN IF NOT EXISTS, but we checked above\n          const alterSql = `ALTER TABLE ${parsedTableName} ADD COLUMN \"${columnName}\" ${sqlType} ${defaultValue}`;\n          await this.client.execute(alterSql);\n          this.logger.debug(`LibSQLDB: Added column ${columnName} to table ${tableName}`);\n        }\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'ALTER_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { tableName },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes all records from the specified table.\n   * Errors are logged but not thrown.\n   *\n   * @param args - The delete arguments\n   * @param args.tableName - The name of the table to clear\n   */\n  async deleteData({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    try {\n      await this.client.execute(`DELETE FROM ${parsedTableName}`);\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CLEAR_TABLE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        e,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  AgentsStorage,\n  createStorageErrorId,\n  normalizePerPage,\n  calculatePagination,\n  TABLE_AGENTS,\n  AGENTS_SCHEMA,\n} from '@mastra/core/storage';\nimport type {\n  StorageAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n} from '@mastra/core/storage';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\n\nexport class AgentsLibSQL extends AgentsStorage {\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_AGENTS, schema: AGENTS_SCHEMA });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_AGENTS });\n  }\n\n  private parseJson(value: any, fieldName?: string): any {\n    if (!value) return undefined;\n    if (typeof value !== 'string') return value;\n\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      const details: Record<string, string> = {\n        value: value.length > 100 ? value.substring(0, 100) + '...' : value,\n      };\n      if (fieldName) {\n        details.field = fieldName;\n      }\n\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'PARSE_JSON', 'INVALID_JSON'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.SYSTEM,\n          text: `Failed to parse JSON${fieldName ? ` for field \"${fieldName}\"` : ''}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          details,\n        },\n        error,\n      );\n    }\n  }\n\n  private parseRow(row: any): StorageAgentType {\n    return {\n      id: row.id as string,\n      name: row.name as string,\n      description: row.description as string | undefined,\n      instructions: row.instructions as string,\n      model: this.parseJson(row.model, 'model'),\n      tools: this.parseJson(row.tools, 'tools'),\n      defaultOptions: this.parseJson(row.defaultOptions, 'defaultOptions'),\n      workflows: this.parseJson(row.workflows, 'workflows'),\n      agents: this.parseJson(row.agents, 'agents'),\n      inputProcessors: this.parseJson(row.inputProcessors, 'inputProcessors'),\n      outputProcessors: this.parseJson(row.outputProcessors, 'outputProcessors'),\n      memory: this.parseJson(row.memory, 'memory'),\n      scorers: this.parseJson(row.scorers, 'scorers'),\n      metadata: this.parseJson(row.metadata, 'metadata'),\n      createdAt: new Date(row.createdAt as string),\n      updatedAt: new Date(row.updatedAt as string),\n    };\n  }\n\n  async getAgentById({ id }: { id: string }): Promise<StorageAgentType | null> {\n    try {\n      const result = await this.#db.select<Record<string, any>>({\n        tableName: TABLE_AGENTS,\n        keys: { id },\n      });\n\n      return result ? this.parseRow(result) : null;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_AGENT_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async createAgent({ agent }: { agent: StorageCreateAgentInput }): Promise<StorageAgentType> {\n    try {\n      const now = new Date();\n\n      await this.#db.insert({\n        tableName: TABLE_AGENTS,\n        record: {\n          id: agent.id,\n          name: agent.name,\n          description: agent.description ?? null,\n          instructions: agent.instructions,\n          model: agent.model,\n          tools: agent.tools ?? null,\n          defaultOptions: agent.defaultOptions ?? null,\n          workflows: agent.workflows ?? null,\n          agents: agent.agents ?? null,\n          inputProcessors: agent.inputProcessors ?? null,\n          outputProcessors: agent.outputProcessors ?? null,\n          memory: agent.memory ?? null,\n          scorers: agent.scorers ?? null,\n          metadata: agent.metadata ?? null,\n          createdAt: now,\n          updatedAt: now,\n        },\n      });\n\n      return {\n        ...agent,\n        createdAt: now,\n        updatedAt: now,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: agent.id },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateAgent({ id, ...updates }: StorageUpdateAgentInput): Promise<StorageAgentType> {\n    try {\n      // First, get the existing agent\n      const existingAgent = await this.getAgentById({ id });\n      if (!existingAgent) {\n        throw new MastraError({\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'NOT_FOUND'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          text: `Agent ${id} not found`,\n          details: { agentId: id },\n        });\n      }\n\n      // Build the data object with only the fields that are being updated\n      const data: Record<string, any> = {\n        updatedAt: new Date(),\n      };\n\n      if (updates.name !== undefined) data.name = updates.name;\n      if (updates.description !== undefined) data.description = updates.description;\n      if (updates.instructions !== undefined) data.instructions = updates.instructions;\n      if (updates.model !== undefined) data.model = updates.model;\n      if (updates.tools !== undefined) data.tools = updates.tools;\n      if (updates.defaultOptions !== undefined) data.defaultOptions = updates.defaultOptions;\n      if (updates.workflows !== undefined) data.workflows = updates.workflows;\n      if (updates.agents !== undefined) data.agents = updates.agents;\n      if (updates.inputProcessors !== undefined) data.inputProcessors = updates.inputProcessors;\n      if (updates.outputProcessors !== undefined) data.outputProcessors = updates.outputProcessors;\n      if (updates.memory !== undefined) data.memory = updates.memory;\n      if (updates.scorers !== undefined) data.scorers = updates.scorers;\n      if (updates.metadata !== undefined) {\n        // Merge metadata\n        data.metadata = { ...existingAgent.metadata, ...updates.metadata };\n      }\n\n      // Only update if there's more than just updatedAt\n      if (Object.keys(data).length > 1) {\n        await this.#db.update({\n          tableName: TABLE_AGENTS,\n          keys: { id },\n          data,\n        });\n      }\n\n      // Return the updated agent\n      const updatedAgent = await this.getAgentById({ id });\n      if (!updatedAgent) {\n        throw new MastraError({\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'NOT_FOUND_AFTER_UPDATE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.SYSTEM,\n          text: `Agent ${id} not found after update`,\n          details: { agentId: id },\n        });\n      }\n\n      return updatedAgent;\n    } catch (error) {\n      if (error instanceof MastraError) {\n        throw error;\n      }\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteAgent({ id }: { id: string }): Promise<void> {\n    try {\n      await this.#db.delete({\n        tableName: TABLE_AGENTS,\n        keys: { id },\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_AGENT', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async listAgents(args?: StorageListAgentsInput): Promise<StorageListAgentsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_AGENTS', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    try {\n      // Get total count\n      const total = await this.#db.selectTotalCount({ tableName: TABLE_AGENTS });\n\n      if (total === 0) {\n        return {\n          agents: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      // Get paginated results\n      const limitValue = perPageInput === false ? total : perPage;\n      const rows = await this.#db.selectMany<Record<string, any>>({\n        tableName: TABLE_AGENTS,\n        orderBy: `\"${field}\" ${direction}`,\n        limit: limitValue,\n        offset,\n      });\n\n      const agents = rows.map(row => this.parseRow(row));\n\n      return {\n        agents,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : offset + perPage < total,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_AGENTS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport type { MastraMessageContentV2 } from '@mastra/core/agent';\nimport { MessageList } from '@mastra/core/agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MastraDBMessage, StorageThreadType } from '@mastra/core/memory';\nimport type {\n  StorageResourceType,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n  ThreadCloneMetadata,\n} from '@mastra/core/storage';\nimport {\n  createStorageErrorId,\n  MemoryStorage,\n  normalizePerPage,\n  calculatePagination,\n  TABLE_MESSAGES,\n  TABLE_RESOURCES,\n  TABLE_THREADS,\n  TABLE_SCHEMAS,\n} from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { buildSelectColumns } from '../../db/utils';\n\nexport class MemoryLibSQL extends MemoryStorage {\n  #client: Client;\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_THREADS, schema: TABLE_SCHEMAS[TABLE_THREADS] });\n    await this.#db.createTable({ tableName: TABLE_MESSAGES, schema: TABLE_SCHEMAS[TABLE_MESSAGES] });\n    await this.#db.createTable({ tableName: TABLE_RESOURCES, schema: TABLE_SCHEMAS[TABLE_RESOURCES] });\n    // Add resourceId column for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_MESSAGES,\n      schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      ifNotExists: ['resourceId'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_MESSAGES });\n    await this.#db.deleteData({ tableName: TABLE_THREADS });\n    await this.#db.deleteData({ tableName: TABLE_RESOURCES });\n  }\n\n  private parseRow(row: any): MastraDBMessage {\n    let content = row.content;\n    try {\n      content = JSON.parse(row.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    const result = {\n      id: row.id,\n      content,\n      role: row.role,\n      createdAt: new Date(row.createdAt as string),\n      threadId: row.thread_id,\n      resourceId: row.resourceId,\n    } as MastraDBMessage;\n    if (row.type && row.type !== `v2`) result.type = row.type;\n    return result;\n  }\n\n  private async _getIncludedMessages({ include }: { include: StorageListMessagesInput['include'] }) {\n    if (!include || include.length === 0) return null;\n\n    const unionQueries: string[] = [];\n    const params: any[] = [];\n\n    for (const inc of include) {\n      const { id, withPreviousMessages = 0, withNextMessages = 0 } = inc;\n      // Query by message ID directly - get the threadId from the message itself via subquery\n      unionQueries.push(\n        `\n                SELECT * FROM (\n                  WITH target_thread AS (\n                    SELECT thread_id FROM \"${TABLE_MESSAGES}\" WHERE id = ?\n                  ),\n                  numbered_messages AS (\n                    SELECT\n                      id, content, role, type, \"createdAt\", thread_id, \"resourceId\",\n                      ROW_NUMBER() OVER (ORDER BY \"createdAt\" ASC) as row_num\n                    FROM \"${TABLE_MESSAGES}\"\n                    WHERE thread_id = (SELECT thread_id FROM target_thread)\n                  ),\n                  target_positions AS (\n                    SELECT row_num as target_pos\n                    FROM numbered_messages\n                    WHERE id = ?\n                  )\n                  SELECT DISTINCT m.*\n                  FROM numbered_messages m\n                  CROSS JOIN target_positions t\n                  WHERE m.row_num BETWEEN (t.target_pos - ?) AND (t.target_pos + ?)\n                ) \n                `, // Keep ASC for final sorting after fetching context\n      );\n      params.push(id, id, withPreviousMessages, withNextMessages);\n    }\n    const finalQuery = unionQueries.join(' UNION ALL ') + ' ORDER BY \"createdAt\" ASC';\n    const includedResult = await this.#client.execute({ sql: finalQuery, args: params });\n    const includedRows = includedResult.rows?.map(row => this.parseRow(row));\n    const seen = new Set<string>();\n    const dedupedRows = includedRows.filter(row => {\n      if (seen.has(row.id)) return false;\n      seen.add(row.id);\n      return true;\n    });\n    return dedupedRows;\n  }\n\n  public async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    if (messageIds.length === 0) return { messages: [] };\n\n    try {\n      const sql = `\n        SELECT \n          id, \n          content, \n          role, \n          type,\n          \"createdAt\", \n          thread_id,\n          \"resourceId\"\n        FROM \"${TABLE_MESSAGES}\"\n        WHERE id IN (${messageIds.map(() => '?').join(', ')})\n        ORDER BY \"createdAt\" DESC\n      `;\n      const result = await this.#client.execute({ sql, args: messageIds });\n      if (!result.rows) return { messages: [] };\n\n      const list = new MessageList().add(result.rows.map(this.parseRow), 'memory');\n      return { messages: list.get.all.db() };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: JSON.stringify(messageIds) },\n        },\n        error,\n      );\n    }\n  }\n\n  public async listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    const { threadId, resourceId, include, filter, perPage: perPageInput, page = 0, orderBy } = args;\n\n    // Normalize threadId to array\n    const threadIds = Array.isArray(threadId) ? threadId : [threadId];\n\n    if (threadIds.length === 0 || threadIds.some(id => !id.trim())) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'INVALID_THREAD_ID'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId: Array.isArray(threadId) ? threadId.join(',') : threadId },\n        },\n        new Error('threadId must be a non-empty string or array of non-empty strings'),\n      );\n    }\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 40);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    try {\n      // Determine sort field and direction\n      const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n      const orderByStatement = `ORDER BY \"${field}\" ${direction}`;\n\n      // Build WHERE conditions - use IN for multiple thread IDs\n      const threadPlaceholders = threadIds.map(() => '?').join(', ');\n      const conditions: string[] = [`thread_id IN (${threadPlaceholders})`];\n      const queryParams: InValue[] = [...threadIds];\n\n      if (resourceId) {\n        conditions.push(`\"resourceId\" = ?`);\n        queryParams.push(resourceId);\n      }\n\n      if (filter?.dateRange?.start) {\n        const startOp = filter.dateRange.startExclusive ? '>' : '>=';\n        conditions.push(`\"createdAt\" ${startOp} ?`);\n        queryParams.push(\n          filter.dateRange.start instanceof Date ? filter.dateRange.start.toISOString() : filter.dateRange.start,\n        );\n      }\n\n      if (filter?.dateRange?.end) {\n        const endOp = filter.dateRange.endExclusive ? '<' : '<=';\n        conditions.push(`\"createdAt\" ${endOp} ?`);\n        queryParams.push(\n          filter.dateRange.end instanceof Date ? filter.dateRange.end.toISOString() : filter.dateRange.end,\n        );\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get total count\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_MESSAGES} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      // Step 1: Get paginated messages from the thread first (without excluding included ones)\n      const limitValue = perPageInput === false ? total : perPage;\n      const dataResult = await this.#client.execute({\n        sql: `SELECT id, content, role, type, \"createdAt\", \"resourceId\", \"thread_id\" FROM ${TABLE_MESSAGES} ${whereClause} ${orderByStatement} LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, offset],\n      });\n      const messages: MastraDBMessage[] = (dataResult.rows || []).map((row: any) => this.parseRow(row));\n\n      // Only return early if there are no messages AND no includes to process\n      if (total === 0 && messages.length === 0 && (!include || include.length === 0)) {\n        return {\n          messages: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      // Step 2: Add included messages with context (if any), excluding duplicates\n      const messageIds = new Set(messages.map(m => m.id));\n      if (include && include.length > 0) {\n        const includeMessages = await this._getIncludedMessages({ include });\n        if (includeMessages) {\n          // Deduplicate: only add messages that aren't already in the paginated results\n          for (const includeMsg of includeMessages) {\n            if (!messageIds.has(includeMsg.id)) {\n              messages.push(includeMsg);\n              messageIds.add(includeMsg.id);\n            }\n          }\n        }\n      }\n\n      // Use MessageList for proper deduplication and format conversion to V2\n      const list = new MessageList().add(messages, 'memory');\n      let finalMessages = list.get.all.db();\n\n      // Sort all messages (paginated + included) for final output\n      finalMessages = finalMessages.sort((a, b) => {\n        const isDateField = field === 'createdAt' || field === 'updatedAt';\n        const aValue = isDateField ? new Date((a as any)[field]).getTime() : (a as any)[field];\n        const bValue = isDateField ? new Date((b as any)[field]).getTime() : (b as any)[field];\n\n        if (typeof aValue === 'number' && typeof bValue === 'number') {\n          return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n        }\n        return direction === 'ASC'\n          ? String(aValue).localeCompare(String(bValue))\n          : String(bValue).localeCompare(String(aValue));\n      });\n\n      // Calculate hasMore based on pagination window\n      // If all thread messages have been returned (through pagination or include), hasMore = false\n      // Otherwise, check if there are more pages in the pagination window\n      const threadIdSet = new Set(threadIds);\n      const returnedThreadMessageIds = new Set(\n        finalMessages.filter(m => m.threadId && threadIdSet.has(m.threadId)).map(m => m.id),\n      );\n      const allThreadMessagesReturned = returnedThreadMessageIds.size >= total;\n      const hasMore = perPageInput !== false && !allThreadMessagesReturned && offset + perPage < total;\n\n      return {\n        messages: finalMessages,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId: Array.isArray(threadId) ? threadId.join(',') : threadId,\n            resourceId: resourceId ?? '',\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException?.(mastraError);\n      return {\n        messages: [],\n        total: 0,\n        page,\n        perPage: perPageForResponse,\n        hasMore: false,\n      };\n    }\n  }\n\n  async saveMessages({ messages }: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    if (messages.length === 0) return { messages };\n\n    try {\n      const threadId = messages[0]?.threadId;\n      if (!threadId) {\n        throw new Error('Thread ID is required');\n      }\n\n      // Prepare batch statements for all messages\n      const batchStatements = messages.map(message => {\n        const time = message.createdAt || new Date();\n        if (!message.threadId) {\n          throw new Error(\n            `Expected to find a threadId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        if (!message.resourceId) {\n          throw new Error(\n            `Expected to find a resourceId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        return {\n          sql: `INSERT INTO \"${TABLE_MESSAGES}\" (id, thread_id, content, role, type, \"createdAt\", \"resourceId\") \n                  VALUES (?, ?, ?, ?, ?, ?, ?)\n                  ON CONFLICT(id) DO UPDATE SET\n                    thread_id=excluded.thread_id,\n                    content=excluded.content,\n                    role=excluded.role,\n                    type=excluded.type,\n                    \"resourceId\"=excluded.\"resourceId\"\n                `,\n          args: [\n            message.id,\n            message.threadId!,\n            typeof message.content === 'object' ? JSON.stringify(message.content) : message.content,\n            message.role,\n            message.type || 'v2',\n            time instanceof Date ? time.toISOString() : time,\n            message.resourceId,\n          ],\n        };\n      });\n\n      const now = new Date().toISOString();\n      batchStatements.push({\n        sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n        args: [now, threadId],\n      });\n\n      // Execute in batches to avoid potential limitations\n      const BATCH_SIZE = 50; // Safe batch size for libsql\n\n      // Separate message statements from thread update\n      const messageStatements = batchStatements.slice(0, -1);\n      const threadUpdateStatement = batchStatements[batchStatements.length - 1];\n\n      // Process message statements in batches\n      for (let i = 0; i < messageStatements.length; i += BATCH_SIZE) {\n        const batch = messageStatements.slice(i, i + BATCH_SIZE);\n        if (batch.length > 0) {\n          await this.#client.batch(batch, 'write');\n        }\n      }\n\n      // Execute thread update separately\n      if (threadUpdateStatement) {\n        await this.#client.execute(threadUpdateStatement);\n      }\n\n      const list = new MessageList().add(messages as any, 'memory');\n      return { messages: list.get.all.db() };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraDBMessage[]> {\n    if (messages.length === 0) {\n      return [];\n    }\n\n    const messageIds = messages.map(m => m.id);\n    const placeholders = messageIds.map(() => '?').join(',');\n\n    const selectSql = `SELECT * FROM ${TABLE_MESSAGES} WHERE id IN (${placeholders})`;\n    const existingResult = await this.#client.execute({ sql: selectSql, args: messageIds });\n    const existingMessages: MastraDBMessage[] = existingResult.rows.map(row => this.parseRow(row));\n\n    if (existingMessages.length === 0) {\n      return [];\n    }\n\n    const batchStatements = [];\n    const threadIdsToUpdate = new Set<string>();\n    const columnMapping: Record<string, string> = {\n      threadId: 'thread_id',\n    };\n\n    for (const existingMessage of existingMessages) {\n      const updatePayload = messages.find(m => m.id === existingMessage.id);\n      if (!updatePayload) continue;\n\n      const { id, ...fieldsToUpdate } = updatePayload;\n      if (Object.keys(fieldsToUpdate).length === 0) continue;\n\n      threadIdsToUpdate.add(existingMessage.threadId!);\n      if (updatePayload.threadId && updatePayload.threadId !== existingMessage.threadId) {\n        threadIdsToUpdate.add(updatePayload.threadId);\n      }\n\n      const setClauses = [];\n      const args: InValue[] = [];\n      const updatableFields = { ...fieldsToUpdate };\n\n      // Special handling for the 'content' field to merge instead of overwrite\n      if (updatableFields.content) {\n        const newContent = {\n          ...existingMessage.content,\n          ...updatableFields.content,\n          // Deep merge metadata if it exists on both\n          ...(existingMessage.content?.metadata && updatableFields.content.metadata\n            ? {\n                metadata: {\n                  ...existingMessage.content.metadata,\n                  ...updatableFields.content.metadata,\n                },\n              }\n            : {}),\n        };\n        setClauses.push(`${parseSqlIdentifier('content', 'column name')} = ?`);\n        args.push(JSON.stringify(newContent));\n        delete updatableFields.content;\n      }\n\n      for (const key in updatableFields) {\n        if (Object.prototype.hasOwnProperty.call(updatableFields, key)) {\n          const dbKey = columnMapping[key] || key;\n          setClauses.push(`${parseSqlIdentifier(dbKey, 'column name')} = ?`);\n          let value = updatableFields[key as keyof typeof updatableFields];\n\n          if (typeof value === 'object' && value !== null) {\n            value = JSON.stringify(value);\n          }\n          args.push(value as InValue);\n        }\n      }\n\n      if (setClauses.length === 0) continue;\n\n      args.push(id);\n\n      const sql = `UPDATE ${TABLE_MESSAGES} SET ${setClauses.join(', ')} WHERE id = ?`;\n      batchStatements.push({ sql, args });\n    }\n\n    if (batchStatements.length === 0) {\n      return existingMessages;\n    }\n\n    const now = new Date().toISOString();\n    for (const threadId of threadIdsToUpdate) {\n      if (threadId) {\n        batchStatements.push({\n          sql: `UPDATE ${TABLE_THREADS} SET updatedAt = ? WHERE id = ?`,\n          args: [now, threadId],\n        });\n      }\n    }\n\n    await this.#client.batch(batchStatements, 'write');\n\n    const updatedResult = await this.#client.execute({ sql: selectSql, args: messageIds });\n    return updatedResult.rows.map(row => this.parseRow(row));\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    try {\n      // Process in batches to avoid SQL parameter limits\n      const BATCH_SIZE = 100;\n      const threadIds = new Set<string>();\n\n      // Use a transaction to ensure consistency\n      const tx = await this.#client.transaction('write');\n\n      try {\n        for (let i = 0; i < messageIds.length; i += BATCH_SIZE) {\n          const batch = messageIds.slice(i, i + BATCH_SIZE);\n          const placeholders = batch.map(() => '?').join(',');\n\n          // Get thread IDs for this batch\n          const result = await tx.execute({\n            sql: `SELECT DISTINCT thread_id FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n\n          result.rows?.forEach(row => {\n            if (row.thread_id) threadIds.add(row.thread_id as string);\n          });\n\n          // Delete messages in this batch\n          await tx.execute({\n            sql: `DELETE FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n        }\n\n        // Update thread timestamps within the transaction\n        if (threadIds.size > 0) {\n          const now = new Date().toISOString();\n          for (const threadId of threadIds) {\n            await tx.execute({\n              sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n              args: [now, threadId],\n            });\n          }\n        }\n\n        // Commit the transaction\n        await tx.commit();\n      } catch (error) {\n        // Rollback on error\n        await tx.rollback();\n        throw error;\n      }\n\n      // TODO: Delete from vector store if semantic recall is enabled\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_MESSAGES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: messageIds.join(', ') },\n        },\n        error,\n      );\n    }\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    const result = await this.#db.select<StorageResourceType>({\n      tableName: TABLE_RESOURCES,\n      keys: { id: resourceId },\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      ...result,\n      // Ensure workingMemory is always returned as a string, even if auto-parsed as JSON\n      workingMemory:\n        result.workingMemory && typeof result.workingMemory === 'object'\n          ? JSON.stringify(result.workingMemory)\n          : result.workingMemory,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n      createdAt: new Date(result.createdAt),\n      updatedAt: new Date(result.updatedAt),\n    };\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    await this.#db.insert({\n      tableName: TABLE_RESOURCES,\n      record: {\n        ...resource,\n        // metadata is handled by prepareStatement which stringifies jsonb columns\n      },\n    });\n\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    const existingResource = await this.getResourceById({ resourceId });\n\n    if (!existingResource) {\n      // Create new resource if it doesn't exist\n      const newResource: StorageResourceType = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n      return this.saveResource({ resource: newResource });\n    }\n\n    const updatedResource = {\n      ...existingResource,\n      workingMemory: workingMemory !== undefined ? workingMemory : existingResource.workingMemory,\n      metadata: {\n        ...existingResource.metadata,\n        ...metadata,\n      },\n      updatedAt: new Date(),\n    };\n\n    const updates: string[] = [];\n    const values: InValue[] = [];\n\n    if (workingMemory !== undefined) {\n      updates.push('workingMemory = ?');\n      values.push(workingMemory);\n    }\n\n    if (metadata) {\n      updates.push('metadata = jsonb(?)');\n      values.push(JSON.stringify(updatedResource.metadata));\n    }\n\n    updates.push('updatedAt = ?');\n    values.push(updatedResource.updatedAt.toISOString());\n\n    values.push(resourceId);\n\n    await this.#client.execute({\n      sql: `UPDATE ${TABLE_RESOURCES} SET ${updates.join(', ')} WHERE id = ?`,\n      args: values,\n    });\n\n    return updatedResource;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    try {\n      const result = await this.#db.select<\n        Omit<StorageThreadType, 'createdAt' | 'updatedAt'> & { createdAt: string; updatedAt: string }\n      >({\n        tableName: TABLE_THREADS,\n        keys: { id: threadId },\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      return {\n        ...result,\n        metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n        createdAt: new Date(result.createdAt),\n        updatedAt: new Date(result.updatedAt),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_THREAD_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  public async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;\n\n    if (page < 0) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_THREADS_BY_RESOURCE_ID', 'INVALID_PAGE'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { page },\n        },\n        new Error('page must be >= 0'),\n      );\n    }\n\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    try {\n      const baseQuery = `FROM ${TABLE_THREADS} WHERE resourceId = ?`;\n      const queryParams: InValue[] = [resourceId];\n\n      const mapRowToStorageThreadType = (row: any): StorageThreadType => ({\n        id: row.id as string,\n        resourceId: row.resourceId as string,\n        title: row.title as string,\n        createdAt: new Date(row.createdAt as string), // Convert string to Date\n        updatedAt: new Date(row.updatedAt as string), // Convert string to Date\n        metadata: typeof row.metadata === 'string' ? JSON.parse(row.metadata) : row.metadata,\n      });\n\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count ${baseQuery}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          threads: [],\n          total: 0,\n          page,\n          perPage: perPageForResponse,\n          hasMore: false,\n        };\n      }\n\n      const limitValue = perPageInput === false ? total : perPage;\n      const dataResult = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_THREADS)} ${baseQuery} ORDER BY \"${field}\" ${direction} LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, offset],\n      });\n\n      const threads = (dataResult.rows || []).map(mapRowToStorageThreadType);\n\n      return {\n        threads,\n        total,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : offset + perPage < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_THREADS_BY_RESOURCE_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { resourceId },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      return {\n        threads: [],\n        total: 0,\n        page,\n        perPage: perPageForResponse,\n        hasMore: false,\n      };\n    }\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    try {\n      await this.#db.insert({\n        tableName: TABLE_THREADS,\n        record: {\n          ...thread,\n          // metadata is handled by prepareStatement which stringifies jsonb columns\n        },\n      });\n\n      return thread;\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId: thread.id },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      throw mastraError;\n    }\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const thread = await this.getThreadById({ threadId: id });\n    if (!thread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'UPDATE_THREAD', 'NOT_FOUND'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread ${id} not found`,\n        details: {\n          status: 404,\n          threadId: id,\n        },\n      });\n    }\n\n    const updatedThread = {\n      ...thread,\n      title,\n      metadata: {\n        ...thread.metadata,\n        ...metadata,\n      },\n    };\n\n    try {\n      await this.#client.execute({\n        sql: `UPDATE ${TABLE_THREADS} SET title = ?, metadata = jsonb(?) WHERE id = ?`,\n        args: [title, JSON.stringify(updatedThread.metadata), id],\n      });\n\n      return updatedThread;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          text: `Failed to update thread ${id}`,\n          details: { threadId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    try {\n      // Delete messages first (child records), then thread\n      // Note: Not using a transaction to avoid SQLITE_BUSY errors when multiple\n      // deleteThread calls run concurrently. The two deletes are independent and\n      // orphaned messages (if thread delete fails) would be cleaned up on next delete attempt.\n      await this.#client.execute({\n        sql: `DELETE FROM ${TABLE_MESSAGES} WHERE thread_id = ?`,\n        args: [threadId],\n      });\n      await this.#client.execute({\n        sql: `DELETE FROM ${TABLE_THREADS} WHERE id = ?`,\n        args: [threadId],\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'DELETE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  async cloneThread(args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;\n\n    // Get the source thread\n    const sourceThread = await this.getThreadById({ threadId: sourceThreadId });\n    if (!sourceThread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'SOURCE_NOT_FOUND'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Source thread with id ${sourceThreadId} not found`,\n        details: { sourceThreadId },\n      });\n    }\n\n    // Use provided ID or generate a new one\n    const newThreadId = providedThreadId || crypto.randomUUID();\n\n    // Check if the new thread ID already exists\n    const existingThread = await this.getThreadById({ threadId: newThreadId });\n    if (existingThread) {\n      throw new MastraError({\n        id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'THREAD_EXISTS'),\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread with id ${newThreadId} already exists`,\n        details: { newThreadId },\n      });\n    }\n\n    try {\n      // Build message query with filters\n      let messageQuery = `SELECT id, content, role, type, \"createdAt\", thread_id, \"resourceId\"\n                          FROM \"${TABLE_MESSAGES}\" WHERE thread_id = ?`;\n      const messageParams: InValue[] = [sourceThreadId];\n\n      // Apply date filters\n      if (options?.messageFilter?.startDate) {\n        messageQuery += ` AND \"createdAt\" >= ?`;\n        messageParams.push(\n          options.messageFilter.startDate instanceof Date\n            ? options.messageFilter.startDate.toISOString()\n            : options.messageFilter.startDate,\n        );\n      }\n      if (options?.messageFilter?.endDate) {\n        messageQuery += ` AND \"createdAt\" <= ?`;\n        messageParams.push(\n          options.messageFilter.endDate instanceof Date\n            ? options.messageFilter.endDate.toISOString()\n            : options.messageFilter.endDate,\n        );\n      }\n\n      // Apply message ID filter\n      if (options?.messageFilter?.messageIds && options.messageFilter.messageIds.length > 0) {\n        messageQuery += ` AND id IN (${options.messageFilter.messageIds.map(() => '?').join(', ')})`;\n        messageParams.push(...options.messageFilter.messageIds);\n      }\n\n      messageQuery += ` ORDER BY \"createdAt\" ASC`;\n\n      // Apply message limit (from most recent, so we need to reverse order for limit then sort back)\n      if (options?.messageLimit && options.messageLimit > 0) {\n        const limitQuery = `SELECT * FROM (${messageQuery.replace('ORDER BY \"createdAt\" ASC', 'ORDER BY \"createdAt\" DESC')} LIMIT ?) ORDER BY \"createdAt\" ASC`;\n        messageParams.push(options.messageLimit);\n        messageQuery = limitQuery;\n      }\n\n      const sourceMessagesResult = await this.#client.execute({ sql: messageQuery, args: messageParams });\n      const sourceMessages = sourceMessagesResult.rows || [];\n\n      const now = new Date();\n      const nowStr = now.toISOString();\n\n      // Determine the last message ID for clone metadata\n      const lastMessageId =\n        sourceMessages.length > 0 ? (sourceMessages[sourceMessages.length - 1]!.id as string) : undefined;\n\n      // Create clone metadata\n      const cloneMetadata: ThreadCloneMetadata = {\n        sourceThreadId,\n        clonedAt: now,\n        ...(lastMessageId && { lastMessageId }),\n      };\n\n      // Create the new thread\n      const newThread: StorageThreadType = {\n        id: newThreadId,\n        resourceId: resourceId || sourceThread.resourceId,\n        title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : undefined),\n        metadata: {\n          ...metadata,\n          clone: cloneMetadata,\n        },\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      // Use transaction for consistency\n      const tx = await this.#client.transaction('write');\n\n      try {\n        // Insert the new thread\n        await tx.execute({\n          sql: `INSERT INTO \"${TABLE_THREADS}\" (id, \"resourceId\", title, metadata, \"createdAt\", \"updatedAt\")\n                VALUES (?, ?, ?, jsonb(?), ?, ?)`,\n          args: [\n            newThread.id,\n            newThread.resourceId,\n            newThread.title || null,\n            JSON.stringify(newThread.metadata),\n            nowStr,\n            nowStr,\n          ],\n        });\n\n        // Clone messages with new IDs\n        const clonedMessages: MastraDBMessage[] = [];\n        const targetResourceId = resourceId || sourceThread.resourceId;\n\n        for (const sourceMsg of sourceMessages) {\n          const newMessageId = crypto.randomUUID();\n          const contentStr = sourceMsg.content as string;\n          let parsedContent: MastraDBMessage['content'];\n          try {\n            parsedContent = JSON.parse(contentStr);\n          } catch {\n            // use content as is - wrap in format 2 structure if needed\n            parsedContent = { format: 2, parts: [{ type: 'text', text: contentStr }] };\n          }\n\n          await tx.execute({\n            sql: `INSERT INTO \"${TABLE_MESSAGES}\" (id, thread_id, content, role, type, \"createdAt\", \"resourceId\")\n                  VALUES (?, ?, ?, ?, ?, ?, ?)`,\n            args: [\n              newMessageId,\n              newThreadId,\n              contentStr,\n              sourceMsg.role as string,\n              (sourceMsg.type as string) || 'v2',\n              sourceMsg.createdAt as string,\n              targetResourceId,\n            ],\n          });\n\n          clonedMessages.push({\n            id: newMessageId,\n            threadId: newThreadId,\n            content: parsedContent,\n            role: sourceMsg.role as MastraDBMessage['role'],\n            type: (sourceMsg.type as string) || undefined,\n            createdAt: new Date(sourceMsg.createdAt as string),\n            resourceId: targetResourceId,\n          });\n        }\n\n        await tx.commit();\n\n        return {\n          thread: newThread,\n          clonedMessages,\n        };\n      } catch (error) {\n        await tx.rollback();\n        throw error;\n      }\n    } catch (error) {\n      if (error instanceof MastraError) {\n        throw error;\n      }\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CLONE_THREAD', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { sourceThreadId, newThreadId },\n        },\n        error,\n      );\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  createStorageErrorId,\n  listTracesArgsSchema,\n  ObservabilityStorage,\n  SPAN_SCHEMA,\n  TABLE_SPANS,\n  TraceStatus,\n} from '@mastra/core/storage';\nimport type {\n  SpanRecord,\n  ListTracesArgs,\n  PaginationInfo,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  BatchCreateSpansArgs,\n  CreateSpanArgs,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n} from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { transformFromSqlRow } from '../../db/utils';\n\nexport class ObservabilityLibSQL extends ObservabilityStorage {\n  #db: LibSQLDB;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_SPANS, schema: SPAN_SCHEMA });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_SPANS });\n  }\n\n  public override get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates',\n      supported: ['batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createSpan(args: CreateSpanArgs): Promise<void> {\n    const { span } = args;\n    try {\n      const startedAt = span.startedAt instanceof Date ? span.startedAt.toISOString() : span.startedAt;\n      const endedAt = span.endedAt instanceof Date ? span.endedAt.toISOString() : span.endedAt;\n      const now = new Date().toISOString();\n\n      const record = {\n        ...span,\n        startedAt,\n        endedAt,\n        createdAt: now,\n        updatedAt: now,\n      };\n      return this.#db.insert({ tableName: TABLE_SPANS, record });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'CREATE_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId: span.spanId,\n            traceId: span.traceId,\n            spanType: span.spanType,\n            name: span.name,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async getSpan(args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    const { traceId, spanId } = args;\n    try {\n      const rows = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ? AND spanId = ?', args: [traceId, spanId] },\n        limit: 1,\n      });\n\n      if (!rows || rows.length === 0) {\n        return null;\n      }\n\n      return {\n        span: transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: rows[0]! }),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { traceId, spanId },\n        },\n        error,\n      );\n    }\n  }\n\n  async getRootSpan(args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    const { traceId } = args;\n    try {\n      const rows = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ? AND parentSpanId IS NULL', args: [traceId] },\n        limit: 1,\n      });\n\n      if (!rows || rows.length === 0) {\n        return null;\n      }\n\n      return {\n        span: transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: rows[0]! }),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_ROOT_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { traceId },\n        },\n        error,\n      );\n    }\n  }\n\n  async getTrace(args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    const { traceId } = args;\n    try {\n      const spans = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: ' WHERE traceId = ?', args: [traceId] },\n        orderBy: 'startedAt ASC',\n      });\n\n      if (!spans || spans.length === 0) {\n        return null;\n      }\n\n      return {\n        traceId,\n        spans: spans.map(span => transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: span })),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_TRACE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateSpan(args: UpdateSpanArgs): Promise<void> {\n    const { traceId, spanId, updates } = args;\n    try {\n      const data: Record<string, any> = { ...updates };\n      if (data.endedAt instanceof Date) {\n        data.endedAt = data.endedAt.toISOString();\n      }\n      if (data.startedAt instanceof Date) {\n        data.startedAt = data.startedAt.toISOString();\n      }\n      data.updatedAt = new Date().toISOString();\n\n      await this.#db.update({\n        tableName: TABLE_SPANS,\n        keys: { spanId, traceId },\n        data,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'UPDATE_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId,\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async listTraces(args: ListTracesArgs): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    // Parse args through schema to apply defaults\n    const { filters, pagination, orderBy } = listTracesArgsSchema.parse(args);\n    const { page, perPage } = pagination;\n\n    const tableName = parseSqlIdentifier(TABLE_SPANS, 'table name');\n\n    try {\n      // Build WHERE clause for filters\n      const conditions: string[] = ['parentSpanId IS NULL']; // Only root spans\n      const queryArgs: any[] = [];\n\n      if (filters) {\n        // Date range filters\n        if (filters.startedAt?.start) {\n          conditions.push(`startedAt >= ?`);\n          queryArgs.push(filters.startedAt.start.toISOString());\n        }\n        if (filters.startedAt?.end) {\n          conditions.push(`startedAt <= ?`);\n          queryArgs.push(filters.startedAt.end.toISOString());\n        }\n        if (filters.endedAt?.start) {\n          conditions.push(`endedAt >= ?`);\n          queryArgs.push(filters.endedAt.start.toISOString());\n        }\n        if (filters.endedAt?.end) {\n          conditions.push(`endedAt <= ?`);\n          queryArgs.push(filters.endedAt.end.toISOString());\n        }\n\n        // Span type filter\n        if (filters.spanType !== undefined) {\n          conditions.push(`spanType = ?`);\n          queryArgs.push(filters.spanType);\n        }\n\n        // Entity filters\n        if (filters.entityType !== undefined) {\n          conditions.push(`entityType = ?`);\n          queryArgs.push(filters.entityType);\n        }\n        if (filters.entityId !== undefined) {\n          conditions.push(`entityId = ?`);\n          queryArgs.push(filters.entityId);\n        }\n        if (filters.entityName !== undefined) {\n          conditions.push(`entityName = ?`);\n          queryArgs.push(filters.entityName);\n        }\n\n        // Identity & Tenancy filters\n        if (filters.userId !== undefined) {\n          conditions.push(`userId = ?`);\n          queryArgs.push(filters.userId);\n        }\n        if (filters.organizationId !== undefined) {\n          conditions.push(`organizationId = ?`);\n          queryArgs.push(filters.organizationId);\n        }\n        if (filters.resourceId !== undefined) {\n          conditions.push(`resourceId = ?`);\n          queryArgs.push(filters.resourceId);\n        }\n\n        // Correlation ID filters\n        if (filters.runId !== undefined) {\n          conditions.push(`runId = ?`);\n          queryArgs.push(filters.runId);\n        }\n        if (filters.sessionId !== undefined) {\n          conditions.push(`sessionId = ?`);\n          queryArgs.push(filters.sessionId);\n        }\n        if (filters.threadId !== undefined) {\n          conditions.push(`threadId = ?`);\n          queryArgs.push(filters.threadId);\n        }\n        if (filters.requestId !== undefined) {\n          conditions.push(`requestId = ?`);\n          queryArgs.push(filters.requestId);\n        }\n\n        // Deployment context filters\n        if (filters.environment !== undefined) {\n          conditions.push(`environment = ?`);\n          queryArgs.push(filters.environment);\n        }\n        if (filters.source !== undefined) {\n          conditions.push(`source = ?`);\n          queryArgs.push(filters.source);\n        }\n        if (filters.serviceName !== undefined) {\n          conditions.push(`serviceName = ?`);\n          queryArgs.push(filters.serviceName);\n        }\n\n        // Scope filter (JSON containment - SQLite uses json_extract)\n        if (filters.scope != null) {\n          // For SQLite/libsql, we need to check each key in the scope object\n          for (const [key, value] of Object.entries(filters.scope)) {\n            // Validate key to prevent SQL injection in JSON path\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {\n              throw new MastraError({\n                id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'INVALID_FILTER_KEY'),\n                domain: ErrorDomain.STORAGE,\n                category: ErrorCategory.USER,\n                details: { key },\n              });\n            }\n            conditions.push(`json_extract(scope, '$.${key}') = ?`);\n            queryArgs.push(typeof value === 'string' ? value : JSON.stringify(value));\n          }\n        }\n\n        // Metadata filter (JSON containment)\n        if (filters.metadata != null) {\n          for (const [key, value] of Object.entries(filters.metadata)) {\n            // Validate key to prevent SQL injection in JSON path\n            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {\n              throw new MastraError({\n                id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'INVALID_FILTER_KEY'),\n                domain: ErrorDomain.STORAGE,\n                category: ErrorCategory.USER,\n                details: { key },\n              });\n            }\n            conditions.push(`json_extract(metadata, '$.${key}') = ?`);\n            queryArgs.push(typeof value === 'string' ? value : JSON.stringify(value));\n          }\n        }\n\n        // Tags filter (all tags must be present)\n        if (filters.tags != null && filters.tags.length > 0) {\n          // Use json_each for exact tag matching (LIKE can match substrings)\n          for (const tag of filters.tags) {\n            conditions.push(`EXISTS (SELECT 1 FROM json_each(${tableName}.tags) WHERE value = ?)`);\n            queryArgs.push(tag);\n          }\n        }\n\n        // Status filter (derived from error and endedAt)\n        if (filters.status !== undefined) {\n          switch (filters.status) {\n            case TraceStatus.ERROR:\n              conditions.push(`error IS NOT NULL`);\n              break;\n            case TraceStatus.RUNNING:\n              conditions.push(`endedAt IS NULL AND error IS NULL`);\n              break;\n            case TraceStatus.SUCCESS:\n              conditions.push(`endedAt IS NOT NULL AND error IS NULL`);\n              break;\n          }\n        }\n\n        // hasChildError filter (requires subquery)\n        if (filters.hasChildError !== undefined) {\n          if (filters.hasChildError) {\n            conditions.push(`EXISTS (\n              SELECT 1 FROM ${tableName} c\n              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL\n            )`);\n          } else {\n            conditions.push(`NOT EXISTS (\n              SELECT 1 FROM ${tableName} c\n              WHERE c.traceId = ${tableName}.traceId AND c.error IS NOT NULL\n            )`);\n          }\n        }\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Order by clause with proper NULL handling for endedAt\n      // For endedAt DESC: NULLs FIRST (running spans on top when viewing newest)\n      // For endedAt ASC: NULLs LAST (running spans at end when viewing oldest)\n      // startedAt is never null (required field), so no special handling needed\n      // SQLite's natural behavior: NULLs are \"smaller\" than any value\n      //   - ASC: NULLs first (natural)\n      //   - DESC: NULLs last (natural)\n      // So we need CASE WHEN workarounds to invert the natural behavior for endedAt\n      const sortField = orderBy.field;\n      const sortDirection = orderBy.direction;\n      let orderByClause: string;\n      if (sortField === 'endedAt') {\n        // endedAt DESC: want NULLs first (running spans on top) - need CASE WHEN\n        // endedAt ASC: want NULLs last (oldest completed first) - need CASE WHEN\n        orderByClause =\n          sortDirection === 'DESC'\n            ? `CASE WHEN ${sortField} IS NULL THEN 0 ELSE 1 END, ${sortField} DESC`\n            : `CASE WHEN ${sortField} IS NULL THEN 1 ELSE 0 END, ${sortField} ASC`;\n      } else {\n        orderByClause = `${sortField} ${sortDirection}`;\n      }\n\n      // Get total count\n      const count = await this.#db.selectTotalCount({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: whereClause, args: queryArgs },\n      });\n\n      if (count === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage,\n            hasMore: false,\n          },\n          spans: [],\n        };\n      }\n\n      // Get paginated spans\n      const spans = await this.#db.selectMany<SpanRecord>({\n        tableName: TABLE_SPANS,\n        whereClause: { sql: whereClause, args: queryArgs },\n        orderBy: orderByClause,\n        offset: page * perPage,\n        limit: perPage,\n      });\n\n      return {\n        pagination: {\n          total: count,\n          page,\n          perPage,\n          hasMore: (page + 1) * perPage < count,\n        },\n        spans: spans.map(span => transformFromSqlRow<SpanRecord>({ tableName: TABLE_SPANS, sqlRow: span })),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_TRACES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchCreateSpans(args: BatchCreateSpansArgs): Promise<void> {\n    try {\n      const now = new Date().toISOString();\n      const records = args.records.map(record => {\n        const startedAt = record.startedAt instanceof Date ? record.startedAt.toISOString() : record.startedAt;\n        const endedAt = record.endedAt instanceof Date ? record.endedAt.toISOString() : record.endedAt;\n\n        return {\n          ...record,\n          startedAt,\n          endedAt,\n          createdAt: now,\n          updatedAt: now,\n        };\n      });\n\n      return this.#db.batchInsert({\n        tableName: TABLE_SPANS,\n        records,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_CREATE_SPANS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchUpdateSpans(args: BatchUpdateSpansArgs): Promise<void> {\n    const now = new Date().toISOString();\n\n    try {\n      return this.#db.batchUpdate({\n        tableName: TABLE_SPANS,\n        updates: args.records.map(record => {\n          const data: Record<string, any> = { ...record.updates };\n          if (data.endedAt instanceof Date) {\n            data.endedAt = data.endedAt.toISOString();\n          }\n          if (data.startedAt instanceof Date) {\n            data.startedAt = data.startedAt.toISOString();\n          }\n          data.updatedAt = now;\n\n          return {\n            keys: { spanId: record.spanId, traceId: record.traceId },\n            data,\n          };\n        }),\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_UPDATE_SPANS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchDeleteTraces(args: BatchDeleteTracesArgs): Promise<void> {\n    try {\n      const keys = args.traceIds.map(traceId => ({ traceId }));\n      return this.#db.batchDelete({\n        tableName: TABLE_SPANS,\n        keys,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'BATCH_DELETE_TRACES', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { saveScorePayloadSchema } from '@mastra/core/evals';\nimport type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '@mastra/core/evals';\nimport {\n  createStorageErrorId,\n  TABLE_SCORERS,\n  SCORERS_SCHEMA,\n  ScoresStorage,\n  calculatePagination,\n  normalizePerPage,\n  transformScoreRow as coreTransformScoreRow,\n} from '@mastra/core/storage';\nimport type { StoragePagination } from '@mastra/core/storage';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { buildSelectColumns } from '../../db/utils';\n\nexport class ScoresLibSQL extends ScoresStorage {\n  #db: LibSQLDB;\n  #client: Client;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });\n  }\n\n  async init(): Promise<void> {\n    await this.#db.createTable({ tableName: TABLE_SCORERS, schema: SCORERS_SCHEMA });\n    // Add columns for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_SCORERS,\n      schema: SCORERS_SCHEMA,\n      ifNotExists: ['spanId', 'requestContext'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_SCORERS });\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE runId = ?`,\n        args: [runId],\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE runId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [runId, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_RUN_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    source,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      const conditions: string[] = [];\n      const queryParams: InValue[] = [];\n\n      if (scorerId) {\n        conditions.push(`scorerId = ?`);\n        queryParams.push(scorerId);\n      }\n\n      if (entityId) {\n        conditions.push(`entityId = ?`);\n        queryParams.push(entityId);\n      }\n\n      if (entityType) {\n        conditions.push(`entityType = ?`);\n        queryParams.push(entityType);\n      }\n\n      if (source) {\n        conditions.push(`source = ?`);\n        queryParams.push(source);\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} ${whereClause} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [...queryParams, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_SCORER_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * LibSQL-specific score row transformation.\n   */\n  private transformScoreRow(row: Record<string, any>): ScoreRowData {\n    return coreTransformScoreRow(row);\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    const result = await this.#client.execute({\n      sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE id = ?`,\n      args: [id],\n    });\n    return result.rows?.[0] ? this.transformScoreRow(result.rows[0]) : null;\n  }\n\n  async saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }> {\n    let parsedScore: SaveScorePayload;\n    try {\n      parsedScore = saveScorePayloadSchema.parse(score);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_SCORE', 'VALIDATION_FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            scorer: typeof score.scorer?.id === 'string' ? score.scorer.id : String(score.scorer?.id ?? 'unknown'),\n            entityId: score.entityId ?? 'unknown',\n            entityType: score.entityType ?? 'unknown',\n            traceId: score.traceId ?? '',\n            spanId: score.spanId ?? '',\n          },\n        },\n        error,\n      );\n    }\n\n    try {\n      const id = crypto.randomUUID();\n      const now = new Date();\n\n      await this.#db.insert({\n        tableName: TABLE_SCORERS,\n        record: {\n          ...parsedScore,\n          id,\n          createdAt: now.toISOString(),\n          updatedAt: now.toISOString(),\n        },\n      });\n\n      return { score: { ...parsedScore, id, createdAt: now, updatedAt: now } as ScoreRowData };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'SAVE_SCORE', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n\n      // Get total count first\n      const countResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE entityId = ? AND entityType = ?`,\n        args: [entityId, entityType],\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage: perPageInput,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE entityId = ? AND entityType = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [entityId, entityType, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_ENTITY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    try {\n      const { page, perPage: perPageInput } = pagination;\n      const perPage = normalizePerPage(perPageInput, 100);\n      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n      const countSQLResult = await this.#client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_SCORERS} WHERE traceId = ? AND spanId = ?`,\n        args: [traceId, spanId],\n      });\n\n      const total = Number(countSQLResult.rows?.[0]?.count ?? 0);\n\n      const limitValue = perPageInput === false ? total : perPage;\n      const end = perPageInput === false ? total : start + perPage;\n\n      const result = await this.#client.execute({\n        sql: `SELECT ${buildSelectColumns(TABLE_SCORERS)} FROM ${TABLE_SCORERS} WHERE traceId = ? AND spanId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [traceId, spanId, limitValue, start],\n      });\n\n      const scores = result.rows?.map(row => this.transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page,\n          perPage: perPageForResponse,\n          hasMore: end < total,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_SCORES_BY_SPAN', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type {\n  WorkflowRun,\n  WorkflowRuns,\n  StorageListWorkflowRunsInput,\n  UpdateWorkflowStateOptions,\n} from '@mastra/core/storage';\nimport {\n  createStorageErrorId,\n  normalizePerPage,\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_SCHEMAS,\n  WorkflowsStorage,\n} from '@mastra/core/storage';\nimport type { WorkflowRunState, StepResult } from '@mastra/core/workflows';\nimport { LibSQLDB, resolveClient } from '../../db';\nimport type { LibSQLDomainConfig } from '../../db';\nimport { createExecuteWriteOperationWithRetry } from '../../db/utils';\n\nexport class WorkflowsLibSQL extends WorkflowsStorage {\n  #db: LibSQLDB;\n  #client: Client;\n  private readonly executeWithRetry: <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;\n\n  constructor(config: LibSQLDomainConfig) {\n    super();\n    const client = resolveClient(config);\n    const maxRetries = config.maxRetries ?? 5;\n    const initialBackoffMs = config.initialBackoffMs ?? 500;\n\n    this.#client = client;\n    this.#db = new LibSQLDB({ client, maxRetries, initialBackoffMs });\n    this.executeWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries,\n      initialBackoffMs,\n    });\n\n    // Set PRAGMA settings to help with database locks\n    // Note: This is async but we can't await in constructor, so we'll handle it as a fire-and-forget\n    this.setupPragmaSettings().catch(err =>\n      this.logger.warn('LibSQL Workflows: Failed to setup PRAGMA settings.', err),\n    );\n  }\n\n  private parseWorkflowRun(row: Record<string, any>): WorkflowRun {\n    let parsedSnapshot: WorkflowRunState | string = row.snapshot as string;\n    if (typeof parsedSnapshot === 'string') {\n      try {\n        parsedSnapshot = JSON.parse(row.snapshot as string) as WorkflowRunState;\n      } catch (e) {\n        this.logger.warn(`Failed to parse snapshot for workflow ${row.workflow_name}: ${e}`);\n      }\n    }\n    return {\n      workflowName: row.workflow_name as string,\n      runId: row.run_id as string,\n      snapshot: parsedSnapshot,\n      resourceId: row.resourceId as string,\n      createdAt: new Date(row.createdAt as string),\n      updatedAt: new Date(row.updatedAt as string),\n    };\n  }\n\n  async init(): Promise<void> {\n    const schema = TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT];\n    await this.#db.createTable({ tableName: TABLE_WORKFLOW_SNAPSHOT, schema });\n    // Add resourceId column for backwards compatibility\n    await this.#db.alterTable({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      schema,\n      ifNotExists: ['resourceId'],\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    await this.#db.deleteData({ tableName: TABLE_WORKFLOW_SNAPSHOT });\n  }\n\n  private async setupPragmaSettings() {\n    try {\n      // Set busy timeout to wait longer before returning busy errors\n      await this.#client.execute('PRAGMA busy_timeout = 10000;');\n      this.logger.debug('LibSQL Workflows: PRAGMA busy_timeout=10000 set.');\n\n      // Enable WAL mode for better concurrency (if supported)\n      try {\n        await this.#client.execute('PRAGMA journal_mode = WAL;');\n        this.logger.debug('LibSQL Workflows: PRAGMA journal_mode=WAL set.');\n      } catch {\n        this.logger.debug('LibSQL Workflows: WAL mode not supported, using default journal mode.');\n      }\n\n      // Set synchronous mode for better durability vs performance trade-off\n      try {\n        await this.#client.execute('PRAGMA synchronous = NORMAL;');\n        this.logger.debug('LibSQL Workflows: PRAGMA synchronous=NORMAL set.');\n      } catch {\n        this.logger.debug('LibSQL Workflows: Failed to set synchronous mode.');\n      }\n    } catch (err) {\n      this.logger.warn('LibSQL Workflows: Failed to set PRAGMA settings.', err);\n    }\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    return this.executeWithRetry(async () => {\n      // Use a transaction to ensure atomicity\n      const tx = await this.#client.transaction('write');\n      try {\n        // Load existing snapshot within transaction\n        const existingSnapshotResult = await tx.execute({\n          sql: `SELECT json(snapshot) as snapshot FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n\n        let snapshot: WorkflowRunState;\n        if (!existingSnapshotResult.rows?.[0]) {\n          // Create new snapshot if none exists\n          snapshot = {\n            context: {},\n            activePaths: [],\n            timestamp: Date.now(),\n            suspendedPaths: {},\n            activeStepsPath: {},\n            resumeLabels: {},\n            serializedStepGraph: [],\n            status: 'pending',\n            value: {},\n            waitingPaths: {},\n            runId: runId,\n            requestContext: {},\n          } as WorkflowRunState;\n        } else {\n          // Parse existing snapshot\n          const existingSnapshot = existingSnapshotResult.rows[0].snapshot;\n          snapshot = typeof existingSnapshot === 'string' ? JSON.parse(existingSnapshot) : existingSnapshot;\n        }\n\n        // Merge the new step result and request context\n        snapshot.context[stepId] = result;\n        snapshot.requestContext = { ...snapshot.requestContext, ...requestContext };\n\n        // Upsert the snapshot within the same transaction\n        const now = new Date().toISOString();\n        await tx.execute({\n          sql: `INSERT INTO ${TABLE_WORKFLOW_SNAPSHOT} (workflow_name, run_id, snapshot, createdAt, updatedAt)\n                VALUES (?, ?, jsonb(?), ?, ?)\n                ON CONFLICT(workflow_name, run_id)\n                DO UPDATE SET snapshot = excluded.snapshot, updatedAt = excluded.updatedAt`,\n          args: [workflowName, runId, JSON.stringify(snapshot), now, now],\n        });\n\n        await tx.commit();\n        return snapshot.context;\n      } catch (error) {\n        if (!tx.closed) {\n          await tx.rollback();\n        }\n        throw error;\n      }\n    }, 'updateWorkflowResults');\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined> {\n    return this.executeWithRetry(async () => {\n      // Use a transaction to ensure atomicity\n      const tx = await this.#client.transaction('write');\n      try {\n        // Load existing snapshot within transaction\n        const existingSnapshotResult = await tx.execute({\n          sql: `SELECT json(snapshot) as snapshot FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n\n        if (!existingSnapshotResult.rows?.[0]) {\n          await tx.rollback();\n          return undefined;\n        }\n\n        // Parse existing snapshot\n        const existingSnapshot = existingSnapshotResult.rows[0].snapshot;\n        const snapshot = typeof existingSnapshot === 'string' ? JSON.parse(existingSnapshot) : existingSnapshot;\n\n        if (!snapshot || !snapshot?.context) {\n          await tx.rollback();\n          throw new Error(`Snapshot not found for runId ${runId}`);\n        }\n\n        // Merge the new options with the existing snapshot\n        const updatedSnapshot = { ...snapshot, ...opts };\n\n        // Update the snapshot within the same transaction\n        await tx.execute({\n          sql: `UPDATE ${TABLE_WORKFLOW_SNAPSHOT} SET snapshot = jsonb(?) WHERE workflow_name = ? AND run_id = ?`,\n          args: [JSON.stringify(updatedSnapshot), workflowName, runId],\n        });\n\n        await tx.commit();\n        return updatedSnapshot;\n      } catch (error) {\n        if (!tx.closed) {\n          await tx.rollback();\n        }\n        throw error;\n      }\n    }, 'updateWorkflowState');\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n    createdAt,\n    updatedAt,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }) {\n    const now = new Date();\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: createdAt ?? now,\n      updatedAt: updatedAt ?? now,\n    };\n\n    this.logger.debug('Persisting workflow snapshot', { workflowName, runId, data });\n    await this.#db.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.#db.select<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    return d ? d.snapshot : null;\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const conditions: string[] = [];\n    const args: (string | number)[] = [];\n\n    if (runId) {\n      conditions.push('run_id = ?');\n      args.push(runId);\n    }\n\n    if (workflowName) {\n      conditions.push('workflow_name = ?');\n      args.push(workflowName);\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const result = await this.#client.execute({\n        sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause} ORDER BY createdAt DESC LIMIT 1`,\n        args,\n      });\n\n      if (!result.rows?.[0]) {\n        return null;\n      }\n\n      return this.parseWorkflowRun(result.rows[0]);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'GET_WORKFLOW_RUN_BY_ID', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteWorkflowRunById({ runId, workflowName }: { runId: string; workflowName: string }): Promise<void> {\n    return this.executeWithRetry(async () => {\n      try {\n        await this.#client.execute({\n          sql: `DELETE FROM ${TABLE_WORKFLOW_SNAPSHOT} WHERE workflow_name = ? AND run_id = ?`,\n          args: [workflowName, runId],\n        });\n      } catch (error) {\n        throw new MastraError(\n          {\n            id: createStorageErrorId('LIBSQL', 'DELETE_WORKFLOW_RUN_BY_ID', 'FAILED'),\n            domain: ErrorDomain.STORAGE,\n            category: ErrorCategory.THIRD_PARTY,\n            details: { runId, workflowName },\n          },\n          error,\n        );\n      }\n    }, 'deleteWorkflowRunById');\n  }\n\n  async listWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    page,\n    perPage,\n    resourceId,\n    status,\n  }: StorageListWorkflowRunsInput = {}): Promise<WorkflowRuns> {\n    try {\n      const conditions: string[] = [];\n      const args: InValue[] = [];\n\n      if (workflowName) {\n        conditions.push('workflow_name = ?');\n        args.push(workflowName);\n      }\n\n      if (status) {\n        conditions.push(\"json_extract(snapshot, '$.status') = ?\");\n        args.push(status);\n      }\n\n      if (fromDate) {\n        conditions.push('createdAt >= ?');\n        args.push(fromDate.toISOString());\n      }\n\n      if (toDate) {\n        conditions.push('createdAt <= ?');\n        args.push(toDate.toISOString());\n      }\n\n      if (resourceId) {\n        const hasResourceId = await this.#db.hasColumn(TABLE_WORKFLOW_SNAPSHOT, 'resourceId');\n        if (hasResourceId) {\n          conditions.push('resourceId = ?');\n          args.push(resourceId);\n        } else {\n          this.logger.warn(`[${TABLE_WORKFLOW_SNAPSHOT}] resourceId column not found. Skipping resourceId filter.`);\n        }\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      let total = 0;\n      // Only get total count when using pagination\n      const usePagination = typeof perPage === 'number' && typeof page === 'number';\n      if (usePagination) {\n        const countResult = await this.#client.execute({\n          sql: `SELECT COUNT(*) as count FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause}`,\n          args,\n        });\n        total = Number(countResult.rows?.[0]?.count ?? 0);\n      }\n\n      // Get results\n      const normalizedPerPage = usePagination ? normalizePerPage(perPage, Number.MAX_SAFE_INTEGER) : 0;\n      const offset = usePagination ? page! * normalizedPerPage : 0;\n      const result = await this.#client.execute({\n        sql: `SELECT workflow_name, run_id, resourceId, json(snapshot) as snapshot, createdAt, updatedAt FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause} ORDER BY createdAt DESC${usePagination ? ` LIMIT ? OFFSET ?` : ''}`,\n        args: usePagination ? [...args, normalizedPerPage, offset] : args,\n      });\n\n      const runs = (result.rows || []).map(row => this.parseWorkflowRun(row));\n\n      // Use runs.length as total when not paginating\n      return { runs, total: total || runs.length };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: createStorageErrorId('LIBSQL', 'LIST_WORKFLOW_RUNS', 'FAILED'),\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import { createClient } from '@libsql/client';\nimport type { Client } from '@libsql/client';\nimport type { StorageDomains } from '@mastra/core/storage';\nimport { MastraStorage } from '@mastra/core/storage';\n\nimport { AgentsLibSQL } from './domains/agents';\nimport { MemoryLibSQL } from './domains/memory';\nimport { ObservabilityLibSQL } from './domains/observability';\nimport { ScoresLibSQL } from './domains/scores';\nimport { WorkflowsLibSQL } from './domains/workflows';\n\n// Export domain classes for direct use with MastraStorage composition\nexport { AgentsLibSQL, MemoryLibSQL, ObservabilityLibSQL, ScoresLibSQL, WorkflowsLibSQL };\nexport type { LibSQLDomainConfig } from './db';\n\n/**\n * Base configuration options shared across LibSQL configurations\n */\nexport type LibSQLBaseConfig = {\n  id: string;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   * This is useful for CI/CD pipelines where you want to:\n   * 1. Run migrations explicitly during deployment (not at runtime)\n   * 2. Use different credentials for schema changes vs runtime operations\n   *\n   * When disableInit is true:\n   * - The storage will not automatically create/alter tables on first use\n   * - You must call `storage.init()` explicitly in your CI/CD scripts\n   *\n   * @example\n   * // In CI/CD script:\n   * const storage = new LibSQLStore({ ...config, disableInit: false });\n   * await storage.init(); // Explicitly run migrations\n   *\n   * // In runtime application:\n   * const storage = new LibSQLStore({ ...config, disableInit: true });\n   * // No auto-init, tables must already exist\n   */\n  disableInit?: boolean;\n};\n\nexport type LibSQLConfig =\n  | (LibSQLBaseConfig & {\n      url: string;\n      authToken?: string;\n    })\n  | (LibSQLBaseConfig & {\n      client: Client;\n    });\n\n/**\n * LibSQL/Turso storage adapter for Mastra.\n *\n * Access domain-specific storage via `getStore()`:\n *\n * @example\n * ```typescript\n * const storage = new LibSQLStore({ id: 'my-store', url: 'file:./dev.db' });\n *\n * // Access memory domain\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n *\n * // Access workflows domain\n * const workflows = await storage.getStore('workflows');\n * await workflows?.persistWorkflowSnapshot({ workflowName, runId, snapshot });\n * ```\n */\nexport class LibSQLStore extends MastraStorage {\n  private client: Client;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  stores: StorageDomains;\n\n  constructor(config: LibSQLConfig) {\n    if (!config.id || typeof config.id !== 'string' || config.id.trim() === '') {\n      throw new Error('LibSQLStore: id must be provided and cannot be empty.');\n    }\n    super({ id: config.id, name: `LibSQLStore`, disableInit: config.disableInit });\n\n    this.maxRetries = config.maxRetries ?? 5;\n    this.initialBackoffMs = config.initialBackoffMs ?? 100;\n\n    if ('url' in config) {\n      // need to re-init every time for in memory dbs or the tables might not exist\n      if (config.url.endsWith(':memory:')) {\n        this.shouldCacheInit = false;\n      }\n\n      this.client = createClient({\n        url: config.url,\n        ...(config.authToken ? { authToken: config.authToken } : {}),\n      });\n\n      // Set PRAGMAs for better concurrency, especially for file-based databases\n      if (config.url.startsWith('file:') || config.url.includes(':memory:')) {\n        this.client\n          .execute('PRAGMA journal_mode=WAL;')\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n        this.client\n          .execute('PRAGMA busy_timeout = 5000;') // 5 seconds\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout.', err));\n      }\n    } else {\n      this.client = config.client;\n    }\n\n    const domainConfig = {\n      client: this.client,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    };\n\n    const scores = new ScoresLibSQL(domainConfig);\n    const workflows = new WorkflowsLibSQL(domainConfig);\n    const memory = new MemoryLibSQL(domainConfig);\n    const observability = new ObservabilityLibSQL(domainConfig);\n    const agents = new AgentsLibSQL(domainConfig);\n\n    this.stores = {\n      scores,\n      workflows,\n      memory,\n      observability,\n      agents,\n    };\n  }\n}\n\nexport { LibSQLStore as DefaultStorage };\n","/**\n * Vector store specific prompt that details supported operators and examples.\n * This prompt helps users construct valid filters for LibSQL Vector.\n */\nexport const LIBSQL_PROMPT = `When querying LibSQL Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Direct RegExp patterns will throw an error\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Basic operators handle array values as JSON strings\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$contains\": \"value\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 50 }, \"inStock\": true } } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n"]}