import type { Client, InValue } from '@libsql/client';
import { MastraBase } from '@mastra/core/base';
import type { TABLE_NAMES, StorageColumn } from '@mastra/core/storage';
/**
 * Base configuration options shared across LibSQL domain configurations
 */
export type LibSQLDomainBaseConfig = {
    /**
     * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.
     * @default 5
     */
    maxRetries?: number;
    /**
     * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.
     * The backoff time will double with each retry (exponential backoff).
     * @default 100
     */
    initialBackoffMs?: number;
};
/**
 * Configuration for LibSQL domains - accepts either credentials or an existing client
 */
export type LibSQLDomainConfig = (LibSQLDomainBaseConfig & {
    /** The database connection URL (e.g., "file:local.db", "libsql://...", "file::memory:") */
    url: string;
    /** Optional authentication token for remote databases */
    authToken?: string;
}) | (LibSQLDomainBaseConfig & {
    /** An existing LibSQL client instance */
    client: Client;
});
/**
 * Resolves a LibSQLDomainConfig to a Client instance.
 * Creates a new client if credentials are provided, or returns the existing client.
 *
 * @param config - The domain configuration
 * @returns The resolved LibSQL client
 */
export declare function resolveClient(config: LibSQLDomainConfig): Client;
export declare class LibSQLDB extends MastraBase {
    private client;
    maxRetries: number;
    initialBackoffMs: number;
    executeWriteOperationWithRetry: <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;
    constructor({ client, maxRetries, initialBackoffMs, }: {
        client: Client;
        maxRetries?: number;
        initialBackoffMs?: number;
    });
    /**
     * Checks if a column exists in the specified table.
     *
     * @param table - The name of the table to check
     * @param column - The name of the column to look for
     * @returns `true` if the column exists in the table, `false` otherwise
     */
    hasColumn(table: string, column: string): Promise<boolean>;
    /**
     * Internal insert implementation without retry logic.
     */
    private doInsert;
    /**
     * Inserts or replaces a record in the specified table with automatic retry on lock errors.
     *
     * @param args - The insert arguments
     * @param args.tableName - The name of the table to insert into
     * @param args.record - The record to insert (key-value pairs)
     */
    insert(args: {
        tableName: TABLE_NAMES;
        record: Record<string, any>;
    }): Promise<void>;
    /**
     * Internal update implementation without retry logic.
     */
    private doUpdate;
    /**
     * Updates a record in the specified table with automatic retry on lock errors.
     *
     * @param args - The update arguments
     * @param args.tableName - The name of the table to update
     * @param args.keys - The key(s) identifying the record to update
     * @param args.data - The fields to update (key-value pairs)
     */
    update(args: {
        tableName: TABLE_NAMES;
        keys: Record<string, any>;
        data: Record<string, any>;
    }): Promise<void>;
    /**
     * Internal batch insert implementation without retry logic.
     */
    private doBatchInsert;
    /**
     * Inserts multiple records in a single batch transaction with automatic retry on lock errors.
     *
     * @param args - The batch insert arguments
     * @param args.tableName - The name of the table to insert into
     * @param args.records - Array of records to insert
     * @throws {MastraError} When the batch insert fails after retries
     */
    batchInsert(args: {
        tableName: TABLE_NAMES;
        records: Record<string, any>[];
    }): Promise<void>;
    /**
     * Internal batch update implementation without retry logic.
     * Each record can be updated based on single or composite keys.
     */
    private doBatchUpdate;
    /**
     * Updates multiple records in a single batch transaction with automatic retry on lock errors.
     * Each record can be updated based on single or composite keys.
     *
     * @param args - The batch update arguments
     * @param args.tableName - The name of the table to update
     * @param args.updates - Array of update operations, each containing keys and data
     * @throws {MastraError} When the batch update fails after retries
     */
    batchUpdate(args: {
        tableName: TABLE_NAMES;
        updates: Array<{
            keys: Record<string, any>;
            data: Record<string, any>;
        }>;
    }): Promise<void>;
    /**
     * Internal batch delete implementation without retry logic.
     * Each record can be deleted based on single or composite keys.
     */
    private doBatchDelete;
    /**
     * Deletes multiple records in a single batch transaction with automatic retry on lock errors.
     * Each record can be deleted based on single or composite keys.
     *
     * @param args - The batch delete arguments
     * @param args.tableName - The name of the table to delete from
     * @param args.keys - Array of key objects identifying records to delete
     * @throws {MastraError} When the batch delete fails after retries
     */
    batchDelete({ tableName, keys, }: {
        tableName: TABLE_NAMES;
        keys: Array<Record<string, any>>;
    }): Promise<void>;
    /**
     * Internal single-record delete implementation without retry logic.
     */
    private doDelete;
    /**
     * Deletes a single record from the specified table with automatic retry on lock errors.
     *
     * @param args - The delete arguments
     * @param args.tableName - The name of the table to delete from
     * @param args.keys - The key(s) identifying the record to delete
     * @throws {MastraError} When the delete fails after retries
     */
    delete(args: {
        tableName: TABLE_NAMES;
        keys: Record<string, any>;
    }): Promise<void>;
    /**
     * Selects a single record from the specified table by key(s).
     * Returns the most recently created record if multiple matches exist.
     * Automatically parses JSON string values back to objects/arrays.
     *
     * @typeParam R - The expected return type of the record
     * @param args - The select arguments
     * @param args.tableName - The name of the table to select from
     * @param args.keys - The key(s) identifying the record to select
     * @returns The matching record or `null` if not found
     */
    select<R>({ tableName, keys }: {
        tableName: TABLE_NAMES;
        keys: Record<string, string>;
    }): Promise<R | null>;
    /**
     * Selects multiple records from the specified table with optional filtering, ordering, and pagination.
     *
     * @typeParam R - The expected return type of each record
     * @param args - The select arguments
     * @param args.tableName - The name of the table to select from
     * @param args.whereClause - Optional WHERE clause with SQL string and arguments
     * @param args.orderBy - Optional ORDER BY clause (e.g., "createdAt DESC")
     * @param args.offset - Optional offset for pagination
     * @param args.limit - Optional limit for pagination
     * @param args.args - Optional additional query arguments
     * @returns Array of matching records
     */
    selectMany<R>({ tableName, whereClause, orderBy, offset, limit, args, }: {
        tableName: TABLE_NAMES;
        whereClause?: {
            sql: string;
            args: InValue[];
        };
        orderBy?: string;
        offset?: number;
        limit?: number;
        args?: any[];
    }): Promise<R[]>;
    /**
     * Returns the total count of records matching the optional WHERE clause.
     *
     * @param args - The count arguments
     * @param args.tableName - The name of the table to count from
     * @param args.whereClause - Optional WHERE clause with SQL string and arguments
     * @returns The total count of matching records
     */
    selectTotalCount({ tableName, whereClause, }: {
        tableName: TABLE_NAMES;
        whereClause?: {
            sql: string;
            args: InValue[];
        };
    }): Promise<number>;
    /**
     * Maps a storage column type to its SQLite equivalent.
     */
    protected getSqlType(type: StorageColumn['type']): string;
    /**
     * Creates a table if it doesn't exist based on the provided schema.
     *
     * @param args - The create table arguments
     * @param args.tableName - The name of the table to create
     * @param args.schema - The schema definition for the table columns
     */
    createTable({ tableName, schema, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
    }): Promise<void>;
    /**
     * Migrates the spans table schema from OLD_SPAN_SCHEMA to current SPAN_SCHEMA.
     * This adds new columns that don't exist in old schema.
     */
    private migrateSpansTable;
    /**
     * Gets a default value for a column type (used when adding NOT NULL columns).
     */
    private getDefaultValue;
    /**
     * Alters an existing table to add missing columns.
     * Used for schema migrations when new columns are added.
     *
     * @param args - The alter table arguments
     * @param args.tableName - The name of the table to alter
     * @param args.schema - The full schema definition for the table
     * @param args.ifNotExists - Array of column names to add if they don't exist
     */
    alterTable({ tableName, schema, ifNotExists, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
        ifNotExists: string[];
    }): Promise<void>;
    /**
     * Deletes all records from the specified table.
     * Errors are logged but not thrown.
     *
     * @param args - The delete arguments
     * @param args.tableName - The name of the table to clear
     */
    deleteData({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map