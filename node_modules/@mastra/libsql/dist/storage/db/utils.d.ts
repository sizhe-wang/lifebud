import type { InValue } from '@libsql/client';
import type { IMastraLogger } from '@mastra/core/logger';
import type { StorageColumn, TABLE_NAMES } from '@mastra/core/storage';
/**
 * Builds a SQL column list for SELECT statements, wrapping JSONB columns with json()
 * to convert binary JSONB to TEXT.
 *
 * The json() function handles both:
 * - Binary JSONB data (converts to TEXT)
 * - Legacy TEXT JSON data (returns as-is)
 *
 * Note: json_valid() was considered for guarding against malformed legacy TEXT,
 * but it doesn't work correctly with binary JSONB data (returns false for valid JSONB blobs).
 *
 * @param tableName - The table name to get the schema for
 * @returns A comma-separated column list with json() wrappers for JSONB columns
 */
export declare function buildSelectColumns(tableName: TABLE_NAMES): string;
/**
 * Checks if an error is a SQLite lock/busy error that should be retried
 */
export declare function isLockError(error: any): boolean;
export declare function createExecuteWriteOperationWithRetry({ logger, maxRetries, initialBackoffMs, }: {
    logger: IMastraLogger;
    maxRetries: number;
    initialBackoffMs: number;
}): <T>(operationFn: () => Promise<T>, operationDescription: string) => Promise<T>;
export declare function prepareStatement({ tableName, record }: {
    tableName: TABLE_NAMES;
    record: Record<string, any>;
}): {
    sql: string;
    args: InValue[];
};
export declare function prepareUpdateStatement({ tableName, updates, keys, }: {
    tableName: TABLE_NAMES;
    updates: Record<string, any>;
    keys: Record<string, any>;
}): {
    sql: string;
    args: InValue[];
};
export declare function transformToSqlValue(value: any, forceJsonStringify?: boolean): InValue;
export declare function prepareDeleteStatement({ tableName, keys }: {
    tableName: TABLE_NAMES;
    keys: Record<string, any>;
}): {
    sql: string;
    args: InValue[];
};
type WhereValue = InValue | {
    startAt?: InValue;
    endAt?: InValue;
};
export declare function prepareWhereClause(filters: Record<string, WhereValue>, schema: Record<string, StorageColumn>): {
    sql: string;
    args: InValue[];
};
/**
 * Transforms SQL row data back to a typed object format
 * Reverses the transformations done in prepareStatement
 */
export declare function transformFromSqlRow<T>({ tableName, sqlRow, }: {
    tableName: TABLE_NAMES;
    sqlRow: Record<string, any>;
}): T;
export {};
//# sourceMappingURL=utils.d.ts.map