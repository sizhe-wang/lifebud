import { embedMany } from './_types/@internal_ai-sdk-v4/dist/index.js';
import type { MastraDBMessage } from '@mastra/core/agent';
import type { MemoryConfig, SharedMemoryConfig, StorageThreadType, WorkingMemoryTemplate, MessageDeleteInput } from '@mastra/core/memory';
import { MastraMemory } from '@mastra/core/memory';
import type { StorageListThreadsByResourceIdOutput, StorageListThreadsByResourceIdInput, StorageListMessagesInput, MemoryStorage, StorageCloneThreadInput, StorageCloneThreadOutput, ThreadCloneMetadata } from '@mastra/core/storage';
import type { ToolAction } from '@mastra/core/tools';
import { deepMergeWorkingMemory } from './tools/working-memory.js';
export { deepMergeWorkingMemory };
export { extractWorkingMemoryTags, extractWorkingMemoryContent, removeWorkingMemoryTags } from '@mastra/core/memory';
/**
 * Concrete implementation of MastraMemory that adds support for thread configuration
 * and message injection.
 */
export declare class Memory extends MastraMemory {
    constructor(config?: SharedMemoryConfig);
    /**
     * Gets the memory storage domain, throwing if not available.
     */
    protected getMemoryStore(): Promise<MemoryStorage>;
    protected validateThreadIsOwnedByResource(threadId: string, resourceId: string, config: MemoryConfig): Promise<void>;
    recall(args: StorageListMessagesInput & {
        threadConfig?: MemoryConfig;
        vectorSearchString?: string;
        threadId: string;
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    getThreadById({ threadId }: {
        threadId: string;
    }): Promise<StorageThreadType | null>;
    listThreadsByResourceId(args: StorageListThreadsByResourceIdInput): Promise<StorageListThreadsByResourceIdOutput>;
    private handleWorkingMemoryFromMetadata;
    saveThread({ thread, memoryConfig, }: {
        thread: StorageThreadType;
        memoryConfig?: MemoryConfig;
    }): Promise<StorageThreadType>;
    updateThread({ id, title, metadata, memoryConfig, }: {
        id: string;
        title: string;
        metadata: Record<string, unknown>;
        memoryConfig?: MemoryConfig;
    }): Promise<StorageThreadType>;
    deleteThread(threadId: string): Promise<void>;
    updateWorkingMemory({ threadId, resourceId, workingMemory, memoryConfig, }: {
        threadId: string;
        resourceId?: string;
        workingMemory: string;
        memoryConfig?: MemoryConfig;
    }): Promise<void>;
    private updateWorkingMemoryMutexes;
    /**
     * @warning experimental! can be removed or changed at any time
     */
    __experimental_updateWorkingMemoryVNext({ threadId, resourceId, workingMemory, searchString, memoryConfig, }: {
        threadId: string;
        resourceId?: string;
        workingMemory: string;
        searchString?: string;
        memoryConfig?: MemoryConfig;
    }): Promise<{
        success: boolean;
        reason: string;
    }>;
    protected chunkText(text: string, tokenSize?: number): string[];
    private hasher;
    private embeddingCache;
    private firstEmbed;
    protected embedMessageContent(content: string): Promise<{
        chunks: string[];
        embeddings: Awaited<ReturnType<typeof embedMany>>["embeddings"];
        dimension: number | undefined;
    }>;
    saveMessages({ messages, memoryConfig, }: {
        messages: MastraDBMessage[];
        memoryConfig?: MemoryConfig | undefined;
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    protected updateMessageToHideWorkingMemoryV2(message: MastraDBMessage): MastraDBMessage | null;
    protected parseWorkingMemory(text: string): string | null;
    getWorkingMemory({ threadId, resourceId, memoryConfig, }: {
        threadId: string;
        resourceId?: string;
        memoryConfig?: MemoryConfig;
    }): Promise<string | null>;
    /**
     * Gets the working memory template for the current memory configuration.
     * Supports both ZodObject and JSONSchema7 schemas.
     *
     * @param memoryConfig - The memory configuration containing the working memory settings
     * @returns The working memory template with format and content, or null if working memory is disabled
     */
    getWorkingMemoryTemplate({ memoryConfig, }: {
        memoryConfig?: MemoryConfig;
    }): Promise<WorkingMemoryTemplate | null>;
    getSystemMessage({ threadId, resourceId, memoryConfig, }: {
        threadId: string;
        resourceId?: string;
        memoryConfig?: MemoryConfig;
    }): Promise<string | null>;
    defaultWorkingMemoryTemplate: string;
    protected getWorkingMemoryToolInstruction({ template, data, }: {
        template: WorkingMemoryTemplate;
        data: string | null;
    }): string;
    protected __experimental_getWorkingMemoryToolInstructionVNext({ template, data, }: {
        template: WorkingMemoryTemplate;
        data: string | null;
    }): string;
    private isVNextWorkingMemoryConfig;
    listTools(config?: MemoryConfig): Record<string, ToolAction<any, any, any>>;
    /**
     * Updates a list of messages and syncs the vector database for semantic recall.
     * When message content is updated, the corresponding vector embeddings are also updated
     * to ensure semantic recall stays in sync with the message content.
     *
     * @param messages - The list of messages to update (must include id, can include partial content)
     * @param memoryConfig - Optional memory configuration to determine if semantic recall is enabled
     * @returns The list of updated messages
     */
    updateMessages({ messages, memoryConfig, }: {
        messages: (Partial<MastraDBMessage> & {
            id: string;
        })[];
        memoryConfig?: MemoryConfig;
    }): Promise<MastraDBMessage[]>;
    /**
     * Deletes one or more messages
     * @param input - Must be an array containing either:
     *   - Message ID strings
     *   - Message objects with 'id' properties
     * @returns Promise that resolves when all messages are deleted
     */
    deleteMessages(input: MessageDeleteInput): Promise<void>;
    /**
     * Clone a thread and its messages to create a new independent thread.
     * The cloned thread will have metadata tracking its source.
     *
     * If semantic recall is enabled, the cloned messages will also be embedded
     * and added to the vector store for semantic search.
     *
     * @param args - Clone configuration options
     * @param args.sourceThreadId - ID of the thread to clone
     * @param args.newThreadId - ID for the new cloned thread (if not provided, a random UUID will be generated)
     * @param args.resourceId - Resource ID for the new thread (defaults to source thread's resourceId)
     * @param args.title - Title for the new cloned thread
     * @param args.metadata - Additional metadata to merge with clone metadata
     * @param args.options - Options for filtering which messages to include
     * @param args.options.messageLimit - Maximum number of messages to copy (from most recent)
     * @param args.options.messageFilter - Filter messages by date range or specific IDs
     * @param memoryConfig - Optional memory configuration override
     * @returns The newly created thread and the cloned messages
     *
     * @example
     * ```typescript
     * // Clone entire thread
     * const { thread, clonedMessages } = await memory.cloneThread({
     *   sourceThreadId: 'thread-123',
     * });
     *
     * // Clone with custom ID
     * const { thread, clonedMessages } = await memory.cloneThread({
     *   sourceThreadId: 'thread-123',
     *   newThreadId: 'my-custom-thread-id',
     * });
     *
     * // Clone with message limit
     * const { thread, clonedMessages } = await memory.cloneThread({
     *   sourceThreadId: 'thread-123',
     *   title: 'My cloned conversation',
     *   options: {
     *     messageLimit: 10, // Only clone last 10 messages
     *   },
     * });
     *
     * // Clone with date filter
     * const { thread, clonedMessages } = await memory.cloneThread({
     *   sourceThreadId: 'thread-123',
     *   options: {
     *     messageFilter: {
     *       startDate: new Date('2024-01-01'),
     *       endDate: new Date('2024-06-01'),
     *     },
     *   },
     * });
     * ```
     */
    cloneThread(args: StorageCloneThreadInput, memoryConfig?: MemoryConfig): Promise<StorageCloneThreadOutput>;
    /**
     * Embed cloned messages for semantic recall.
     * This is similar to the embedding logic in saveMessages but operates on already-saved messages.
     */
    private embedClonedMessages;
    /**
     * Get the clone metadata from a thread if it was cloned from another thread.
     *
     * @param thread - The thread to check
     * @returns The clone metadata if the thread is a clone, null otherwise
     *
     * @example
     * ```typescript
     * const thread = await memory.getThreadById({ threadId: 'thread-123' });
     * const cloneInfo = memory.getCloneMetadata(thread);
     * if (cloneInfo) {
     *   console.log(`This thread was cloned from ${cloneInfo.sourceThreadId}`);
     * }
     * ```
     */
    getCloneMetadata(thread: StorageThreadType | null): ThreadCloneMetadata | null;
    /**
     * Check if a thread is a clone of another thread.
     *
     * @param thread - The thread to check
     * @returns True if the thread is a clone, false otherwise
     *
     * @example
     * ```typescript
     * const thread = await memory.getThreadById({ threadId: 'thread-123' });
     * if (memory.isClone(thread)) {
     *   console.log('This is a cloned thread');
     * }
     * ```
     */
    isClone(thread: StorageThreadType | null): boolean;
    /**
     * Get the source thread that a cloned thread was created from.
     *
     * @param threadId - ID of the cloned thread
     * @returns The source thread if found, null if the thread is not a clone or source doesn't exist
     *
     * @example
     * ```typescript
     * const sourceThread = await memory.getSourceThread('cloned-thread-123');
     * if (sourceThread) {
     *   console.log(`Original thread: ${sourceThread.title}`);
     * }
     * ```
     */
    getSourceThread(threadId: string): Promise<StorageThreadType | null>;
    /**
     * List all threads that were cloned from a specific source thread.
     *
     * @param sourceThreadId - ID of the source thread
     * @param resourceId - Optional resource ID to filter by
     * @returns Array of threads that are clones of the source thread
     *
     * @example
     * ```typescript
     * const clones = await memory.listClones('original-thread-123', 'user-456');
     * console.log(`Found ${clones.length} clones of this thread`);
     * ```
     */
    listClones(sourceThreadId: string, resourceId?: string): Promise<StorageThreadType[]>;
    /**
     * Get the clone history chain for a thread (all ancestors back to the original).
     *
     * @param threadId - ID of the thread to get history for
     * @returns Array of threads from oldest ancestor to the given thread (inclusive)
     *
     * @example
     * ```typescript
     * const history = await memory.getCloneHistory('deeply-cloned-thread');
     * // Returns: [originalThread, firstClone, secondClone, deeplyClonedThread]
     * ```
     */
    getCloneHistory(threadId: string): Promise<StorageThreadType[]>;
}
export { SemanticRecall, WorkingMemory, MessageHistory } from '@mastra/core/processors';
export type { StorageCloneThreadInput, StorageCloneThreadOutput, ThreadCloneMetadata } from '@mastra/core/storage';
//# sourceMappingURL=index.d.ts.map