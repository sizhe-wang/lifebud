import { validateBody, parseFilters } from './chunk-XWGAT2DA.js';
import { createPagePaginationSchema, baseLogMessageSchema, runIdSchema } from './chunk-HT4LP3BO.js';
import { createRoute } from './chunk-7S7ALPCY.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { __export } from './chunk-PR4QN5HX.js';
import z from 'zod';

// src/server/handlers/logs.ts
var logs_exports = {};
__export(logs_exports, {
  LIST_LOGS_BY_RUN_ID_ROUTE: () => LIST_LOGS_BY_RUN_ID_ROUTE,
  LIST_LOGS_ROUTE: () => LIST_LOGS_ROUTE,
  LIST_LOG_TRANSPORTS_ROUTE: () => LIST_LOG_TRANSPORTS_ROUTE
});
var listLogsQuerySchema = createPagePaginationSchema().extend({
  fromDate: z.coerce.date().optional(),
  toDate: z.coerce.date().optional(),
  logLevel: z.enum(["debug", "info", "warn", "error", "silent"]).optional(),
  filters: z.union([z.string(), z.array(z.string())]).optional(),
  transportId: z.string()
});
var listLogsResponseSchema = z.object({
  logs: z.array(baseLogMessageSchema),
  total: z.number(),
  page: z.number(),
  perPage: z.union([z.number(), z.literal(false)]),
  hasMore: z.boolean()
});
var listLogTransportsResponseSchema = z.object({
  transports: z.array(z.string())
});

// src/server/handlers/logs.ts
var LIST_LOG_TRANSPORTS_ROUTE = createRoute({
  method: "GET",
  path: "/api/logs/transports",
  responseType: "json",
  responseSchema: listLogTransportsResponseSchema,
  summary: "List log transports",
  description: "Returns a list of all available log transports",
  tags: ["Logs"],
  handler: async ({ mastra }) => {
    try {
      const logger = mastra.getLogger();
      const transports = logger.getTransports();
      return {
        transports: transports ? [...transports.keys()] : []
      };
    } catch (error) {
      return handleError(error, "Error getting log Transports");
    }
  }
});
var LIST_LOGS_ROUTE = createRoute({
  method: "GET",
  path: "/api/logs",
  responseType: "json",
  queryParamSchema: listLogsQuerySchema,
  responseSchema: listLogsResponseSchema,
  summary: "List logs",
  description: "Returns logs from a specific transport with optional filtering by date range, log level, and custom filters",
  tags: ["Logs"],
  handler: async ({ mastra, ...params }) => {
    try {
      const { transportId, fromDate, toDate, logLevel, filters: _filters, page, perPage } = params;
      validateBody({ transportId });
      const filters = parseFilters(_filters);
      const logs = await mastra.listLogs(transportId, {
        fromDate,
        toDate,
        logLevel,
        filters,
        page: page ? Number(page) : void 0,
        perPage: perPage ? Number(perPage) : void 0
      });
      return logs;
    } catch (error) {
      return handleError(error, "Error getting logs");
    }
  }
});
var LIST_LOGS_BY_RUN_ID_ROUTE = createRoute({
  method: "GET",
  path: "/api/logs/:runId",
  responseType: "json",
  pathParamSchema: runIdSchema,
  queryParamSchema: listLogsQuerySchema,
  responseSchema: listLogsResponseSchema,
  summary: "List logs by run ID",
  description: "Returns all logs for a specific execution run from a transport",
  tags: ["Logs"],
  handler: async ({ mastra, runId, ...params }) => {
    try {
      const { transportId, fromDate, toDate, logLevel, filters: _filters, page, perPage } = params;
      validateBody({ runId, transportId });
      const filters = parseFilters(_filters);
      const logs = await mastra.listLogsByRunId({
        runId,
        transportId,
        fromDate,
        toDate,
        logLevel,
        filters,
        page: page ? Number(page) : void 0,
        perPage: perPage ? Number(perPage) : void 0
      });
      return logs;
    } catch (error) {
      return handleError(error, "Error getting logs by run ID");
    }
  }
});

export { LIST_LOGS_BY_RUN_ID_ROUTE, LIST_LOGS_ROUTE, LIST_LOG_TRANSPORTS_ROUTE, logs_exports };
//# sourceMappingURL=chunk-3FEYUHHJ.js.map
//# sourceMappingURL=chunk-3FEYUHHJ.js.map