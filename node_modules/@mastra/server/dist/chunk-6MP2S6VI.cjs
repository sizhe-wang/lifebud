'use strict';

var chunk5W4RPVTK_cjs = require('./chunk-5W4RPVTK.cjs');
var chunkBRI4GUZ2_cjs = require('./chunk-BRI4GUZ2.cjs');
var chunkMCYD5LW7_cjs = require('./chunk-MCYD5LW7.cjs');
var chunkGU4EWMZB_cjs = require('./chunk-GU4EWMZB.cjs');
var chunkAVRO3FIN_cjs = require('./chunk-AVRO3FIN.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var tools = require('@mastra/core/tools');
var zodToJson = require('@mastra/core/utils/zod-to-json');

// src/server/handlers/tools.ts
var tools_exports = {};
chunkO7I5CWRX_cjs.__export(tools_exports, {
  EXECUTE_AGENT_TOOL_ROUTE: () => EXECUTE_AGENT_TOOL_ROUTE,
  EXECUTE_TOOL_ROUTE: () => EXECUTE_TOOL_ROUTE,
  GET_AGENT_TOOL_ROUTE: () => GET_AGENT_TOOL_ROUTE,
  GET_TOOL_BY_ID_ROUTE: () => GET_TOOL_BY_ID_ROUTE,
  LIST_TOOLS_ROUTE: () => LIST_TOOLS_ROUTE
});
var LIST_TOOLS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/tools",
  responseType: "json",
  responseSchema: chunkBRI4GUZ2_cjs.listToolsResponseSchema,
  summary: "List all tools",
  description: "Returns a list of all available tools in the system",
  tags: ["Tools"],
  handler: async ({ mastra, tools }) => {
    try {
      const allTools = tools || mastra.listTools() || {};
      const serializedTools = Object.entries(allTools).reduce(
        (acc, [id, _tool]) => {
          const tool = _tool;
          acc[id] = {
            ...tool,
            inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
            outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
          };
          return acc;
        },
        {}
      );
      return serializedTools;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting tools");
    }
  }
});
var GET_TOOL_BY_ID_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/tools/:toolId",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.toolIdPathParams,
  responseSchema: chunkBRI4GUZ2_cjs.serializedToolSchema,
  summary: "Get tool by ID",
  description: "Returns details for a specific tool including its schema and configuration",
  tags: ["Tools"],
  handler: async ({ mastra, tools, toolId }) => {
    try {
      let tool;
      if (tools && Object.keys(tools).length > 0) {
        tool = Object.values(tools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting tool");
    }
  }
});
var EXECUTE_TOOL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.toolIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.optionalRunIdSchema,
  bodySchema: chunkBRI4GUZ2_cjs.executeToolContextBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.executeToolResponseSchema,
  summary: "Execute tool",
  description: "Executes a specific tool with the provided input data",
  tags: ["Tools"],
  handler: async ({ mastra, runId, toolId, tools: tools$1, requestContext, ...bodyParams }) => {
    try {
      if (!toolId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool ID is required" });
      }
      let tool;
      if (tools$1 && Object.keys(tools$1).length > 0) {
        tool = Object.values(tools$1).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool is not executable" });
      }
      const { data } = bodyParams;
      chunk5W4RPVTK_cjs.validateBody({ data });
      if (tools.isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 },
        ...runId ? {
          workflow: {
            runId,
            suspend: async () => {
            }
          }
        } : {}
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error executing tool");
    }
  }
});
var GET_AGENT_TOOL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agents/:agentId/tools/:toolId",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentToolPathParams,
  responseSchema: chunkBRI4GUZ2_cjs.serializedToolSchema,
  summary: "Get agent tool",
  description: "Returns details for a specific tool assigned to the agent",
  tags: ["Agents", "Tools"],
  handler: async ({ mastra, agentId, toolId, requestContext }) => {
    try {
      const agent = agentId ? mastra.getAgentById(agentId) : null;
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent tool");
    }
  }
});
var EXECUTE_AGENT_TOOL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agents/:agentId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentToolPathParams,
  bodySchema: chunkBRI4GUZ2_cjs.executeToolBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.executeToolResponseSchema,
  summary: "Execute agent tool",
  description: "Executes a specific tool assigned to the agent with the provided input data",
  tags: ["Agents", "Tools"],
  handler: async ({ mastra, agentId, toolId, data, requestContext }) => {
    try {
      const agent = agentId ? mastra.getAgentById(agentId) : null;
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool is not executable" });
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 }
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error executing agent tool");
    }
  }
});

exports.EXECUTE_AGENT_TOOL_ROUTE = EXECUTE_AGENT_TOOL_ROUTE;
exports.EXECUTE_TOOL_ROUTE = EXECUTE_TOOL_ROUTE;
exports.GET_AGENT_TOOL_ROUTE = GET_AGENT_TOOL_ROUTE;
exports.GET_TOOL_BY_ID_ROUTE = GET_TOOL_BY_ID_ROUTE;
exports.LIST_TOOLS_ROUTE = LIST_TOOLS_ROUTE;
exports.tools_exports = tools_exports;
//# sourceMappingURL=chunk-6MP2S6VI.cjs.map
//# sourceMappingURL=chunk-6MP2S6VI.cjs.map