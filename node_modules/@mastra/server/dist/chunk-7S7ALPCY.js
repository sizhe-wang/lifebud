import { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';
import { z } from 'zod';

// src/server/server-adapter/openapi-utils.ts
function generateRouteOpenAPI({
  method,
  path,
  summary,
  description,
  tags = [],
  pathParamSchema,
  queryParamSchema,
  bodySchema,
  responseSchema,
  deprecated
}) {
  const route = {
    summary: summary || `${method} ${path}`,
    description,
    tags,
    deprecated,
    responses: {
      200: {
        description: "Successful response"
      }
    }
  };
  if (pathParamSchema || queryParamSchema) {
    route.requestParams = {};
    if (pathParamSchema) {
      route.requestParams.path = pathParamSchema;
    }
    if (queryParamSchema) {
      route.requestParams.query = queryParamSchema;
    }
  }
  if (bodySchema) {
    route.requestBody = {
      content: {
        "application/json": {
          schema: bodySchema
        }
      }
    };
  }
  if (responseSchema) {
    route.responses[200] = {
      description: "Successful response",
      content: {
        "application/json": {
          schema: responseSchema
        }
      }
    };
  }
  return route;
}
function convertZodToJsonSchema(spec) {
  const converted = {
    summary: spec.summary,
    description: spec.description,
    tags: spec.tags,
    responses: {}
  };
  const parameters = [];
  if (spec.requestParams?.path) {
    const pathSchema = zodToJsonSchema(spec.requestParams.path, "openApi3", "none");
    const properties = pathSchema.properties || {};
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "path",
        required: true,
        description: schema.description || `The ${name} parameter`,
        schema
      });
    });
  }
  if (spec.requestParams?.query) {
    const querySchema = zodToJsonSchema(spec.requestParams.query, "openApi3", "none");
    const properties = querySchema.properties || {};
    const required = querySchema.required || [];
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "query",
        required: required.includes(name),
        description: schema.description || `Query parameter: ${name}`,
        schema
      });
    });
  }
  if (parameters.length > 0) {
    converted.parameters = parameters;
  }
  if (spec.requestBody?.content?.["application/json"]?.schema) {
    converted.requestBody = {
      required: true,
      content: {
        "application/json": {
          schema: zodToJsonSchema(spec.requestBody.content["application/json"].schema, "openApi3", "none")
        }
      }
    };
  }
  Object.entries(spec.responses).forEach(([statusCode, response]) => {
    converted.responses[statusCode] = {
      description: response.description
    };
    if (response.content?.["application/json"]?.schema) {
      converted.responses[statusCode].content = {
        "application/json": {
          schema: zodToJsonSchema(response.content["application/json"].schema, "openApi3", "none")
        }
      };
    }
  });
  return converted;
}
function generateOpenAPIDocument(routes, info) {
  const paths = {};
  routes.forEach((route) => {
    if (!route.openapi) return;
    const openapiPath = route.path.replace(/:(\w+)/g, "{$1}");
    if (!paths[openapiPath]) {
      paths[openapiPath] = {};
    }
    paths[openapiPath][route.method.toLowerCase()] = convertZodToJsonSchema(route.openapi);
  });
  return {
    openapi: "3.1.0",
    info: {
      title: info.title,
      version: info.version,
      description: info.description
    },
    paths
  };
}
function pickParams(schema, params) {
  const keys = Object.keys(schema.shape);
  const result = {};
  for (const key of keys) {
    if (key in params) {
      result[key] = params[key];
    }
  }
  return result;
}
function jsonQueryParam(schema) {
  return z.union([
    schema,
    // Already the expected type (non-string input)
    z.string().transform((val, ctx) => {
      try {
        const parsed = JSON.parse(val);
        const result = schema.safeParse(parsed);
        if (!result.success) {
          for (const issue of result.error.issues) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: issue.message,
              path: issue.path
            });
          }
          return z.NEVER;
        }
        return result.data;
      } catch (e) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Invalid JSON: ${e instanceof Error ? e.message : "parse error"}`
        });
        return z.NEVER;
      }
    })
  ]);
}
function getZodTypeName(schema) {
  return schema?._def?.typeName;
}
function isComplexType(schema) {
  let inner = schema;
  let typeName = getZodTypeName(inner);
  while (typeName === "ZodOptional" || typeName === "ZodNullable") {
    inner = inner._def.innerType;
    typeName = getZodTypeName(inner);
  }
  return typeName === "ZodArray" || typeName === "ZodRecord" || typeName === "ZodObject";
}
function wrapSchemaForQueryParams(schema) {
  const newShape = {};
  for (const [key, fieldSchema] of Object.entries(schema.shape)) {
    if (isComplexType(fieldSchema)) {
      newShape[key] = jsonQueryParam(fieldSchema);
    } else {
      newShape[key] = fieldSchema;
    }
  }
  return z.object(newShape);
}
function createRoute(config) {
  const { summary, description, tags, deprecated, ...baseRoute } = config;
  const openapi = config.method !== "ALL" ? generateRouteOpenAPI({
    method: config.method,
    path: config.path,
    summary,
    description,
    tags,
    pathParamSchema: config.pathParamSchema,
    queryParamSchema: config.queryParamSchema,
    bodySchema: config.bodySchema,
    responseSchema: config.responseSchema,
    deprecated
  }) : void 0;
  return {
    ...baseRoute,
    openapi,
    deprecated
  };
}

export { createRoute, generateOpenAPIDocument, jsonQueryParam, pickParams, wrapSchemaForQueryParams };
//# sourceMappingURL=chunk-7S7ALPCY.js.map
//# sourceMappingURL=chunk-7S7ALPCY.js.map