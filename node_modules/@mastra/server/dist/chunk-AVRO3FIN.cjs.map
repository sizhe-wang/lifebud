{"version":3,"sources":["../src/server/server-adapter/openapi-utils.ts","../src/server/server-adapter/routes/route-builder.ts"],"names":["zodToJsonSchema","z"],"mappings":"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","file":"chunk-AVRO3FIN.cjs","sourcesContent":["import { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';\nimport type { ZodSchema } from 'zod';\nimport type { ServerRoute } from './routes';\n\ninterface RouteOpenAPIConfig {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  path: string;\n  summary?: string;\n  description?: string;\n  tags?: string[];\n  pathParamSchema?: ZodSchema;\n  queryParamSchema?: ZodSchema;\n  bodySchema?: ZodSchema;\n  responseSchema?: ZodSchema;\n  deprecated?: boolean;\n}\n\ninterface OpenAPIRoute {\n  summary?: string;\n  description?: string;\n  tags?: string[];\n  deprecated?: boolean;\n  requestParams?: {\n    path?: ZodSchema;\n    query?: ZodSchema;\n  };\n  requestBody?: {\n    content: {\n      'application/json': {\n        schema: ZodSchema;\n      };\n    };\n  };\n  responses: {\n    [statusCode: string]: {\n      description: string;\n      content?: {\n        'application/json': {\n          schema: ZodSchema;\n        };\n      };\n    };\n  };\n}\n\n/**\n * Generates OpenAPI specification for a single route\n * Extracts path parameters, query parameters, request body, and response schemas\n */\nexport function generateRouteOpenAPI({\n  method,\n  path,\n  summary,\n  description,\n  tags = [],\n  pathParamSchema,\n  queryParamSchema,\n  bodySchema,\n  responseSchema,\n  deprecated,\n}: RouteOpenAPIConfig): OpenAPIRoute {\n  const route: OpenAPIRoute = {\n    summary: summary || `${method} ${path}`,\n    description,\n    tags,\n    deprecated,\n    responses: {\n      200: {\n        description: 'Successful response',\n      },\n    },\n  };\n\n  // Add path and query parameters\n  if (pathParamSchema || queryParamSchema) {\n    route.requestParams = {};\n\n    if (pathParamSchema) {\n      route.requestParams.path = pathParamSchema;\n    }\n\n    if (queryParamSchema) {\n      route.requestParams.query = queryParamSchema;\n    }\n  }\n\n  // Add request body with raw Zod schema\n  if (bodySchema) {\n    route.requestBody = {\n      content: {\n        'application/json': {\n          schema: bodySchema,\n        },\n      },\n    };\n  }\n\n  // Add response schema with raw Zod schema\n  if (responseSchema) {\n    route.responses[200] = {\n      description: 'Successful response',\n      content: {\n        'application/json': {\n          schema: responseSchema,\n        },\n      },\n    };\n  }\n\n  return route;\n}\n\n/**\n * Converts an OpenAPI route spec with Zod schemas to one with JSON Schema\n */\nfunction convertZodToJsonSchema(spec: OpenAPIRoute): any {\n  const converted: any = {\n    summary: spec.summary,\n    description: spec.description,\n    tags: spec.tags,\n    responses: {},\n  };\n\n  const parameters: any[] = [];\n\n  // Convert path parameters\n  if (spec.requestParams?.path) {\n    const pathSchema = zodToJsonSchema(spec.requestParams.path, 'openApi3', 'none') as any;\n    const properties = pathSchema.properties || {};\n\n    Object.entries(properties).forEach(([name, schema]) => {\n      parameters.push({\n        name,\n        in: 'path',\n        required: true,\n        description: (schema as any).description || `The ${name} parameter`,\n        schema,\n      });\n    });\n  }\n\n  // Convert query parameters\n  if (spec.requestParams?.query) {\n    const querySchema = zodToJsonSchema(spec.requestParams.query, 'openApi3', 'none') as any;\n    const properties = querySchema.properties || {};\n    const required = querySchema.required || [];\n\n    Object.entries(properties).forEach(([name, schema]) => {\n      parameters.push({\n        name,\n        in: 'query',\n        required: required.includes(name),\n        description: (schema as any).description || `Query parameter: ${name}`,\n        schema,\n      });\n    });\n  }\n\n  if (parameters.length > 0) {\n    converted.parameters = parameters;\n  }\n\n  // Convert request body\n  if (spec.requestBody?.content?.['application/json']?.schema) {\n    converted.requestBody = {\n      required: true,\n      content: {\n        'application/json': {\n          schema: zodToJsonSchema(spec.requestBody.content['application/json'].schema, 'openApi3', 'none'),\n        },\n      },\n    };\n  }\n\n  // Convert response schemas\n  Object.entries(spec.responses).forEach(([statusCode, response]) => {\n    converted.responses[statusCode] = {\n      description: response.description,\n    };\n\n    if (response.content?.['application/json']?.schema) {\n      converted.responses[statusCode].content = {\n        'application/json': {\n          schema: zodToJsonSchema(response.content['application/json'].schema, 'openApi3', 'none'),\n        },\n      };\n    }\n  });\n\n  return converted;\n}\n\n/**\n * Generates a complete OpenAPI 3.1.0 document from server routes\n * @param routes - Array of ServerRoute objects with OpenAPI specifications\n * @param info - API metadata (title, version, description)\n * @returns Complete OpenAPI 3.1.0 document\n */\nexport function generateOpenAPIDocument(\n  routes: ServerRoute[],\n  info: { title: string; version: string; description?: string },\n): any {\n  const paths: Record<string, any> = {};\n\n  // Build paths object from routes\n  // Convert Express-style :param to OpenAPI-style {param}\n  routes.forEach(route => {\n    if (!route.openapi) return;\n\n    const openapiPath = route.path.replace(/:(\\w+)/g, '{$1}');\n    if (!paths[openapiPath]) {\n      paths[openapiPath] = {};\n    }\n\n    // Convert Zod schemas to JSON Schema\n    paths[openapiPath][route.method.toLowerCase()] = convertZodToJsonSchema(route.openapi);\n  });\n\n  return {\n    openapi: '3.1.0',\n    info: {\n      title: info.title,\n      version: info.version,\n      description: info.description,\n    },\n    paths,\n  };\n}\n","import { z } from 'zod';\nimport type { ZodObject, ZodRawShape, ZodTypeAny } from 'zod';\nimport { generateRouteOpenAPI } from '../openapi-utils';\nimport type { InferParams, ResponseType, ServerRoute, ServerRouteHandler } from './index';\n\n/**\n * Extracts parameters matching a Zod schema's shape from a params object.\n * Useful for separating schema-defined params from ServerContext in handlers.\n *\n * @example\n * ```typescript\n * const querySchema = z.object({ page: z.number(), name: z.string() });\n *\n * handler: async (params) => {\n *   const query = pickParams(querySchema, params);\n *   // query is typed as { page: number, name: string }\n * }\n * ```\n */\nexport function pickParams<T extends z.ZodRawShape, P extends Record<string, unknown>>(\n  schema: z.ZodObject<T>,\n  params: P,\n): z.infer<z.ZodObject<T>> {\n  const keys = Object.keys(schema.shape);\n  const result = {} as z.infer<z.ZodObject<T>>;\n  for (const key of keys) {\n    if (key in params) {\n      (result as any)[key] = params[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Wraps a Zod schema to accept either the expected type OR a JSON string.\n * Used for complex query parameters (arrays, objects) that are serialized as JSON in URLs.\n *\n * - If input is already the expected type, passes through to schema validation\n * - If input is a string, attempts JSON.parse then validates\n * - Provides clear error messages for JSON parse failures\n *\n * @example\n * ```typescript\n * const tagsSchema = jsonQueryParam(z.array(z.string()));\n * // Accepts: [\"tag1\", \"tag2\"] OR '[\"tag1\", \"tag2\"]'\n *\n * const dateRangeSchema = jsonQueryParam(z.object({ gte: z.coerce.date() }));\n * // Accepts: { gte: \"2024-01-01\" } OR '{\"gte\": \"2024-01-01\"}'\n * ```\n */\nexport function jsonQueryParam<T extends ZodTypeAny>(schema: T): z.ZodType<z.infer<T>> {\n  return z.union([\n    schema, // Already the expected type (non-string input)\n    z.string().transform((val, ctx) => {\n      try {\n        const parsed = JSON.parse(val);\n        const result = schema.safeParse(parsed);\n        if (!result.success) {\n          for (const issue of result.error.issues) {\n            ctx.addIssue({\n              code: z.ZodIssueCode.custom,\n              message: issue.message,\n              path: issue.path,\n            });\n          }\n          return z.NEVER;\n        }\n        return result.data;\n      } catch (e) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Invalid JSON: ${e instanceof Error ? e.message : 'parse error'}`,\n        });\n        return z.NEVER;\n      }\n    }),\n  ]) as z.ZodType<z.infer<T>>;\n}\n\n/**\n * Gets the type name from a Zod schema's internal definition.\n * Works across zod v3 and v4 by checking _def.typeName.\n */\nfunction getZodTypeName(schema: ZodTypeAny): string | undefined {\n  return (schema as any)?._def?.typeName;\n}\n\n/**\n * Checks if a Zod schema represents a complex type that needs JSON parsing from query strings.\n * Complex types: arrays, objects, records (these can't be represented as simple strings)\n * Simple types: strings, numbers, booleans, enums (can use z.coerce for conversion)\n *\n * Uses _def.typeName string comparison instead of instanceof to support both zod v3 and v4,\n * since instanceof checks fail across different zod versions in bundled code.\n */\nfunction isComplexType(schema: ZodTypeAny): boolean {\n  // Unwrap all optional/nullable layers to check the inner type\n  // Note: .partial() can create nested optionals (e.g., ZodOptional<ZodOptional<ZodObject>>)\n  let inner: ZodTypeAny = schema;\n  let typeName = getZodTypeName(inner);\n\n  while (typeName === 'ZodOptional' || typeName === 'ZodNullable') {\n    // Access innerType directly from _def to avoid version-specific method differences\n    inner = (inner as any)._def.innerType;\n    typeName = getZodTypeName(inner);\n  }\n\n  // Complex types that need JSON parsing\n  return typeName === 'ZodArray' || typeName === 'ZodRecord' || typeName === 'ZodObject';\n}\n\n/**\n * Wraps a Zod object schema for HTTP query parameter handling.\n * Automatically detects complex fields (arrays, objects, records) and wraps them\n * with jsonQueryParam() to accept JSON strings from query parameters.\n *\n * Simple fields (strings, numbers, booleans, enums) are left unchanged and should\n * use z.coerce for string-to-type conversion.\n *\n * @example\n * ```typescript\n * // Base schema (for internal/storage use)\n * const tracesFilterSchema = z.object({\n *   tags: z.array(z.string()).optional(),\n *   startedAt: dateRangeSchema.optional(),\n *   perPage: z.coerce.number().optional(),\n * });\n *\n * // HTTP schema (accepts JSON strings for complex fields)\n * const httpTracesFilterSchema = wrapSchemaForQueryParams(tracesFilterSchema);\n *\n * // Now accepts:\n * // ?tags=[\"tag1\",\"tag2\"]&startedAt={\"gte\":\"2024-01-01\"}&perPage=10\n * ```\n */\nexport function wrapSchemaForQueryParams<T extends ZodRawShape>(schema: ZodObject<T>): ZodObject<ZodRawShape> {\n  const newShape: ZodRawShape = {};\n\n  for (const [key, fieldSchema] of Object.entries(schema.shape)) {\n    if (isComplexType(fieldSchema as ZodTypeAny)) {\n      // Wrap complex types to accept JSON strings\n      newShape[key] = jsonQueryParam(fieldSchema as ZodTypeAny);\n    } else {\n      // Keep simple types as-is\n      newShape[key] = fieldSchema as ZodTypeAny;\n    }\n  }\n\n  return z.object(newShape);\n}\n\ninterface RouteConfig<\n  TPathSchema extends z.ZodTypeAny | undefined = undefined,\n  TQuerySchema extends z.ZodTypeAny | undefined = undefined,\n  TBodySchema extends z.ZodTypeAny | undefined = undefined,\n  TResponseSchema extends z.ZodTypeAny | undefined = undefined,\n  TResponseType extends ResponseType = 'json',\n> {\n  method: ServerRoute['method'];\n  path: string;\n  responseType: TResponseType;\n  streamFormat?: 'sse' | 'stream'; // Only used when responseType is 'stream'\n  handler: ServerRouteHandler<\n    InferParams<TPathSchema, TQuerySchema, TBodySchema>,\n    TResponseSchema extends z.ZodTypeAny ? z.infer<TResponseSchema> : unknown,\n    TResponseType\n  >;\n  pathParamSchema?: TPathSchema;\n  queryParamSchema?: TQuerySchema;\n  bodySchema?: TBodySchema;\n  responseSchema?: TResponseSchema;\n  summary?: string;\n  description?: string;\n  tags?: string[];\n  deprecated?: boolean;\n  maxBodySize?: number;\n}\n\n/**\n * Creates a server route with auto-generated OpenAPI specification and type-safe handler inference.\n *\n * The handler parameters are automatically inferred from the provided schemas:\n * - pathParamSchema: Infers path parameter types (e.g., :agentId)\n * - queryParamSchema: Infers query parameter types\n * - bodySchema: Infers request body types\n * - Runtime context (mastra, requestContext, tools, taskStore) is always available\n *\n * @param config - Route configuration including schemas, handler, and metadata\n * @returns Complete ServerRoute with OpenAPI spec\n *\n * @example\n * ```typescript\n * export const getAgentRoute = createRoute({\n *   method: 'GET',\n *   path: '/api/agents/:agentId',\n *   responseType: 'json',\n *   pathParamSchema: z.object({ agentId: z.string() }),\n *   responseSchema: serializedAgentSchema,\n *   handler: async ({ agentId, mastra, requestContext }) => {\n *     // agentId is typed as string\n *     // mastra, requestContext, tools, taskStore are always available\n *     return mastra.getAgentById(agentId);\n *   },\n *   summary: 'Get agent by ID',\n *   description: 'Returns details for a specific agent',\n *   tags: ['Agents'],\n * });\n * ```\n */\nexport function createRoute<\n  TPathSchema extends z.ZodTypeAny | undefined = undefined,\n  TQuerySchema extends z.ZodTypeAny | undefined = undefined,\n  TBodySchema extends z.ZodTypeAny | undefined = undefined,\n  TResponseSchema extends z.ZodTypeAny | undefined = undefined,\n  TResponseType extends ResponseType = 'json',\n>(\n  config: RouteConfig<TPathSchema, TQuerySchema, TBodySchema, TResponseSchema, TResponseType>,\n): ServerRoute<\n  InferParams<TPathSchema, TQuerySchema, TBodySchema>,\n  TResponseSchema extends z.ZodTypeAny ? z.infer<TResponseSchema> : unknown,\n  TResponseType\n> {\n  const { summary, description, tags, deprecated, ...baseRoute } = config;\n\n  // Generate OpenAPI specification from the route config\n  // Skip OpenAPI generation for 'ALL' method as it doesn't map to OpenAPI\n  const openapi =\n    config.method !== 'ALL'\n      ? generateRouteOpenAPI({\n          method: config.method as 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH',\n          path: config.path,\n          summary,\n          description,\n          tags,\n          pathParamSchema: config.pathParamSchema,\n          queryParamSchema: config.queryParamSchema,\n          bodySchema: config.bodySchema,\n          responseSchema: config.responseSchema,\n          deprecated,\n        })\n      : undefined;\n\n  return {\n    ...baseRoute,\n    openapi: openapi as any,\n    deprecated,\n  };\n}\n"]}