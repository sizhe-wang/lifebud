import { createPagePaginationSchema, paginationInfoSchema } from './chunk-HT4LP3BO.js';
import { createRoute } from './chunk-7S7ALPCY.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import z from 'zod';

var storedAgentIdPathParams = z.object({
  storedAgentId: z.string().describe("Unique identifier for the stored agent")
});
var storageOrderBySchema = z.object({
  field: z.enum(["createdAt", "updatedAt"]).optional(),
  direction: z.enum(["ASC", "DESC"]).optional()
});
var listStoredAgentsQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema.optional()
});
var scorerConfigSchema = z.object({
  sampling: z.object({
    type: z.enum(["ratio", "count"]),
    rate: z.number().optional(),
    count: z.number().optional()
  }).optional()
});
var storedAgentBaseSchema = z.object({
  name: z.string().describe("Name of the agent"),
  description: z.string().optional().describe("Description of the agent"),
  instructions: z.string().describe("System instructions for the agent"),
  model: z.record(z.string(), z.unknown()).describe("Model configuration (provider, name, etc.)"),
  tools: z.array(z.string()).optional().describe("Array of tool keys to resolve from Mastra registry"),
  defaultOptions: z.record(z.string(), z.unknown()).optional().describe("Default options for generate/stream calls"),
  workflows: z.array(z.string()).optional().describe("Array of workflow keys to resolve from Mastra registry"),
  agents: z.array(z.string()).optional().describe("Array of agent keys to resolve from Mastra registry"),
  inputProcessors: z.array(z.record(z.string(), z.unknown())).optional().describe("Input processor configurations"),
  outputProcessors: z.array(z.record(z.string(), z.unknown())).optional().describe("Output processor configurations"),
  memory: z.string().optional().describe("Memory key to resolve from Mastra registry"),
  scorers: z.record(z.string(), scorerConfigSchema).optional().describe("Scorer keys with optional sampling config"),
  metadata: z.record(z.string(), z.unknown()).optional().describe("Additional metadata for the agent")
});
var createStoredAgentBodySchema = storedAgentBaseSchema.extend({
  id: z.string().describe("Unique identifier for the agent")
});
var updateStoredAgentBodySchema = storedAgentBaseSchema.partial();
var storedAgentSchema = storedAgentBaseSchema.extend({
  id: z.string(),
  createdAt: z.date(),
  updatedAt: z.date()
});
var listStoredAgentsResponseSchema = paginationInfoSchema.extend({
  agents: z.array(storedAgentSchema)
});
var getStoredAgentResponseSchema = storedAgentSchema;
var createStoredAgentResponseSchema = storedAgentSchema;
var updateStoredAgentResponseSchema = storedAgentSchema;
var deleteStoredAgentResponseSchema = z.object({
  success: z.boolean(),
  message: z.string()
});

// src/server/handlers/stored-agents.ts
var LIST_STORED_AGENTS_ROUTE = createRoute({
  method: "GET",
  path: "/api/stored/agents",
  responseType: "json",
  queryParamSchema: listStoredAgentsQuerySchema,
  responseSchema: listStoredAgentsResponseSchema,
  summary: "List stored agents",
  description: "Returns a paginated list of all agents stored in the database",
  tags: ["Stored Agents"],
  handler: async ({ mastra, page, perPage, orderBy }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const result = await agentsStore.listAgents({
        page,
        perPage,
        orderBy
      });
      return result;
    } catch (error) {
      return handleError(error, "Error listing stored agents");
    }
  }
});
var GET_STORED_AGENT_ROUTE = createRoute({
  method: "GET",
  path: "/api/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  responseSchema: getStoredAgentResponseSchema,
  summary: "Get stored agent by ID",
  description: "Returns a specific agent from storage by its unique identifier",
  tags: ["Stored Agents"],
  handler: async ({ mastra, storedAgentId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getAgentById({ id: storedAgentId });
      if (!agent) {
        throw new HTTPException(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      return agent;
    } catch (error) {
      return handleError(error, "Error getting stored agent");
    }
  }
});
var CREATE_STORED_AGENT_ROUTE = createRoute({
  method: "POST",
  path: "/api/stored/agents",
  responseType: "json",
  bodySchema: createStoredAgentBodySchema,
  responseSchema: createStoredAgentResponseSchema,
  summary: "Create stored agent",
  description: "Creates a new agent in storage with the provided configuration",
  tags: ["Stored Agents"],
  handler: async ({
    mastra,
    id,
    name,
    description,
    instructions,
    model,
    tools,
    defaultOptions,
    workflows,
    agents,
    inputProcessors,
    outputProcessors,
    memory,
    scorers,
    metadata
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const existing = await agentsStore.getAgentById({ id });
      if (existing) {
        throw new HTTPException(409, { message: `Agent with id ${id} already exists` });
      }
      const toolsFromBody = Array.isArray(tools) ? tools : void 0;
      const agent = await agentsStore.createAgent({
        agent: {
          id,
          name,
          description,
          instructions,
          model,
          tools: toolsFromBody,
          defaultOptions,
          workflows,
          agents,
          inputProcessors,
          outputProcessors,
          memory,
          scorers,
          metadata
        }
      });
      return agent;
    } catch (error) {
      return handleError(error, "Error creating stored agent");
    }
  }
});
var UPDATE_STORED_AGENT_ROUTE = createRoute({
  method: "PATCH",
  path: "/api/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  bodySchema: updateStoredAgentBodySchema,
  responseSchema: updateStoredAgentResponseSchema,
  summary: "Update stored agent",
  description: "Updates an existing agent in storage with the provided fields",
  tags: ["Stored Agents"],
  handler: async ({
    mastra,
    storedAgentId,
    name,
    description,
    instructions,
    model,
    tools,
    defaultOptions,
    workflows,
    agents,
    inputProcessors,
    outputProcessors,
    memory,
    scorers,
    metadata
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const existing = await agentsStore.getAgentById({ id: storedAgentId });
      if (!existing) {
        throw new HTTPException(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      const toolsFromBody = Array.isArray(tools) ? tools : void 0;
      const agent = await agentsStore.updateAgent({
        id: storedAgentId,
        name,
        description,
        instructions,
        model,
        tools: toolsFromBody,
        defaultOptions,
        workflows,
        agents,
        inputProcessors,
        outputProcessors,
        memory,
        scorers,
        metadata
      });
      return agent;
    } catch (error) {
      return handleError(error, "Error updating stored agent");
    }
  }
});
var DELETE_STORED_AGENT_ROUTE = createRoute({
  method: "DELETE",
  path: "/api/stored/agents/:storedAgentId",
  responseType: "json",
  pathParamSchema: storedAgentIdPathParams,
  responseSchema: deleteStoredAgentResponseSchema,
  summary: "Delete stored agent",
  description: "Deletes an agent from storage by its unique identifier",
  tags: ["Stored Agents"],
  handler: async ({ mastra, storedAgentId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const existing = await agentsStore.getAgentById({ id: storedAgentId });
      if (!existing) {
        throw new HTTPException(404, { message: `Stored agent with id ${storedAgentId} not found` });
      }
      await agentsStore.deleteAgent({ id: storedAgentId });
      return { success: true, message: `Agent ${storedAgentId} deleted successfully` };
    } catch (error) {
      return handleError(error, "Error deleting stored agent");
    }
  }
});

export { CREATE_STORED_AGENT_ROUTE, DELETE_STORED_AGENT_ROUTE, GET_STORED_AGENT_ROUTE, LIST_STORED_AGENTS_ROUTE, UPDATE_STORED_AGENT_ROUTE };
//# sourceMappingURL=chunk-CGIGPJRU.js.map
//# sourceMappingURL=chunk-CGIGPJRU.js.map