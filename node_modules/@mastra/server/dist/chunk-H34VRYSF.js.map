{"version":3,"sources":["../src/server/handlers/voice.ts"],"names":[],"mappings":"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","file":"chunk-H34VRYSF.js","sourcesContent":["import { Readable } from 'node:stream';\nimport { MastraError } from '@mastra/core/error';\nimport { HTTPException } from '../http-exception';\nimport {\n  agentIdPathParams,\n  voiceSpeakersResponseSchema,\n  generateSpeechBodySchema,\n  speakResponseSchema,\n  transcribeSpeechBodySchema,\n  transcribeSpeechResponseSchema,\n  getListenerResponseSchema,\n} from '../schemas/agents';\nimport { createRoute } from '../server-adapter/routes/route-builder';\n\nimport { handleError } from './error';\nimport { validateBody } from './utils';\n\n// ============================================================================\n// Route Objects\n// ============================================================================\n\nexport const GET_SPEAKERS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/agents/:agentId/voice/speakers',\n  responseType: 'json',\n  pathParamSchema: agentIdPathParams,\n  responseSchema: voiceSpeakersResponseSchema,\n  summary: 'Get voice speakers',\n  description: 'Returns available voice speakers for the specified agent',\n  tags: ['Agents', 'Voice'],\n  handler: async ({ mastra, agentId, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n\n      const agent = mastra.getAgentById(agentId);\n\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const voice = await agent.getVoice({ requestContext });\n\n      const speakers = await Promise.resolve()\n        .then(() => voice.getSpeakers())\n        .catch(err => {\n          if (err instanceof MastraError) {\n            // No voice provider configured, return empty array\n            return [];\n          }\n          throw err;\n        });\n\n      return speakers;\n    } catch (error) {\n      return handleError(error, 'Error getting speakers');\n    }\n  },\n});\n\nexport const GET_SPEAKERS_DEPRECATED_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/agents/:agentId/speakers',\n  responseType: 'json',\n  pathParamSchema: agentIdPathParams,\n  responseSchema: voiceSpeakersResponseSchema,\n  summary: 'Get available speakers for an agent',\n  description: '[DEPRECATED] Use /api/agents/:agentId/voice/speakers instead. Get available speakers for an agent',\n  tags: ['Agents', 'Voice'],\n  handler: GET_SPEAKERS_ROUTE.handler,\n});\n\nexport const GENERATE_SPEECH_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/agents/:agentId/voice/speak',\n  responseType: 'stream',\n  pathParamSchema: agentIdPathParams,\n  bodySchema: generateSpeechBodySchema,\n  responseSchema: speakResponseSchema,\n  summary: 'Generate speech',\n  description: 'Generates speech audio from text using the agent voice configuration',\n  tags: ['Agents', 'Voice'],\n  handler: async ({ mastra, agentId, text, speakerId, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n\n      validateBody({ text });\n\n      const agent = mastra.getAgentById(agentId);\n\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const voice = await agent.getVoice({ requestContext });\n\n      if (!voice) {\n        throw new HTTPException(400, { message: 'Agent does not have voice capabilities' });\n      }\n\n      const audioStream = await Promise.resolve()\n        .then(() => voice.speak(text!, { speaker: speakerId! }))\n        .catch(err => {\n          if (err instanceof MastraError) {\n            throw new HTTPException(400, { message: err.message });\n          }\n\n          throw err;\n        });\n\n      if (!audioStream) {\n        throw new HTTPException(500, { message: 'Failed to generate speech' });\n      }\n\n      return audioStream as unknown as ReadableStream<any>;\n    } catch (error) {\n      return handleError(error, 'Error generating speech');\n    }\n  },\n});\n\nexport const GENERATE_SPEECH_DEPRECATED_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/agents/:agentId/speak',\n  responseType: 'stream',\n  pathParamSchema: agentIdPathParams,\n  bodySchema: generateSpeechBodySchema,\n  responseSchema: speakResponseSchema,\n  summary: 'Convert text to speech',\n  description:\n    \"[DEPRECATED] Use /api/agents/:agentId/voice/speak instead. Convert text to speech using the agent's voice provider\",\n  tags: ['Agents', 'Voice'],\n  handler: GENERATE_SPEECH_ROUTE.handler,\n});\n\nexport const TRANSCRIBE_SPEECH_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/agents/:agentId/voice/listen',\n  responseType: 'json',\n  pathParamSchema: agentIdPathParams,\n  bodySchema: transcribeSpeechBodySchema,\n  responseSchema: transcribeSpeechResponseSchema,\n  summary: 'Transcribe speech',\n  description: 'Transcribes speech audio to text using the agent voice configuration',\n  tags: ['Agents', 'Voice'],\n  handler: async ({ mastra, agentId, audio, options, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n\n      if (!audio) {\n        throw new HTTPException(400, { message: 'Audio data is required' });\n      }\n\n      const agent = mastra.getAgentById(agentId);\n\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const voice = await agent.getVoice({ requestContext });\n\n      if (!voice) {\n        throw new HTTPException(400, { message: 'Agent does not have voice capabilities' });\n      }\n\n      const audioStream = new Readable();\n      audioStream.push(audio);\n      audioStream.push(null);\n\n      const text = await voice.listen(audioStream, options);\n      return { text: text as string };\n    } catch (error) {\n      return handleError(error, 'Error transcribing speech');\n    }\n  },\n});\n\nexport const TRANSCRIBE_SPEECH_DEPRECATED_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/agents/:agentId/listen',\n  responseType: 'json',\n  pathParamSchema: agentIdPathParams,\n  bodySchema: transcribeSpeechBodySchema,\n  responseSchema: transcribeSpeechResponseSchema,\n  summary: 'Convert speech to text',\n  description:\n    \"[DEPRECATED] Use /api/agents/:agentId/voice/listen instead. Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.\",\n  tags: ['Agents', 'Voice'],\n  handler: TRANSCRIBE_SPEECH_ROUTE.handler,\n});\n\nexport const GET_LISTENER_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/agents/:agentId/voice/listener',\n  responseType: 'json',\n  pathParamSchema: agentIdPathParams,\n  responseSchema: getListenerResponseSchema,\n  summary: 'Get voice listener',\n  description: 'Returns the voice listener configuration for the agent',\n  tags: ['Agents', 'Voice'],\n  handler: async ({ mastra, agentId, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n\n      const agent = mastra.getAgentById(agentId);\n\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const voice = await agent.getVoice({ requestContext });\n\n      const listeners = await Promise.resolve()\n        .then(() => voice.getListener())\n        .catch(err => {\n          if (err instanceof MastraError) {\n            // No voice provider configured\n            return { enabled: false };\n          }\n          throw err;\n        });\n\n      return listeners;\n    } catch (error) {\n      return handleError(error, 'Error getting listeners');\n    }\n  },\n});\n"]}