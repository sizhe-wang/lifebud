import { validateBody } from './chunk-XWGAT2DA.js';
import { listToolsResponseSchema, serializedToolSchema, toolIdPathParams, executeToolResponseSchema, executeToolContextBodySchema, agentToolPathParams, executeToolBodySchema } from './chunk-WLGJVDH4.js';
import { optionalRunIdSchema } from './chunk-HT4LP3BO.js';
import { stringify } from './chunk-LF2ZLOFP.js';
import { createRoute } from './chunk-7S7ALPCY.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import { __export } from './chunk-PR4QN5HX.js';
import { isVercelTool } from '@mastra/core/tools';
import { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';

// src/server/handlers/tools.ts
var tools_exports = {};
__export(tools_exports, {
  EXECUTE_AGENT_TOOL_ROUTE: () => EXECUTE_AGENT_TOOL_ROUTE,
  EXECUTE_TOOL_ROUTE: () => EXECUTE_TOOL_ROUTE,
  GET_AGENT_TOOL_ROUTE: () => GET_AGENT_TOOL_ROUTE,
  GET_TOOL_BY_ID_ROUTE: () => GET_TOOL_BY_ID_ROUTE,
  LIST_TOOLS_ROUTE: () => LIST_TOOLS_ROUTE
});
var LIST_TOOLS_ROUTE = createRoute({
  method: "GET",
  path: "/api/tools",
  responseType: "json",
  responseSchema: listToolsResponseSchema,
  summary: "List all tools",
  description: "Returns a list of all available tools in the system",
  tags: ["Tools"],
  handler: async ({ mastra, tools }) => {
    try {
      const allTools = tools || mastra.listTools() || {};
      const serializedTools = Object.entries(allTools).reduce(
        (acc, [id, _tool]) => {
          const tool = _tool;
          acc[id] = {
            ...tool,
            inputSchema: tool.inputSchema ? stringify(zodToJsonSchema(tool.inputSchema)) : void 0,
            outputSchema: tool.outputSchema ? stringify(zodToJsonSchema(tool.outputSchema)) : void 0
          };
          return acc;
        },
        {}
      );
      return serializedTools;
    } catch (error) {
      return handleError(error, "Error getting tools");
    }
  }
});
var GET_TOOL_BY_ID_ROUTE = createRoute({
  method: "GET",
  path: "/api/tools/:toolId",
  responseType: "json",
  pathParamSchema: toolIdPathParams,
  responseSchema: serializedToolSchema,
  summary: "Get tool by ID",
  description: "Returns details for a specific tool including its schema and configuration",
  tags: ["Tools"],
  handler: async ({ mastra, tools, toolId }) => {
    try {
      let tool;
      if (tools && Object.keys(tools).length > 0) {
        tool = Object.values(tools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? stringify(zodToJsonSchema(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? stringify(zodToJsonSchema(tool.outputSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return handleError(error, "Error getting tool");
    }
  }
});
var EXECUTE_TOOL_ROUTE = createRoute({
  method: "POST",
  path: "/api/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: toolIdPathParams,
  queryParamSchema: optionalRunIdSchema,
  bodySchema: executeToolContextBodySchema,
  responseSchema: executeToolResponseSchema,
  summary: "Execute tool",
  description: "Executes a specific tool with the provided input data",
  tags: ["Tools"],
  handler: async ({ mastra, runId, toolId, tools, requestContext, ...bodyParams }) => {
    try {
      if (!toolId) {
        throw new HTTPException(400, { message: "Tool ID is required" });
      }
      let tool;
      if (tools && Object.keys(tools).length > 0) {
        tool = Object.values(tools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new HTTPException(400, { message: "Tool is not executable" });
      }
      const { data } = bodyParams;
      validateBody({ data });
      if (isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 },
        ...runId ? {
          workflow: {
            runId,
            suspend: async () => {
            }
          }
        } : {}
      });
      return result;
    } catch (error) {
      return handleError(error, "Error executing tool");
    }
  }
});
var GET_AGENT_TOOL_ROUTE = createRoute({
  method: "GET",
  path: "/api/agents/:agentId/tools/:toolId",
  responseType: "json",
  pathParamSchema: agentToolPathParams,
  responseSchema: serializedToolSchema,
  summary: "Get agent tool",
  description: "Returns details for a specific tool assigned to the agent",
  tags: ["Agents", "Tools"],
  handler: async ({ mastra, agentId, toolId, requestContext }) => {
    try {
      const agent = agentId ? mastra.getAgentById(agentId) : null;
      if (!agent) {
        throw new HTTPException(404, { message: "Agent not found" });
      }
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      const serializedTool = {
        ...tool,
        inputSchema: tool.inputSchema ? stringify(zodToJsonSchema(tool.inputSchema)) : void 0,
        outputSchema: tool.outputSchema ? stringify(zodToJsonSchema(tool.outputSchema)) : void 0
      };
      return serializedTool;
    } catch (error) {
      return handleError(error, "Error getting agent tool");
    }
  }
});
var EXECUTE_AGENT_TOOL_ROUTE = createRoute({
  method: "POST",
  path: "/api/agents/:agentId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: agentToolPathParams,
  bodySchema: executeToolBodySchema,
  responseSchema: executeToolResponseSchema,
  summary: "Execute agent tool",
  description: "Executes a specific tool assigned to the agent with the provided input data",
  tags: ["Agents", "Tools"],
  handler: async ({ mastra, agentId, toolId, data, requestContext }) => {
    try {
      const agent = agentId ? mastra.getAgentById(agentId) : null;
      if (!agent) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new HTTPException(400, { message: "Tool is not executable" });
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 }
      });
      return result;
    } catch (error) {
      return handleError(error, "Error executing agent tool");
    }
  }
});

export { EXECUTE_AGENT_TOOL_ROUTE, EXECUTE_TOOL_ROUTE, GET_AGENT_TOOL_ROUTE, GET_TOOL_BY_ID_ROUTE, LIST_TOOLS_ROUTE, tools_exports };
//# sourceMappingURL=chunk-IVGQTL3T.js.map
//# sourceMappingURL=chunk-IVGQTL3T.js.map