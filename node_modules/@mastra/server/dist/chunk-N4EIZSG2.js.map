{"version":3,"sources":["../src/server/handlers/observability.ts"],"names":[],"mappings":"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","file":"chunk-N4EIZSG2.js","sourcesContent":["import type { Mastra } from '@mastra/core';\nimport { listScoresResponseSchema } from '@mastra/core/evals';\nimport { scoreTraces } from '@mastra/core/evals/scoreTraces';\nimport type { MastraStorage, ScoresStorage, ObservabilityStorage } from '@mastra/core/storage';\nimport {\n  tracesFilterSchema,\n  tracesOrderBySchema,\n  paginationArgsSchema,\n  spanIdsSchema,\n  listTracesResponseSchema,\n  scoreTracesRequestSchema,\n  scoreTracesResponseSchema,\n  getTraceArgsSchema,\n  getTraceResponseSchema,\n  dateRangeSchema,\n} from '@mastra/core/storage';\nimport { z } from 'zod';\nimport { HTTPException } from '../http-exception';\nimport { createRoute, pickParams, wrapSchemaForQueryParams } from '../server-adapter/routes/route-builder';\nimport { handleError } from './error';\n\n// ============================================================================\n// Legacy Parameter Support (backward compatibility with main branch API)\n// ============================================================================\n\n/**\n * Legacy query parameters from the old API (main branch).\n * These are accepted for backward compatibility and transformed to new format.\n */\nconst legacyQueryParamsSchema = z.object({\n  // Old: dateRange was in pagination, now it's startedAt in filters\n  dateRange: dateRangeSchema.optional(),\n  // Old: name matched span names like \"agent run: 'myAgent'\"\n  name: z.string().optional(),\n  // entityType needs preprocessing to handle legacy 'workflow' value\n  entityType: z.preprocess(val => (val === 'workflow' ? 'workflow_run' : val), z.string().optional()),\n});\n\n/**\n * Transforms legacy query parameters to the new format.\n * - dateRange -> startedAt (if startedAt not already set)\n * - name=\"agent run: 'x'\" -> entityId='x', entityType='agent'\n * - name=\"workflow run: 'x'\" -> entityId='x', entityType='workflow_run'\n * - entityType='workflow' -> entityType='workflow_run' (enum value fix)\n */\nfunction transformLegacyParams(params: Record<string, unknown>): Record<string, unknown> {\n  const result = { ...params };\n\n  // Transform old entityType='workflow' -> 'workflow_run' (the Zod validation would have already transformed this)\n  if (result.entityType === 'workflow') {\n    result.entityType = 'workflow_run';\n  }\n\n  // Transform old dateRange -> new startedAt\n  if (params.dateRange && !params.startedAt) {\n    result.startedAt = params.dateRange;\n    delete result.dateRange;\n  }\n\n  // Transform old name -> entityId + entityType\n  // Old format: name matched span names like \"agent run: 'myAgent'\" or \"workflow run: 'myWorkflow'\"\n  if (typeof params.name === 'string' && !params.entityId) {\n    const agentMatch = params.name.match(/^agent run: '([^']+)'$/);\n    const workflowMatch = params.name.match(/^workflow run: '([^']+)'$/);\n\n    if (agentMatch) {\n      result.entityId = agentMatch[1];\n      result.entityType = 'agent';\n    } else if (workflowMatch) {\n      result.entityId = workflowMatch[1];\n      result.entityType = 'workflow_run';\n    }\n    delete result.name;\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Route Definitions (new pattern - handlers defined inline with createRoute)\n// ============================================================================\n\nfunction getStorage(mastra: Mastra): MastraStorage {\n  const storage = mastra.getStorage();\n  if (!storage) {\n    throw new HTTPException(500, { message: 'Storage is not available' });\n  }\n  return storage;\n}\n\nasync function getObservabilityStore(mastra: Mastra): Promise<ObservabilityStorage> {\n  const storage = getStorage(mastra);\n  const observability = await storage.getStore('observability');\n  if (!observability) {\n    throw new HTTPException(500, { message: 'Observability storage domain is not available' });\n  }\n  return observability;\n}\n\nasync function getScoresStore(mastra: Mastra): Promise<ScoresStorage> {\n  const storage = getStorage(mastra);\n  const scores = await storage.getStore('scores');\n  if (!scores) {\n    throw new HTTPException(500, { message: 'Scores storage domain is not available' });\n  }\n  return scores;\n}\n\nexport const LIST_TRACES_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/observability/traces',\n  responseType: 'json',\n  queryParamSchema: wrapSchemaForQueryParams(\n    tracesFilterSchema\n      .merge(paginationArgsSchema)\n      .merge(tracesOrderBySchema)\n      .merge(legacyQueryParamsSchema) // Accept legacy params for backward compatibility\n      .partial(),\n  ),\n  responseSchema: listTracesResponseSchema,\n  summary: 'List traces',\n  description: 'Returns a paginated list of traces with optional filtering and sorting',\n  tags: ['Observability'],\n  handler: async ({ mastra, ...params }) => {\n    try {\n      // Transform legacy params to new format before processing\n      const transformedParams = transformLegacyParams(params);\n\n      const filters = pickParams(tracesFilterSchema, transformedParams);\n      const pagination = pickParams(paginationArgsSchema, transformedParams);\n      const orderBy = pickParams(tracesOrderBySchema, transformedParams);\n\n      const observabilityStore = await getObservabilityStore(mastra);\n      return await observabilityStore.listTraces({ filters, pagination, orderBy });\n    } catch (error) {\n      handleError(error, 'Error listing traces');\n    }\n  },\n});\n\nexport const GET_TRACE_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/observability/traces/:traceId',\n  responseType: 'json',\n  pathParamSchema: getTraceArgsSchema,\n  responseSchema: getTraceResponseSchema,\n  summary: 'Get AI trace by ID',\n  description: 'Returns a complete AI trace with all spans by trace ID',\n  tags: ['Observability'],\n  handler: async ({ mastra, traceId }) => {\n    try {\n      const observabilityStore = await getObservabilityStore(mastra);\n      const trace = await observabilityStore.getTrace({ traceId });\n\n      if (!trace) {\n        throw new HTTPException(404, { message: `Trace with ID '${traceId}' not found` });\n      }\n\n      return trace;\n    } catch (error) {\n      handleError(error, 'Error getting trace');\n    }\n  },\n});\n\nexport const SCORE_TRACES_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/observability/traces/score',\n  responseType: 'json',\n  bodySchema: scoreTracesRequestSchema,\n  responseSchema: scoreTracesResponseSchema,\n  summary: 'Score traces',\n  description: 'Scores one or more traces using a specified scorer (fire-and-forget)',\n  tags: ['Observability'],\n  handler: async ({ mastra, ...params }) => {\n    try {\n      // Validate storage exists before starting background task\n      getStorage(mastra);\n\n      const { scorerName, targets } = params;\n\n      const scorer = mastra.getScorerById(scorerName);\n      if (!scorer) {\n        throw new HTTPException(404, { message: `Scorer '${scorerName}' not found` });\n      }\n\n      scoreTraces({\n        scorerId: scorer.config.id || scorer.config.name,\n        targets,\n        mastra,\n      }).catch(error => {\n        const logger = mastra.getLogger();\n        logger?.error(`Background trace scoring failed: ${error.message}`, error);\n      });\n\n      return {\n        status: 'success',\n        message: `Scoring started for ${targets.length} ${targets.length === 1 ? 'trace' : 'traces'}`,\n        traceCount: targets.length,\n      };\n    } catch (error) {\n      handleError(error, 'Error processing trace scoring');\n    }\n  },\n});\n\nexport const LIST_SCORES_BY_SPAN_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/observability/traces/:traceId/:spanId/scores',\n  responseType: 'json',\n  pathParamSchema: spanIdsSchema,\n  queryParamSchema: paginationArgsSchema,\n  responseSchema: listScoresResponseSchema,\n  summary: 'List scores by span',\n  description: 'Returns all scores for a specific span within a trace',\n  tags: ['Observability'],\n  handler: async ({ mastra, ...params }) => {\n    try {\n      const pagination = pickParams(paginationArgsSchema, params);\n      const spanIds = pickParams(spanIdsSchema, params);\n\n      const scoresStore = await getScoresStore(mastra);\n\n      return await scoresStore.listScoresBySpan({\n        ...spanIds,\n        pagination,\n      });\n    } catch (error) {\n      handleError(error, 'Error getting scores by span');\n    }\n  },\n});\n"]}