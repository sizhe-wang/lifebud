'use strict';

var chunk4EYONQIW_cjs = require('./chunk-4EYONQIW.cjs');
var chunkAQI6GLTN_cjs = require('./chunk-AQI6GLTN.cjs');
var chunkFWSKVWS7_cjs = require('./chunk-FWSKVWS7.cjs');
var chunkILV5M6C7_cjs = require('./chunk-ILV5M6C7.cjs');
var chunkT4SPG2GP_cjs = require('./chunk-T4SPG2GP.cjs');
var chunkGWLR6K3H_cjs = require('./chunk-GWLR6K3H.cjs');
var chunkBRI4GUZ2_cjs = require('./chunk-BRI4GUZ2.cjs');
var chunkMCYD5LW7_cjs = require('./chunk-MCYD5LW7.cjs');
var chunkAVRO3FIN_cjs = require('./chunk-AVRO3FIN.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var agent = require('@mastra/core/agent');
var z18 = require('zod');
var z42 = require('zod/v4');
var v3 = require('zod/v3');
var memory = require('@mastra/core/memory');
var utils = require('@mastra/core/utils');
var tools = require('@mastra/core/tools');
var child_process = require('child_process');
var promises = require('fs/promises');
var path = require('path');
var fs = require('fs');
var module$1 = require('module');
var util = require('util');
var llm = require('@mastra/core/llm');
var os = require('os');
var workflows = require('@mastra/core/workflows');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var z18__default = /*#__PURE__*/_interopDefault(z18);
var z42__namespace = /*#__PURE__*/_interopNamespace(z42);

// ../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js
var require_ignore = chunkO7I5CWRX_cjs.__commonJS({
  "../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var UNDEFINED = void 0;
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    var REGEX_TEST_TRAILING_SLASH = /\/$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = /* @__PURE__ */ Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object5, key, value) => {
      Object.defineProperty(object5, key, { value });
      return value;
    };
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ]
    ];
    var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    var MODE_IGNORE = "regex";
    var MODE_CHECK_IGNORE = "checkRegex";
    var UNDERSCORE = "_";
    var TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    var makeRegexPrefix = (pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    );
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
    var IgnoreRule = class {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define(this, "body", body);
        define(this, "ignoreCase", ignoreCase);
        define(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define(this, key, regex);
      }
    };
    var createRule = ({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    };
    var RuleManager = class {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      checkIgnore(path) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path)) {
          return this.test(path);
        }
        const slices = path.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent.ignored) {
            return parent;
          }
        }
        return this._rules.test(path, false, MODE_CHECK_IGNORE);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._rules.test(path, checkUnignored, MODE_IGNORE);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    var setupWindows = () => {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    };
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module.exports = factory;
    factory.default = factory;
    module.exports.isPathValid = isPathValid;
    define(module.exports, /* @__PURE__ */ Symbol.for("setupWindows"), setupWindows);
  }
});

// src/server/handlers/agent-builder.ts
var agent_builder_exports = {};
chunkO7I5CWRX_cjs.__export(agent_builder_exports, {
  CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE: () => CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE,
  CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE: () => CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE,
  GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE: () => GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE,
  GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE: () => GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE,
  LIST_AGENT_BUILDER_ACTIONS_ROUTE: () => LIST_AGENT_BUILDER_ACTIONS_ROUTE,
  LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE: () => LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE,
  OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE: () => OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE: () => OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE: () => RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE,
  START_AGENT_BUILDER_ACTION_RUN_ROUTE: () => START_AGENT_BUILDER_ACTION_RUN_ROUTE,
  START_ASYNC_AGENT_BUILDER_ACTION_ROUTE: () => START_ASYNC_AGENT_BUILDER_ACTION_ROUTE,
  STREAM_AGENT_BUILDER_ACTION_ROUTE: () => STREAM_AGENT_BUILDER_ACTION_ROUTE,
  STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE: () => STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name4, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name4],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== z18.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object5 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object5[object5[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object5[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case z18.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case z18.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case z18.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case z18.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUnion:
    case z18.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case z18.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case z18.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case z18.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNaN:
    case z18.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case z18.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case z18.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case z18.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodFunction:
    case z18.ZodFirstPartyTypeKind.ZodVoid:
    case z18.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema5 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema5) {
    addMeta(def, refs, jsonSchema5);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema5, def, refs);
    newItem.jsonSchema = jsonSchema5;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema5;
  return jsonSchema5;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema5) => {
  if (def.description) {
    jsonSchema5.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema5.markdownDescription = def.description;
    }
  }
  return jsonSchema5;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name5, schema2]) => ({
    ...acc,
    [name5]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name5]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name4 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name4 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name4]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name4 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name4
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name4]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// ../../node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default = zodToJsonSchema;

// ../schema-compat/dist/chunk-3RG3ZAXL.js
var PATCHED = /* @__PURE__ */ Symbol("__mastra_patched__");
function patchRecordSchemas(schema) {
  if (!schema || typeof schema !== "object") return schema;
  if (schema[PATCHED]) return schema;
  schema[PATCHED] = true;
  const def = schema._zod?.def;
  if (def?.type === "record" && def.keyType && !def.valueType) {
    def.valueType = def.keyType;
    def.keyType = z18.z.string();
  }
  if (!def) return schema;
  if (def.type === "object" && def.shape) {
    const shape = typeof def.shape === "function" ? def.shape() : def.shape;
    for (const key of Object.keys(shape)) {
      patchRecordSchemas(shape[key]);
    }
  }
  if (def.type === "array" && def.element) {
    patchRecordSchemas(def.element);
  }
  if (def.type === "union" && def.options) {
    def.options.forEach(patchRecordSchemas);
  }
  if (def.type === "record") {
    if (def.keyType) patchRecordSchemas(def.keyType);
    if (def.valueType) patchRecordSchemas(def.valueType);
  }
  if (def.type === "intersection") {
    if (def.left) patchRecordSchemas(def.left);
    if (def.right) patchRecordSchemas(def.right);
  }
  if (def.type === "lazy") {
    if (def.getter && typeof def.getter === "function") {
      const originalGetter = def.getter;
      def.getter = function() {
        const innerSchema = originalGetter();
        if (innerSchema) {
          patchRecordSchemas(innerSchema);
        }
        return innerSchema;
      };
    }
  }
  if (def.innerType) {
    patchRecordSchemas(def.innerType);
  }
  return schema;
}
function zodToJsonSchema2(zodSchema5, target = "jsonSchema7", strategy = "relative") {
  const fn = "toJSONSchema";
  if (fn in z18.z) {
    patchRecordSchemas(zodSchema5);
    return z18.z[fn](zodSchema5, {
      unrepresentable: "any",
      override: (ctx) => {
        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;
        if (def && (def.typeName === "ZodDate" || def.type === "date")) {
          ctx.jsonSchema.type = "string";
          ctx.jsonSchema.format = "date-time";
        }
      }
    });
  } else {
    return esm_default(zodSchema5, {
      $refStrategy: strategy,
      target
    });
  }
}
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve5, reject) => {
      const task = { resolve: resolve5, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve5) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve5, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach(((waiter) => waiter.resolve()));
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// ../../node_modules/.pnpm/xxhash-wasm@1.1.0/node_modules/xxhash-wasm/esm/xxhash-wasm.js
var t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 48, 8, 96, 3, 127, 127, 127, 1, 127, 96, 3, 127, 127, 127, 0, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 3, 127, 127, 126, 1, 126, 96, 3, 126, 127, 127, 1, 126, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 3, 11, 10, 0, 0, 2, 1, 3, 4, 5, 6, 1, 7, 5, 3, 1, 0, 1, 7, 85, 9, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 6, 105, 110, 105, 116, 51, 50, 0, 2, 8, 117, 112, 100, 97, 116, 101, 51, 50, 0, 3, 8, 100, 105, 103, 101, 115, 116, 51, 50, 0, 4, 5, 120, 120, 104, 54, 52, 0, 5, 6, 105, 110, 105, 116, 54, 52, 0, 7, 8, 117, 112, 100, 97, 116, 101, 54, 52, 0, 8, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 9, 10, 251, 22, 10, 242, 1, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 3, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 3, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 3, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 32, 1, 106, 32, 0, 32, 1, 65, 15, 113, 16, 1, 11, 146, 1, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 4, 106, 32, 2, 75, 69, 4, 64, 32, 0, 32, 1, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 0, 32, 1, 65, 4, 106, 33, 1, 12, 1, 11, 11, 3, 64, 32, 1, 32, 2, 79, 69, 4, 64, 32, 0, 32, 1, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 63, 0, 32, 0, 65, 8, 106, 32, 1, 65, 168, 136, 141, 161, 2, 106, 54, 2, 0, 32, 0, 65, 12, 106, 32, 1, 65, 137, 235, 208, 208, 7, 107, 54, 2, 0, 32, 0, 65, 16, 106, 32, 1, 54, 2, 0, 32, 0, 65, 20, 106, 32, 1, 65, 207, 140, 162, 142, 6, 106, 54, 2, 0, 11, 195, 4, 1, 6, 127, 32, 1, 32, 2, 106, 33, 6, 32, 0, 65, 24, 106, 33, 4, 32, 0, 65, 40, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 40, 2, 0, 32, 2, 106, 54, 2, 0, 32, 0, 65, 4, 106, 34, 5, 32, 5, 40, 2, 0, 32, 2, 65, 16, 79, 32, 0, 40, 2, 0, 65, 16, 79, 114, 114, 54, 2, 0, 32, 2, 32, 3, 106, 65, 16, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 16, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 12, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 4, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 8, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 20, 106, 34, 3, 32, 3, 40, 2, 0, 32, 4, 65, 12, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 54, 2, 0, 32, 0, 65, 40, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 32, 6, 65, 16, 107, 77, 4, 64, 32, 6, 65, 16, 107, 33, 8, 32, 0, 65, 8, 106, 40, 2, 0, 33, 2, 32, 0, 65, 12, 106, 40, 2, 0, 33, 3, 32, 0, 65, 16, 106, 40, 2, 0, 33, 5, 32, 0, 65, 20, 106, 40, 2, 0, 33, 7, 3, 64, 32, 2, 32, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 3, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 5, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 7, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 7, 32, 8, 32, 1, 65, 4, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 2, 54, 2, 0, 32, 0, 65, 12, 106, 32, 3, 54, 2, 0, 32, 0, 65, 16, 106, 32, 5, 54, 2, 0, 32, 0, 65, 20, 106, 32, 7, 54, 2, 0, 11, 32, 1, 32, 6, 73, 4, 64, 32, 4, 32, 1, 32, 6, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 1, 54, 2, 0, 11, 11, 97, 1, 1, 127, 32, 0, 65, 16, 106, 40, 2, 0, 33, 1, 32, 0, 65, 4, 106, 40, 2, 0, 4, 127, 32, 1, 65, 12, 119, 32, 0, 65, 20, 106, 40, 2, 0, 65, 18, 119, 106, 32, 0, 65, 12, 106, 40, 2, 0, 65, 7, 119, 106, 32, 0, 65, 8, 106, 40, 2, 0, 65, 1, 119, 106, 5, 32, 1, 65, 177, 207, 217, 178, 1, 106, 11, 32, 0, 40, 2, 0, 106, 32, 0, 65, 24, 106, 32, 0, 65, 40, 106, 40, 2, 0, 16, 1, 11, 255, 3, 2, 3, 126, 1, 127, 32, 0, 32, 1, 106, 33, 6, 32, 1, 65, 32, 79, 4, 126, 32, 6, 65, 32, 107, 33, 6, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 6, 32, 0, 65, 8, 106, 34, 0, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 32, 0, 32, 1, 65, 31, 113, 16, 6, 11, 134, 2, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 2, 32, 1, 65, 8, 106, 79, 4, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 0, 32, 1, 65, 8, 106, 33, 1, 12, 1, 11, 11, 32, 1, 65, 4, 106, 32, 2, 77, 4, 64, 32, 0, 32, 1, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 0, 32, 1, 65, 4, 106, 33, 1, 11, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 0, 32, 1, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 32, 0, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 0, 32, 0, 66, 29, 136, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 0, 32, 0, 66, 32, 136, 133, 11, 77, 0, 32, 0, 65, 8, 106, 32, 1, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 55, 3, 0, 32, 0, 65, 16, 106, 32, 1, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 55, 3, 0, 32, 0, 65, 24, 106, 32, 1, 55, 3, 0, 32, 0, 65, 32, 106, 32, 1, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 55, 3, 0, 11, 244, 4, 2, 3, 127, 4, 126, 32, 1, 32, 2, 106, 33, 5, 32, 0, 65, 40, 106, 33, 4, 32, 0, 65, 200, 0, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 41, 3, 0, 32, 2, 173, 124, 55, 3, 0, 32, 2, 32, 3, 106, 65, 32, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 32, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 16, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 8, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 24, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 16, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 32, 106, 34, 3, 32, 3, 41, 3, 0, 32, 4, 65, 24, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 55, 3, 0, 32, 0, 65, 200, 0, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 65, 32, 106, 32, 5, 77, 4, 64, 32, 5, 65, 32, 107, 33, 2, 32, 0, 65, 8, 106, 41, 3, 0, 33, 6, 32, 0, 65, 16, 106, 41, 3, 0, 33, 7, 32, 0, 65, 24, 106, 41, 3, 0, 33, 8, 32, 0, 65, 32, 106, 41, 3, 0, 33, 9, 3, 64, 32, 6, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 7, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 7, 32, 8, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 8, 32, 9, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 9, 32, 2, 32, 1, 65, 8, 106, 34, 1, 79, 13, 0, 11, 32, 0, 65, 8, 106, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 32, 7, 55, 3, 0, 32, 0, 65, 24, 106, 32, 8, 55, 3, 0, 32, 0, 65, 32, 106, 32, 9, 55, 3, 0, 11, 32, 1, 32, 5, 73, 4, 64, 32, 4, 32, 1, 32, 5, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 1, 54, 2, 0, 11, 11, 188, 2, 1, 5, 126, 32, 0, 65, 24, 106, 41, 3, 0, 33, 1, 32, 0, 41, 3, 0, 34, 2, 66, 32, 90, 4, 126, 32, 0, 65, 8, 106, 41, 3, 0, 34, 3, 66, 1, 137, 32, 0, 65, 16, 106, 41, 3, 0, 34, 4, 66, 7, 137, 124, 32, 1, 66, 12, 137, 32, 0, 65, 32, 106, 41, 3, 0, 34, 5, 66, 18, 137, 124, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 1, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 2, 124, 32, 0, 65, 40, 106, 32, 2, 66, 31, 131, 167, 16, 6, 11]);
async function e() {
  return (function(t2) {
    const { exports: { mem: e2, xxh32: n, xxh64: r, init32: i, update32: a, digest32: o, init64: s, update64: u, digest64: c } } = t2;
    let h = new Uint8Array(e2.buffer);
    function g(t3, n2) {
      if (e2.buffer.byteLength < t3 + n2) {
        const r2 = Math.ceil((t3 + n2 - e2.buffer.byteLength) / 65536);
        e2.grow(r2), h = new Uint8Array(e2.buffer);
      }
    }
    function f(t3, e3, n2, r2, i2, a2) {
      g(t3);
      const o2 = new Uint8Array(t3);
      return h.set(o2), n2(0, e3), o2.set(h.subarray(0, t3)), { update(e4) {
        let n3;
        return h.set(o2), "string" == typeof e4 ? (g(3 * e4.length, t3), n3 = w.encodeInto(e4, h.subarray(t3)).written) : (g(e4.byteLength, t3), h.set(e4, t3), n3 = e4.byteLength), r2(0, t3, n3), o2.set(h.subarray(0, t3)), this;
      }, digest: () => (h.set(o2), a2(i2(0))) };
    }
    function y(t3) {
      return t3 >>> 0;
    }
    const b = 2n ** 64n - 1n;
    function d(t3) {
      return t3 & b;
    }
    const w = new TextEncoder(), l = 0, p = 0n;
    function x(t3, e3 = l) {
      return g(3 * t3.length, 0), y(n(0, w.encodeInto(t3, h).written, e3));
    }
    function L(t3, e3 = p) {
      return g(3 * t3.length, 0), d(r(0, w.encodeInto(t3, h).written, e3));
    }
    return { h32: x, h32ToString: (t3, e3 = l) => x(t3, e3).toString(16).padStart(8, "0"), h32Raw: (t3, e3 = l) => (g(t3.byteLength, 0), h.set(t3), y(n(0, t3.byteLength, e3))), create32: (t3 = l) => f(48, t3, i, a, o, y), h64: L, h64ToString: (t3, e3 = p) => L(t3, e3).toString(16).padStart(16, "0"), h64Raw: (t3, e3 = p) => (g(t3.byteLength, 0), h.set(t3), d(r(0, t3.byteLength, e3))), create64: (t3 = p) => f(88, t3, s, u, c, d) };
  })((await WebAssembly.instantiate(t)).instance);
}
var TypeHandler = class {
  apply(types, schema) {
    if (!schema.type) return;
    const allowedTypes = Array.isArray(schema.type) ? schema.type : [schema.type];
    const typeSet = new Set(allowedTypes);
    if (!typeSet.has("string")) {
      types.string = false;
    }
    if (!typeSet.has("number") && !typeSet.has("integer")) {
      types.number = false;
    }
    if (!typeSet.has("boolean")) {
      types.boolean = false;
    }
    if (!typeSet.has("null")) {
      types.null = false;
    }
    if (!typeSet.has("array")) {
      types.array = false;
    }
    if (!typeSet.has("object")) {
      types.object = false;
    }
    if (typeSet.has("integer") && types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        types.number = currentNumber.int();
      }
    }
  }
};
var ConstHandler = class {
  apply(types, schema) {
    if (schema.const === void 0) return;
    const constValue = schema.const;
    types.string = false;
    types.number = false;
    types.boolean = false;
    types.null = false;
    types.array = false;
    types.object = false;
    if (typeof constValue === "string") {
      types.string = z42.z.literal(constValue);
    } else if (typeof constValue === "number") {
      types.number = z42.z.literal(constValue);
    } else if (typeof constValue === "boolean") {
      types.boolean = z42.z.literal(constValue);
    } else if (constValue === null) {
      types.null = z42.z.null();
    } else if (Array.isArray(constValue)) {
      types.array = void 0;
    } else if (typeof constValue === "object") {
      types.object = void 0;
    }
  }
};
var EnumHandler = class {
  apply(types, schema) {
    if (!schema.enum) return;
    if (schema.enum.length === 0) {
      if (!schema.type) {
        types.string = false;
        types.number = false;
        types.boolean = false;
        types.null = false;
        types.array = false;
        types.object = false;
      }
      return;
    }
    const valuesByType = {
      string: schema.enum.filter((v) => typeof v === "string"),
      number: schema.enum.filter((v) => typeof v === "number"),
      boolean: schema.enum.filter((v) => typeof v === "boolean"),
      null: schema.enum.filter((v) => v === null),
      array: schema.enum.filter((v) => Array.isArray(v)),
      object: schema.enum.filter((v) => typeof v === "object" && v !== null && !Array.isArray(v))
    };
    types.string = this.createTypeSchema(valuesByType.string, "string");
    types.number = this.createTypeSchema(valuesByType.number, "number");
    types.boolean = this.createTypeSchema(valuesByType.boolean, "boolean");
    types.null = valuesByType.null.length > 0 ? z42.z.null() : false;
    types.array = valuesByType.array.length > 0 ? void 0 : false;
    types.object = valuesByType.object.length > 0 ? void 0 : false;
  }
  createTypeSchema(values, type) {
    if (values.length === 0) return false;
    if (values.length === 1) {
      return z42.z.literal(values[0]);
    }
    if (type === "string") {
      return z42.z.enum(values);
    }
    if (type === "number") {
      const [first, second, ...rest] = values;
      return z42.z.union([z42.z.literal(first), z42.z.literal(second), ...rest.map((v) => z42.z.literal(v))]);
    }
    if (type === "boolean") {
      return z42.z.union([z42.z.literal(true), z42.z.literal(false)]);
    }
    return false;
  }
};
var ImplicitStringHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (schema.type === void 0 && (stringSchema.minLength !== void 0 || stringSchema.maxLength !== void 0 || stringSchema.pattern !== void 0)) {
      if (types.string === void 0) {
        types.string = z42.z.string();
      }
    }
  }
};
var MinLengthHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.minLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || z42.z.string();
      if (currentString instanceof z42.z.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength >= stringSchema.minLength;
          },
          { message: `String must be at least ${stringSchema.minLength} characters long` }
        );
      }
    }
  }
};
var MaxLengthHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (stringSchema.maxLength === void 0) return;
    if (types.string !== false) {
      const currentString = types.string || z42.z.string();
      if (currentString instanceof z42.z.ZodString) {
        types.string = currentString.refine(
          (value) => {
            const graphemeLength = Array.from(value).length;
            return graphemeLength <= stringSchema.maxLength;
          },
          { message: `String must be at most ${stringSchema.maxLength} characters long` }
        );
      }
    }
  }
};
var PatternHandler = class {
  apply(types, schema) {
    const stringSchema = schema;
    if (!stringSchema.pattern) return;
    if (types.string !== false) {
      const currentString = types.string || z42.z.string();
      if (currentString instanceof z42.z.ZodString) {
        const regex = new RegExp(stringSchema.pattern);
        types.string = currentString.regex(regex);
      }
    }
  }
};
var MinimumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.minimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        types.number = currentNumber.min(numberSchema.minimum);
      }
    }
  }
};
var MaximumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.maximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        types.number = currentNumber.max(numberSchema.maximum);
      }
    }
  }
};
var ExclusiveMinimumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMinimum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        if (typeof numberSchema.exclusiveMinimum === "number") {
          types.number = currentNumber.gt(numberSchema.exclusiveMinimum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var ExclusiveMaximumHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.exclusiveMaximum === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        if (typeof numberSchema.exclusiveMaximum === "number") {
          types.number = currentNumber.lt(numberSchema.exclusiveMaximum);
        } else {
          types.number = false;
        }
      }
    }
  }
};
var MultipleOfHandler = class {
  apply(types, schema) {
    const numberSchema = schema;
    if (numberSchema.multipleOf === void 0) return;
    if (types.number !== false) {
      const currentNumber = types.number || z42.z.number();
      if (currentNumber instanceof z42.z.ZodNumber) {
        types.number = currentNumber.refine(
          (value) => {
            if (numberSchema.multipleOf === 0) return false;
            const quotient = value / numberSchema.multipleOf;
            const rounded = Math.round(quotient);
            const tolerance = Math.min(
              Math.abs(value) * Number.EPSILON * 10,
              Math.abs(numberSchema.multipleOf) * Number.EPSILON * 10
            );
            return Math.abs(quotient - rounded) <= tolerance / Math.abs(numberSchema.multipleOf);
          },
          { message: `Must be a multiple of ${numberSchema.multipleOf}` }
        );
      }
    }
  }
};
var ImplicitArrayHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (schema.type === void 0 && (arraySchema.minItems !== void 0 || arraySchema.maxItems !== void 0 || arraySchema.items !== void 0 || arraySchema.prefixItems !== void 0)) {
      if (types.array === void 0) {
        types.array = z42.z.array(z42.z.any());
      }
    }
  }
};
var MinItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.minItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || z42.z.array(z42.z.any())).min(arraySchema.minItems);
    }
  }
};
var MaxItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (arraySchema.maxItems === void 0) return;
    if (types.array !== false) {
      types.array = (types.array || z42.z.array(z42.z.any())).max(arraySchema.maxItems);
    }
  }
};
var ItemsHandler = class {
  apply(types, schema) {
    const arraySchema = schema;
    if (types.array === false) return;
    if (Array.isArray(arraySchema.items)) {
      types.array = types.array || z42.z.array(z42.z.any());
    } else if (arraySchema.items && typeof arraySchema.items !== "boolean" && !arraySchema.prefixItems) {
      const itemSchema = convertJsonSchemaToZod(arraySchema.items);
      let newArray = z42.z.array(itemSchema);
      if (types.array && types.array instanceof z42.z.ZodArray) {
        const existingDef = types.array._def;
        if (existingDef.checks) {
          existingDef.checks.forEach((check) => {
            if (check._zod && check._zod.def) {
              const def = check._zod.def;
              if (def.check === "min_length" && def.minimum !== void 0) {
                newArray = newArray.min(def.minimum);
              } else if (def.check === "max_length" && def.maximum !== void 0) {
                newArray = newArray.max(def.maximum);
              }
            }
          });
        }
      }
      types.array = newArray;
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
      if (!arraySchema.prefixItems) {
        types.array = z42.z.array(z42.z.any()).max(0);
      } else {
        types.array = types.array || z42.z.array(z42.z.any());
      }
    } else if (typeof arraySchema.items === "boolean" && arraySchema.items === true) {
      types.array = types.array || z42.z.array(z42.z.any());
    } else if (arraySchema.prefixItems) {
      types.array = types.array || z42.z.array(z42.z.any());
    }
  }
};
var TupleHandler = class {
  apply(types, schema) {
    if (schema.type !== "array") return;
    const arraySchema = schema;
    if (!Array.isArray(arraySchema.items)) return;
    if (types.array === false) return;
    const itemSchemas = arraySchema.items.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
    let tuple;
    if (itemSchemas.length === 0) {
      tuple = z42.z.tuple([]);
    } else {
      tuple = z42.z.tuple(itemSchemas);
    }
    if (arraySchema.minItems !== void 0 && arraySchema.minItems > itemSchemas.length) {
      tuple = false;
    }
    if (arraySchema.maxItems !== void 0 && arraySchema.maxItems < itemSchemas.length) {
      tuple = false;
    }
    types.tuple = tuple;
    types.array = false;
  }
};
var PropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (types.object === false) return;
    if (objectSchema.properties || objectSchema.required || objectSchema.additionalProperties !== void 0) {
      types.object = types.object || z42.z.object({}).passthrough();
    }
  }
};
var ImplicitObjectHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (schema.type === void 0 && (objectSchema.maxProperties !== void 0 || objectSchema.minProperties !== void 0)) {
      if (types.object === void 0) {
        types.object = z42.z.object({}).passthrough();
      }
    }
  }
};
var MaxPropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.maxProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || z42.z.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length <= objectSchema.maxProperties,
        { message: `Object must have at most ${objectSchema.maxProperties} properties` }
      );
    }
  }
};
var MinPropertiesHandler = class {
  apply(types, schema) {
    const objectSchema = schema;
    if (objectSchema.minProperties === void 0) return;
    if (types.object !== false) {
      const baseObject = types.object || z42.z.object({}).passthrough();
      types.object = baseObject.refine(
        (obj) => Object.keys(obj).length >= objectSchema.minProperties,
        { message: `Object must have at least ${objectSchema.minProperties} properties` }
      );
    }
  }
};
function deepEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return a === b;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => deepEqual(item, b[index]));
  }
  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));
  }
  return false;
}
function createUniqueItemsValidator() {
  return (value) => {
    if (!Array.isArray(value)) {
      return true;
    }
    const seen = [];
    return value.every((item) => {
      const isDuplicate = seen.some((seenItem) => deepEqual(item, seenItem));
      if (isDuplicate) {
        return false;
      }
      seen.push(item);
      return true;
    });
  };
}
function isValidWithSchema(schema, value) {
  return schema.safeParse(value).success;
}
var NotHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.not) return zodSchema5;
    const notSchema = convertJsonSchemaToZod(schema.not);
    return zodSchema5.refine(
      (value) => !isValidWithSchema(notSchema, value),
      { message: "Value must not match the 'not' schema" }
    );
  }
};
var UniqueItemsHandler = class {
  apply(zodSchema5, schema) {
    const arraySchema = schema;
    if (arraySchema.uniqueItems !== true) return zodSchema5;
    return zodSchema5.refine(createUniqueItemsValidator(), {
      message: "Array items must be unique"
    });
  }
};
var AllOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.allOf || schema.allOf.length === 0) return zodSchema5;
    const allOfSchemas = schema.allOf.map((s) => convertJsonSchemaToZod(s));
    return allOfSchemas.reduce(
      (acc, s) => z42.z.intersection(acc, s),
      zodSchema5
    );
  }
};
var AnyOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.anyOf || schema.anyOf.length === 0) return zodSchema5;
    const anyOfSchema = schema.anyOf.length === 1 ? convertJsonSchemaToZod(schema.anyOf[0]) : z42.z.union([
      convertJsonSchemaToZod(schema.anyOf[0]),
      convertJsonSchemaToZod(schema.anyOf[1]),
      ...schema.anyOf.slice(2).map((s) => convertJsonSchemaToZod(s))
    ]);
    return z42.z.intersection(zodSchema5, anyOfSchema);
  }
};
var OneOfHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.oneOf || schema.oneOf.length === 0) return zodSchema5;
    const oneOfSchemas = schema.oneOf.map((s) => convertJsonSchemaToZod(s));
    return zodSchema5.refine(
      (value) => {
        let validCount = 0;
        for (const oneOfSchema of oneOfSchemas) {
          const result = oneOfSchema.safeParse(value);
          if (result.success) {
            validCount++;
            if (validCount > 1) return false;
          }
        }
        return validCount === 1;
      },
      { message: "Value must match exactly one of the oneOf schemas" }
    );
  }
};
var PrefixItemsHandler = class {
  apply(zodSchema5, schema) {
    const arraySchema = schema;
    if (arraySchema.prefixItems && Array.isArray(arraySchema.prefixItems)) {
      const prefixItems = arraySchema.prefixItems;
      const prefixSchemas = prefixItems.map((itemSchema) => convertJsonSchemaToZod(itemSchema));
      return zodSchema5.refine(
        (value) => {
          if (!Array.isArray(value)) return true;
          for (let i = 0; i < Math.min(value.length, prefixSchemas.length); i++) {
            if (!isValidWithSchema(prefixSchemas[i], value[i])) {
              return false;
            }
          }
          if (value.length > prefixSchemas.length) {
            if (typeof arraySchema.items === "boolean" && arraySchema.items === false) {
              return false;
            } else if (arraySchema.items && typeof arraySchema.items === "object" && !Array.isArray(arraySchema.items)) {
              const additionalItemSchema = convertJsonSchemaToZod(arraySchema.items);
              for (let i = prefixSchemas.length; i < value.length; i++) {
                if (!isValidWithSchema(additionalItemSchema, value[i])) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        { message: "Array does not match prefixItems schema" }
      );
    }
    return zodSchema5;
  }
};
var ObjectPropertiesHandler = class {
  apply(zodSchema5, schema) {
    const objectSchema = schema;
    if (!objectSchema.properties && !objectSchema.required && objectSchema.additionalProperties !== false) {
      return zodSchema5;
    }
    if (zodSchema5 instanceof z42.z.ZodObject || zodSchema5 instanceof z42.z.ZodRecord) {
      const shape = {};
      if (objectSchema.properties) {
        for (const [key, propSchema] of Object.entries(objectSchema.properties)) {
          if (propSchema !== void 0) {
            shape[key] = convertJsonSchemaToZod(propSchema);
          }
        }
      }
      if (objectSchema.required && Array.isArray(objectSchema.required)) {
        const required = new Set(objectSchema.required);
        for (const key of Object.keys(shape)) {
          if (!required.has(key)) {
            shape[key] = shape[key].optional();
          }
        }
      } else {
        for (const key of Object.keys(shape)) {
          shape[key] = shape[key].optional();
        }
      }
      if (objectSchema.additionalProperties === false) {
        return z42.z.object(shape);
      } else {
        return z42.z.object(shape).passthrough();
      }
    }
    return zodSchema5.refine(
      (value) => {
        if (typeof value !== "object" || value === null || Array.isArray(value)) {
          return true;
        }
        if (objectSchema.properties) {
          for (const [propName, propSchema] of Object.entries(objectSchema.properties)) {
            if (propSchema !== void 0) {
              const propExists = Object.getOwnPropertyDescriptor(value, propName) !== void 0;
              if (propExists) {
                const zodPropSchema = convertJsonSchemaToZod(propSchema);
                const propResult = zodPropSchema.safeParse(value[propName]);
                if (!propResult.success) {
                  return false;
                }
              }
            }
          }
        }
        if (objectSchema.required && Array.isArray(objectSchema.required)) {
          for (const requiredProp of objectSchema.required) {
            const propExists = Object.getOwnPropertyDescriptor(value, requiredProp) !== void 0;
            if (!propExists) {
              return false;
            }
          }
        }
        if (objectSchema.additionalProperties === false && objectSchema.properties) {
          const allowedProps = new Set(Object.keys(objectSchema.properties));
          for (const prop in value) {
            if (!allowedProps.has(prop)) {
              return false;
            }
          }
        }
        return true;
      },
      { message: "Object constraints validation failed" }
    );
  }
};
var EnumComplexHandler = class {
  apply(zodSchema5, schema) {
    if (!schema.enum || schema.enum.length === 0) return zodSchema5;
    const complexValues = schema.enum.filter(
      (v) => Array.isArray(v) || typeof v === "object" && v !== null
    );
    if (complexValues.length === 0) return zodSchema5;
    return zodSchema5.refine(
      (value) => {
        if (typeof value !== "object" || value === null) return true;
        return complexValues.some(
          (enumValue) => deepEqual(value, enumValue)
        );
      },
      { message: "Value must match one of the enum values" }
    );
  }
};
var ConstComplexHandler = class {
  apply(zodSchema5, schema) {
    if (schema.const === void 0) return zodSchema5;
    const constValue = schema.const;
    if (typeof constValue !== "object" || constValue === null) {
      return zodSchema5;
    }
    return zodSchema5.refine(
      (value) => deepEqual(value, constValue),
      { message: "Value must equal the const value" }
    );
  }
};
var MetadataHandler = class {
  apply(zodSchema5, schema) {
    if (schema.description) {
      zodSchema5 = zodSchema5.describe(schema.description);
    }
    return zodSchema5;
  }
};
var ProtoRequiredHandler = class {
  apply(zodSchema5, schema) {
    var _a5;
    const objectSchema = schema;
    if (!((_a5 = objectSchema.required) == null ? void 0 : _a5.includes("__proto__")) || schema.type !== void 0) {
      return zodSchema5;
    }
    return z42.z.any().refine(
      (value) => this.validateRequired(value, objectSchema.required),
      { message: "Missing required properties" }
    );
  }
  validateRequired(value, required) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      return true;
    }
    return required.every(
      (prop) => Object.prototype.hasOwnProperty.call(value, prop)
    );
  }
};
var ContainsHandler = class {
  apply(zodSchema5, schema) {
    var _a5;
    const arraySchema = schema;
    if (arraySchema.contains === void 0) return zodSchema5;
    const containsSchema = convertJsonSchemaToZod(arraySchema.contains);
    const minContains = (_a5 = arraySchema.minContains) != null ? _a5 : 1;
    const maxContains = arraySchema.maxContains;
    return zodSchema5.refine(
      (value) => {
        if (!Array.isArray(value)) {
          return true;
        }
        let matchCount = 0;
        for (const item of value) {
          if (isValidWithSchema(containsSchema, item)) {
            matchCount++;
          }
        }
        if (matchCount < minContains) {
          return false;
        }
        if (maxContains !== void 0 && matchCount > maxContains) {
          return false;
        }
        return true;
      },
      { message: "Array must contain required items matching the schema" }
    );
  }
};
var primitiveHandlers = [
  // Type constraints - should run first
  new ConstHandler(),
  new EnumHandler(),
  new TypeHandler(),
  // Implicit type detection - must run before other constraints
  new ImplicitStringHandler(),
  new ImplicitArrayHandler(),
  new ImplicitObjectHandler(),
  // String constraints
  new MinLengthHandler(),
  new MaxLengthHandler(),
  new PatternHandler(),
  // Number constraints
  new MinimumHandler(),
  new MaximumHandler(),
  new ExclusiveMinimumHandler(),
  new ExclusiveMaximumHandler(),
  new MultipleOfHandler(),
  // Array constraints - TupleHandler must run before ItemsHandler
  new TupleHandler(),
  new MinItemsHandler(),
  new MaxItemsHandler(),
  new ItemsHandler(),
  // Object constraints
  new MaxPropertiesHandler(),
  new MinPropertiesHandler(),
  new PropertiesHandler()
];
var refinementHandlers = [
  // Handle special cases first
  new ProtoRequiredHandler(),
  new EnumComplexHandler(),
  new ConstComplexHandler(),
  // Logical combinations
  new AllOfHandler(),
  new AnyOfHandler(),
  new OneOfHandler(),
  // Type-specific refinements
  new PrefixItemsHandler(),
  new ObjectPropertiesHandler(),
  // Array refinements
  new ContainsHandler(),
  // Other refinements
  new NotHandler(),
  new UniqueItemsHandler(),
  // Metadata last
  new MetadataHandler()
];
function convertJsonSchemaToZod(schema) {
  if (typeof schema === "boolean") {
    return schema ? z42.z.any() : z42.z.never();
  }
  const types = {};
  for (const handler of primitiveHandlers) {
    handler.apply(types, schema);
  }
  const allowedSchemas = [];
  if (types.string !== false) {
    allowedSchemas.push(types.string || z42.z.string());
  }
  if (types.number !== false) {
    allowedSchemas.push(types.number || z42.z.number());
  }
  if (types.boolean !== false) {
    allowedSchemas.push(types.boolean || z42.z.boolean());
  }
  if (types.null !== false) {
    allowedSchemas.push(types.null || z42.z.null());
  }
  if (types.array !== false) {
    allowedSchemas.push(types.array || z42.z.array(z42.z.any()));
  }
  if (types.tuple !== false && types.tuple !== void 0) {
    allowedSchemas.push(types.tuple);
  }
  if (types.object !== false) {
    if (types.object) {
      allowedSchemas.push(types.object);
    } else {
      const objectSchema = z42.z.custom((val) => {
        return typeof val === "object" && val !== null && !Array.isArray(val);
      }, "Must be an object, not an array");
      allowedSchemas.push(objectSchema);
    }
  }
  let zodSchema5;
  if (allowedSchemas.length === 0) {
    zodSchema5 = z42.z.never();
  } else if (allowedSchemas.length === 1) {
    zodSchema5 = allowedSchemas[0];
  } else {
    const hasConstraints = Object.keys(schema).some(
      (key) => key !== "$schema" && key !== "title" && key !== "description"
    );
    if (!hasConstraints) {
      zodSchema5 = z42.z.any();
    } else {
      zodSchema5 = z42.z.union(allowedSchemas);
    }
  }
  for (const handler of refinementHandlers) {
    zodSchema5 = handler.apply(zodSchema5, schema);
  }
  return zodSchema5;
}
function convertJsonSchemaToZod2(schema) {
  function addMetadata(zodSchema5, jsonSchema5) {
    if (jsonSchema5.description) {
      zodSchema5 = zodSchema5.describe(jsonSchema5.description);
    }
    return zodSchema5;
  }
  if (schema.const !== void 0) {
    if (typeof schema.const === "string") {
      return addMetadata(z18.z.literal(schema.const), schema);
    } else if (typeof schema.const === "number") {
      return addMetadata(z18.z.literal(schema.const), schema);
    } else if (typeof schema.const === "boolean") {
      return addMetadata(z18.z.literal(schema.const), schema);
    } else if (schema.const === null) {
      return addMetadata(z18.z.null(), schema);
    }
    return addMetadata(z18.z.literal(schema.const), schema);
  }
  if (schema.type) {
    switch (schema.type) {
      case "string": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z18.z.string(), schema);
          }
          return addMetadata(z18.z.enum(schema.enum), schema);
        }
        let stringSchema = z18.z.string();
        if (schema.minLength !== void 0) {
          stringSchema = stringSchema.min(schema.minLength);
        }
        if (schema.maxLength !== void 0) {
          stringSchema = stringSchema.max(schema.maxLength);
        }
        if (schema.pattern !== void 0) {
          const regex = new RegExp(schema.pattern);
          stringSchema = stringSchema.regex(regex);
        }
        return addMetadata(stringSchema, schema);
      }
      case "number":
      case "integer": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z18.z.number(), schema);
          }
          const options = schema.enum.map((val) => z18.z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = z18.z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        let numberSchema = schema.type === "integer" ? z18.z.number().int() : z18.z.number();
        if (schema.minimum !== void 0) {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (schema.maximum !== void 0) {
          numberSchema = numberSchema.max(schema.maximum);
        }
        if (schema.exclusiveMinimum !== void 0) {
          numberSchema = numberSchema.gt(schema.exclusiveMinimum);
        }
        if (schema.exclusiveMaximum !== void 0) {
          numberSchema = numberSchema.lt(schema.exclusiveMaximum);
        }
        if (schema.multipleOf !== void 0) {
          numberSchema = numberSchema.multipleOf(schema.multipleOf);
        }
        return addMetadata(numberSchema, schema);
      }
      case "boolean":
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(z18.z.boolean(), schema);
          }
          const options = schema.enum.map((val) => z18.z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = z18.z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        return addMetadata(z18.z.boolean(), schema);
      case "null":
        return addMetadata(z18.z.null(), schema);
      case "object":
        if (schema.properties) {
          const shape = {};
          for (const [key, propSchema] of Object.entries(
            schema.properties
          )) {
            shape[key] = convertJsonSchemaToZod2(propSchema);
          }
          if (schema.required && Array.isArray(schema.required)) {
            const required = new Set(schema.required);
            for (const key of Object.keys(shape)) {
              if (!required.has(key)) {
                shape[key] = shape[key].optional();
              }
            }
          } else {
            for (const key of Object.keys(shape)) {
              shape[key] = shape[key].optional();
            }
          }
          let zodSchema5;
          if (schema.additionalProperties !== false) {
            zodSchema5 = z18.z.object(shape).passthrough();
          } else {
            zodSchema5 = z18.z.object(shape);
          }
          return addMetadata(zodSchema5, schema);
        }
        return addMetadata(z18.z.object({}), schema);
      case "array": {
        let arraySchema;
        if (schema.items) {
          arraySchema = z18.z.array(convertJsonSchemaToZod2(schema.items));
        } else {
          arraySchema = z18.z.array(z18.z.any());
        }
        if (schema.minItems !== void 0) {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (schema.maxItems !== void 0) {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        if (schema.uniqueItems === true) {
          arraySchema = arraySchema.refine(
            (items) => {
              const seen = /* @__PURE__ */ new Set();
              return items.every((item) => {
                if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
                  if (seen.has(item)) return false;
                  seen.add(item);
                  return true;
                }
                const serialized = JSON.stringify(item);
                if (seen.has(serialized)) return false;
                seen.add(serialized);
                return true;
              });
            },
            { message: "Array items must be unique" }
          );
        }
        return addMetadata(arraySchema, schema);
      }
    }
  }
  if (schema.enum) {
    if (schema.enum.length === 0) {
      return addMetadata(z18.z.never(), schema);
    }
    const allStrings = schema.enum.every((val) => typeof val === "string");
    if (allStrings) {
      return addMetadata(z18.z.enum(schema.enum), schema);
    } else {
      const options = schema.enum.map((val) => z18.z.literal(val));
      if (options.length === 1) {
        return addMetadata(options[0], schema);
      }
      if (options.length >= 2) {
        const unionSchema = z18.z.union([options[0], options[1], ...options.slice(2)]);
        return addMetadata(unionSchema, schema);
      }
    }
  }
  if (schema.anyOf && schema.anyOf.length >= 2) {
    const schemas = schema.anyOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      z18.z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  if (schema.allOf) {
    return addMetadata(
      schema.allOf.reduce(
        (acc, s) => z18.z.intersection(acc, convertJsonSchemaToZod2(s)),
        z18.z.object({})
      ),
      schema
    );
  }
  if (schema.oneOf && schema.oneOf.length >= 2) {
    const schemas = schema.oneOf.map(convertJsonSchemaToZod2);
    return addMetadata(
      z18.z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  return addMetadata(z18.z.any(), schema);
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS5 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM5 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }),
  mod
));
var require_secure_json_parse = __commonJS5({
  "../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx4 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx4 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse4(text23, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text23)) {
        text23 = text23.toString();
      }
      if (text23 && text23.charCodeAt(0) === 65279) {
        text23 = text23.slice(1);
      }
      const obj = JSON.parse(text23, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx4.test(text23) === false && suspectConstructorRx4.test(text23) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx4.test(text23) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx4.test(text23) === false) {
          return obj;
        }
      }
      return filter4(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter4(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text23, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse4(text23, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text23, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse4(text23, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter4;
  }
});
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name1422,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name1422;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker152) {
    const markerSymbol = Symbol.for(marker152);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text: text23, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text23}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text23;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var import_secure_json_parse = __toESM5(require_secure_json_parse());
function convertAsyncIteratorToReadableStream(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}
var createIdGenerator = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
createIdGenerator();
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema23) {
  return validator((value) => {
    const result = zodSchema23.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes({
  value,
  schema
}) {
  const validator23 = asValidator(schema);
  try {
    if (validator23.validate == null) {
      return { success: true, value };
    }
    const result = validator23.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON({
  text: text23,
  schema
}) {
  try {
    const value = import_secure_json_parse.default.parse(text23);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text: text23, cause: error })
    };
  }
}
var ignoreOverride2 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions2 = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};
var getRefs2 = (options) => {
  const _options = getDefaultOptions2(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name172, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name172],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage2(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors2(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage2(res, key, errorMessage, refs);
}
var getRelativePath2 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseAnyDef2(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath2(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef2(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== z18.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors2(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors2(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors2(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors2(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef2() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
var parseCatchDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
var integerDateParser2 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors2(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors2(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2(refs);
}
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType2 = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef2(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex2 = void 0;
var zodPatterns2 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern2(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(escapeLiteralCheckValue2(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat2(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat2(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors2(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue2(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
}
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC2.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat2(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors2(schema, "format", value, message, refs);
  }
}
function addPattern2(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors2(schema, "pattern", stringifyRegExpWithFlags2(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags2(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef2(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef2(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef2(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef2(refs);
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef2(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef2(def) {
  const object23 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object23[object23[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object23[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef2(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef2({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
function parseNullDef2(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef2(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef2(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage2(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors2(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors2(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors2(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors2(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseObjectDef2(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional2(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var parseOptionalDef2 = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef2(def.innerType._def, refs);
  }
  const innerSchema = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef2(refs)
      },
      innerSchema
    ]
  } : parseAnyDef2(refs);
};
var parsePipelineDef2 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef2(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef2(def.out._def, refs);
  }
  const a = parseDef2(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef2(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors2(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors2(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef2(refs) {
  return {
    not: parseAnyDef2(refs)
  };
}
function parseUnknownDef2(refs) {
  return parseAnyDef2(refs);
}
var parseReadonlyDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
var selectParser2 = (def, typeName, refs) => {
  switch (typeName) {
    case z18.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case z18.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2(refs);
    case z18.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2(refs);
    case z18.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUnion:
    case z18.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case z18.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case z18.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case z18.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNaN:
    case z18.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2(refs);
    case z18.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2(refs);
    case z18.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2(refs);
    case z18.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodFunction:
    case z18.ZodFirstPartyTypeKind.ZodVoid:
    case z18.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema23 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema23) {
    addMeta2(def, refs, jsonSchema23);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema23, def, refs);
    newItem.jsonSchema = jsonSchema23;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema23;
  return jsonSchema23;
}
var get$ref2 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef2(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2(refs) : void 0;
    }
  }
};
var addMeta2 = (def, refs, jsonSchema23) => {
  if (def.description) {
    jsonSchema23.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema23.markdownDescription = def.description;
    }
  }
  return jsonSchema23;
};
var zodToJsonSchema22 = (schema, options) => {
  const refs = getRefs2(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name182, schema2]) => ({
    ...acc,
    [name182]: parseDef2(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name182]
    }, true) ?? parseAnyDef2(refs)
  }), {}) : void 0;
  const name172 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef2(schema._def, name172 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name172]
  }, false) ?? parseAnyDef2(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name172 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name172
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name172]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
var esm_default2 = zodToJsonSchema22;
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
function formatDataStreamPart(type, value) {
  const streamPart = dataStreamParts.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema(zodSchema23, options) {
  var _a172;
  const useReferences = (_a172 = void 0) != null ? _a172 : false;
  return jsonSchema(
    esm_default2(zodSchema23, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (value) => {
        const result = zodSchema23.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
var schemaSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema23, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    jsonSchema: jsonSchema23,
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return isSchema(schema) ? schema : zodSchema(schema);
}
var _globalThis = typeof globalThis === "object" ? globalThis : global;
var VERSION = "1.9.0";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible23(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
  var _a172;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a172 !== void 0 ? _a172 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a172, _b10;
  var globalVersion = (_a172 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a172 === void 0 ? void 0 : _a172.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b10 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b10 === void 0 ? void 0 : _b10[type];
}
function unregisterGlobal(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  (function() {
    function DiagComponentLogger23(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger23.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger23.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger23.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger23.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger23.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger23;
  })()
);
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel23) {
  DiagLogLevel23[DiagLogLevel23["NONE"] = 0] = "NONE";
  DiagLogLevel23[DiagLogLevel23["ERROR"] = 30] = "ERROR";
  DiagLogLevel23[DiagLogLevel23["WARN"] = 50] = "WARN";
  DiagLogLevel23[DiagLogLevel23["INFO"] = 60] = "INFO";
  DiagLogLevel23[DiagLogLevel23["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel23[DiagLogLevel23["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel23[DiagLogLevel23["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  (function() {
    function DiagAPI23() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a172, _b10, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a172 = err.stack) !== null && _a172 !== void 0 ? _a172 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b10 = optionsOrLogLevel.logLevel) !== null && _b10 !== void 0 ? _b10 : DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal(API_NAME, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI23.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI23();
      }
      return this._instance;
    };
    return DiagAPI23;
  })()
);
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext23(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context = new BaseContext23(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function(key) {
        var context = new BaseContext23(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext23;
  })()
);
var ROOT_CONTEXT = new BaseContext();
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  (function() {
    function NoopContextManager23() {
    }
    NoopContextManager23.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager23.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
    };
    NoopContextManager23.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager23.prototype.enable = function() {
      return this;
    };
    NoopContextManager23.prototype.disable = function() {
      return this;
    };
    return NoopContextManager23;
  })()
);
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  (function() {
    function ContextAPI23() {
    }
    ContextAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI23();
      }
      return this._instance;
    };
    ContextAPI23.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI23.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI23.prototype.with = function(context, fn, thisArg) {
      var _a172;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a172 = this._getContextManager()).with.apply(_a172, __spreadArray4([context, fn, thisArg], __read4(args), false));
    };
    ContextAPI23.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI23.prototype._getContextManager = function() {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI23.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI23;
  })()
);
var TraceFlags;
(function(TraceFlags23) {
  TraceFlags23[TraceFlags23["NONE"] = 0] = "NONE";
  TraceFlags23[TraceFlags23["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = (
  /** @class */
  (function() {
    function NonRecordingSpan23(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan23.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan23.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan23.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan23.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan23.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan23.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan23.prototype.end = function(_endTime) {
    };
    NonRecordingSpan23.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan23.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan23;
  })()
);
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
  return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
  return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
  return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
  return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
  var _a172;
  return (_a172 = getSpan(context)) === null || _a172 === void 0 ? void 0 : _a172.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  (function() {
    function NoopTracer23() {
    }
    NoopTracer23.prototype.startSpan = function(name172, options, context) {
      if (context === void 0) {
        context = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context && getSpanContext(context);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer23.prototype.startActiveSpan = function(name172, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name172, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer23;
  })()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  (function() {
    function ProxyTracer23(_provider, name172, version, options) {
      this._provider = _provider;
      this.name = name172;
      this.version = version;
      this.options = options;
    }
    ProxyTracer23.prototype.startSpan = function(name172, options, context) {
      return this._getTracer().startSpan(name172, options, context);
    };
    ProxyTracer23.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer23.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer23;
  })()
);
var NoopTracerProvider = (
  /** @class */
  (function() {
    function NoopTracerProvider23() {
    }
    NoopTracerProvider23.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider23;
  })()
);
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  (function() {
    function ProxyTracerProvider23() {
    }
    ProxyTracerProvider23.prototype.getTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this.getDelegateTracer(name172, version, options)) !== null && _a172 !== void 0 ? _a172 : new ProxyTracer(this, name172, version, options);
    };
    ProxyTracerProvider23.prototype.getDelegate = function() {
      var _a172;
      return (_a172 = this._delegate) !== null && _a172 !== void 0 ? _a172 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider23.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider23.prototype.getDelegateTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this._delegate) === null || _a172 === void 0 ? void 0 : _a172.getTracer(name172, version, options);
    };
    return ProxyTracerProvider23;
  })()
);
var SpanStatusCode;
(function(SpanStatusCode23) {
  SpanStatusCode23[SpanStatusCode23["UNSET"] = 0] = "UNSET";
  SpanStatusCode23[SpanStatusCode23["OK"] = 1] = "OK";
  SpanStatusCode23[SpanStatusCode23["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
var API_NAME3 = "trace";
var TraceAPI = (
  /** @class */
  (function() {
    function TraceAPI23() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI23();
      }
      return this._instance;
    };
    TraceAPI23.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI23.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI23.prototype.getTracer = function(name172, version) {
      return this.getTracerProvider().getTracer(name172, version);
    };
    TraceAPI23.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI23;
  })()
);
TraceAPI.getInstance();
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name172 in all)
    __defProp2(target, name172, { get: all[name172], enumerable: true });
};
function prepareResponseHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}
var name42 = "AI_NoObjectGeneratedError";
var marker42 = `vercel.ai.error.${name42}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text23,
    response,
    usage,
    finishReason
  }) {
    super({ name: name42, message, cause });
    this[_a42] = true;
    this.text = text23;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker42);
  }
};
_a42 = symbol42;
var dataContentSchema = z18.z.union([
  z18.z.string(),
  z18.z.instanceof(Uint8Array),
  z18.z.instanceof(ArrayBuffer),
  z18.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b10;
      return (_b10 = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b10 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema = z18.z.lazy(
  () => z18.z.union([
    z18.z.null(),
    z18.z.string(),
    z18.z.number(),
    z18.z.boolean(),
    z18.z.record(z18.z.string(), jsonValueSchema),
    z18.z.array(jsonValueSchema)
  ])
);
var providerMetadataSchema = z18.z.record(
  z18.z.string(),
  z18.z.record(z18.z.string(), jsonValueSchema)
);
var toolResultContentSchema = z18.z.array(
  z18.z.union([
    z18.z.object({ type: z18.z.literal("text"), text: z18.z.string() }),
    z18.z.object({
      type: z18.z.literal("image"),
      data: z18.z.string(),
      mimeType: z18.z.string().optional()
    })
  ])
);
var textPartSchema = z18.z.object({
  type: z18.z.literal("text"),
  text: z18.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var imagePartSchema = z18.z.object({
  type: z18.z.literal("image"),
  image: z18.z.union([dataContentSchema, z18.z.instanceof(URL)]),
  mimeType: z18.z.string().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var filePartSchema = z18.z.object({
  type: z18.z.literal("file"),
  data: z18.z.union([dataContentSchema, z18.z.instanceof(URL)]),
  filename: z18.z.string().optional(),
  mimeType: z18.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var reasoningPartSchema = z18.z.object({
  type: z18.z.literal("reasoning"),
  text: z18.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var redactedReasoningPartSchema = z18.z.object({
  type: z18.z.literal("redacted-reasoning"),
  data: z18.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolCallPartSchema = z18.z.object({
  type: z18.z.literal("tool-call"),
  toolCallId: z18.z.string(),
  toolName: z18.z.string(),
  args: z18.z.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolResultPartSchema = z18.z.object({
  type: z18.z.literal("tool-result"),
  toolCallId: z18.z.string(),
  toolName: z18.z.string(),
  result: z18.z.unknown(),
  content: toolResultContentSchema.optional(),
  isError: z18.z.boolean().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreSystemMessageSchema = z18.z.object({
  role: z18.z.literal("system"),
  content: z18.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreUserMessageSchema = z18.z.object({
  role: z18.z.literal("user"),
  content: z18.z.union([
    z18.z.string(),
    z18.z.array(z18.z.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = z18.z.object({
  role: z18.z.literal("assistant"),
  content: z18.z.union([
    z18.z.string(),
    z18.z.array(
      z18.z.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        redactedReasoningPartSchema,
        toolCallPartSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreToolMessageSchema = z18.z.object({
  role: z18.z.literal("tool"),
  content: z18.z.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
z18.z.union([
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
createIdGenerator({ prefix: "aiobj", size: 24 });
createIdGenerator({ prefix: "aiobj", size: 24 });
createIdGenerator({
  prefix: "aitxt",
  size: 24
});
createIdGenerator({
  prefix: "msg",
  size: 24
});
var output_exports = {};
__export2(output_exports, {
  object: () => object,
  text: () => text
});
var text = () => ({
  type: "text",
  responseFormat: () => ({ type: "text" }),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text23 }) {
    return { partial: text23 };
  },
  parseOutput({ text: text23 }) {
    return text23;
  }
});
var object = ({
  schema: inputSchema
}) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: ({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text23 }) {
      const result = parsePartialJson(text23);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text23 }, context) {
      const parseResult = safeParseJSON({ text: text23 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text23,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text23,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
function mergeStreams(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
createIdGenerator({
  prefix: "aitxt",
  size: 24
});
createIdGenerator({
  prefix: "msg",
  size: 24
});
var ClientOrServerImplementationSchema = z18.z.object({
  name: z18.z.string(),
  version: z18.z.string()
}).passthrough();
var BaseParamsSchema = z18.z.object({
  _meta: z18.z.optional(z18.z.object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = z18.z.object({
  method: z18.z.string(),
  params: z18.z.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = z18.z.object({
  experimental: z18.z.optional(z18.z.object({}).passthrough()),
  logging: z18.z.optional(z18.z.object({}).passthrough()),
  prompts: z18.z.optional(
    z18.z.object({
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  ),
  resources: z18.z.optional(
    z18.z.object({
      subscribe: z18.z.optional(z18.z.boolean()),
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  ),
  tools: z18.z.optional(
    z18.z.object({
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  )
}).passthrough();
ResultSchema.extend({
  protocolVersion: z18.z.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: z18.z.optional(z18.z.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: z18.z.optional(z18.z.string())
});
var ToolSchema = z18.z.object({
  name: z18.z.string(),
  description: z18.z.optional(z18.z.string()),
  inputSchema: z18.z.object({
    type: z18.z.literal("object"),
    properties: z18.z.optional(z18.z.object({}).passthrough())
  }).passthrough()
}).passthrough();
PaginatedResultSchema.extend({
  tools: z18.z.array(ToolSchema)
});
var TextContentSchema = z18.z.object({
  type: z18.z.literal("text"),
  text: z18.z.string()
}).passthrough();
var ImageContentSchema = z18.z.object({
  type: z18.z.literal("image"),
  data: z18.z.string().base64(),
  mimeType: z18.z.string()
}).passthrough();
var ResourceContentsSchema = z18.z.object({
  /**
   * The URI of this resource.
   */
  uri: z18.z.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z18.z.optional(z18.z.string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: z18.z.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: z18.z.string().base64()
});
var EmbeddedResourceSchema = z18.z.object({
  type: z18.z.literal("resource"),
  resource: z18.z.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).passthrough();
ResultSchema.extend({
  content: z18.z.array(
    z18.z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
  ),
  isError: z18.z.boolean().default(false).optional()
}).or(
  ResultSchema.extend({
    toolResult: z18.z.unknown()
  })
);
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION),
  id: z18.z.union([z18.z.string(), z18.z.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION),
  id: z18.z.union([z18.z.string(), z18.z.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION),
  id: z18.z.union([z18.z.string(), z18.z.number().int()]),
  error: z18.z.object({
    code: z18.z.number().int(),
    message: z18.z.string(),
    data: z18.z.optional(z18.z.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION)
}).merge(
  z18.z.object({
    method: z18.z.string(),
    params: z18.z.optional(BaseParamsSchema)
  })
).strict();
z18.z.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var langchain_adapter_exports = {};
__export2(langchain_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream,
  toDataStream: () => toDataStream,
  toDataStreamResponse: () => toDataStreamResponse
});
function createCallbacksTransformer(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function toDataStreamInternal(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: async (value, controller) => {
        var _a172;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk(
              (_a172 = value.data) == null ? void 0 : _a172.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk(value, controller);
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream(stream, callbacks) {
  return toDataStreamInternal(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse(stream, options) {
  var _a172;
  const dataStream = toDataStreamInternal(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream(stream, options) {
  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
function forwardAIMessageChunk(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
var llamaindex_adapter_exports = {};
__export2(llamaindex_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream2,
  toDataStream: () => toDataStream2,
  toDataStreamResponse: () => toDataStreamResponse2
});
function toDataStreamInternal2(stream, callbacks) {
  const trimStart = trimStartOfStream();
  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream2(stream, callbacks) {
  return toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse2(stream, options = {}) {
  var _a172;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream2(stream, options) {
  options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
function trimStartOfStream() {
  let isStreamStart = true;
  return (text23) => {
    if (isStreamStart) {
      text23 = text23.trimStart();
      if (text23)
        isStreamStart = false;
    }
    return text23;
  };
}
function isZodType(value) {
  return typeof value === "object" && value !== null && ("_def" in value || "_zod" in value) && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function convertSchemaToZod(schema) {
  if (isZodType(schema)) {
    return schema;
  } else {
    const jsonSchemaToConvert = "jsonSchema" in schema ? schema.jsonSchema : schema;
    try {
      if ("toJSONSchema" in z18.z) {
        return convertJsonSchemaToZod(jsonSchemaToConvert);
      } else {
        return convertJsonSchemaToZod2(jsonSchemaToConvert);
      }
    } catch (e2) {
      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;
      console.error(errorMessage, e2);
      throw new Error(errorMessage + (e2 instanceof Error ? `
${e2.stack}` : "\nUnknown error object"));
    }
  }
}
var __create2 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS32 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM32 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp3(target, "default", { value: mod, enumerable: true }),
  mod
));
var require_secure_json_parse2 = __commonJS32({
  "../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports, module) {
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx32 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx32 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse32(text42, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text42)) {
        text42 = text42.toString();
      }
      if (text42 && text42.charCodeAt(0) === 65279) {
        text42 = text42.slice(1);
      }
      const obj = JSON.parse(text42, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx32.test(text42) === false && suspectConstructorRx32.test(text42) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx32.test(text42) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx32.test(text42) === false) {
          return obj;
        }
      }
      return filter32(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter32(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text42, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse32(text42, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text42, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse32(text42, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse;
    module.exports.default = parse;
    module.exports.parse = parse;
    module.exports.safeParse = safeParse;
    module.exports.scan = filter32;
  }
});
var marker2 = "vercel.ai.error";
var symbol2 = Symbol.for(marker2);
var _a2;
var _AISDKError3 = class _AISDKError22 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a2] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError22.hasMarker(error, marker2);
  }
  static hasMarker(error, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a2 = symbol2;
var AISDKError2 = _AISDKError3;
var name = "AI_APICallError";
var marker22 = `vercel.ai.error.${name}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var APICallError = class extends AISDKError2 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a22] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker22);
  }
};
_a22 = symbol22;
function getErrorMessage2(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name32 = "AI_InvalidArgumentError";
var marker43 = `vercel.ai.error.${name32}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidArgumentError2 = class extends AISDKError2 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name32, message, cause });
    this[_a43] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker43);
  }
};
_a43 = symbol43;
var name62 = "AI_JSONParseError";
var marker72 = `vercel.ai.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var JSONParseError2 = class extends AISDKError2 {
  constructor({ text: text42, cause }) {
    super({
      name: name62,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage2(cause)}`,
      cause
    });
    this[_a72] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker72);
  }
};
_a72 = symbol72;
var name122 = "AI_TypeValidationError";
var marker132 = `vercel.ai.error.${name122}`;
var symbol132 = Symbol.for(marker132);
var _a132;
var _TypeValidationError3 = class _TypeValidationError22 extends AISDKError2 {
  constructor({ value, cause }) {
    super({
      name: name122,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage2(cause)}`,
      cause
    });
    this[_a132] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker132);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError22.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError22({ value, cause });
  }
};
_a132 = symbol132;
var TypeValidationError2 = _TypeValidationError3;
var customAlphabet2 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var import_secure_json_parse2 = __toESM32(require_secure_json_parse2());
function convertAsyncIteratorToReadableStream2(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}
async function delay(delayInMs) {
  return delayInMs == null ? Promise.resolve() : new Promise((resolve22) => setTimeout(resolve22, delayInMs));
}
var createIdGenerator2 = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet2(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError2({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
createIdGenerator2();
function getErrorMessage22(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError(error) {
  return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}
var validatorSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator2(validate) {
  return { [validatorSymbol2]: true, validate };
}
function isValidator2(value) {
  return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
function asValidator2(value) {
  return isValidator2(value) ? value : zodValidator2(value);
}
function zodValidator2(zodSchema42) {
  return validator2((value) => {
    const result = zodSchema42.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes2({
  value,
  schema
}) {
  const validator222 = asValidator2(schema);
  try {
    if (validator222.validate == null) {
      return { success: true, value };
    }
    const result = validator222.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON2({
  text: text42,
  schema
}) {
  try {
    const value = import_secure_json_parse2.default.parse(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes2({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError2.isInstance(error) ? error : new JSONParseError2({ text: text42, cause: error })
    };
  }
}
var ignoreOverride3 = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions3 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions3 = (options) => typeof options === "string" ? {
  ...defaultOptions3,
  name: options
} : {
  ...defaultOptions3,
  ...options
};
var getRefs3 = (options) => {
  const _options = getDefaultOptions3(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name172, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name172],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage3(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors3(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage3(res, key, errorMessage, refs);
}
var getRelativePath3 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseAnyDef3(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath3(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
function parseArrayDef3(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== z18.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef3(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors3(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors3(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors3(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors3(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef3(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef3() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef3(_def, refs) {
  return parseDef3(_def.type._def, refs);
}
var parseCatchDef3 = (def, refs) => {
  return parseDef3(def.innerType._def, refs);
};
function parseDateDef3(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef3(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser3(def, refs);
  }
}
var integerDateParser3 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors3(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors3(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef3(_def, refs) {
  return {
    ...parseDef3(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef3(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef3(_def.schema._def, refs) : parseAnyDef3(refs);
}
function parseEnumDef3(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType3 = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef3(def, refs) {
  const allOf = [
    parseDef3(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef3(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType3(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef3(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex3 = void 0;
var zodPatterns3 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex3 === void 0) {
      emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex3;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef3(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat3(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat3(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern3(res, zodPatterns3.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat3(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat3(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern3(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern3(res, zodPatterns3.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern3(res, zodPatterns3.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern3(res, RegExp(`^${escapeLiteralCheckValue3(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern3(res, RegExp(`${escapeLiteralCheckValue3(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat3(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat3(res, "date", check.message, refs);
          break;
        case "time":
          addFormat3(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat3(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern3(res, RegExp(escapeLiteralCheckValue3(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat3(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat3(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern3(res, zodPatterns3.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern3(res, zodPatterns3.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern3(res, zodPatterns3.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern3(res, zodPatterns3.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern3(res, zodPatterns3.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern3(res, zodPatterns3.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat3(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors3(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern3(res, zodPatterns3.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern3(res, zodPatterns3.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue3(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric3(literal) : literal;
}
var ALPHA_NUMERIC3 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric3(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC3.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat3(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "format", value, message, refs);
  }
}
function addPattern3(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags3(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "pattern", stringifyRegExpWithFlags3(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags3(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef3(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef3(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef3(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef3(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef3(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === z18.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === z18.ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef3(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef3(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef3(def, refs);
  }
  const keys = parseDef3(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef3(refs);
  const values = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef3(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef3(def) {
  const object222 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object222[object222[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object222[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef3(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef3({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
function parseNullDef3(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var primitiveMappings3 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef3(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf3(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings3 && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings3[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf3(def, refs);
}
var asAnyOf3 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef3(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef3(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings3[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings3[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef3(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef3(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef3(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage3(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseObjectDef3(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional3(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef3(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties3(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties3(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef3(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional3(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var parseOptionalDef3 = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef3(def.innerType._def, refs);
  }
  const innerSchema = parseDef3(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef3(refs)
      },
      innerSchema
    ]
  } : parseAnyDef3(refs);
};
var parsePipelineDef3 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef3(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef3(def.out._def, refs);
  }
  const a = parseDef3(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef3(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef3(def, refs) {
  return parseDef3(def.type._def, refs);
}
function parseSetDef3(def, refs) {
  const items = parseDef3(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors3(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors3(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef3(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef3(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef3(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef3(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef3(refs) {
  return {
    not: parseAnyDef3(refs)
  };
}
function parseUnknownDef3(refs) {
  return parseAnyDef3(refs);
}
var parseReadonlyDef3 = (def, refs) => {
  return parseDef3(def.innerType._def, refs);
};
var selectParser3 = (def, typeName, refs) => {
  switch (typeName) {
    case z18.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef3();
    case z18.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef3(refs);
    case z18.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef3(refs);
    case z18.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodUnion:
    case z18.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef3(def);
    case z18.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef3(def);
    case z18.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case z18.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodNaN:
    case z18.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef3(refs);
    case z18.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef3(refs);
    case z18.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef3(refs);
    case z18.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef3(def, refs);
    case z18.ZodFirstPartyTypeKind.ZodFunction:
    case z18.ZodFirstPartyTypeKind.ZodVoid:
    case z18.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef3(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride3) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref3(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser3(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta3(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref3 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath3(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef3(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef3(refs) : void 0;
    }
  }
};
var addMeta3 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema222.markdownDescription = def.description;
    }
  }
  return jsonSchema222;
};
var zodToJsonSchema3 = (schema, options) => {
  const refs = getRefs3(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name182, schema2]) => ({
    ...acc,
    [name182]: parseDef3(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name182]
    }, true) ?? parseAnyDef3(refs)
  }), {}) : void 0;
  const name172 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef3(schema._def, name172 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name172]
  }, false) ?? parseAnyDef3(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name172 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name172
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name172]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
var esm_default3 = zodToJsonSchema3;
function fixJson2(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
function parsePartialJson2(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON2({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON2({ text: fixJson2(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var textStreamPart22 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart2 = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart22 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart2 = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart2 = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart2 = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart2 = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart2 = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart2 = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart2 = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart2 = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart2 = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart2 = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart2 = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart2 = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart2 = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts2 = [
  textStreamPart22,
  dataStreamPart2,
  errorStreamPart22,
  messageAnnotationsStreamPart2,
  toolCallStreamPart2,
  toolResultStreamPart2,
  toolCallStreamingStartStreamPart2,
  toolCallDeltaStreamPart2,
  finishMessageStreamPart2,
  finishStepStreamPart2,
  startStepStreamPart2,
  reasoningStreamPart2,
  sourcePart2,
  redactedReasoningStreamPart2,
  reasoningSignatureStreamPart2,
  fileStreamPart2
];
Object.fromEntries(
  dataStreamParts2.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts2.map((part) => [part.name, part.code])
);
function formatDataStreamPart2(type, value) {
  const streamPart = dataStreamParts2.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema2(zodSchema222, options) {
  var _a172;
  const useReferences = (_a172 = void 0) != null ? _a172 : false;
  return jsonSchema2(
    esm_default3(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (value) => {
        const result = zodSchema222.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
var schemaSymbol2 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema2(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol2]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol2]: true,
    jsonSchema: jsonSchema222,
    validate
  };
}
function isSchema2(value) {
  return typeof value === "object" && value !== null && schemaSymbol2 in value && value[schemaSymbol2] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema2(schema) {
  return isSchema2(schema) ? schema : zodSchema2(schema);
}
var _globalThis2 = typeof globalThis === "object" ? globalThis : global;
var VERSION2 = "1.9.0";
var re2 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck2(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re2);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re2);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible2 = _makeCompatibilityCheck2(VERSION2);
var major2 = VERSION2.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY2 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major2);
var _global2 = _globalThis2;
function registerGlobal2(type, instance, diag, allowOverride) {
  var _a172;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2] = (_a172 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) !== null && _a172 !== void 0 ? _a172 : {
    version: VERSION2
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION2) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION2);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION2 + ".");
  return true;
}
function getGlobal2(type) {
  var _a172, _b17;
  var globalVersion = (_a172 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _a172 === void 0 ? void 0 : _a172.version;
  if (!globalVersion || !isCompatible2(globalVersion)) {
    return;
  }
  return (_b17 = _global2[GLOBAL_OPENTELEMETRY_API_KEY2]) === null || _b17 === void 0 ? void 0 : _b17[type];
}
function unregisterGlobal2(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION2 + ".");
  var api = _global2[GLOBAL_OPENTELEMETRY_API_KEY2];
  if (api) {
    delete api[type];
  }
}
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger2 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy2("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy2(funcName, namespace, args) {
  var logger = getGlobal2("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray5([], __read5(args), false));
}
var DiagLogLevel2;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel2 || (DiagLogLevel2 = {}));
function createLogLevelDiagLogger2(maxLevel, logger) {
  if (maxLevel < DiagLogLevel2.NONE) {
    maxLevel = DiagLogLevel2.NONE;
  } else if (maxLevel > DiagLogLevel2.ALL) {
    maxLevel = DiagLogLevel2.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel2.ERROR),
    warn: _filterFunc("warn", DiagLogLevel2.WARN),
    info: _filterFunc("info", DiagLogLevel2.INFO),
    debug: _filterFunc("debug", DiagLogLevel2.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel2.VERBOSE)
  };
}
var __read22 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray22 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME4 = "diag";
var DiagAPI2 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal2("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray22([], __read22(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a172, _b17, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel2.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a172 = err.stack) !== null && _a172 !== void 0 ? _a172 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal2("diag");
        var newLogger = createLogLevelDiagLogger2((_b17 = optionsOrLogLevel.logLevel) !== null && _b17 !== void 0 ? _b17 : DiagLogLevel2.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal2("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal2(API_NAME4, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger2(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey2(description) {
  return Symbol.for(description);
}
var BaseContext2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function(key) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT2 = new BaseContext2();
var __read32 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray32 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager2 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT2;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray32([thisArg], __read32(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read42 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray42 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME22 = "context";
var NOOP_CONTEXT_MANAGER2 = new NoopContextManager2();
var ContextAPI2 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal2(API_NAME22, contextManager, DiagAPI2.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context, fn, thisArg) {
      var _a172;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a172 = this._getContextManager()).with.apply(_a172, __spreadArray42([context, fn, thisArg], __read42(args), false));
    };
    ContextAPI222.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal2(API_NAME22) || NOOP_CONTEXT_MANAGER2;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal2(API_NAME22, DiagAPI2.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags2;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags2 || (TraceFlags2 = {}));
var INVALID_SPANID2 = "0000000000000000";
var INVALID_TRACEID2 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT2 = {
  traceId: INVALID_TRACEID2,
  spanId: INVALID_SPANID2,
  traceFlags: TraceFlags2.NONE
};
var NonRecordingSpan2 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT2;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY2 = createContextKey2("OpenTelemetry Context Key SPAN");
function getSpan2(context) {
  return context.getValue(SPAN_KEY2) || void 0;
}
function getActiveSpan2() {
  return getSpan2(ContextAPI2.getInstance().active());
}
function setSpan2(context, span) {
  return context.setValue(SPAN_KEY2, span);
}
function deleteSpan2(context) {
  return context.deleteValue(SPAN_KEY2);
}
function setSpanContext2(context, spanContext) {
  return setSpan2(context, new NonRecordingSpan2(spanContext));
}
function getSpanContext2(context) {
  var _a172;
  return (_a172 = getSpan2(context)) === null || _a172 === void 0 ? void 0 : _a172.spanContext();
}
var VALID_TRACEID_REGEX2 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX2 = /^[0-9a-f]{16}$/i;
function isValidTraceId2(traceId) {
  return VALID_TRACEID_REGEX2.test(traceId) && traceId !== INVALID_TRACEID2;
}
function isValidSpanId2(spanId) {
  return VALID_SPANID_REGEX2.test(spanId) && spanId !== INVALID_SPANID2;
}
function isSpanContextValid2(spanContext) {
  return isValidTraceId2(spanContext.traceId) && isValidSpanId2(spanContext.spanId);
}
function wrapSpanContext2(spanContext) {
  return new NonRecordingSpan2(spanContext);
}
var contextApi2 = ContextAPI2.getInstance();
var NoopTracer2 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name172, options, context) {
      if (context === void 0) {
        context = contextApi2.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan2();
      }
      var parentFromContext = context && getSpanContext2(context);
      if (isSpanContext2(parentFromContext) && isSpanContextValid2(parentFromContext)) {
        return new NonRecordingSpan2(parentFromContext);
      } else {
        return new NonRecordingSpan2();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name172, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi2.active();
      var span = this.startSpan(name172, opts, parentContext);
      var contextWithSpanSet = setSpan2(parentContext, span);
      return contextApi2.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext2(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER2 = new NoopTracer2();
var ProxyTracer2 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name172, version, options) {
      this._provider = _provider;
      this.name = name172;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name172, options, context) {
      return this._getTracer().startSpan(name172, options, context);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER2;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider2 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer2();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER2 = new NoopTracerProvider2();
var ProxyTracerProvider2 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this.getDelegateTracer(name172, version, options)) !== null && _a172 !== void 0 ? _a172 : new ProxyTracer2(this, name172, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a172;
      return (_a172 = this._delegate) !== null && _a172 !== void 0 ? _a172 : NOOP_TRACER_PROVIDER2;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name172, version, options) {
      var _a172;
      return (_a172 = this._delegate) === null || _a172 === void 0 ? void 0 : _a172.getTracer(name172, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode2;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode2 || (SpanStatusCode2 = {}));
var API_NAME32 = "trace";
var TraceAPI2 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider2();
      this.wrapSpanContext = wrapSpanContext2;
      this.isSpanContextValid = isSpanContextValid2;
      this.deleteSpan = deleteSpan2;
      this.getSpan = getSpan2;
      this.getActiveSpan = getActiveSpan2;
      this.getSpanContext = getSpanContext2;
      this.setSpan = setSpan2;
      this.setSpanContext = setSpanContext2;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal2(API_NAME32, this._proxyTracerProvider, DiagAPI2.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal2(API_NAME32) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name172, version) {
      return this.getTracerProvider().getTracer(name172, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal2(API_NAME32, DiagAPI2.instance());
      this._proxyTracerProvider = new ProxyTracerProvider2();
    };
    return TraceAPI222;
  })()
);
var trace = TraceAPI2.getInstance();
var __defProp22 = Object.defineProperty;
var __export3 = (target, all) => {
  for (var name172 in all)
    __defProp22(target, name172, { get: all[name172], enumerable: true });
};
function prepareResponseHeaders2(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}
var UnsupportedModelVersionError = class extends AISDKError2 {
  constructor() {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version. AI SDK 4 only supports models that implement specification version "v1". Please upgrade to AI SDK 5 to use this model.`
    });
  }
};
var name8 = "AI_InvalidArgumentError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var InvalidArgumentError22 = class extends AISDKError2 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name8,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a9] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker9);
  }
};
_a9 = symbol9;
var name22 = "AI_RetryError";
var marker222 = `vercel.ai.error.${name22}`;
var symbol222 = Symbol.for(marker222);
var _a222;
var RetryError = class extends AISDKError2 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name22, message });
    this[_a222] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker222);
  }
};
_a222 = symbol222;
var retryWithExponentialBackoff = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage22(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay(delayInMs);
      return _retryWithExponentialBackoff(
        f,
        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries({
  maxRetries
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError22({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError22({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })
  };
}
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a172;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a172 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a172 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name172, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  }
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return trace.getTracer("ai");
}
function recordSpan({
  name: name172,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name172, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error) {
      try {
        recordErrorOnSpan(span, error);
      } finally {
        span.end();
      }
      throw error;
    }
  });
}
function recordErrorOnSpan(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode2.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode2.ERROR });
  }
}
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value === void 0) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function splitArray(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany({
  model,
  values,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_telemetry: telemetry
}) {
  if (typeof model === "string" || model.specificationVersion !== "v1") {
    throw new UnsupportedModelVersionError();
  }
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { maxRetries }
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;
      if (maxEmbeddingsPerCall == null) {
        const { embeddings: embeddings2, usage } = await retry(() => {
          return recordSpan({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => values.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a172;
              const modelResponse = await model.doEmbed({
                values,
                abortSignal,
                headers
              });
              const embeddings3 = modelResponse.embeddings;
              const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return { embeddings: embeddings3, usage: usage2 };
            }
          });
        });
        span.setAttributes(
          selectTelemetryAttributes({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });
      }
      const valueChunks = splitArray(values, maxEmbeddingsPerCall);
      const embeddings = [];
      let tokens = 0;
      for (const chunk of valueChunks) {
        const { embeddings: responseEmbeddings, usage } = await retry(() => {
          return recordSpan({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => chunk.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a172;
              const modelResponse = await model.doEmbed({
                values: chunk,
                abortSignal,
                headers
              });
              const embeddings2 = modelResponse.embeddings;
              const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return { embeddings: embeddings2, usage: usage2 };
            }
          });
        });
        embeddings.push(...responseEmbeddings);
        tokens += usage.tokens;
      }
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      return new DefaultEmbedManyResult({
        values,
        embeddings,
        usage: { tokens }
      });
    }
  });
}
var DefaultEmbedManyResult = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
  }
};
var name422 = "AI_NoObjectGeneratedError";
var marker422 = `vercel.ai.error.${name422}`;
var symbol422 = Symbol.for(marker422);
var _a422;
var NoObjectGeneratedError2 = class extends AISDKError2 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name422, message, cause });
    this[_a422] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError2.hasMarker(error, marker422);
  }
};
_a422 = symbol422;
var dataContentSchema2 = z18.z.union([
  z18.z.string(),
  z18.z.instanceof(Uint8Array),
  z18.z.instanceof(ArrayBuffer),
  z18.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b17;
      return (_b17 = (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) != null ? _b17 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema2 = z18.z.lazy(
  () => z18.z.union([
    z18.z.null(),
    z18.z.string(),
    z18.z.number(),
    z18.z.boolean(),
    z18.z.record(z18.z.string(), jsonValueSchema2),
    z18.z.array(jsonValueSchema2)
  ])
);
var providerMetadataSchema2 = z18.z.record(
  z18.z.string(),
  z18.z.record(z18.z.string(), jsonValueSchema2)
);
var toolResultContentSchema2 = z18.z.array(
  z18.z.union([
    z18.z.object({ type: z18.z.literal("text"), text: z18.z.string() }),
    z18.z.object({
      type: z18.z.literal("image"),
      data: z18.z.string(),
      mimeType: z18.z.string().optional()
    })
  ])
);
var textPartSchema2 = z18.z.object({
  type: z18.z.literal("text"),
  text: z18.z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var imagePartSchema2 = z18.z.object({
  type: z18.z.literal("image"),
  image: z18.z.union([dataContentSchema2, z18.z.instanceof(URL)]),
  mimeType: z18.z.string().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var filePartSchema2 = z18.z.object({
  type: z18.z.literal("file"),
  data: z18.z.union([dataContentSchema2, z18.z.instanceof(URL)]),
  filename: z18.z.string().optional(),
  mimeType: z18.z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var reasoningPartSchema2 = z18.z.object({
  type: z18.z.literal("reasoning"),
  text: z18.z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var redactedReasoningPartSchema2 = z18.z.object({
  type: z18.z.literal("redacted-reasoning"),
  data: z18.z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolCallPartSchema2 = z18.z.object({
  type: z18.z.literal("tool-call"),
  toolCallId: z18.z.string(),
  toolName: z18.z.string(),
  args: z18.z.unknown(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var toolResultPartSchema2 = z18.z.object({
  type: z18.z.literal("tool-result"),
  toolCallId: z18.z.string(),
  toolName: z18.z.string(),
  result: z18.z.unknown(),
  content: toolResultContentSchema2.optional(),
  isError: z18.z.boolean().optional(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreSystemMessageSchema2 = z18.z.object({
  role: z18.z.literal("system"),
  content: z18.z.string(),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreUserMessageSchema2 = z18.z.object({
  role: z18.z.literal("user"),
  content: z18.z.union([
    z18.z.string(),
    z18.z.array(z18.z.union([textPartSchema2, imagePartSchema2, filePartSchema2]))
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreAssistantMessageSchema2 = z18.z.object({
  role: z18.z.literal("assistant"),
  content: z18.z.union([
    z18.z.string(),
    z18.z.array(
      z18.z.union([
        textPartSchema2,
        filePartSchema2,
        reasoningPartSchema2,
        redactedReasoningPartSchema2,
        toolCallPartSchema2
      ])
    )
  ]),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
var coreToolMessageSchema2 = z18.z.object({
  role: z18.z.literal("tool"),
  content: z18.z.array(toolResultPartSchema2),
  providerOptions: providerMetadataSchema2.optional(),
  experimental_providerMetadata: providerMetadataSchema2.optional()
});
z18.z.union([
  coreSystemMessageSchema2,
  coreUserMessageSchema2,
  coreAssistantMessageSchema2,
  coreToolMessageSchema2
]);
var DEFAULT_SCHEMA_PREFIX2 = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX2 = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX2 = "You MUST answer with JSON.";
function injectJsonInstruction2({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX2 : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX2 : DEFAULT_GENERIC_SUFFIX2
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
createIdGenerator2({ prefix: "aiobj", size: 24 });
createIdGenerator2({ prefix: "aiobj", size: 24 });
createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
createIdGenerator2({
  prefix: "msg",
  size: 24
});
var output_exports2 = {};
__export3(output_exports2, {
  object: () => object2,
  text: () => text2
});
var text2 = () => ({
  type: "text",
  responseFormat: () => ({ type: "text" }),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text222 }) {
    return { partial: text222 };
  },
  parseOutput({ text: text222 }) {
    return text222;
  }
});
var object2 = ({
  schema: inputSchema
}) => {
  const schema = asSchema2(inputSchema);
  return {
    type: "object",
    responseFormat: ({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction2({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text222 }) {
      const result = parsePartialJson2(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text222 }, context) {
      const parseResult = safeParseJSON2({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = safeValidateTypes2({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError2({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
function mergeStreams2(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
createIdGenerator2({
  prefix: "aitxt",
  size: 24
});
createIdGenerator2({
  prefix: "msg",
  size: 24
});
var ClientOrServerImplementationSchema2 = z18.z.object({
  name: z18.z.string(),
  version: z18.z.string()
}).passthrough();
var BaseParamsSchema2 = z18.z.object({
  _meta: z18.z.optional(z18.z.object({}).passthrough())
}).passthrough();
var ResultSchema2 = BaseParamsSchema2;
var RequestSchema2 = z18.z.object({
  method: z18.z.string(),
  params: z18.z.optional(BaseParamsSchema2)
});
var ServerCapabilitiesSchema2 = z18.z.object({
  experimental: z18.z.optional(z18.z.object({}).passthrough()),
  logging: z18.z.optional(z18.z.object({}).passthrough()),
  prompts: z18.z.optional(
    z18.z.object({
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  ),
  resources: z18.z.optional(
    z18.z.object({
      subscribe: z18.z.optional(z18.z.boolean()),
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  ),
  tools: z18.z.optional(
    z18.z.object({
      listChanged: z18.z.optional(z18.z.boolean())
    }).passthrough()
  )
}).passthrough();
ResultSchema2.extend({
  protocolVersion: z18.z.string(),
  capabilities: ServerCapabilitiesSchema2,
  serverInfo: ClientOrServerImplementationSchema2,
  instructions: z18.z.optional(z18.z.string())
});
var PaginatedResultSchema2 = ResultSchema2.extend({
  nextCursor: z18.z.optional(z18.z.string())
});
var ToolSchema2 = z18.z.object({
  name: z18.z.string(),
  description: z18.z.optional(z18.z.string()),
  inputSchema: z18.z.object({
    type: z18.z.literal("object"),
    properties: z18.z.optional(z18.z.object({}).passthrough())
  }).passthrough()
}).passthrough();
PaginatedResultSchema2.extend({
  tools: z18.z.array(ToolSchema2)
});
var TextContentSchema2 = z18.z.object({
  type: z18.z.literal("text"),
  text: z18.z.string()
}).passthrough();
var ImageContentSchema2 = z18.z.object({
  type: z18.z.literal("image"),
  data: z18.z.string().base64(),
  mimeType: z18.z.string()
}).passthrough();
var ResourceContentsSchema2 = z18.z.object({
  /**
   * The URI of this resource.
   */
  uri: z18.z.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z18.z.optional(z18.z.string())
}).passthrough();
var TextResourceContentsSchema2 = ResourceContentsSchema2.extend({
  text: z18.z.string()
});
var BlobResourceContentsSchema2 = ResourceContentsSchema2.extend({
  blob: z18.z.string().base64()
});
var EmbeddedResourceSchema2 = z18.z.object({
  type: z18.z.literal("resource"),
  resource: z18.z.union([TextResourceContentsSchema2, BlobResourceContentsSchema2])
}).passthrough();
ResultSchema2.extend({
  content: z18.z.array(
    z18.z.union([TextContentSchema2, ImageContentSchema2, EmbeddedResourceSchema2])
  ),
  isError: z18.z.boolean().default(false).optional()
}).or(
  ResultSchema2.extend({
    toolResult: z18.z.unknown()
  })
);
var JSONRPC_VERSION2 = "2.0";
var JSONRPCRequestSchema2 = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION2),
  id: z18.z.union([z18.z.string(), z18.z.number().int()])
}).merge(RequestSchema2).strict();
var JSONRPCResponseSchema2 = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION2),
  id: z18.z.union([z18.z.string(), z18.z.number().int()]),
  result: ResultSchema2
}).strict();
var JSONRPCErrorSchema2 = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION2),
  id: z18.z.union([z18.z.string(), z18.z.number().int()]),
  error: z18.z.object({
    code: z18.z.number().int(),
    message: z18.z.string(),
    data: z18.z.optional(z18.z.unknown())
  })
}).strict();
var JSONRPCNotificationSchema2 = z18.z.object({
  jsonrpc: z18.z.literal(JSONRPC_VERSION2)
}).merge(
  z18.z.object({
    method: z18.z.string(),
    params: z18.z.optional(BaseParamsSchema2)
  })
).strict();
z18.z.union([
  JSONRPCRequestSchema2,
  JSONRPCNotificationSchema2,
  JSONRPCResponseSchema2,
  JSONRPCErrorSchema2
]);
var langchain_adapter_exports2 = {};
__export3(langchain_adapter_exports2, {
  mergeIntoDataStream: () => mergeIntoDataStream3,
  toDataStream: () => toDataStream3,
  toDataStreamResponse: () => toDataStreamResponse3
});
function createCallbacksTransformer2(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function toDataStreamInternal3(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: async (value, controller) => {
        var _a172;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk2(
              (_a172 = value.data) == null ? void 0 : _a172.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk2(value, controller);
      }
    })
  ).pipeThrough(createCallbacksTransformer2(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart2("text", chunk));
      }
    })
  );
}
function toDataStream3(stream, callbacks) {
  return toDataStreamInternal3(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse3(stream, options) {
  var _a172;
  const dataStream = toDataStreamInternal3(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams2(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders2(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream3(stream, options) {
  options.dataStream.merge(toDataStreamInternal3(stream, options.callbacks));
}
function forwardAIMessageChunk2(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
var llamaindex_adapter_exports2 = {};
__export3(llamaindex_adapter_exports2, {
  mergeIntoDataStream: () => mergeIntoDataStream22,
  toDataStream: () => toDataStream22,
  toDataStreamResponse: () => toDataStreamResponse22
});
function toDataStreamInternal22(stream, callbacks) {
  const trimStart = trimStartOfStream2();
  return convertAsyncIteratorToReadableStream2(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer2(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart2("text", chunk));
      }
    })
  );
}
function toDataStream22(stream, callbacks) {
  return toDataStreamInternal22(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse22(stream, options = {}) {
  var _a172;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal22(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams2(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a172 = init == null ? void 0 : init.status) != null ? _a172 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders2(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream22(stream, options) {
  options.dataStream.merge(toDataStreamInternal22(stream, options.callbacks));
}
function trimStartOfStream2() {
  let isStreamStart = true;
  return (text222) => {
    if (isStreamStart) {
      text222 = text222.trimStart();
      if (text222)
        isStreamStart = false;
    }
    return text222;
  };
}
var marker17 = "vercel.ai.error";
var symbol17 = Symbol.for(marker17);
var _a17;
var _AISDKError32 = class _AISDKError222 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name144,
    message,
    cause
  }) {
    super(message);
    this[_a17] = true;
    this.name = name144;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError222.hasMarker(error, marker17);
  }
  static hasMarker(error, marker154) {
    const markerSymbol = Symbol.for(marker154);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a17 = symbol17;
var AISDKError22 = _AISDKError32;
var name17 = "AI_APICallError";
var marker23 = `vercel.ai.error.${name17}`;
var symbol23 = Symbol.for(marker23);
var _a23;
var APICallError2 = class extends AISDKError22 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name17, message, cause });
    this[_a23] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker23);
  }
};
_a23 = symbol23;
var name23 = "AI_EmptyResponseBodyError";
var marker33 = `vercel.ai.error.${name23}`;
var symbol33 = Symbol.for(marker33);
var _a33;
var EmptyResponseBodyError = class extends AISDKError22 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name23, message });
    this[_a33] = true;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker33);
  }
};
_a33 = symbol33;
function getErrorMessage3(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name33 = "AI_InvalidArgumentError";
var marker432 = `vercel.ai.error.${name33}`;
var symbol432 = Symbol.for(marker432);
var _a432;
var InvalidArgumentError3 = class extends AISDKError22 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name33, message, cause });
    this[_a432] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker432);
  }
};
_a432 = symbol432;
var name63 = "AI_JSONParseError";
var marker73 = `vercel.ai.error.${name63}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var JSONParseError22 = class extends AISDKError22 {
  constructor({ text: text42, cause }) {
    super({
      name: name63,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a73] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker73);
  }
};
_a73 = symbol73;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError32 = class _TypeValidationError222 extends AISDKError22 {
  constructor({ value, cause }) {
    super({
      name: name123,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a133] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker133);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError222.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError222({ value, cause });
  }
};
_a133 = symbol133;
var TypeValidationError22 = _TypeValidationError32;
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
async function delay2(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve22, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve22();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator22 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError3({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator22();
function getErrorMessage222(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError2(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError2(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError2({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a154, _b17, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a154 = globalThisAny.navigator) == null ? void 0 : _a154.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b17 = globalThisAny.process) == null ? void 0 : _b17.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION22 = "3.0.17";
var getOriginalFetch = () => globalThis.fetch;
var getFromApi = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION22}`,
        getRuntimeEnvironmentUserAgent()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text42) {
  const obj = JSON.parse(text42);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text42) === false && suspectConstructorRx.test(text42) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text42) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse(text42);
  }
  try {
    return _parse(text42);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol22 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator22(validate) {
  return { [validatorSymbol22]: true, validate };
}
function isValidator22(value) {
  return typeof value === "object" && value !== null && validatorSymbol22 in value && value[validatorSymbol22] === true && "validate" in value;
}
function lazyValidator(createValidator) {
  let validator222;
  return () => {
    if (validator222 == null) {
      validator222 = createValidator();
    }
    return validator222;
  };
}
function asValidator22(value) {
  return isValidator22(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema2) {
  return validator22(async (value) => {
    const result = await standardSchema2["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError22({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes22({ value, schema });
  if (!result.success) {
    throw TypeValidationError22.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes22({
  value,
  schema
}) {
  const validator222 = asValidator22(schema);
  try {
    if (validator222.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator222.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError22.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError22.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse(text42);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error) {
    if (JSONParseError22.isInstance(error) || TypeValidationError22.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError22({ text: text42, cause: error });
  }
}
async function safeParseJSON22({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes22({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError22.isInstance(error) ? error : new JSONParseError22({ text: text42, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON22({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION22}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError2(error) || APICallError2.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: body.values });
  }
};
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError2({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON22({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError2({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var getRelativePath22 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var ignoreOverride22 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions22 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions22 = (options) => typeof options === "string" ? {
  ...defaultOptions22,
  name: options
} : {
  ...defaultOptions22,
  ...options
};
function parseAnyDef22() {
  return {};
}
function parseArrayDef22(def, refs) {
  var _a154, _b17, _c;
  const res = {
    type: "array"
  };
  if (((_a154 = def.type) == null ? void 0 : _a154._def) && ((_c = (_b17 = def.type) == null ? void 0 : _b17._def) == null ? void 0 : _c.typeName) !== v3.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef22(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef22(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef22() {
  return { type: "boolean" };
}
function parseBrandedDef22(_def, refs) {
  return parseDef22(_def.type._def, refs);
}
var parseCatchDef22 = (def, refs) => {
  return parseDef22(def.innerType._def, refs);
};
function parseDateDef22(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef22(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser22(def);
  }
}
var integerDateParser22 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef22(_def, refs) {
  return {
    ...parseDef22(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef22(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef22(_def.schema._def, refs) : parseAnyDef22();
}
function parseEnumDef22(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType22 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef22(def, refs) {
  const allOf = [
    parseDef22(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef22(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType22(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef22(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex22 = void 0;
var zodPatterns22 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex22 === void 0) {
      emojiRegex22 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex22;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef22(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat22(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat22(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern22(res, zodPatterns22.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat22(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat22(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern22(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern22(res, zodPatterns22.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern22(res, zodPatterns22.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern22(
            res,
            RegExp(`^${escapeLiteralCheckValue22(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern22(
            res,
            RegExp(`${escapeLiteralCheckValue22(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat22(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat22(res, "date", check.message, refs);
          break;
        case "time":
          addFormat22(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat22(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern22(
            res,
            RegExp(escapeLiteralCheckValue22(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat22(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat22(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern22(res, zodPatterns22.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern22(res, zodPatterns22.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern22(res, zodPatterns22.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern22(res, zodPatterns22.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern22(res, zodPatterns22.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern22(res, zodPatterns22.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat22(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern22(res, zodPatterns22.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern22(res, zodPatterns22.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue22(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric22(literal) : literal;
}
var ALPHA_NUMERIC22 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric22(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC22.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat22(schema, value, message, refs) {
  var _a154;
  if (schema.format || ((_a154 = schema.anyOf) == null ? void 0 : _a154.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern22(schema, regex, message, refs) {
  var _a154;
  if (schema.pattern || ((_a154 = schema.allOf) == null ? void 0 : _a154.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags22(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags22(regex, refs);
  }
}
function stringifyRegExpWithFlags22(regex, refs) {
  var _a154;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a154 = source[i + 2]) == null ? void 0 : _a154.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef22(def, refs) {
  var _a154, _b17, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a154 = parseDef22(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a154 : refs.allowedAdditionalProperties
  };
  if (((_b17 = def.keyType) == null ? void 0 : _b17._def.typeName) === v3.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef22(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === v3.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === v3.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === v3.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef22(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef22(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef22(def, refs);
  }
  const keys = parseDef22(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef22();
  const values = parseDef22(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef22();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef22(def) {
  const object42 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object42[object42[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object42[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef22() {
  return { not: parseAnyDef22() };
}
function parseNullDef22() {
  return {
    type: "null"
  };
}
var primitiveMappings22 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef22(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings22 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings22[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf22(def, refs);
}
var asAnyOf22 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef22(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef22(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings22[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef22(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef22(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef22(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional22(propDef);
    const parsedDef = parseDef22(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties22(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties22(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef22(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional22(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef22 = (def, refs) => {
  var _a154;
  if (refs.currentPath.toString() === ((_a154 = refs.propertyPath) == null ? void 0 : _a154.toString())) {
    return parseDef22(def.innerType._def, refs);
  }
  const innerSchema = parseDef22(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef22() }, innerSchema] } : parseAnyDef22();
};
var parsePipelineDef22 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef22(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef22(def.out._def, refs);
  }
  const a = parseDef22(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef22(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef22(def, refs) {
  return parseDef22(def.type._def, refs);
}
function parseSetDef22(def, refs) {
  const items = parseDef22(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef22(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef22(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef22(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef22(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef22() {
  return {
    not: parseAnyDef22()
  };
}
function parseUnknownDef22() {
  return parseAnyDef22();
}
var parseReadonlyDef22 = (def, refs) => {
  return parseDef22(def.innerType._def, refs);
};
var selectParser22 = (def, typeName, refs) => {
  switch (typeName) {
    case v3.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef22(def);
    case v3.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef22(def);
    case v3.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef22();
    case v3.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef22();
    case v3.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef22();
    case v3.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUnion:
    case v3.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef22(def);
    case v3.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef22(def);
    case v3.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef22(def);
    case v3.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case v3.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNaN:
    case v3.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef22();
    case v3.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef22();
    case v3.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef22();
    case v3.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef22(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodFunction:
    case v3.ZodFirstPartyTypeKind.ZodVoid:
    case v3.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef22(def, refs, forceResolution = false) {
  var _a154;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a154 = refs.override) == null ? void 0 : _a154.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride22) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref22(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser22(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef22(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta22(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref22 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath22(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef22();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef22() : void 0;
    }
  }
};
var addMeta22 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
  }
  return jsonSchema222;
};
var getRefs22 = (options) => {
  const _options = getDefaultOptions22(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name144, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name144],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zodToJsonSchema23 = (schema, options) => {
  var _a154;
  const refs = getRefs22(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name224, schema2]) => {
      var _a224;
      return {
        ...acc,
        [name224]: (_a224 = parseDef22(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name224]
          },
          true
        )) != null ? _a224 : parseAnyDef22()
      };
    },
    {}
  ) : void 0;
  const name144 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a154 = parseDef22(
    schema._def,
    name144 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name144]
    },
    false
  )) != null ? _a154 : parseAnyDef22();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name144 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name144
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name144]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default = zodToJsonSchema23;
function zod3Schema(zodSchema222, options) {
  var _a154;
  const useReferences = (_a154 = void 0) != null ? _a154 : false;
  return jsonSchema22(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema222.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema(zodSchema222, options) {
  var _a154;
  const useReferences = (_a154 = void 0) != null ? _a154 : false;
  return jsonSchema22(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z42__namespace.toJSONSchema(zodSchema222, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: async (value) => {
        const result = await z42__namespace.safeParseAsync(zodSchema222, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema(zodSchema222) {
  return "_zod" in zodSchema222;
}
function zodSchema22(zodSchema222, options) {
  if (isZod4Schema(zodSchema222)) {
    return zod4Schema(zodSchema222);
  } else {
    return zod3Schema(zodSchema222);
  }
}
var schemaSymbol22 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema22(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol22]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol22]: true,
    get jsonSchema() {
      if (typeof jsonSchema222 === "function") {
        jsonSchema222 = jsonSchema222();
      }
      return jsonSchema222;
    },
    validate
  };
}
function isSchema22(value) {
  return typeof value === "object" && value !== null && schemaSymbol22 in value && value[schemaSymbol22] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema22(schema) {
  return schema == null ? jsonSchema22({
    properties: {},
    additionalProperties: false
  }) : isSchema22(schema) ? schema : typeof schema === "function" ? schema() : zodSchema22(schema);
}
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context = chunkT4SPG2GP_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name162 in all)
        __defProp222(target, name162, { get: all[name162], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export222(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token = chunkT4SPG2GP_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name162 in all)
        __defProp222(target, name162, { get: all[name162], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export222(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context();
    var import_token_error = chunkT4SPG2GP_cjs.require_token_error();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-NEHG7TUY-TIJ3LMSH-ANFISSXX.cjs'),
          await import('./token-6GSAFR2W-VLY2XUPA-RKITWXKR.cjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        if (err?.message && error instanceof Error) {
          error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist = chunkT4SPG2GP_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name162 in all)
        __defProp222(target, name162, { get: all[name162], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export222(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
    var import_get_context = require_get_context();
  }
});
var import_oidc = chunkT4SPG2GP_cjs.__toESM(require_dist(), 1);
var import_oidc2 = chunkT4SPG2GP_cjs.__toESM(require_dist(), 1);
var marker18 = "vercel.ai.gateway.error";
var symbol18 = Symbol.for(marker18);
var _a18;
var _b;
var GatewayError = class _GatewayError extends (_b = Error, _a18 = symbol18, _b) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a18] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol18 in error && error[symbol18] === true;
  }
};
var name18 = "GatewayAuthenticationError";
var marker24 = `vercel.ai.gateway.error.${name18}`;
var symbol24 = Symbol.for(marker24);
var _a24;
var _b2;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a24 = symbol24, _b2) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a24] = true;
    this.name = name18;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol24 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name24 = "GatewayInvalidRequestError";
var marker34 = `vercel.ai.gateway.error.${name24}`;
var symbol34 = Symbol.for(marker34);
var _a34;
var _b3;
var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a34 = symbol34, _b3) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a34] = true;
    this.name = name24;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol34 in error;
  }
};
var name34 = "GatewayRateLimitError";
var marker44 = `vercel.ai.gateway.error.${name34}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var _b4;
var GatewayRateLimitError = class extends (_b4 = GatewayError, _a44 = symbol44, _b4) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a44] = true;
    this.name = name34;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol44 in error;
  }
};
var name44 = "GatewayModelNotFoundError";
var marker54 = `vercel.ai.gateway.error.${name44}`;
var symbol54 = Symbol.for(marker54);
var modelNotFoundParamSchema = lazyValidator(
  () => zodSchema22(
    z42.z.object({
      modelId: z42.z.string()
    })
  )
);
var _a54;
var _b5;
var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a54 = symbol54, _b5) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a54] = true;
    this.name = name44;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol54 in error;
  }
};
var name54 = "GatewayInternalServerError";
var marker64 = `vercel.ai.gateway.error.${name54}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var _b6;
var GatewayInternalServerError = class extends (_b6 = GatewayError, _a64 = symbol64, _b6) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a64] = true;
    this.name = name54;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol64 in error;
  }
};
var name64 = "GatewayResponseError";
var marker74 = `vercel.ai.gateway.error.${name64}`;
var symbol74 = Symbol.for(marker74);
var _a74;
var _b7;
var GatewayResponseError = class extends (_b7 = GatewayError, _a74 = symbol74, _b7) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a74] = true;
    this.name = name64;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError.hasMarker(error) && symbol74 in error;
  }
};
async function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = await safeValidateTypes22({
    value: response,
    schema: gatewayErrorResponseSchema
  });
  if (!parseResult.success) {
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = await safeValidateTypes22({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema
      });
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema = lazyValidator(
  () => zodSchema22(
    z42.z.object({
      error: z42.z.object({
        message: z42.z.string(),
        type: z42.z.string().nullish(),
        param: z42.z.unknown().nullish(),
        code: z42.z.union([z42.z.string(), z42.z.number()]).nullish()
      })
    })
  )
);
function asGatewayError(error, authMethod) {
  var _a832;
  if (GatewayError.isInstance(error)) {
    return error;
  }
  if (APICallError2.isInstance(error)) {
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error),
      statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
async function parseAuthMethod(headers) {
  const result = await safeValidateTypes22({
    value: headers[GATEWAY_AUTH_METHOD_HEADER],
    schema: gatewayAuthMethodSchema
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema = lazyValidator(
  () => zodSchema22(z42.z.union([z42.z.literal("api-key"), z42.z.literal("oidc")]))
);
var GatewayFetchMetadata = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi({
        url: `${this.config.baseURL}/config`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(
          gatewayAvailableModelsResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(
          gatewayCreditsResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema = lazyValidator(
  () => zodSchema22(
    z42.z.object({
      models: z42.z.array(
        z42.z.object({
          id: z42.z.string(),
          name: z42.z.string(),
          description: z42.z.string().nullish(),
          pricing: z42.z.object({
            input: z42.z.string(),
            output: z42.z.string(),
            input_cache_read: z42.z.string().nullish(),
            input_cache_write: z42.z.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z42.z.object({
            specificationVersion: z42.z.literal("v2"),
            provider: z42.z.string(),
            modelId: z42.z.string()
          }),
          modelType: z42.z.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema = lazyValidator(
  () => zodSchema22(
    z42.z.object({
      balance: z42.z.string(),
      total_used: z42.z.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a832;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve(this.config.o11yHeaders)
        ),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler(
          gatewayEmbeddingResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    } catch (error) {
      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema = lazyValidator(
  () => zodSchema22(
    z42.z.object({
      embeddings: z42.z.array(z42.z.array(z42.z.number())),
      usage: z42.z.object({ tokens: z42.z.number() }).nullish(),
      providerMetadata: z42.z.record(z42.z.string(), z42.z.record(z42.z.string(), z42.z.unknown())).optional()
    })
  )
);
var GatewayImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a832;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions }
        },
        successfulResponseHandler: createJsonResponseHandler(
          gatewayImageResponseSchema
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var providerMetadataEntrySchema = z42.z.object({
  images: z42.z.array(z42.z.unknown()).optional()
}).catchall(z42.z.unknown());
var gatewayImageResponseSchema = z42.z.object({
  images: z42.z.array(z42.z.string()),
  // Always base64 strings over the wire
  warnings: z42.z.array(
    z42.z.object({
      type: z42.z.literal("other"),
      message: z42.z.string()
    })
  ).optional(),
  providerMetadata: z42.z.record(z42.z.string(), providerMetadataEntrySchema).optional()
});
async function getVercelRequestId() {
  var _a832;
  return (_a832 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION3 = "2.0.15";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
  var _a832, _b83;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b83 = withoutTrailingSlash(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken(options);
    if (auth) {
      return withUserAgentSuffix(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION3}`
      );
    }
    throw GatewayAuthenticationError.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError(
          error,
          await parseAuthMethod(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError(
        error,
        await parseAuthMethod(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
  const apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e2) {
    return null;
  }
}
var _globalThis22 = typeof globalThis === "object" ? globalThis : global;
var VERSION222 = "1.9.0";
var re22 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck22(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re22);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re22);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible22 = _makeCompatibilityCheck22(VERSION222);
var major22 = VERSION222.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY22 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major22);
var _global22 = _globalThis22;
function registerGlobal22(type, instance, diag, allowOverride) {
  var _a162;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global22[GLOBAL_OPENTELEMETRY_API_KEY22] = (_a162 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) !== null && _a162 !== void 0 ? _a162 : {
    version: VERSION222
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION222) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION222);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION222 + ".");
  return true;
}
function getGlobal22(type) {
  var _a162, _b83;
  var globalVersion = (_a162 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) === null || _a162 === void 0 ? void 0 : _a162.version;
  if (!globalVersion || !isCompatible22(globalVersion)) {
    return;
  }
  return (_b83 = _global22[GLOBAL_OPENTELEMETRY_API_KEY22]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal22(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION222 + ".");
  var api = _global22[GLOBAL_OPENTELEMETRY_API_KEY22];
  if (api) {
    delete api[type];
  }
}
var __read52 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray52 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger22 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy22("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy22(funcName, namespace, args) {
  var logger = getGlobal22("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray52([], __read52(args), false));
}
var DiagLogLevel22;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel22 || (DiagLogLevel22 = {}));
function createLogLevelDiagLogger22(maxLevel, logger) {
  if (maxLevel < DiagLogLevel22.NONE) {
    maxLevel = DiagLogLevel22.NONE;
  } else if (maxLevel > DiagLogLevel22.ALL) {
    maxLevel = DiagLogLevel22.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel22.ERROR),
    warn: _filterFunc("warn", DiagLogLevel22.WARN),
    info: _filterFunc("info", DiagLogLevel22.INFO),
    debug: _filterFunc("debug", DiagLogLevel22.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel22.VERBOSE)
  };
}
var __read222 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray222 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME42 = "diag";
var DiagAPI22 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal22("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray222([], __read222(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a162, _b83, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel22.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a162 = err.stack) !== null && _a162 !== void 0 ? _a162 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal22("diag");
        var newLogger = createLogLevelDiagLogger22((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel22.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal22("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal22(API_NAME42, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger22(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey22(description) {
  return Symbol.for(description);
}
var BaseContext22 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function(key) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT22 = new BaseContext22();
var __read322 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray322 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager22 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT22;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray322([thisArg], __read322(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read422 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray422 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME222 = "context";
var NOOP_CONTEXT_MANAGER22 = new NoopContextManager22();
var ContextAPI22 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal22(API_NAME222, contextManager, DiagAPI22.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context, fn, thisArg) {
      var _a162;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a162 = this._getContextManager()).with.apply(_a162, __spreadArray422([context, fn, thisArg], __read422(args), false));
    };
    ContextAPI222.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal22(API_NAME222) || NOOP_CONTEXT_MANAGER22;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal22(API_NAME222, DiagAPI22.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags22;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags22 || (TraceFlags22 = {}));
var INVALID_SPANID22 = "0000000000000000";
var INVALID_TRACEID22 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT22 = {
  traceId: INVALID_TRACEID22,
  spanId: INVALID_SPANID22,
  traceFlags: TraceFlags22.NONE
};
var NonRecordingSpan22 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT22;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY22 = createContextKey22("OpenTelemetry Context Key SPAN");
function getSpan22(context) {
  return context.getValue(SPAN_KEY22) || void 0;
}
function getActiveSpan22() {
  return getSpan22(ContextAPI22.getInstance().active());
}
function setSpan22(context, span) {
  return context.setValue(SPAN_KEY22, span);
}
function deleteSpan22(context) {
  return context.deleteValue(SPAN_KEY22);
}
function setSpanContext22(context, spanContext) {
  return setSpan22(context, new NonRecordingSpan22(spanContext));
}
function getSpanContext22(context) {
  var _a162;
  return (_a162 = getSpan22(context)) === null || _a162 === void 0 ? void 0 : _a162.spanContext();
}
var VALID_TRACEID_REGEX22 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX22 = /^[0-9a-f]{16}$/i;
function isValidTraceId22(traceId) {
  return VALID_TRACEID_REGEX22.test(traceId) && traceId !== INVALID_TRACEID22;
}
function isValidSpanId22(spanId) {
  return VALID_SPANID_REGEX22.test(spanId) && spanId !== INVALID_SPANID22;
}
function isSpanContextValid22(spanContext) {
  return isValidTraceId22(spanContext.traceId) && isValidSpanId22(spanContext.spanId);
}
function wrapSpanContext22(spanContext) {
  return new NonRecordingSpan22(spanContext);
}
var contextApi22 = ContextAPI22.getInstance();
var NoopTracer22 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name162, options, context) {
      if (context === void 0) {
        context = contextApi22.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan22();
      }
      var parentFromContext = context && getSpanContext22(context);
      if (isSpanContext22(parentFromContext) && isSpanContextValid22(parentFromContext)) {
        return new NonRecordingSpan22(parentFromContext);
      } else {
        return new NonRecordingSpan22();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name162, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi22.active();
      var span = this.startSpan(name162, opts, parentContext);
      var contextWithSpanSet = setSpan22(parentContext, span);
      return contextApi22.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext22(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER22 = new NoopTracer22();
var ProxyTracer22 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name162, version, options) {
      this._provider = _provider;
      this.name = name162;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name162, options, context) {
      return this._getTracer().startSpan(name162, options, context);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER22;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider22 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer22();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER22 = new NoopTracerProvider22();
var ProxyTracerProvider22 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name162, version, options) {
      var _a162;
      return (_a162 = this.getDelegateTracer(name162, version, options)) !== null && _a162 !== void 0 ? _a162 : new ProxyTracer22(this, name162, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a162;
      return (_a162 = this._delegate) !== null && _a162 !== void 0 ? _a162 : NOOP_TRACER_PROVIDER22;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name162, version, options) {
      var _a162;
      return (_a162 = this._delegate) === null || _a162 === void 0 ? void 0 : _a162.getTracer(name162, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode22;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode22 || (SpanStatusCode22 = {}));
var API_NAME322 = "trace";
var TraceAPI22 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider22();
      this.wrapSpanContext = wrapSpanContext22;
      this.isSpanContextValid = isSpanContextValid22;
      this.deleteSpan = deleteSpan22;
      this.getSpan = getSpan22;
      this.getActiveSpan = getActiveSpan22;
      this.getSpanContext = getSpanContext22;
      this.setSpan = setSpan22;
      this.setSpanContext = setSpanContext22;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal22(API_NAME322, this._proxyTracerProvider, DiagAPI22.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal22(API_NAME322) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name162, version) {
      return this.getTracerProvider().getTracer(name162, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal22(API_NAME322, DiagAPI22.instance());
      this._proxyTracerProvider = new ProxyTracerProvider22();
    };
    return TraceAPI222;
  })()
);
var trace2 = TraceAPI22.getInstance();
var __defProp32 = Object.defineProperty;
var __export22 = (target, all) => {
  for (var name162 in all)
    __defProp32(target, name162, { get: all[name162], enumerable: true });
};
var name222 = "AI_InvalidArgumentError";
var marker2222 = `vercel.ai.error.${name222}`;
var symbol2222 = Symbol.for(marker2222);
var _a2222;
var InvalidArgumentError222 = class extends AISDKError22 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name222,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a2222] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker2222);
  }
};
_a2222 = symbol2222;
var name622 = "AI_NoObjectGeneratedError";
var marker622 = `vercel.ai.error.${name622}`;
var symbol622 = Symbol.for(marker622);
var _a622;
var NoObjectGeneratedError22 = class extends AISDKError22 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name622, message, cause });
    this[_a622] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker622);
  }
};
_a622 = symbol622;
var UnsupportedModelVersionError2 = class extends AISDKError22 {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name142 = "AI_RetryError";
var marker144 = `vercel.ai.error.${name142}`;
var symbol144 = Symbol.for(marker144);
var _a144;
var RetryError2 = class extends AISDKError22 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name142, message });
    this[_a144] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError22.hasMarker(error, marker144);
  }
};
_a144 = symbol144;
function resolveEmbeddingModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v2") {
      throw new UnsupportedModelVersionError2({
        version: model.specificationVersion,
        provider: model.provider,
        modelId: model.modelId
      });
    }
    return model;
  }
  return getGlobalProvider().textEmbeddingModel(
    model
  );
}
function getGlobalProvider() {
  var _a162;
  return (_a162 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a162 : gateway;
}
var VERSION32 = "5.0.101";
var dataContentSchema22 = z42.z.union([
  z42.z.string(),
  z42.z.instanceof(Uint8Array),
  z42.z.instanceof(ArrayBuffer),
  z42.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a162, _b83;
      return (_b83 = (_a162 = globalThis.Buffer) == null ? void 0 : _a162.isBuffer(value)) != null ? _b83 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema22 = z42.z.lazy(
  () => z42.z.union([
    z42.z.null(),
    z42.z.string(),
    z42.z.number(),
    z42.z.boolean(),
    z42.z.record(z42.z.string(), jsonValueSchema22),
    z42.z.array(jsonValueSchema22)
  ])
);
var providerMetadataSchema22 = z42.z.record(
  z42.z.string(),
  z42.z.record(z42.z.string(), jsonValueSchema22)
);
var textPartSchema22 = z42.z.object({
  type: z42.z.literal("text"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var imagePartSchema22 = z42.z.object({
  type: z42.z.literal("image"),
  image: z42.z.union([dataContentSchema22, z42.z.instanceof(URL)]),
  mediaType: z42.z.string().optional(),
  providerOptions: providerMetadataSchema22.optional()
});
var filePartSchema22 = z42.z.object({
  type: z42.z.literal("file"),
  data: z42.z.union([dataContentSchema22, z42.z.instanceof(URL)]),
  filename: z42.z.string().optional(),
  mediaType: z42.z.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var reasoningPartSchema22 = z42.z.object({
  type: z42.z.literal("reasoning"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema22.optional()
});
var toolCallPartSchema22 = z42.z.object({
  type: z42.z.literal("tool-call"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  input: z42.z.unknown(),
  providerOptions: providerMetadataSchema22.optional(),
  providerExecuted: z42.z.boolean().optional()
});
var outputSchema = z42.z.discriminatedUnion("type", [
  z42.z.object({
    type: z42.z.literal("text"),
    value: z42.z.string()
  }),
  z42.z.object({
    type: z42.z.literal("json"),
    value: jsonValueSchema22
  }),
  z42.z.object({
    type: z42.z.literal("error-text"),
    value: z42.z.string()
  }),
  z42.z.object({
    type: z42.z.literal("error-json"),
    value: jsonValueSchema22
  }),
  z42.z.object({
    type: z42.z.literal("content"),
    value: z42.z.array(
      z42.z.union([
        z42.z.object({
          type: z42.z.literal("text"),
          text: z42.z.string()
        }),
        z42.z.object({
          type: z42.z.literal("media"),
          data: z42.z.string(),
          mediaType: z42.z.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema22 = z42.z.object({
  type: z42.z.literal("tool-result"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema22.optional()
});
var systemModelMessageSchema = z42.z.object(
  {
    role: z42.z.literal("system"),
    content: z42.z.string(),
    providerOptions: providerMetadataSchema22.optional()
  }
);
var userModelMessageSchema = z42.z.object({
  role: z42.z.literal("user"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(z42.z.union([textPartSchema22, imagePartSchema22, filePartSchema22]))
  ]),
  providerOptions: providerMetadataSchema22.optional()
});
var assistantModelMessageSchema = z42.z.object({
  role: z42.z.literal("assistant"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(
      z42.z.union([
        textPartSchema22,
        filePartSchema22,
        reasoningPartSchema22,
        toolCallPartSchema22,
        toolResultPartSchema22
      ])
    )
  ]),
  providerOptions: providerMetadataSchema22.optional()
});
var toolModelMessageSchema = z42.z.object({
  role: z42.z.literal("tool"),
  content: z42.z.array(toolResultPartSchema22),
  providerOptions: providerMetadataSchema22.optional()
});
z42.z.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
function assembleOperationName2({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes2({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a162;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a162 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a162 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer2 = {
  startSpan() {
    return noopSpan2;
  },
  startActiveSpan(name162, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan2);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan2);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan2);
    }
  }
};
var noopSpan2 = {
  spanContext() {
    return noopSpanContext2;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext2 = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer2({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer2;
  }
  if (tracer) {
    return tracer;
  }
  return trace2.getTracer("ai");
}
function recordSpan2({
  name: name162,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name162, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error) {
      try {
        recordErrorOnSpan2(span, error);
      } finally {
        span.end();
      }
      throw error;
    }
  });
}
function recordErrorOnSpan2(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode22.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode22.ERROR });
  }
}
function selectTelemetryAttributes2({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value == null) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function getRetryDelayInMs({
  error,
  exponentialBackoffDelay
}) {
  const headers = error.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff2(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff2(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError2(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage222(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError2({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError2.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay2(
        getRetryDelayInMs({
          error,
          exponentialBackoffDelay: delayInMs
        }),
        { abortSignal }
      );
      return _retryWithExponentialBackoff2(
        f,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal
        },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError2({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries2({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError222({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError222({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
createIdGenerator22({
  prefix: "aitxt",
  size: 24
});
function fixJson22(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson22(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON22({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON22({ text: fixJson22(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
createIdGenerator22({
  prefix: "aitxt",
  size: 24
});
function splitArray2(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany2({
  model: modelArg,
  values,
  maxParallelCalls = Infinity,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry
}) {
  const model = resolveEmbeddingModel(modelArg);
  const { maxRetries, retry } = prepareRetries2({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION32}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes2({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer2(telemetry);
  return recordSpan2({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes2({
      telemetry,
      attributes: {
        ...assembleOperationName2({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      var _a162;
      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
        model.maxEmbeddingsPerCall,
        model.supportsParallelCalls
      ]);
      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
        const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(
          () => {
            return recordSpan2({
              name: "ai.embedMany.doEmbed",
              attributes: selectTelemetryAttributes2({
                telemetry,
                attributes: {
                  ...assembleOperationName2({
                    operationId: "ai.embedMany.doEmbed",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  // specific settings that only make sense on the outer level:
                  "ai.values": {
                    input: () => values.map((value) => JSON.stringify(value))
                  }
                }
              }),
              tracer,
              fn: async (doEmbedSpan) => {
                var _a172;
                const modelResponse = await model.doEmbed({
                  values,
                  abortSignal,
                  headers: headersWithUserAgent,
                  providerOptions
                });
                const embeddings3 = modelResponse.embeddings;
                const usage2 = (_a172 = modelResponse.usage) != null ? _a172 : { tokens: NaN };
                doEmbedSpan.setAttributes(
                  selectTelemetryAttributes2({
                    telemetry,
                    attributes: {
                      "ai.embeddings": {
                        output: () => embeddings3.map(
                          (embedding) => JSON.stringify(embedding)
                        )
                      },
                      "ai.usage.tokens": usage2.tokens
                    }
                  })
                );
                return {
                  embeddings: embeddings3,
                  usage: usage2,
                  providerMetadata: modelResponse.providerMetadata,
                  response: modelResponse.response
                };
              }
            });
          }
        );
        span.setAttributes(
          selectTelemetryAttributes2({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        return new DefaultEmbedManyResult2({
          values,
          embeddings: embeddings2,
          usage,
          providerMetadata: providerMetadata2,
          responses: [response]
        });
      }
      const valueChunks = splitArray2(values, maxEmbeddingsPerCall);
      const embeddings = [];
      const responses = [];
      let tokens = 0;
      let providerMetadata;
      const parallelChunks = splitArray2(
        valueChunks,
        supportsParallelCalls ? maxParallelCalls : 1
      );
      for (const parallelChunk of parallelChunks) {
        const results = await Promise.all(
          parallelChunk.map((chunk) => {
            return retry(() => {
              return recordSpan2({
                name: "ai.embedMany.doEmbed",
                attributes: selectTelemetryAttributes2({
                  telemetry,
                  attributes: {
                    ...assembleOperationName2({
                      operationId: "ai.embedMany.doEmbed",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.values": {
                      input: () => chunk.map((value) => JSON.stringify(value))
                    }
                  }
                }),
                tracer,
                fn: async (doEmbedSpan) => {
                  var _a172;
                  const modelResponse = await model.doEmbed({
                    values: chunk,
                    abortSignal,
                    headers: headersWithUserAgent,
                    providerOptions
                  });
                  const embeddings2 = modelResponse.embeddings;
                  const usage = (_a172 = modelResponse.usage) != null ? _a172 : { tokens: NaN };
                  doEmbedSpan.setAttributes(
                    selectTelemetryAttributes2({
                      telemetry,
                      attributes: {
                        "ai.embeddings": {
                          output: () => embeddings2.map(
                            (embedding) => JSON.stringify(embedding)
                          )
                        },
                        "ai.usage.tokens": usage.tokens
                      }
                    })
                  );
                  return {
                    embeddings: embeddings2,
                    usage,
                    providerMetadata: modelResponse.providerMetadata,
                    response: modelResponse.response
                  };
                }
              });
            });
          })
        );
        for (const result of results) {
          embeddings.push(...result.embeddings);
          responses.push(result.response);
          tokens += result.usage.tokens;
          if (result.providerMetadata) {
            if (!providerMetadata) {
              providerMetadata = { ...result.providerMetadata };
            } else {
              for (const [providerName, metadata] of Object.entries(
                result.providerMetadata
              )) {
                providerMetadata[providerName] = {
                  ...(_a162 = providerMetadata[providerName]) != null ? _a162 : {},
                  ...metadata
                };
              }
            }
          }
        }
      }
      span.setAttributes(
        selectTelemetryAttributes2({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      return new DefaultEmbedManyResult2({
        values,
        embeddings,
        usage: { tokens },
        providerMetadata,
        responses
      });
    }
  });
}
var DefaultEmbedManyResult2 = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
    this.providerMetadata = options.providerMetadata;
    this.responses = options.responses;
  }
};
createIdGenerator22({ prefix: "aiobj", size: 24 });
createIdGenerator22({ prefix: "aiobj", size: 24 });
var output_exports22 = {};
__export22(output_exports22, {
  object: () => object22,
  text: () => text22
});
var text22 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text222 }) {
    return { partial: text222 };
  },
  async parseOutput({ text: text222 }) {
    return text222;
  }
});
var object22 = ({
  schema: inputSchema
}) => {
  const schema = asSchema22(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text222 }) {
      const result = await parsePartialJson22(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text222 }, context) {
      const parseResult = await safeParseJSON22({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError22({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = await safeValidateTypes22({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError22({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
var marker19 = "vercel.ai.error";
var symbol19 = Symbol.for(marker19);
var _a19;
var _b8;
var AISDKError3 = class _AISDKError4 extends (_b8 = Error, _a19 = symbol19, _b8) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name1422,
    message,
    cause
  }) {
    super(message);
    this[_a19] = true;
    this.name = name1422;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError4.hasMarker(error, marker19);
  }
  static hasMarker(error, marker1522) {
    const markerSymbol = Symbol.for(marker1522);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
var name19 = "AI_APICallError";
var marker25 = `vercel.ai.error.${name19}`;
var symbol25 = Symbol.for(marker25);
var _a25;
var _b22;
var APICallError3 = class extends (_b22 = AISDKError3, _a25 = symbol25, _b22) {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name19, message, cause });
    this[_a25] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker25);
  }
};
var name25 = "AI_EmptyResponseBodyError";
var marker35 = `vercel.ai.error.${name25}`;
var symbol35 = Symbol.for(marker35);
var _a35;
var _b32;
var EmptyResponseBodyError2 = class extends (_b32 = AISDKError3, _a35 = symbol35, _b32) {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name25, message });
    this[_a35] = true;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker35);
  }
};
function getErrorMessage4(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name35 = "AI_InvalidArgumentError";
var marker45 = `vercel.ai.error.${name35}`;
var symbol45 = Symbol.for(marker45);
var _a45;
var _b42;
var InvalidArgumentError4 = class extends (_b42 = AISDKError3, _a45 = symbol45, _b42) {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name35, message, cause });
    this[_a45] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker45);
  }
};
var name65 = "AI_JSONParseError";
var marker75 = `vercel.ai.error.${name65}`;
var symbol75 = Symbol.for(marker75);
var _a75;
var _b72;
var JSONParseError3 = class extends (_b72 = AISDKError3, _a75 = symbol75, _b72) {
  constructor({ text: text42, cause }) {
    super({
      name: name65,
      message: `JSON parsing failed: Text: ${text42}.
Error message: ${getErrorMessage4(cause)}`,
      cause
    });
    this[_a75] = true;
    this.text = text42;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker75);
  }
};
var name125 = "AI_TypeValidationError";
var marker135 = `vercel.ai.error.${name125}`;
var symbol135 = Symbol.for(marker135);
var _a135;
var _b13;
var TypeValidationError3 = class _TypeValidationError4 extends (_b13 = AISDKError3, _a135 = symbol135, _b13) {
  constructor({ value, cause }) {
    super({
      name: name125,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage4(cause)}`,
      cause
    });
    this[_a135] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker135);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError4.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError4({ value, cause });
  }
};
var ParseError2 = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop2(_arg) {
}
function createParser2(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop2, onError = noop2, onRetry = noop2, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError2(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError2(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines2(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream2 = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser2({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
async function delay3(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve22, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError2());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve22();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError2());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError2() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator3 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError4({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator3();
function getErrorMessage23(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError3(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
function handleFetchError2({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError3(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError3({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
  var _a224, _b222, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a224 = globalThisAny.navigator) == null ? void 0 : _a224.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b222 = globalThisAny.process) == null ? void 0 : _b222.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders2(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders2(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION4 = "4.0.0";
var getOriginalFetch3 = () => globalThis.fetch;
var getFromApi2 = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch3()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix2(
        headers,
        `ai-sdk/provider-utils/${VERSION4}`,
        getRuntimeEnvironmentUserAgent2()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
        throw new APICallError3({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError3({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError2({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting2({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx2 = /"__proto__"\s*:/;
var suspectConstructorRx2 = /"constructor"\s*:/;
function _parse2(text42) {
  const obj = JSON.parse(text42);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text42) === false && suspectConstructorRx2.test(text42) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text42) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse2(text42);
  }
  try {
    return _parse2(text42);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema222) {
  if (jsonSchema222.type === "object") {
    jsonSchema222.additionalProperties = false;
    const properties = jsonSchema222.properties;
    if (properties != null) {
      for (const property in properties) {
        properties[property] = addAdditionalPropertiesToJsonSchema(
          properties[property]
        );
      }
    }
  }
  if (jsonSchema222.type === "array" && jsonSchema222.items != null) {
    if (Array.isArray(jsonSchema222.items)) {
      jsonSchema222.items = jsonSchema222.items.map(
        (item) => addAdditionalPropertiesToJsonSchema(item)
      );
    } else {
      jsonSchema222.items = addAdditionalPropertiesToJsonSchema(
        jsonSchema222.items
      );
    }
  }
  return jsonSchema222;
}
var ignoreOverride32 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions32 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions32 = (options) => typeof options === "string" ? {
  ...defaultOptions32,
  name: options
} : {
  ...defaultOptions32,
  ...options
};
function parseAnyDef32() {
  return {};
}
function parseArrayDef32(def, refs) {
  var _a224, _b222, _c;
  const res = {
    type: "array"
  };
  if (((_a224 = def.type) == null ? void 0 : _a224._def) && ((_c = (_b222 = def.type) == null ? void 0 : _b222._def) == null ? void 0 : _c.typeName) !== v3.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef32(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef32(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef32() {
  return { type: "boolean" };
}
function parseBrandedDef32(_def, refs) {
  return parseDef32(_def.type._def, refs);
}
var parseCatchDef32 = (def, refs) => {
  return parseDef32(def.innerType._def, refs);
};
function parseDateDef32(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef32(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser32(def);
  }
}
var integerDateParser32 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef32(_def, refs) {
  return {
    ...parseDef32(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef32(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef32(_def.schema._def, refs) : parseAnyDef32();
}
function parseEnumDef32(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType32 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef32(def, refs) {
  const allOf = [
    parseDef32(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef32(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType32(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef32(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex32 = void 0;
var zodPatterns32 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex32 === void 0) {
      emojiRegex32 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex32;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef32(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat32(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat32(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern32(res, zodPatterns32.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat32(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat32(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern32(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern32(res, zodPatterns32.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern32(res, zodPatterns32.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern32(
            res,
            RegExp(`^${escapeLiteralCheckValue32(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern32(
            res,
            RegExp(`${escapeLiteralCheckValue32(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat32(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat32(res, "date", check.message, refs);
          break;
        case "time":
          addFormat32(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat32(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern32(
            res,
            RegExp(escapeLiteralCheckValue32(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat32(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat32(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern32(res, zodPatterns32.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern32(res, zodPatterns32.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern32(res, zodPatterns32.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern32(res, zodPatterns32.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern32(res, zodPatterns32.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern32(res, zodPatterns32.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat32(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern32(res, zodPatterns32.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern32(res, zodPatterns32.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue32(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric32(literal) : literal;
}
var ALPHA_NUMERIC32 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric32(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC32.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat32(schema, value, message, refs) {
  var _a224;
  if (schema.format || ((_a224 = schema.anyOf) == null ? void 0 : _a224.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern32(schema, regex, message, refs) {
  var _a224;
  if (schema.pattern || ((_a224 = schema.allOf) == null ? void 0 : _a224.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags32(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags32(regex, refs);
  }
}
function stringifyRegExpWithFlags32(regex, refs) {
  var _a224;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a224 = source[i + 2]) == null ? void 0 : _a224.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef32(def, refs) {
  var _a224, _b222, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a224 = parseDef32(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a224 : refs.allowedAdditionalProperties
  };
  if (((_b222 = def.keyType) == null ? void 0 : _b222._def.typeName) === v3.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef32(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === v3.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === v3.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === v3.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef32(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef32(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef32(def, refs);
  }
  const keys = parseDef32(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef32();
  const values = parseDef32(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef32();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef32(def) {
  const object42 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object42[object42[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object42[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef32() {
  return { not: parseAnyDef32() };
}
function parseNullDef32() {
  return {
    type: "null"
  };
}
var primitiveMappings32 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef32(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings32 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings32[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf32(def, refs);
}
var asAnyOf32 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef32(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef32(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings32[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef32(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef32(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef32(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional32(propDef);
    const parsedDef = parseDef32(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties32(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties32(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef32(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional32(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef32 = (def, refs) => {
  var _a224;
  if (refs.currentPath.toString() === ((_a224 = refs.propertyPath) == null ? void 0 : _a224.toString())) {
    return parseDef32(def.innerType._def, refs);
  }
  const innerSchema = parseDef32(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef32() }, innerSchema] } : parseAnyDef32();
};
var parsePipelineDef32 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef32(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef32(def.out._def, refs);
  }
  const a = parseDef32(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef32(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef32(def, refs) {
  return parseDef32(def.type._def, refs);
}
function parseSetDef32(def, refs) {
  const items = parseDef32(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef32(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef32(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef32(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef32(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef32() {
  return {
    not: parseAnyDef32()
  };
}
function parseUnknownDef32() {
  return parseAnyDef32();
}
var parseReadonlyDef32 = (def, refs) => {
  return parseDef32(def.innerType._def, refs);
};
var selectParser32 = (def, typeName, refs) => {
  switch (typeName) {
    case v3.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef32(def);
    case v3.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef32(def);
    case v3.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef32();
    case v3.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef32();
    case v3.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef32();
    case v3.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUnion:
    case v3.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef32(def);
    case v3.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef32(def);
    case v3.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef32(def);
    case v3.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case v3.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNaN:
    case v3.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef32();
    case v3.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef32();
    case v3.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef32();
    case v3.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef32(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodFunction:
    case v3.ZodFirstPartyTypeKind.ZodVoid:
    case v3.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
var getRelativePath32 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseDef32(def, refs, forceResolution = false) {
  var _a224;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a224 = refs.override) == null ? void 0 : _a224.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride32) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref32(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser32(def, def.typeName, refs);
  const jsonSchema222 = typeof jsonSchemaOrGetter === "function" ? parseDef32(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema222) {
    addMeta32(def, refs, jsonSchema222);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema222, def, refs);
    newItem.jsonSchema = jsonSchema222;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema222;
  return jsonSchema222;
}
var get$ref32 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath32(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef32();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef32() : void 0;
    }
  }
};
var addMeta32 = (def, refs, jsonSchema222) => {
  if (def.description) {
    jsonSchema222.description = def.description;
  }
  return jsonSchema222;
};
var getRefs32 = (options) => {
  const _options = getDefaultOptions32(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name224, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name224],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zod3ToJsonSchema = (schema, options) => {
  var _a224;
  const refs = getRefs32(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name324, schema2]) => {
      var _a324;
      return {
        ...acc,
        [name324]: (_a324 = parseDef32(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name324]
          },
          true
        )) != null ? _a324 : parseAnyDef32()
      };
    },
    {}
  ) : void 0;
  const name224 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a224 = parseDef32(
    schema._def,
    name224 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name224]
    },
    false
  )) != null ? _a224 : parseAnyDef32();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name224 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name224
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name224]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var schemaSymbol3 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema3(jsonSchema222, {
  validate
} = {}) {
  return {
    [schemaSymbol3]: true,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      if (typeof jsonSchema222 === "function") {
        jsonSchema222 = jsonSchema222();
      }
      return jsonSchema222;
    },
    validate
  };
}
function isSchema3(value) {
  return typeof value === "object" && value !== null && schemaSymbol3 in value && value[schemaSymbol3] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema3(schema) {
  return schema == null ? jsonSchema3({ properties: {}, additionalProperties: false }) : isSchema3(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema3(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
  return jsonSchema3(
    () => standardSchema2["~standard"].jsonSchema.input({
      target: "draft-07"
    }),
    {
      validate: async (value) => {
        const result = await standardSchema2["~standard"].validate(value);
        return "value" in result ? { success: true, value: result.value } : {
          success: false,
          error: new TypeValidationError3({
            value,
            cause: result.issues
          })
        };
      }
    }
  );
}
function zod3Schema2(zodSchema222, options) {
  var _a224;
  const useReferences = (_a224 = void 0) != null ? _a224 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod3ToJsonSchema(zodSchema222, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema222.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema2(zodSchema222, options) {
  var _a224;
  const useReferences = (_a224 = void 0) != null ? _a224 : false;
  return jsonSchema3(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => addAdditionalPropertiesToJsonSchema(
      z42__namespace.toJSONSchema(zodSchema222, {
        target: "draft-7",
        io: "input",
        reused: useReferences ? "ref" : "inline"
      })
    ),
    {
      validate: async (value) => {
        const result = await z42__namespace.safeParseAsync(zodSchema222, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema2(zodSchema222) {
  return "_zod" in zodSchema222;
}
function zodSchema3(zodSchema222, options) {
  if (isZod4Schema2(zodSchema222)) {
    return zod4Schema2(zodSchema222);
  } else {
    return zod3Schema2(zodSchema222);
  }
}
async function validateTypes2({
  value,
  schema
}) {
  const result = await safeValidateTypes3({ value, schema });
  if (!result.success) {
    throw TypeValidationError3.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes3({
  value,
  schema
}) {
  const actualSchema = asSchema3(schema);
  try {
    if (actualSchema.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await actualSchema.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError3.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON2({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse2(text42);
    if (schema == null) {
      return value;
    }
    return validateTypes2({ value, schema });
  } catch (error) {
    if (JSONParseError3.isInstance(error) || TypeValidationError3.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError3({ text: text42, cause: error });
  }
}
async function safeParseJSON3({
  text: text42,
  schema
}) {
  try {
    const value = secureJsonParse2(text42);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes3({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError3.isInstance(error) ? error : new JSONParseError3({ text: text42, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON3({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch22 = () => globalThis.fetch;
var postJsonToApi2 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi2({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi2 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch22()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix2(
        headers,
        `ai-sdk/provider-utils/${VERSION4}`,
        getRuntimeEnvironmentUserAgent2()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
        throw new APICallError3({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError3(error) || APICallError3.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError3({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError2({ error, url, requestBodyValues: body.values });
  }
};
async function resolve2(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler2 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders2(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError3({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON2({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError3({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError3({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler2 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders2(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError2({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream2({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler2 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON3({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders2(response);
  if (!parsedResult.success) {
    throw new APICallError3({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
function withoutTrailingSlash2(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context2 = chunk4EYONQIW_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name144 in all)
        __defProp222(target, name144, { get: all[name144], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export222(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token2 = chunk4EYONQIW_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name144 in all)
        __defProp222(target, name144, { get: all[name144], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export222(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context2();
    var import_token_error = chunk4EYONQIW_cjs.require_token_error();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-NEHG7TUY-KSXDO2NO-J6DEINGO.cjs'),
          await import('./token-6GSAFR2W-K2BTU23I-5WBYUIGY.cjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        if (err?.message && error instanceof Error) {
          error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist2 = chunk4EYONQIW_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js"(exports, module) {
    var __defProp222 = Object.defineProperty;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __export222 = (target, all) => {
      for (var name144 in all)
        __defProp222(target, name144, { get: all[name144], enumerable: true });
    };
    var __copyProps22 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames22(from))
          if (!__hasOwnProp22.call(to, key) && key !== except)
            __defProp222(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps22(__defProp222({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export222(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token2();
    var import_get_context = require_get_context2();
  }
});
var import_oidc3 = chunk4EYONQIW_cjs.__toESM(require_dist2(), 1);
var import_oidc22 = chunk4EYONQIW_cjs.__toESM(require_dist2(), 1);
var marker20 = "vercel.ai.gateway.error";
var symbol20 = Symbol.for(marker20);
var _a20;
var _b16;
var GatewayError2 = class _GatewayError2 extends (_b16 = Error, _a20 = symbol20, _b16) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a20] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError2.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol20 in error && error[symbol20] === true;
  }
};
var name20 = "GatewayAuthenticationError";
var marker26 = `vercel.ai.gateway.error.${name20}`;
var symbol26 = Symbol.for(marker26);
var _a26;
var _b23;
var GatewayAuthenticationError2 = class _GatewayAuthenticationError2 extends (_b23 = GatewayError2, _a26 = symbol26, _b23) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a26] = true;
    this.name = name20;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol26 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError2({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name26 = "GatewayInvalidRequestError";
var marker36 = `vercel.ai.gateway.error.${name26}`;
var symbol36 = Symbol.for(marker36);
var _a36;
var _b33;
var GatewayInvalidRequestError2 = class extends (_b33 = GatewayError2, _a36 = symbol36, _b33) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a36] = true;
    this.name = name26;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol36 in error;
  }
};
var name36 = "GatewayRateLimitError";
var marker46 = `vercel.ai.gateway.error.${name36}`;
var symbol46 = Symbol.for(marker46);
var _a46;
var _b43;
var GatewayRateLimitError2 = class extends (_b43 = GatewayError2, _a46 = symbol46, _b43) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a46] = true;
    this.name = name36;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol46 in error;
  }
};
var name46 = "GatewayModelNotFoundError";
var marker56 = `vercel.ai.gateway.error.${name46}`;
var symbol56 = Symbol.for(marker56);
var modelNotFoundParamSchema2 = lazySchema(
  () => zodSchema3(
    z42.z.object({
      modelId: z42.z.string()
    })
  )
);
var _a56;
var _b53;
var GatewayModelNotFoundError2 = class extends (_b53 = GatewayError2, _a56 = symbol56, _b53) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a56] = true;
    this.name = name46;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol56 in error;
  }
};
var name56 = "GatewayInternalServerError";
var marker66 = `vercel.ai.gateway.error.${name56}`;
var symbol66 = Symbol.for(marker66);
var _a66;
var _b63;
var GatewayInternalServerError2 = class extends (_b63 = GatewayError2, _a66 = symbol66, _b63) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a66] = true;
    this.name = name56;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol66 in error;
  }
};
var name66 = "GatewayResponseError";
var marker76 = `vercel.ai.gateway.error.${name66}`;
var symbol76 = Symbol.for(marker76);
var _a76;
var _b73;
var GatewayResponseError2 = class extends (_b73 = GatewayError2, _a76 = symbol76, _b73) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a76] = true;
    this.name = name66;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError2.hasMarker(error) && symbol76 in error;
  }
};
async function createGatewayErrorFromResponse2({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = await safeValidateTypes3({
    value: response,
    schema: gatewayErrorResponseSchema2
  });
  if (!parseResult.success) {
    return new GatewayResponseError2({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError2.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError2({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError2({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = await safeValidateTypes3({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema2
      });
      return new GatewayModelNotFoundError2({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError2({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError2({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema2 = lazySchema(
  () => zodSchema3(
    z42.z.object({
      error: z42.z.object({
        message: z42.z.string(),
        type: z42.z.string().nullish(),
        param: z42.z.unknown().nullish(),
        code: z42.z.union([z42.z.string(), z42.z.number()]).nullish()
      })
    })
  )
);
function asGatewayError2(error, authMethod) {
  var _a832;
  if (GatewayError2.isInstance(error)) {
    return error;
  }
  if (APICallError3.isInstance(error)) {
    return createGatewayErrorFromResponse2({
      response: extractApiCallResponse2(error),
      statusCode: (_a832 = error.statusCode) != null ? _a832 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse2({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse2(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER2 = "ai-gateway-auth-method";
async function parseAuthMethod2(headers) {
  const result = await safeValidateTypes3({
    value: headers[GATEWAY_AUTH_METHOD_HEADER2],
    schema: gatewayAuthMethodSchema2
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema2 = lazySchema(
  () => zodSchema3(z42.z.union([z42.z.literal("api-key"), z42.z.literal("oidc")]))
);
var GatewayFetchMetadata2 = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi2({
        url: `${this.config.baseURL}/config`,
        headers: await resolve2(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayAvailableModelsResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError2(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi2({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve2(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayCreditsResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError2(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema2 = lazySchema(
  () => zodSchema3(
    z42.z.object({
      models: z42.z.array(
        z42.z.object({
          id: z42.z.string(),
          name: z42.z.string(),
          description: z42.z.string().nullish(),
          pricing: z42.z.object({
            input: z42.z.string(),
            output: z42.z.string(),
            input_cache_read: z42.z.string().nullish(),
            input_cache_write: z42.z.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z42.z.object({
            specificationVersion: z42.z.literal("v3"),
            provider: z42.z.string(),
            modelId: z42.z.string()
          }),
          modelType: z42.z.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema2 = lazySchema(
  () => zodSchema3(
    z42.z.object({
      balance: z42.z.string(),
      total_used: z42.z.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve2(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler2(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve2(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler2(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a832;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve2(this.config.o11yHeaders)
        ),
        body: {
          values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayEmbeddingResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a832 = responseBody.usage) != null ? _a832 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue },
        warnings: []
      };
    } catch (error) {
      throw await asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema2 = lazySchema(
  () => zodSchema3(
    z42.z.object({
      embeddings: z42.z.array(z42.z.array(z42.z.number())),
      usage: z42.z.object({ tokens: z42.z.number() }).nullish(),
      providerMetadata: z42.z.record(z42.z.string(), z42.z.record(z42.z.string(), z42.z.unknown())).optional()
    })
  )
);
var GatewayImageModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v3";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a832;
    const resolvedHeaders = await resolve2(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi2({
        url: this.getUrl(),
        headers: combineHeaders2(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve2(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions }
        },
        successfulResponseHandler: createJsonResponseHandler2(
          gatewayImageResponseSchema2
        ),
        failedResponseHandler: createJsonErrorResponseHandler2({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a832 = responseBody.warnings) != null ? _a832 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError2(error, await parseAuthMethod2(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var providerMetadataEntrySchema2 = z42.z.object({
  images: z42.z.array(z42.z.unknown()).optional()
}).catchall(z42.z.unknown());
var gatewayImageResponseSchema2 = z42.z.object({
  images: z42.z.array(z42.z.string()),
  // Always base64 strings over the wire
  warnings: z42.z.array(
    z42.z.object({
      type: z42.z.literal("other"),
      message: z42.z.string()
    })
  ).optional(),
  providerMetadata: z42.z.record(z42.z.string(), providerMetadataEntrySchema2).optional()
});
async function getVercelRequestId2() {
  var _a832;
  return (_a832 = (0, import_oidc3.getContext)().headers) == null ? void 0 : _a832["x-vercel-id"];
}
var VERSION5 = "3.0.0";
var AI_GATEWAY_PROTOCOL_VERSION2 = "0.0.1";
function createGatewayProvider2(options = {}) {
  var _a832, _b83;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a832 = options.metadataCacheRefreshMillis) != null ? _a832 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b83 = withoutTrailingSlash2(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v3/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken2(options);
    if (auth) {
      return withUserAgentSuffix2(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION2,
          [GATEWAY_AUTH_METHOD_HEADER2]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION5}`
      );
    }
    throw GatewayAuthenticationError2.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting2({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId2();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata2({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError2(
          error,
          await parseAuthMethod2(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata2({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError2(
        error,
        await parseAuthMethod2(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  const createEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel2(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  return provider;
}
var gateway2 = createGatewayProvider2();
async function getGatewayAuthToken2(options) {
  const apiKey = loadOptionalSetting2({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await (0, import_oidc22.getVercelOidcToken)();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e2) {
    return null;
  }
}
var _globalThis3 = typeof globalThis === "object" ? globalThis : global;
var VERSION23 = "1.9.0";
var re3 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck3(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re3);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible222(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re3);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible3 = _makeCompatibilityCheck3(VERSION23);
var major3 = VERSION23.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY3 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major3);
var _global3 = _globalThis3;
function registerGlobal3(type, instance, diag, allowOverride) {
  var _a146;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3] = (_a146 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) !== null && _a146 !== void 0 ? _a146 : {
    version: VERSION23
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION23) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION23);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION23 + ".");
  return true;
}
function getGlobal3(type) {
  var _a146, _b83;
  var globalVersion = (_a146 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _a146 === void 0 ? void 0 : _a146.version;
  if (!globalVersion || !isCompatible3(globalVersion)) {
    return;
  }
  return (_b83 = _global3[GLOBAL_OPENTELEMETRY_API_KEY3]) === null || _b83 === void 0 ? void 0 : _b83[type];
}
function unregisterGlobal3(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION23 + ".");
  var api = _global3[GLOBAL_OPENTELEMETRY_API_KEY3];
  if (api) {
    delete api[type];
  }
}
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray6 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger3 = (
  /** @class */
  (function() {
    function DiagComponentLogger222(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger222.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("debug", this._namespace, args);
    };
    DiagComponentLogger222.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("error", this._namespace, args);
    };
    DiagComponentLogger222.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("info", this._namespace, args);
    };
    DiagComponentLogger222.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("warn", this._namespace, args);
    };
    DiagComponentLogger222.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy3("verbose", this._namespace, args);
    };
    return DiagComponentLogger222;
  })()
);
function logProxy3(funcName, namespace, args) {
  var logger = getGlobal3("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray6([], __read6(args), false));
}
var DiagLogLevel3;
(function(DiagLogLevel222) {
  DiagLogLevel222[DiagLogLevel222["NONE"] = 0] = "NONE";
  DiagLogLevel222[DiagLogLevel222["ERROR"] = 30] = "ERROR";
  DiagLogLevel222[DiagLogLevel222["WARN"] = 50] = "WARN";
  DiagLogLevel222[DiagLogLevel222["INFO"] = 60] = "INFO";
  DiagLogLevel222[DiagLogLevel222["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel222[DiagLogLevel222["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel222[DiagLogLevel222["ALL"] = 9999] = "ALL";
})(DiagLogLevel3 || (DiagLogLevel3 = {}));
function createLogLevelDiagLogger3(maxLevel, logger) {
  if (maxLevel < DiagLogLevel3.NONE) {
    maxLevel = DiagLogLevel3.NONE;
  } else if (maxLevel > DiagLogLevel3.ALL) {
    maxLevel = DiagLogLevel3.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel3.ERROR),
    warn: _filterFunc("warn", DiagLogLevel3.WARN),
    info: _filterFunc("info", DiagLogLevel3.INFO),
    debug: _filterFunc("debug", DiagLogLevel3.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel3.VERBOSE)
  };
}
var __read23 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray23 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME5 = "diag";
var DiagAPI3 = (
  /** @class */
  (function() {
    function DiagAPI222() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal3("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray23([], __read23(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a146, _b83, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel3.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a146 = err.stack) !== null && _a146 !== void 0 ? _a146 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal3("diag");
        var newLogger = createLogLevelDiagLogger3((_b83 = optionsOrLogLevel.logLevel) !== null && _b83 !== void 0 ? _b83 : DiagLogLevel3.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal3("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal3(API_NAME5, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger3(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI222.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI222();
      }
      return this._instance;
    };
    return DiagAPI222;
  })()
);
function createContextKey3(description) {
  return Symbol.for(description);
}
var BaseContext3 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext222(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function(key) {
        var context = new BaseContext222(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext222;
  })()
);
var ROOT_CONTEXT3 = new BaseContext3();
var __read33 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray33 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager3 = (
  /** @class */
  (function() {
    function NoopContextManager222() {
    }
    NoopContextManager222.prototype.active = function() {
      return ROOT_CONTEXT3;
    };
    NoopContextManager222.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray33([thisArg], __read33(args), false));
    };
    NoopContextManager222.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager222.prototype.enable = function() {
      return this;
    };
    NoopContextManager222.prototype.disable = function() {
      return this;
    };
    return NoopContextManager222;
  })()
);
var __read43 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray43 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME23 = "context";
var NOOP_CONTEXT_MANAGER3 = new NoopContextManager3();
var ContextAPI3 = (
  /** @class */
  (function() {
    function ContextAPI222() {
    }
    ContextAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI222();
      }
      return this._instance;
    };
    ContextAPI222.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal3(API_NAME23, contextManager, DiagAPI3.instance());
    };
    ContextAPI222.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI222.prototype.with = function(context, fn, thisArg) {
      var _a146;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a146 = this._getContextManager()).with.apply(_a146, __spreadArray43([context, fn, thisArg], __read43(args), false));
    };
    ContextAPI222.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI222.prototype._getContextManager = function() {
      return getGlobal3(API_NAME23) || NOOP_CONTEXT_MANAGER3;
    };
    ContextAPI222.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal3(API_NAME23, DiagAPI3.instance());
    };
    return ContextAPI222;
  })()
);
var TraceFlags3;
(function(TraceFlags222) {
  TraceFlags222[TraceFlags222["NONE"] = 0] = "NONE";
  TraceFlags222[TraceFlags222["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags3 || (TraceFlags3 = {}));
var INVALID_SPANID3 = "0000000000000000";
var INVALID_TRACEID3 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT3 = {
  traceId: INVALID_TRACEID3,
  spanId: INVALID_SPANID3,
  traceFlags: TraceFlags3.NONE
};
var NonRecordingSpan3 = (
  /** @class */
  (function() {
    function NonRecordingSpan222(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT3;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan222.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan222.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan222.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan222.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan222.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan222.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan222.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan222.prototype.end = function(_endTime) {
    };
    NonRecordingSpan222.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan222.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan222;
  })()
);
var SPAN_KEY3 = createContextKey3("OpenTelemetry Context Key SPAN");
function getSpan3(context) {
  return context.getValue(SPAN_KEY3) || void 0;
}
function getActiveSpan3() {
  return getSpan3(ContextAPI3.getInstance().active());
}
function setSpan3(context, span) {
  return context.setValue(SPAN_KEY3, span);
}
function deleteSpan3(context) {
  return context.deleteValue(SPAN_KEY3);
}
function setSpanContext3(context, spanContext) {
  return setSpan3(context, new NonRecordingSpan3(spanContext));
}
function getSpanContext3(context) {
  var _a146;
  return (_a146 = getSpan3(context)) === null || _a146 === void 0 ? void 0 : _a146.spanContext();
}
var VALID_TRACEID_REGEX3 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX3 = /^[0-9a-f]{16}$/i;
function isValidTraceId3(traceId) {
  return VALID_TRACEID_REGEX3.test(traceId) && traceId !== INVALID_TRACEID3;
}
function isValidSpanId3(spanId) {
  return VALID_SPANID_REGEX3.test(spanId) && spanId !== INVALID_SPANID3;
}
function isSpanContextValid3(spanContext) {
  return isValidTraceId3(spanContext.traceId) && isValidSpanId3(spanContext.spanId);
}
function wrapSpanContext3(spanContext) {
  return new NonRecordingSpan3(spanContext);
}
var contextApi3 = ContextAPI3.getInstance();
var NoopTracer3 = (
  /** @class */
  (function() {
    function NoopTracer222() {
    }
    NoopTracer222.prototype.startSpan = function(name144, options, context) {
      if (context === void 0) {
        context = contextApi3.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan3();
      }
      var parentFromContext = context && getSpanContext3(context);
      if (isSpanContext3(parentFromContext) && isSpanContextValid3(parentFromContext)) {
        return new NonRecordingSpan3(parentFromContext);
      } else {
        return new NonRecordingSpan3();
      }
    };
    NoopTracer222.prototype.startActiveSpan = function(name144, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi3.active();
      var span = this.startSpan(name144, opts, parentContext);
      var contextWithSpanSet = setSpan3(parentContext, span);
      return contextApi3.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer222;
  })()
);
function isSpanContext3(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER3 = new NoopTracer3();
var ProxyTracer3 = (
  /** @class */
  (function() {
    function ProxyTracer222(_provider, name144, version, options) {
      this._provider = _provider;
      this.name = name144;
      this.version = version;
      this.options = options;
    }
    ProxyTracer222.prototype.startSpan = function(name144, options, context) {
      return this._getTracer().startSpan(name144, options, context);
    };
    ProxyTracer222.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer222.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER3;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer222;
  })()
);
var NoopTracerProvider3 = (
  /** @class */
  (function() {
    function NoopTracerProvider222() {
    }
    NoopTracerProvider222.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer3();
    };
    return NoopTracerProvider222;
  })()
);
var NOOP_TRACER_PROVIDER3 = new NoopTracerProvider3();
var ProxyTracerProvider3 = (
  /** @class */
  (function() {
    function ProxyTracerProvider222() {
    }
    ProxyTracerProvider222.prototype.getTracer = function(name144, version, options) {
      var _a146;
      return (_a146 = this.getDelegateTracer(name144, version, options)) !== null && _a146 !== void 0 ? _a146 : new ProxyTracer3(this, name144, version, options);
    };
    ProxyTracerProvider222.prototype.getDelegate = function() {
      var _a146;
      return (_a146 = this._delegate) !== null && _a146 !== void 0 ? _a146 : NOOP_TRACER_PROVIDER3;
    };
    ProxyTracerProvider222.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider222.prototype.getDelegateTracer = function(name144, version, options) {
      var _a146;
      return (_a146 = this._delegate) === null || _a146 === void 0 ? void 0 : _a146.getTracer(name144, version, options);
    };
    return ProxyTracerProvider222;
  })()
);
var SpanStatusCode3;
(function(SpanStatusCode222) {
  SpanStatusCode222[SpanStatusCode222["UNSET"] = 0] = "UNSET";
  SpanStatusCode222[SpanStatusCode222["OK"] = 1] = "OK";
  SpanStatusCode222[SpanStatusCode222["ERROR"] = 2] = "ERROR";
})(SpanStatusCode3 || (SpanStatusCode3 = {}));
var API_NAME33 = "trace";
var TraceAPI3 = (
  /** @class */
  (function() {
    function TraceAPI222() {
      this._proxyTracerProvider = new ProxyTracerProvider3();
      this.wrapSpanContext = wrapSpanContext3;
      this.isSpanContextValid = isSpanContextValid3;
      this.deleteSpan = deleteSpan3;
      this.getSpan = getSpan3;
      this.getActiveSpan = getActiveSpan3;
      this.getSpanContext = getSpanContext3;
      this.setSpan = setSpan3;
      this.setSpanContext = setSpanContext3;
    }
    TraceAPI222.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI222();
      }
      return this._instance;
    };
    TraceAPI222.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal3(API_NAME33, this._proxyTracerProvider, DiagAPI3.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI222.prototype.getTracerProvider = function() {
      return getGlobal3(API_NAME33) || this._proxyTracerProvider;
    };
    TraceAPI222.prototype.getTracer = function(name144, version) {
      return this.getTracerProvider().getTracer(name144, version);
    };
    TraceAPI222.prototype.disable = function() {
      unregisterGlobal3(API_NAME33, DiagAPI3.instance());
      this._proxyTracerProvider = new ProxyTracerProvider3();
    };
    return TraceAPI222;
  })()
);
var trace3 = TraceAPI3.getInstance();
var __defProp4 = Object.defineProperty;
var __export32 = (target, all) => {
  for (var name144 in all)
    __defProp4(target, name144, { get: all[name144], enumerable: true });
};
var name76 = "AI_InvalidArgumentError";
var marker86 = `vercel.ai.error.${name76}`;
var symbol86 = Symbol.for(marker86);
var _a86;
var InvalidArgumentError23 = class extends AISDKError3 {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name76,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a86] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker86);
  }
};
_a86 = symbol86;
var name523 = "AI_NoObjectGeneratedError";
var marker523 = `vercel.ai.error.${name523}`;
var symbol523 = Symbol.for(marker523);
var _a523;
var NoObjectGeneratedError3 = class extends AISDKError3 {
  constructor({
    message = "No object generated.",
    cause,
    text: text222,
    response,
    usage,
    finishReason
  }) {
    super({ name: name523, message, cause });
    this[_a523] = true;
    this.text = text222;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker523);
  }
};
_a523 = symbol523;
var UnsupportedModelVersionError3 = class extends AISDKError3 {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name126 = "AI_RetryError";
var marker125 = `vercel.ai.error.${name126}`;
var symbol125 = Symbol.for(marker125);
var _a125;
var RetryError3 = class extends AISDKError3 {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name126, message });
    this[_a125] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError3.hasMarker(error, marker125);
  }
};
_a125 = symbol125;
function formatWarning({
  warning,
  provider,
  model
}) {
  const prefix = `AI SDK Warning (${provider} / ${model}):`;
  switch (warning.type) {
    case "unsupported": {
      let message = `${prefix} The feature "${warning.feature}" is not supported.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "compatibility": {
      let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "other": {
      return `${prefix} ${warning.message}`;
    }
    default: {
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
    }
  }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (options) => {
  if (options.warnings.length === 0) {
    return;
  }
  const logger = globalThis.AI_SDK_LOG_WARNINGS;
  if (logger === false) {
    return;
  }
  if (typeof logger === "function") {
    logger(options);
    return;
  }
  if (!hasLoggedBefore) {
    hasLoggedBefore = true;
    console.info(FIRST_WARNING_INFO_MESSAGE);
  }
  for (const warning of options.warnings) {
    console.warn(
      formatWarning({
        warning,
        provider: options.provider,
        model: options.model
      })
    );
  }
};
function logV2CompatibilityWarning({
  provider,
  modelId
}) {
  logWarnings({
    warnings: [
      {
        type: "compatibility",
        feature: "specificationVersion",
        details: `Using v2 specification compatibility mode. Some features may not be available.`
      }
    ],
    provider,
    model: modelId
  });
}
function asEmbeddingModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function resolveEmbeddingModel2(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError3({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asEmbeddingModelV3(model);
  }
  return getGlobalProvider2().embeddingModel(model);
}
function getGlobalProvider2() {
  var _a146;
  return (_a146 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a146 : gateway2;
}
var VERSION33 = "6.0.1";
var dataContentSchema3 = z42.z.union([
  z42.z.string(),
  z42.z.instanceof(Uint8Array),
  z42.z.instanceof(ArrayBuffer),
  z42.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a146, _b83;
      return (_b83 = (_a146 = globalThis.Buffer) == null ? void 0 : _a146.isBuffer(value)) != null ? _b83 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema3 = z42.z.lazy(
  () => z42.z.union([
    z42.z.null(),
    z42.z.string(),
    z42.z.number(),
    z42.z.boolean(),
    z42.z.record(z42.z.string(), jsonValueSchema3.optional()),
    z42.z.array(jsonValueSchema3)
  ])
);
var providerMetadataSchema3 = z42.z.record(
  z42.z.string(),
  z42.z.record(z42.z.string(), jsonValueSchema3.optional())
);
var textPartSchema3 = z42.z.object({
  type: z42.z.literal("text"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var imagePartSchema3 = z42.z.object({
  type: z42.z.literal("image"),
  image: z42.z.union([dataContentSchema3, z42.z.instanceof(URL)]),
  mediaType: z42.z.string().optional(),
  providerOptions: providerMetadataSchema3.optional()
});
var filePartSchema3 = z42.z.object({
  type: z42.z.literal("file"),
  data: z42.z.union([dataContentSchema3, z42.z.instanceof(URL)]),
  filename: z42.z.string().optional(),
  mediaType: z42.z.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var reasoningPartSchema3 = z42.z.object({
  type: z42.z.literal("reasoning"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema3.optional()
});
var toolCallPartSchema3 = z42.z.object({
  type: z42.z.literal("tool-call"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  input: z42.z.unknown(),
  providerOptions: providerMetadataSchema3.optional(),
  providerExecuted: z42.z.boolean().optional()
});
var outputSchema2 = z42.z.discriminatedUnion(
  "type",
  [
    z42.z.object({
      type: z42.z.literal("text"),
      value: z42.z.string(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z42.z.object({
      type: z42.z.literal("json"),
      value: jsonValueSchema3,
      providerOptions: providerMetadataSchema3.optional()
    }),
    z42.z.object({
      type: z42.z.literal("execution-denied"),
      reason: z42.z.string().optional(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z42.z.object({
      type: z42.z.literal("error-text"),
      value: z42.z.string(),
      providerOptions: providerMetadataSchema3.optional()
    }),
    z42.z.object({
      type: z42.z.literal("error-json"),
      value: jsonValueSchema3,
      providerOptions: providerMetadataSchema3.optional()
    }),
    z42.z.object({
      type: z42.z.literal("content"),
      value: z42.z.array(
        z42.z.union([
          z42.z.object({
            type: z42.z.literal("text"),
            text: z42.z.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("media"),
            data: z42.z.string(),
            mediaType: z42.z.string()
          }),
          z42.z.object({
            type: z42.z.literal("file-data"),
            data: z42.z.string(),
            mediaType: z42.z.string(),
            filename: z42.z.string().optional(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("file-url"),
            url: z42.z.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("file-id"),
            fileId: z42.z.union([z42.z.string(), z42.z.record(z42.z.string(), z42.z.string())]),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("image-data"),
            data: z42.z.string(),
            mediaType: z42.z.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("image-url"),
            url: z42.z.string(),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("image-file-id"),
            fileId: z42.z.union([z42.z.string(), z42.z.record(z42.z.string(), z42.z.string())]),
            providerOptions: providerMetadataSchema3.optional()
          }),
          z42.z.object({
            type: z42.z.literal("custom"),
            providerOptions: providerMetadataSchema3.optional()
          })
        ])
      )
    })
  ]
);
var toolResultPartSchema3 = z42.z.object({
  type: z42.z.literal("tool-result"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  output: outputSchema2,
  providerOptions: providerMetadataSchema3.optional()
});
var toolApprovalRequestSchema = z42.z.object({
  type: z42.z.literal("tool-approval-request"),
  approvalId: z42.z.string(),
  toolCallId: z42.z.string()
});
var toolApprovalResponseSchema = z42.z.object({
  type: z42.z.literal("tool-approval-response"),
  approvalId: z42.z.string(),
  approved: z42.z.boolean(),
  reason: z42.z.string().optional()
});
var systemModelMessageSchema2 = z42.z.object(
  {
    role: z42.z.literal("system"),
    content: z42.z.string(),
    providerOptions: providerMetadataSchema3.optional()
  }
);
var userModelMessageSchema2 = z42.z.object({
  role: z42.z.literal("user"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(z42.z.union([textPartSchema3, imagePartSchema3, filePartSchema3]))
  ]),
  providerOptions: providerMetadataSchema3.optional()
});
var assistantModelMessageSchema2 = z42.z.object({
  role: z42.z.literal("assistant"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(
      z42.z.union([
        textPartSchema3,
        filePartSchema3,
        reasoningPartSchema3,
        toolCallPartSchema3,
        toolResultPartSchema3,
        toolApprovalRequestSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema3.optional()
});
var toolModelMessageSchema2 = z42.z.object({
  role: z42.z.literal("tool"),
  content: z42.z.array(z42.z.union([toolResultPartSchema3, toolApprovalResponseSchema])),
  providerOptions: providerMetadataSchema3.optional()
});
z42.z.union([
  systemModelMessageSchema2,
  userModelMessageSchema2,
  assistantModelMessageSchema2,
  toolModelMessageSchema2
]);
function assembleOperationName3({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes3({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a146;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a146 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a146 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer3 = {
  startSpan() {
    return noopSpan3;
  },
  startActiveSpan(name144, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan3);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan3);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan3);
    }
  }
};
var noopSpan3 = {
  spanContext() {
    return noopSpanContext3;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext3 = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer3({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer3;
  }
  if (tracer) {
    return tracer;
  }
  return trace3.getTracer("ai");
}
async function recordSpan3({
  name: name144,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(
    name144,
    { attributes: await attributes },
    async (span) => {
      try {
        const result = await fn(span);
        if (endWhenDone) {
          span.end();
        }
        return result;
      } catch (error) {
        try {
          recordErrorOnSpan3(span, error);
        } finally {
          span.end();
        }
        throw error;
      }
    }
  );
}
function recordErrorOnSpan3(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode3.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode3.ERROR });
  }
}
async function selectTelemetryAttributes3({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  const resultAttributes = {};
  for (const [key, value] of Object.entries(attributes)) {
    if (value == null) {
      continue;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        continue;
      }
      const result = await value.input();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        continue;
      }
      const result = await value.output();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    resultAttributes[key] = value;
  }
  return resultAttributes;
}
function getRetryDelayInMs2({
  error,
  exponentialBackoffDelay
}) {
  const headers = error.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders2 = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff3(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff3(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError3(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage23(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError3({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError3.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay3(
        getRetryDelayInMs2({
          error,
          exponentialBackoffDelay: delayInMs
        }),
        { abortSignal }
      );
      return _retryWithExponentialBackoff3(
        f,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal
        },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError3({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries3({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError23({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError23({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders2({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
var output_exports3 = {};
__export32(output_exports3, {
  array: () => array,
  choice: () => choice,
  json: () => json,
  object: () => object3,
  text: () => text3
});
function fixJson3(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson3(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON3({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON3({ text: fixJson3(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
var text3 = () => ({
  responseFormat: Promise.resolve({ type: "text" }),
  async parseCompleteOutput({ text: text222 }) {
    return text222;
  },
  async parsePartialOutput({ text: text222 }) {
    return { partial: text222 };
  }
});
var object3 = ({
  schema: inputSchema,
  name: name144,
  description
}) => {
  const schema = asSchema3(inputSchema);
  return {
    responseFormat: resolve2(schema.jsonSchema).then((jsonSchema222) => ({
      type: "json",
      schema: jsonSchema222,
      ...name144 != null && { name: name144 },
      ...description != null && { description }
    })),
    async parseCompleteOutput({ text: text222 }, context) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = await safeValidateTypes3({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        }
      }
    }
  };
};
var array = ({
  element: inputElementSchema,
  name: name144,
  description
}) => {
  const elementSchema = asSchema3(inputElementSchema);
  return {
    // JSON schema that describes an array of elements:
    responseFormat: resolve2(elementSchema.jsonSchema).then((jsonSchema222) => {
      const { $schema, ...itemSchema } = jsonSchema222;
      return {
        type: "json",
        schema: {
          $schema: "http://json-schema.org/draft-07/schema#",
          type: "object",
          properties: {
            elements: { type: "array", items: itemSchema }
          },
          required: ["elements"],
          additionalProperties: false
        },
        ...name144 != null && { name: name144 },
        ...description != null && { description }
      };
    }),
    async parseCompleteOutput({ text: text222 }, context) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError3({
            value: outerValue,
            cause: "response must be an object with an elements array"
          }),
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      for (const element of outerValue.elements) {
        const validationResult = await safeValidateTypes3({
          value: element,
          schema: elementSchema
        });
        if (!validationResult.success) {
          throw new NoObjectGeneratedError3({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text222,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
      }
      return outerValue.elements;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          const outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
            return void 0;
          }
          const rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;
          const parsedElements = [];
          for (const rawElement of rawElements) {
            const validationResult = await safeValidateTypes3({
              value: rawElement,
              schema: elementSchema
            });
            if (validationResult.success) {
              parsedElements.push(validationResult.value);
            }
          }
          return { partial: parsedElements };
        }
      }
    }
  };
};
var choice = ({
  options: choiceOptions,
  name: name144,
  description
}) => {
  return {
    // JSON schema that describes an enumeration:
    responseFormat: Promise.resolve({
      type: "json",
      schema: {
        $schema: "http://json-schema.org/draft-07/schema#",
        type: "object",
        properties: {
          result: { type: "string", enum: choiceOptions }
        },
        required: ["result"],
        additionalProperties: false
      },
      ...name144 != null && { name: name144 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text222 }, context) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result)) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError3({
            value: outerValue,
            cause: "response must be an object that contains a choice value."
          }),
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return outerValue.result;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          const outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string") {
            return void 0;
          }
          const potentialMatches = choiceOptions.filter(
            (choiceOption) => choiceOption.startsWith(outerValue.result)
          );
          if (result.state === "successful-parse") {
            return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;
          } else {
            return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;
          }
        }
      }
    }
  };
};
var json = ({
  name: name144,
  description
} = {}) => {
  return {
    responseFormat: Promise.resolve({
      type: "json",
      ...name144 != null && { name: name144 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text222 }, context) {
      const parseResult = await safeParseJSON3({ text: text222 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError3({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text222,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return parseResult.value;
    },
    async parsePartialOutput({ text: text222 }) {
      const result = await parsePartialJson3(text222);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input": {
          return void 0;
        }
        case "repaired-parse":
        case "successful-parse": {
          return result.value === void 0 ? void 0 : { partial: result.value };
        }
      }
    }
  };
};
createIdGenerator3({
  prefix: "aitxt",
  size: 24
});
createIdGenerator3({
  prefix: "aitxt",
  size: 24
});
function splitArray3(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany3({
  model: modelArg,
  values,
  maxParallelCalls = Infinity,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry
}) {
  const model = resolveEmbeddingModel2(modelArg);
  const { maxRetries, retry } = prepareRetries3({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix2(
    headers != null ? headers : {},
    `ai/${VERSION33}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes3({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer3(telemetry);
  return recordSpan3({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes3({
      telemetry,
      attributes: {
        ...assembleOperationName3({ operationId: "ai.embedMany", telemetry }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value) => JSON.stringify(value))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      var _a146;
      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
        model.maxEmbeddingsPerCall,
        model.supportsParallelCalls
      ]);
      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
        const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(() => {
          return recordSpan3({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes3({
              telemetry,
              attributes: {
                ...assembleOperationName3({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => values.map((value) => JSON.stringify(value))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a154;
              const modelResponse = await model.doEmbed({
                values,
                abortSignal,
                headers: headersWithUserAgent,
                providerOptions
              });
              const embeddings3 = modelResponse.embeddings;
              const usage2 = (_a154 = modelResponse.usage) != null ? _a154 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                await selectTelemetryAttributes3({
                  telemetry,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings3.map(
                        (embedding) => JSON.stringify(embedding)
                      )
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return {
                embeddings: embeddings3,
                usage: usage2,
                warnings: modelResponse.warnings,
                providerMetadata: modelResponse.providerMetadata,
                response: modelResponse.response
              };
            }
          });
        });
        span.setAttributes(
          await selectTelemetryAttributes3({
            telemetry,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        logWarnings({
          warnings: warnings2,
          provider: model.provider,
          model: model.modelId
        });
        return new DefaultEmbedManyResult3({
          values,
          embeddings: embeddings2,
          usage,
          warnings: warnings2,
          providerMetadata: providerMetadata2,
          responses: [response]
        });
      }
      const valueChunks = splitArray3(values, maxEmbeddingsPerCall);
      const embeddings = [];
      const warnings = [];
      const responses = [];
      let tokens = 0;
      let providerMetadata;
      const parallelChunks = splitArray3(
        valueChunks,
        supportsParallelCalls ? maxParallelCalls : 1
      );
      for (const parallelChunk of parallelChunks) {
        const results = await Promise.all(
          parallelChunk.map((chunk) => {
            return retry(() => {
              return recordSpan3({
                name: "ai.embedMany.doEmbed",
                attributes: selectTelemetryAttributes3({
                  telemetry,
                  attributes: {
                    ...assembleOperationName3({
                      operationId: "ai.embedMany.doEmbed",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.values": {
                      input: () => chunk.map((value) => JSON.stringify(value))
                    }
                  }
                }),
                tracer,
                fn: async (doEmbedSpan) => {
                  var _a154;
                  const modelResponse = await model.doEmbed({
                    values: chunk,
                    abortSignal,
                    headers: headersWithUserAgent,
                    providerOptions
                  });
                  const embeddings2 = modelResponse.embeddings;
                  const usage = (_a154 = modelResponse.usage) != null ? _a154 : { tokens: NaN };
                  doEmbedSpan.setAttributes(
                    await selectTelemetryAttributes3({
                      telemetry,
                      attributes: {
                        "ai.embeddings": {
                          output: () => embeddings2.map(
                            (embedding) => JSON.stringify(embedding)
                          )
                        },
                        "ai.usage.tokens": usage.tokens
                      }
                    })
                  );
                  return {
                    embeddings: embeddings2,
                    usage,
                    warnings: modelResponse.warnings,
                    providerMetadata: modelResponse.providerMetadata,
                    response: modelResponse.response
                  };
                }
              });
            });
          })
        );
        for (const result of results) {
          embeddings.push(...result.embeddings);
          warnings.push(...result.warnings);
          responses.push(result.response);
          tokens += result.usage.tokens;
          if (result.providerMetadata) {
            if (!providerMetadata) {
              providerMetadata = { ...result.providerMetadata };
            } else {
              for (const [providerName, metadata] of Object.entries(
                result.providerMetadata
              )) {
                providerMetadata[providerName] = {
                  ...(_a146 = providerMetadata[providerName]) != null ? _a146 : {},
                  ...metadata
                };
              }
            }
          }
        }
      }
      span.setAttributes(
        await selectTelemetryAttributes3({
          telemetry,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      logWarnings({
        warnings,
        provider: model.provider,
        model: model.modelId
      });
      return new DefaultEmbedManyResult3({
        values,
        embeddings,
        usage: { tokens },
        warnings,
        providerMetadata,
        responses
      });
    }
  });
}
var DefaultEmbedManyResult3 = class {
  constructor(options) {
    this.values = options.values;
    this.embeddings = options.embeddings;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.providerMetadata = options.providerMetadata;
    this.responses = options.responses;
  }
};
createIdGenerator3({ prefix: "aiobj", size: 24 });
createIdGenerator3({ prefix: "aiobj", size: 24 });
function deepMergeWorkingMemory(existing, update) {
  if (!update || typeof update !== "object" || Object.keys(update).length === 0) {
    return existing && typeof existing === "object" ? { ...existing } : {};
  }
  if (!existing || typeof existing !== "object") {
    return update;
  }
  const result = { ...existing };
  for (const key of Object.keys(update)) {
    const updateValue = update[key];
    const existingValue = result[key];
    if (updateValue === null) {
      delete result[key];
    } else if (Array.isArray(updateValue)) {
      result[key] = updateValue;
    } else if (typeof updateValue === "object" && updateValue !== null && typeof existingValue === "object" && existingValue !== null && !Array.isArray(existingValue)) {
      result[key] = deepMergeWorkingMemory(
        existingValue,
        updateValue
      );
    } else {
      result[key] = updateValue;
    }
  }
  return result;
}
var updateWorkingMemoryTool = (memoryConfig) => {
  const schema = memoryConfig?.workingMemory?.schema;
  let inputSchema = z18.z.object({
    memory: z18.z.string().describe(`The Markdown formatted working memory content to store. This MUST be a string. Never pass an object.`)
  });
  if (schema) {
    inputSchema = z18.z.object({
      memory: schema instanceof z18.ZodObject ? schema : convertSchemaToZod({ jsonSchema: schema }).describe(
        `The JSON formatted working memory content to store.`
      )
    });
  }
  const usesMergeSemantics = Boolean(schema);
  const description = schema ? `Update the working memory with new information. Data is merged with existing memory - you only need to include fields you want to add or update. Set a field to null to remove it. Arrays are replaced entirely when provided.` : `Update the working memory with new information. Any data not included will be overwritten. Always pass data as string to the memory field. Never pass an object.`;
  return tools.createTool({
    id: "update-working-memory",
    description,
    inputSchema,
    execute: async (inputData, context) => {
      const threadId = context?.agent?.threadId;
      const resourceId = context?.agent?.resourceId;
      const memory = context?.memory;
      if (!threadId || !memory || !resourceId) {
        throw new Error("Thread ID, Memory instance, and resourceId are required for working memory updates");
      }
      let thread = await memory.getThreadById({ threadId });
      if (!thread) {
        thread = await memory.createThread({
          threadId,
          resourceId,
          memoryConfig
        });
      }
      if (thread.resourceId && thread.resourceId !== resourceId) {
        throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
      }
      let workingMemory;
      if (usesMergeSemantics) {
        const existingRaw = await memory.getWorkingMemory({
          threadId,
          resourceId,
          memoryConfig
        });
        let existingData = null;
        if (existingRaw) {
          try {
            existingData = typeof existingRaw === "string" ? JSON.parse(existingRaw) : existingRaw;
          } catch {
            existingData = null;
          }
        }
        if (inputData.memory === void 0 || inputData.memory === null) {
          return { success: true, message: "No memory data provided, existing memory unchanged." };
        }
        let newData;
        if (typeof inputData.memory === "string") {
          try {
            newData = JSON.parse(inputData.memory);
          } catch (parseError) {
            const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
            throw new Error(
              `Failed to parse working memory input as JSON: ${errorMessage}. Raw input: ${inputData.memory.length > 500 ? inputData.memory.slice(0, 500) + "..." : inputData.memory}`
            );
          }
        } else {
          newData = inputData.memory;
        }
        const mergedData = deepMergeWorkingMemory(existingData, newData);
        workingMemory = JSON.stringify(mergedData);
      } else {
        workingMemory = typeof inputData.memory === "string" ? inputData.memory : JSON.stringify(inputData.memory);
      }
      await memory.updateWorkingMemory({
        threadId,
        resourceId,
        workingMemory,
        memoryConfig
      });
      return { success: true };
    }
  });
};
var __experimental_updateWorkingMemoryToolVNext = (config) => {
  return tools.createTool({
    id: "update-working-memory",
    description: "Update the working memory with new information.",
    inputSchema: z18.z.object({
      newMemory: z18.z.string().optional().describe(
        `The ${config.workingMemory?.schema ? "JSON" : "Markdown"} formatted working memory content to store`
      ),
      searchString: z18.z.string().optional().describe(
        "The working memory string to find. Will be replaced with the newMemory string. If this is omitted or doesn't exist, the newMemory string will be appended to the end of your working memory. Replacing single lines at a time is encouraged for greater accuracy. If updateReason is not 'append-new-memory', this search string must be provided or the tool call will be rejected."
      ),
      updateReason: z18.z.enum(["append-new-memory", "clarify-existing-memory", "replace-irrelevant-memory"]).optional().describe(
        "The reason you're updating working memory. Passing any value other than 'append-new-memory' requires a searchString to be provided. Defaults to append-new-memory"
      )
    }),
    execute: async (inputData, context) => {
      const threadId = context?.agent?.threadId;
      const resourceId = context?.agent?.resourceId;
      const memory = context?.memory;
      if (!threadId || !memory || !resourceId) {
        throw new Error("Thread ID, Memory instance, and resourceId are required for working memory updates");
      }
      let thread = await memory.getThreadById({ threadId });
      if (!thread) {
        thread = await memory.createThread({
          threadId,
          resourceId,
          memoryConfig: config
        });
      }
      if (thread.resourceId && thread.resourceId !== resourceId) {
        throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);
      }
      const workingMemory = inputData.newMemory || "";
      if (!inputData.updateReason) inputData.updateReason = `append-new-memory`;
      if (inputData.searchString && config.workingMemory?.scope === `resource` && inputData.updateReason === `replace-irrelevant-memory`) {
        inputData.searchString = void 0;
      }
      if (inputData.updateReason === `append-new-memory` && inputData.searchString) {
        inputData.searchString = void 0;
      }
      if (inputData.updateReason !== `append-new-memory` && !inputData.searchString) {
        return {
          success: false,
          reason: `updateReason was ${inputData.updateReason} but no searchString was provided. Unable to replace undefined with "${inputData.newMemory}"`
        };
      }
      const result = await memory.__experimental_updateWorkingMemoryVNext({
        threadId,
        resourceId,
        workingMemory,
        searchString: inputData.searchString,
        memoryConfig: config
      });
      if (result) {
        return result;
      }
      return { success: true };
    }
  });
};
var CHARS_PER_TOKEN = 4;
var DEFAULT_MESSAGE_RANGE = { before: 1, after: 1 };
var DEFAULT_TOP_K = 4;
var isZodObject = (v) => v instanceof z18.ZodObject;
var Memory = class extends memory.MastraMemory {
  constructor(config = {}) {
    super({ name: "Memory", ...config });
    const mergedConfig = this.getMergedThreadConfig({
      workingMemory: config.options?.workingMemory || {
        // these defaults are now set inside @mastra/core/memory in getMergedThreadConfig.
        // In a future release we can remove it from this block - for now if we remove it
        // and someone bumps @mastra/memory without bumping @mastra/core the defaults wouldn't exist yet
        enabled: false,
        template: this.defaultWorkingMemoryTemplate
      }
    });
    this.threadConfig = mergedConfig;
  }
  /**
   * Gets the memory storage domain, throwing if not available.
   */
  async getMemoryStore() {
    const store = await this.storage.getStore("memory");
    if (!store) {
      throw new Error(`Memory storage domain is not available on ${this.storage.constructor.name}`);
    }
    return store;
  }
  async validateThreadIsOwnedByResource(threadId, resourceId, config) {
    const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
    const thread = await this.getThreadById({ threadId });
    if (!thread && !resourceScope) {
      throw new Error(`No thread found with id ${threadId}`);
    }
    if (thread && thread.resourceId !== resourceId) {
      throw new Error(
        `Thread with id ${threadId} is for resource with id ${thread.resourceId} but resource ${resourceId} was queried.`
      );
    }
  }
  async recall(args) {
    const { threadId, resourceId, perPage: perPageArg, page, orderBy, threadConfig, vectorSearchString, filter: filter32 } = args;
    const config = this.getMergedThreadConfig(threadConfig || {});
    if (resourceId) await this.validateThreadIsOwnedByResource(threadId, resourceId, config);
    const perPage = perPageArg !== void 0 ? perPageArg : config.lastMessages;
    const shouldGetNewestAndReverse = !orderBy && perPage !== false;
    const effectiveOrderBy = shouldGetNewestAndReverse ? { field: "createdAt", direction: "DESC" } : orderBy;
    const vectorResults = [];
    this.logger.debug(`Memory recall() with:`, {
      threadId,
      perPage,
      page,
      orderBy: effectiveOrderBy,
      hasWorkingMemorySchema: Boolean(config.workingMemory?.schema),
      workingMemoryEnabled: config.workingMemory?.enabled,
      semanticRecallEnabled: Boolean(config.semanticRecall)
    });
    const defaultRange = DEFAULT_MESSAGE_RANGE;
    const defaultTopK = DEFAULT_TOP_K;
    const vectorConfig = typeof config?.semanticRecall === `boolean` ? {
      topK: defaultTopK,
      messageRange: defaultRange
    } : {
      topK: config?.semanticRecall?.topK ?? defaultTopK,
      messageRange: config?.semanticRecall?.messageRange ?? defaultRange
    };
    const resourceScope = typeof config?.semanticRecall === "object" && config?.semanticRecall?.scope !== `thread` || config.semanticRecall === true;
    if (resourceScope && !resourceId && config?.semanticRecall && vectorSearchString) {
      throw new Error(
        `Memory error: Resource-scoped semantic recall is enabled but no resourceId was provided. Either provide a resourceId or explicitly set semanticRecall.scope to 'thread'.`
      );
    }
    if (config?.semanticRecall && vectorSearchString && this.vector) {
      const { embeddings, dimension } = await this.embedMessageContent(vectorSearchString);
      const { indexName } = await this.createEmbeddingIndex(dimension, config);
      await Promise.all(
        embeddings.map(async (embedding) => {
          if (typeof this.vector === `undefined`) {
            throw new Error(
              `Tried to query vector index ${indexName} but this Memory instance doesn't have an attached vector db.`
            );
          }
          vectorResults.push(
            ...await this.vector.query({
              indexName,
              queryVector: embedding,
              topK: vectorConfig.topK,
              filter: resourceScope ? {
                resource_id: resourceId
              } : {
                thread_id: threadId
              }
            })
          );
        })
      );
    }
    const memoryStore = await this.getMemoryStore();
    const paginatedResult = await memoryStore.listMessages({
      threadId,
      resourceId,
      perPage,
      page,
      orderBy: effectiveOrderBy,
      filter: filter32,
      ...vectorResults?.length ? {
        include: vectorResults.map((r) => ({
          id: r.metadata?.message_id,
          threadId: r.metadata?.thread_id,
          withNextMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.after,
          withPreviousMessages: typeof vectorConfig.messageRange === "number" ? vectorConfig.messageRange : vectorConfig.messageRange.before
        }))
      } : {}
    });
    const rawMessages = shouldGetNewestAndReverse ? paginatedResult.messages.reverse() : paginatedResult.messages;
    const list = new agent.MessageList({ threadId, resourceId }).add(rawMessages, "memory");
    const messages = list.get.all.db();
    return { messages };
  }
  async getThreadById({ threadId }) {
    const memoryStore = await this.getMemoryStore();
    return memoryStore.getThreadById({ threadId });
  }
  async listThreadsByResourceId(args) {
    const memoryStore = await this.getMemoryStore();
    return memoryStore.listThreadsByResourceId(args);
  }
  async handleWorkingMemoryFromMetadata({
    workingMemory,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (config.workingMemory?.enabled) {
      const scope = config.workingMemory.scope || "resource";
      if (scope === "resource" && resourceId) {
        const memoryStore = await this.getMemoryStore();
        await memoryStore.updateResource({
          resourceId,
          workingMemory
        });
      }
    }
  }
  async saveThread({
    thread,
    memoryConfig
  }) {
    const memoryStore = await this.getMemoryStore();
    const savedThread = await memoryStore.saveThread({ thread });
    if (thread.metadata?.workingMemory && typeof thread.metadata.workingMemory === "string" && thread.resourceId) {
      await this.handleWorkingMemoryFromMetadata({
        workingMemory: thread.metadata.workingMemory,
        resourceId: thread.resourceId,
        memoryConfig
      });
    }
    return savedThread;
  }
  async updateThread({
    id,
    title,
    metadata,
    memoryConfig
  }) {
    const memoryStore = await this.getMemoryStore();
    const updatedThread = await memoryStore.updateThread({
      id,
      title,
      metadata
    });
    if (metadata?.workingMemory && typeof metadata.workingMemory === "string" && updatedThread.resourceId) {
      await this.handleWorkingMemoryFromMetadata({
        workingMemory: metadata.workingMemory,
        resourceId: updatedThread.resourceId,
        memoryConfig
      });
    }
    return updatedThread;
  }
  async deleteThread(threadId) {
    const memoryStore = await this.getMemoryStore();
    await memoryStore.deleteThread({ threadId });
  }
  async updateWorkingMemory({
    threadId,
    resourceId,
    workingMemory,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      throw new Error("Working memory is not enabled for this memory instance");
    }
    const scope = config.workingMemory.scope || "resource";
    if (scope === "resource" && !resourceId) {
      throw new Error(
        `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
      );
    }
    const memoryStore = await this.getMemoryStore();
    if (scope === "resource" && resourceId) {
      await memoryStore.updateResource({
        resourceId,
        workingMemory
      });
    } else {
      const thread = await this.getThreadById({ threadId });
      if (!thread) {
        throw new Error(`Thread ${threadId} not found`);
      }
      await memoryStore.updateThread({
        id: threadId,
        title: thread.title || "Untitled Thread",
        metadata: {
          ...thread.metadata,
          workingMemory
        }
      });
    }
  }
  updateWorkingMemoryMutexes = /* @__PURE__ */ new Map();
  /**
   * @warning experimental! can be removed or changed at any time
   */
  async __experimental_updateWorkingMemoryVNext({
    threadId,
    resourceId,
    workingMemory,
    searchString,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      throw new Error("Working memory is not enabled for this memory instance");
    }
    const mutexKey = memoryConfig?.workingMemory?.scope === `resource` ? `resource-${resourceId}` : `thread-${threadId}`;
    const mutex = this.updateWorkingMemoryMutexes.has(mutexKey) ? this.updateWorkingMemoryMutexes.get(mutexKey) : new Mutex();
    this.updateWorkingMemoryMutexes.set(mutexKey, mutex);
    const release = await mutex.acquire();
    try {
      const existingWorkingMemory = await this.getWorkingMemory({ threadId, resourceId, memoryConfig }) || "";
      const template = await this.getWorkingMemoryTemplate({ memoryConfig });
      let reason = "";
      if (existingWorkingMemory) {
        if (searchString && existingWorkingMemory?.includes(searchString)) {
          workingMemory = existingWorkingMemory.replace(searchString, workingMemory);
          reason = `found and replaced searchString with newMemory`;
        } else if (existingWorkingMemory.includes(workingMemory) || template?.content?.trim() === workingMemory.trim()) {
          return {
            success: false,
            reason: `attempted to insert duplicate data into working memory. this entry was skipped`
          };
        } else {
          if (searchString) {
            reason = `attempted to replace working memory string that doesn't exist. Appending to working memory instead.`;
          } else {
            reason = `appended newMemory to end of working memory`;
          }
          workingMemory = existingWorkingMemory + `
${workingMemory}`;
        }
      } else if (workingMemory === template?.content) {
        return {
          success: false,
          reason: `try again when you have data to add. newMemory was equal to the working memory template`
        };
      } else {
        reason = `started new working memory`;
      }
      workingMemory = template?.content ? workingMemory.replaceAll(template?.content, "") : workingMemory;
      const scope = config.workingMemory.scope || "resource";
      if (scope === "resource" && !resourceId) {
        throw new Error(
          `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
        );
      }
      const memoryStore = await this.getMemoryStore();
      if (scope === "resource" && resourceId) {
        await memoryStore.updateResource({
          resourceId,
          workingMemory
        });
        if (reason) {
          return { success: true, reason };
        }
      } else {
        const thread = await this.getThreadById({ threadId });
        if (!thread) {
          throw new Error(`Thread ${threadId} not found`);
        }
        await memoryStore.updateThread({
          id: threadId,
          title: thread.title || "Untitled Thread",
          metadata: {
            ...thread.metadata,
            workingMemory
          }
        });
      }
      return { success: true, reason };
    } catch (e2) {
      this.logger.error(e2 instanceof Error ? e2.stack || e2.message : JSON.stringify(e2));
      return { success: false, reason: "Tool error." };
    } finally {
      release();
    }
  }
  chunkText(text42, tokenSize = 4096) {
    const charSize = tokenSize * CHARS_PER_TOKEN;
    const chunks = [];
    let currentChunk = "";
    const words = text42.split(/\s+/);
    for (const word of words) {
      const wordWithSpace = currentChunk ? " " + word : word;
      if (currentChunk.length + wordWithSpace.length > charSize) {
        chunks.push(currentChunk);
        currentChunk = word;
      } else {
        currentChunk += wordWithSpace;
      }
    }
    if (currentChunk) {
      chunks.push(currentChunk);
    }
    return chunks;
  }
  hasher = e();
  // embedding is computationally expensive so cache content -> embeddings/chunks
  embeddingCache = /* @__PURE__ */ new Map();
  firstEmbed;
  async embedMessageContent(content) {
    const key = (await this.hasher).h32(content);
    const cached = this.embeddingCache.get(key);
    if (cached) return cached;
    const chunks = this.chunkText(content);
    if (typeof this.embedder === `undefined`) {
      throw new Error(`Tried to embed message content but this Memory instance doesn't have an attached embedder.`);
    }
    const isFastEmbed = this.embedder.provider === `fastembed`;
    if (isFastEmbed && this.firstEmbed instanceof Promise) {
      await this.firstEmbed;
    }
    let embedFn;
    const specVersion = this.embedder.specificationVersion;
    switch (specVersion) {
      case "v3":
        embedFn = embedMany3;
        break;
      case "v2":
        embedFn = embedMany2;
        break;
      default:
        embedFn = embedMany;
        break;
    }
    const promise = embedFn({
      values: chunks,
      maxRetries: 3,
      // @ts-ignore
      model: this.embedder,
      ...this.embedderOptions || {}
    });
    if (isFastEmbed && !this.firstEmbed) this.firstEmbed = promise;
    const { embeddings } = await promise;
    const result = {
      embeddings,
      chunks,
      dimension: embeddings[0]?.length
    };
    this.embeddingCache.set(key, result);
    return result;
  }
  async saveMessages({
    messages,
    memoryConfig
  }) {
    const updatedMessages = messages.map((m) => {
      return this.updateMessageToHideWorkingMemoryV2(m);
    }).filter((m) => Boolean(m));
    const config = this.getMergedThreadConfig(memoryConfig);
    const dbMessages = new agent.MessageList({
      generateMessageId: () => this.generateId()
    }).add(updatedMessages, "memory").get.all.db();
    const memoryStore = await this.getMemoryStore();
    const result = await memoryStore.saveMessages({
      messages: dbMessages
    });
    if (this.vector && config.semanticRecall) {
      const embeddingData = [];
      let dimension;
      await Promise.all(
        updatedMessages.map(async (message) => {
          let textForEmbedding = null;
          if (message.content.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
            textForEmbedding = message.content.content;
          } else if (message.content.parts && message.content.parts.length > 0) {
            const joined = message.content.parts.filter((part) => part.type === "text").map((part) => part.text).join(" ").trim();
            if (joined) textForEmbedding = joined;
          }
          if (!textForEmbedding) return;
          const result2 = await this.embedMessageContent(textForEmbedding);
          dimension = result2.dimension;
          embeddingData.push({
            embeddings: result2.embeddings,
            metadata: result2.chunks.map(() => ({
              message_id: message.id,
              thread_id: message.threadId,
              resource_id: message.resourceId
            }))
          });
        })
      );
      if (embeddingData.length > 0 && dimension !== void 0) {
        if (typeof this.vector === `undefined`) {
          throw new Error(`Tried to upsert embeddings but this Memory instance doesn't have an attached vector db.`);
        }
        const { indexName } = await this.createEmbeddingIndex(dimension, config);
        const allVectors = [];
        const allMetadata = [];
        for (const data of embeddingData) {
          allVectors.push(...data.embeddings);
          allMetadata.push(...data.metadata);
        }
        await this.vector.upsert({
          indexName,
          vectors: allVectors,
          metadata: allMetadata
        });
      }
    }
    return result;
  }
  updateMessageToHideWorkingMemoryV2(message) {
    const newMessage = { ...message };
    if (message.content && typeof message.content === "object" && !Array.isArray(message.content)) {
      newMessage.content = { ...message.content };
    }
    if (typeof newMessage.content?.content === "string" && newMessage.content.content.length > 0) {
      newMessage.content.content = memory.removeWorkingMemoryTags(newMessage.content.content).trim();
    }
    if (Array.isArray(newMessage.content?.parts)) {
      newMessage.content.parts = newMessage.content.parts.filter((part) => {
        if (part?.type === "tool-invocation") {
          return part.toolInvocation?.toolName !== "updateWorkingMemory";
        }
        return true;
      }).map((part) => {
        if (part?.type === "text") {
          const text42 = typeof part.text === "string" ? part.text : "";
          return {
            ...part,
            text: memory.removeWorkingMemoryTags(text42).trim()
          };
        }
        return part;
      });
      if (newMessage.content.parts.length === 0) {
        return null;
      }
    }
    return newMessage;
  }
  parseWorkingMemory(text42) {
    if (!this.threadConfig.workingMemory?.enabled) return null;
    const content = memory.extractWorkingMemoryContent(text42);
    return content?.trim() ?? null;
  }
  async getWorkingMemory({
    threadId,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig || {});
    if (!config.workingMemory?.enabled) {
      return null;
    }
    const scope = config.workingMemory.scope || "resource";
    let workingMemoryData = null;
    if (scope === "resource" && !resourceId) {
      throw new Error(
        `Memory error: Resource-scoped working memory is enabled but no resourceId was provided. Either provide a resourceId or explicitly set workingMemory.scope to 'thread'.`
      );
    }
    if (scope === "resource" && resourceId) {
      const memoryStore = await this.getMemoryStore();
      const resource = await memoryStore.getResourceById({ resourceId });
      workingMemoryData = resource?.workingMemory || null;
    } else {
      const thread = await this.getThreadById({ threadId });
      workingMemoryData = thread?.metadata?.workingMemory;
    }
    if (!workingMemoryData) {
      return null;
    }
    return workingMemoryData;
  }
  /**
   * Gets the working memory template for the current memory configuration.
   * Supports both ZodObject and JSONSchema7 schemas.
   *
   * @param memoryConfig - The memory configuration containing the working memory settings
   * @returns The working memory template with format and content, or null if working memory is disabled
   */
  async getWorkingMemoryTemplate({
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig);
    if (!config.workingMemory?.enabled) {
      return null;
    }
    if (config.workingMemory?.schema) {
      try {
        const schema = config.workingMemory.schema;
        let convertedSchema;
        if (isZodObject(schema)) {
          convertedSchema = zodToJsonSchema2(schema);
        } else {
          convertedSchema = schema;
        }
        return { format: "json", content: JSON.stringify(convertedSchema) };
      } catch (error) {
        this.logger.error("Error converting schema", error);
        throw error;
      }
    }
    const memory = config.workingMemory.template || this.defaultWorkingMemoryTemplate;
    return { format: "markdown", content: memory.trim() };
  }
  async getSystemMessage({
    threadId,
    resourceId,
    memoryConfig
  }) {
    const config = this.getMergedThreadConfig(memoryConfig);
    if (!config.workingMemory?.enabled) {
      return null;
    }
    const workingMemoryTemplate = await this.getWorkingMemoryTemplate({ memoryConfig });
    const workingMemoryData = await this.getWorkingMemory({ threadId, resourceId, memoryConfig: config });
    if (!workingMemoryTemplate) {
      return null;
    }
    return this.isVNextWorkingMemoryConfig(memoryConfig) ? this.__experimental_getWorkingMemoryToolInstructionVNext({
      template: workingMemoryTemplate,
      data: workingMemoryData
    }) : this.getWorkingMemoryToolInstruction({
      template: workingMemoryTemplate,
      data: workingMemoryData
    });
  }
  defaultWorkingMemoryTemplate = `
# User Information
- **First Name**: 
- **Last Name**: 
- **Location**: 
- **Occupation**: 
- **Interests**: 
- **Goals**: 
- **Events**: 
- **Facts**: 
- **Projects**: 
`;
  getWorkingMemoryToolInstruction({
    template,
    data
  }) {
    const emptyWorkingMemoryTemplateObject = template.format === "json" ? utils.generateEmptyFromSchema(template.content) : null;
    const hasEmptyWorkingMemoryTemplateObject = emptyWorkingMemoryTemplateObject && Object.keys(emptyWorkingMemoryTemplateObject).length > 0;
    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool. If information might be referenced again - store it!

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
${template.format !== "json" ? `5. IMPORTANT: When calling updateWorkingMemory, the only valid parameter is the memory field. DO NOT pass an object.
6. IMPORTANT: ALWAYS pass the data you want to store in the memory field as a string. DO NOT pass an object.
7. IMPORTANT: Data must only be sent as a string no matter which format is used.` : ""}


${template.format !== "json" ? `<working_memory_template>
${template.content}
</working_memory_template>` : ""}

${hasEmptyWorkingMemoryTemplateObject ? "When working with json data, the object format below represents the template:" : ""}
${hasEmptyWorkingMemoryTemplateObject ? JSON.stringify(emptyWorkingMemoryTemplateObject) : ""}

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- Do not remove empty sections - you must include the empty sections along with the ones you're filling in
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the entire ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it.
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.`;
  }
  __experimental_getWorkingMemoryToolInstructionVNext({
    template,
    data
  }) {
    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:
Store and update any conversation-relevant information by calling the updateWorkingMemory tool.

Guidelines:
1. Store anything that could be useful later in the conversation
2. Update proactively when information changes, no matter how small
3. Use ${template.format === "json" ? "JSON" : "Markdown"} format for all data
4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for "information about yourself"
5. If your memory has not changed, you do not need to call the updateWorkingMemory tool. By default it will persist and be available for you in future interactions
6. Information not being relevant to the current conversation is not a valid reason to replace or remove working memory information. Your working memory spans across multiple conversations and may be needed again later, even if it's not currently relevant.

<working_memory_template>
${template.content}
</working_memory_template>

<working_memory_data>
${data}
</working_memory_data>

Notes:
- Update memory whenever referenced information changes
${template.content !== this.defaultWorkingMemoryTemplate ? `- Only store information if it's in the working memory template, do not store other information unless the user asks you to remember it, as that non-template information may be irrelevant` : `- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)
`}
- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history
- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the ${template.format === "json" ? "JSON" : "Markdown"} content. The system will store it for you. The user will not see it. 
- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information if that information is not already stored.
- IMPORTANT: Preserve the ${template.format === "json" ? "JSON" : "Markdown"} formatting structure above while updating the content.
`;
  }
  isVNextWorkingMemoryConfig(config) {
    if (!config?.workingMemory) return false;
    const isMDWorkingMemory = !(`schema` in config.workingMemory) && (typeof config.workingMemory.template === `string` || config.workingMemory.template) && config.workingMemory;
    return Boolean(isMDWorkingMemory && isMDWorkingMemory.version === `vnext`);
  }
  listTools(config) {
    const mergedConfig = this.getMergedThreadConfig(config);
    if (mergedConfig.workingMemory?.enabled) {
      return {
        updateWorkingMemory: this.isVNextWorkingMemoryConfig(mergedConfig) ? (
          // use the new experimental tool
          __experimental_updateWorkingMemoryToolVNext(mergedConfig)
        ) : updateWorkingMemoryTool(mergedConfig)
      };
    }
    return {};
  }
  /**
   * Updates a list of messages and syncs the vector database for semantic recall.
   * When message content is updated, the corresponding vector embeddings are also updated
   * to ensure semantic recall stays in sync with the message content.
   *
   * @param messages - The list of messages to update (must include id, can include partial content)
   * @param memoryConfig - Optional memory configuration to determine if semantic recall is enabled
   * @returns The list of updated messages
   */
  async updateMessages({
    messages,
    memoryConfig
  }) {
    if (messages.length === 0) return [];
    const memoryStore = await this.getMemoryStore();
    const config = this.getMergedThreadConfig(memoryConfig);
    if (this.vector && config.semanticRecall) {
      const messagesWithContent = messages.filter((m) => m.content !== void 0);
      if (messagesWithContent.length > 0) {
        const existingMessagesResult = await memoryStore.listMessagesById({
          messageIds: messagesWithContent.map((m) => m.id)
        });
        const existingMessagesMap = new Map(existingMessagesResult.messages.map((m) => [m.id, m]));
        const embeddingData = [];
        let dimension;
        const messageIdsWithNewEmbeddings = /* @__PURE__ */ new Set();
        const messageIdsWithClearedContent = /* @__PURE__ */ new Set();
        await Promise.all(
          messagesWithContent.map(async (message) => {
            const existingMessage = existingMessagesMap.get(message.id);
            if (!existingMessage) return;
            let textForEmbedding = null;
            const content = message.content;
            if (content) {
              if ("content" in content && content.content && typeof content.content === "string" && content.content.trim() !== "") {
                textForEmbedding = content.content;
              } else if ("parts" in content && content.parts && Array.isArray(content.parts) && content.parts.length > 0) {
                const joined = content.parts.filter((part) => part?.type === "text").map((part) => part.text).join(" ").trim();
                if (joined) textForEmbedding = joined;
              }
            }
            if (textForEmbedding) {
              const result = await this.embedMessageContent(textForEmbedding);
              dimension = result.dimension;
              embeddingData.push({
                embeddings: result.embeddings,
                metadata: result.chunks.map(() => ({
                  message_id: message.id,
                  thread_id: existingMessage.threadId,
                  resource_id: existingMessage.resourceId
                }))
              });
              messageIdsWithNewEmbeddings.add(message.id);
            } else {
              messageIdsWithClearedContent.add(message.id);
            }
          })
        );
        const messageIdsNeedingDeletion = /* @__PURE__ */ new Set([...messageIdsWithClearedContent, ...messageIdsWithNewEmbeddings]);
        if (messageIdsNeedingDeletion.size > 0) {
          try {
            const indexes = await this.vector.listIndexes();
            const memoryIndexes = indexes.filter((name21) => name21.startsWith("memory_messages"));
            for (const indexName of memoryIndexes) {
              for (const messageId of messageIdsNeedingDeletion) {
                try {
                  await this.vector.deleteVectors({
                    indexName,
                    filter: { message_id: messageId }
                  });
                } catch {
                  this.logger.debug(
                    `No existing vectors found for message ${messageId} in ${indexName}, skipping delete`
                  );
                }
              }
            }
          } catch {
            this.logger.debug(`No memory indexes found to delete from`);
          }
        }
        if (embeddingData.length > 0 && dimension !== void 0) {
          const { indexName } = await this.createEmbeddingIndex(dimension, config);
          const allVectors = [];
          const allMetadata = [];
          for (const data of embeddingData) {
            allVectors.push(...data.embeddings);
            allMetadata.push(...data.metadata);
          }
          await this.vector.upsert({
            indexName,
            vectors: allVectors,
            metadata: allMetadata
          });
        }
      }
    }
    return memoryStore.updateMessages({ messages });
  }
  /**
   * Deletes one or more messages
   * @param input - Must be an array containing either:
   *   - Message ID strings
   *   - Message objects with 'id' properties
   * @returns Promise that resolves when all messages are deleted
   */
  async deleteMessages(input) {
    let messageIds;
    if (!Array.isArray(input)) {
      throw new Error("Invalid input: must be an array of message IDs or message objects");
    }
    if (input.length === 0) {
      return;
    }
    messageIds = input.map((item) => {
      if (typeof item === "string") {
        return item;
      } else if (item && typeof item === "object" && "id" in item) {
        return item.id;
      } else {
        throw new Error("Invalid input: array items must be strings or objects with an id property");
      }
    });
    const invalidIds = messageIds.filter((id) => !id || typeof id !== "string");
    if (invalidIds.length > 0) {
      throw new Error("All message IDs must be non-empty strings");
    }
    const memoryStore = await this.getMemoryStore();
    await memoryStore.deleteMessages(messageIds);
  }
  /**
   * Clone a thread and its messages to create a new independent thread.
   * The cloned thread will have metadata tracking its source.
   *
   * If semantic recall is enabled, the cloned messages will also be embedded
   * and added to the vector store for semantic search.
   *
   * @param args - Clone configuration options
   * @param args.sourceThreadId - ID of the thread to clone
   * @param args.newThreadId - ID for the new cloned thread (if not provided, a random UUID will be generated)
   * @param args.resourceId - Resource ID for the new thread (defaults to source thread's resourceId)
   * @param args.title - Title for the new cloned thread
   * @param args.metadata - Additional metadata to merge with clone metadata
   * @param args.options - Options for filtering which messages to include
   * @param args.options.messageLimit - Maximum number of messages to copy (from most recent)
   * @param args.options.messageFilter - Filter messages by date range or specific IDs
   * @param memoryConfig - Optional memory configuration override
   * @returns The newly created thread and the cloned messages
   *
   * @example
   * ```typescript
   * // Clone entire thread
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   * });
   *
   * // Clone with custom ID
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   newThreadId: 'my-custom-thread-id',
   * });
   *
   * // Clone with message limit
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   title: 'My cloned conversation',
   *   options: {
   *     messageLimit: 10, // Only clone last 10 messages
   *   },
   * });
   *
   * // Clone with date filter
   * const { thread, clonedMessages } = await memory.cloneThread({
   *   sourceThreadId: 'thread-123',
   *   options: {
   *     messageFilter: {
   *       startDate: new Date('2024-01-01'),
   *       endDate: new Date('2024-06-01'),
   *     },
   *   },
   * });
   * ```
   */
  async cloneThread(args, memoryConfig) {
    const memoryStore = await this.getMemoryStore();
    const result = await memoryStore.cloneThread(args);
    const config = this.getMergedThreadConfig(memoryConfig);
    if (this.vector && config.semanticRecall && result.clonedMessages.length > 0) {
      await this.embedClonedMessages(result.clonedMessages, config);
    }
    return result;
  }
  /**
   * Embed cloned messages for semantic recall.
   * This is similar to the embedding logic in saveMessages but operates on already-saved messages.
   */
  async embedClonedMessages(messages, config) {
    if (!this.vector || !this.embedder) {
      return;
    }
    const embeddingData = [];
    let dimension;
    await Promise.all(
      messages.map(async (message) => {
        let textForEmbedding = null;
        if (message.content?.content && typeof message.content.content === "string" && message.content.content.trim() !== "") {
          textForEmbedding = message.content.content;
        } else if (message.content?.parts && message.content.parts.length > 0) {
          const joined = message.content.parts.filter((part) => part.type === "text").map((part) => part.text).join(" ").trim();
          if (joined) textForEmbedding = joined;
        }
        if (!textForEmbedding) return;
        const result = await this.embedMessageContent(textForEmbedding);
        dimension = result.dimension;
        embeddingData.push({
          embeddings: result.embeddings,
          metadata: result.chunks.map(() => ({
            message_id: message.id,
            thread_id: message.threadId,
            resource_id: message.resourceId
          }))
        });
      })
    );
    if (embeddingData.length > 0 && dimension !== void 0) {
      const { indexName } = await this.createEmbeddingIndex(dimension, config);
      const allVectors = [];
      const allMetadata = [];
      for (const data of embeddingData) {
        allVectors.push(...data.embeddings);
        allMetadata.push(...data.metadata);
      }
      await this.vector.upsert({
        indexName,
        vectors: allVectors,
        metadata: allMetadata
      });
    }
  }
  /**
   * Get the clone metadata from a thread if it was cloned from another thread.
   *
   * @param thread - The thread to check
   * @returns The clone metadata if the thread is a clone, null otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * const cloneInfo = memory.getCloneMetadata(thread);
   * if (cloneInfo) {
   *   console.log(`This thread was cloned from ${cloneInfo.sourceThreadId}`);
   * }
   * ```
   */
  getCloneMetadata(thread) {
    if (!thread?.metadata?.clone) {
      return null;
    }
    return thread.metadata.clone;
  }
  /**
   * Check if a thread is a clone of another thread.
   *
   * @param thread - The thread to check
   * @returns True if the thread is a clone, false otherwise
   *
   * @example
   * ```typescript
   * const thread = await memory.getThreadById({ threadId: 'thread-123' });
   * if (memory.isClone(thread)) {
   *   console.log('This is a cloned thread');
   * }
   * ```
   */
  isClone(thread) {
    return this.getCloneMetadata(thread) !== null;
  }
  /**
   * Get the source thread that a cloned thread was created from.
   *
   * @param threadId - ID of the cloned thread
   * @returns The source thread if found, null if the thread is not a clone or source doesn't exist
   *
   * @example
   * ```typescript
   * const sourceThread = await memory.getSourceThread('cloned-thread-123');
   * if (sourceThread) {
   *   console.log(`Original thread: ${sourceThread.title}`);
   * }
   * ```
   */
  async getSourceThread(threadId) {
    const thread = await this.getThreadById({ threadId });
    const cloneMetadata = this.getCloneMetadata(thread);
    if (!cloneMetadata) {
      return null;
    }
    return this.getThreadById({ threadId: cloneMetadata.sourceThreadId });
  }
  /**
   * List all threads that were cloned from a specific source thread.
   *
   * @param sourceThreadId - ID of the source thread
   * @param resourceId - Optional resource ID to filter by
   * @returns Array of threads that are clones of the source thread
   *
   * @example
   * ```typescript
   * const clones = await memory.listClones('original-thread-123', 'user-456');
   * console.log(`Found ${clones.length} clones of this thread`);
   * ```
   */
  async listClones(sourceThreadId, resourceId) {
    let targetResourceId = resourceId;
    if (!targetResourceId) {
      const sourceThread = await this.getThreadById({ threadId: sourceThreadId });
      if (!sourceThread) {
        return [];
      }
      targetResourceId = sourceThread.resourceId;
    }
    const { threads } = await this.listThreadsByResourceId({
      resourceId: targetResourceId,
      perPage: false
      // Get all threads
    });
    return threads.filter((thread) => {
      const cloneMetadata = this.getCloneMetadata(thread);
      return cloneMetadata?.sourceThreadId === sourceThreadId;
    });
  }
  /**
   * Get the clone history chain for a thread (all ancestors back to the original).
   *
   * @param threadId - ID of the thread to get history for
   * @returns Array of threads from oldest ancestor to the given thread (inclusive)
   *
   * @example
   * ```typescript
   * const history = await memory.getCloneHistory('deeply-cloned-thread');
   * // Returns: [originalThread, firstClone, secondClone, deeplyClonedThread]
   * ```
   */
  async getCloneHistory(threadId) {
    const history = [];
    let currentThreadId = threadId;
    while (currentThreadId) {
      const thread = await this.getThreadById({ threadId: currentThreadId });
      if (!thread) {
        break;
      }
      history.unshift(thread);
      const cloneMetadata = this.getCloneMetadata(thread);
      currentThreadId = cloneMetadata?.sourceThreadId ?? null;
    }
    return history;
  }
};

// ../agent-builder/dist/index.js
var import_ignore = chunkO7I5CWRX_cjs.__toESM(require_ignore(), 1);
var UNIT_KINDS = ["mcp-server", "tool", "workflow", "agent", "integration", "network", "other"];
var TemplateUnitSchema = z18.z.object({
  kind: z18.z.enum(UNIT_KINDS),
  id: z18.z.string(),
  file: z18.z.string()
});
z18.z.object({
  slug: z18.z.string(),
  ref: z18.z.string().optional(),
  description: z18.z.string().optional(),
  units: z18.z.array(TemplateUnitSchema)
});
var AgentBuilderInputSchema = z18.z.object({
  repo: z18.z.string().describe("Git URL or local path of the template repo"),
  ref: z18.z.string().optional().describe("Tag/branch/commit to checkout (defaults to main/master)"),
  slug: z18.z.string().optional().describe("Slug for branch/scripts; defaults to inferred from repo"),
  targetPath: z18.z.string().optional().describe("Project path to merge into; defaults to current directory"),
  variables: z18.z.record(z18.z.string()).optional().describe("Environment variables to set in .env file")
});
z18.z.object({
  slug: z18.z.string(),
  commitSha: z18.z.string(),
  templateDir: z18.z.string(),
  units: z18.z.array(TemplateUnitSchema)
});
var CopiedFileSchema = z18.z.object({
  source: z18.z.string(),
  destination: z18.z.string(),
  unit: z18.z.object({
    kind: z18.z.enum(UNIT_KINDS),
    id: z18.z.string()
  })
});
var ConflictSchema = z18.z.object({
  unit: z18.z.object({
    kind: z18.z.enum(UNIT_KINDS),
    id: z18.z.string()
  }),
  issue: z18.z.string(),
  sourceFile: z18.z.string(),
  targetFile: z18.z.string()
});
var FileCopyInputSchema = z18.z.object({
  orderedUnits: z18.z.array(TemplateUnitSchema),
  templateDir: z18.z.string(),
  commitSha: z18.z.string(),
  slug: z18.z.string(),
  targetPath: z18.z.string().optional(),
  variables: z18.z.record(z18.z.string()).optional()
});
var FileCopyResultSchema = z18.z.object({
  success: z18.z.boolean(),
  copiedFiles: z18.z.array(CopiedFileSchema),
  conflicts: z18.z.array(ConflictSchema),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var ConflictResolutionSchema = z18.z.object({
  unit: z18.z.object({
    kind: z18.z.enum(UNIT_KINDS),
    id: z18.z.string()
  }),
  issue: z18.z.string(),
  resolution: z18.z.string()
});
var IntelligentMergeInputSchema = z18.z.object({
  conflicts: z18.z.array(ConflictSchema),
  copiedFiles: z18.z.array(CopiedFileSchema),
  templateDir: z18.z.string(),
  commitSha: z18.z.string(),
  slug: z18.z.string(),
  targetPath: z18.z.string().optional(),
  branchName: z18.z.string().optional()
});
var IntelligentMergeResultSchema = z18.z.object({
  success: z18.z.boolean(),
  applied: z18.z.boolean(),
  message: z18.z.string(),
  conflictsResolved: z18.z.array(ConflictResolutionSchema),
  error: z18.z.string().optional()
});
var ValidationResultsSchema = z18.z.object({
  valid: z18.z.boolean(),
  errorsFixed: z18.z.number(),
  remainingErrors: z18.z.number(),
  errors: z18.z.array(z18.z.any()).optional()
  // Include specific validation errors
});
var ValidationFixInputSchema = z18.z.object({
  commitSha: z18.z.string(),
  slug: z18.z.string(),
  targetPath: z18.z.string().optional(),
  templateDir: z18.z.string(),
  orderedUnits: z18.z.array(TemplateUnitSchema),
  copiedFiles: z18.z.array(CopiedFileSchema),
  conflictsResolved: z18.z.array(ConflictResolutionSchema).optional(),
  maxIterations: z18.z.number().optional().default(5)
});
var ValidationFixResultSchema = z18.z.object({
  success: z18.z.boolean(),
  applied: z18.z.boolean(),
  message: z18.z.string(),
  validationResults: ValidationResultsSchema,
  error: z18.z.string().optional()
});
var ApplyResultSchema = z18.z.object({
  success: z18.z.boolean(),
  applied: z18.z.boolean(),
  branchName: z18.z.string().optional(),
  message: z18.z.string(),
  validationResults: ValidationResultsSchema.optional(),
  error: z18.z.string().optional(),
  errors: z18.z.array(z18.z.string()).optional(),
  stepResults: z18.z.object({
    cloneSuccess: z18.z.boolean().optional(),
    analyzeSuccess: z18.z.boolean().optional(),
    discoverSuccess: z18.z.boolean().optional(),
    orderSuccess: z18.z.boolean().optional(),
    prepareBranchSuccess: z18.z.boolean().optional(),
    packageMergeSuccess: z18.z.boolean().optional(),
    installSuccess: z18.z.boolean().optional(),
    copySuccess: z18.z.boolean().optional(),
    mergeSuccess: z18.z.boolean().optional(),
    validationSuccess: z18.z.boolean().optional(),
    filesCopied: z18.z.number(),
    conflictsSkipped: z18.z.number(),
    conflictsResolved: z18.z.number()
  }).optional()
});
var CloneTemplateResultSchema = z18.z.object({
  templateDir: z18.z.string(),
  commitSha: z18.z.string(),
  slug: z18.z.string(),
  success: z18.z.boolean().optional(),
  error: z18.z.string().optional(),
  targetPath: z18.z.string().optional()
});
var PackageAnalysisSchema = z18.z.object({
  name: z18.z.string().optional(),
  version: z18.z.string().optional(),
  description: z18.z.string().optional(),
  dependencies: z18.z.record(z18.z.string()).optional(),
  devDependencies: z18.z.record(z18.z.string()).optional(),
  peerDependencies: z18.z.record(z18.z.string()).optional(),
  scripts: z18.z.record(z18.z.string()).optional(),
  success: z18.z.boolean().optional(),
  error: z18.z.string().optional()
});
var DiscoveryResultSchema = z18.z.object({
  units: z18.z.array(TemplateUnitSchema),
  success: z18.z.boolean().optional(),
  error: z18.z.string().optional()
});
var OrderedUnitsSchema = z18.z.object({
  orderedUnits: z18.z.array(TemplateUnitSchema),
  success: z18.z.boolean().optional(),
  error: z18.z.string().optional()
});
var PackageMergeInputSchema = z18.z.object({
  commitSha: z18.z.string(),
  slug: z18.z.string(),
  targetPath: z18.z.string().optional(),
  packageInfo: PackageAnalysisSchema
});
var PackageMergeResultSchema = z18.z.object({
  success: z18.z.boolean(),
  applied: z18.z.boolean(),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var InstallInputSchema = z18.z.object({
  targetPath: z18.z.string().optional().describe("Path to the project to install packages in")
});
var InstallResultSchema = z18.z.object({
  success: z18.z.boolean(),
  error: z18.z.string().optional()
});
var PrepareBranchInputSchema = z18.z.object({
  slug: z18.z.string(),
  commitSha: z18.z.string().optional(),
  // from clone-template if relevant
  targetPath: z18.z.string().optional()
});
var PrepareBranchResultSchema = z18.z.object({
  branchName: z18.z.string(),
  success: z18.z.boolean().optional(),
  error: z18.z.string().optional()
});
var exec = util.promisify(child_process.exec);
var execFile = util.promisify(child_process.execFile);
function isInWorkspaceSubfolder(cwd) {
  try {
    const currentPackageJson = path.resolve(cwd, "package.json");
    if (!fs.existsSync(currentPackageJson)) {
      return false;
    }
    let currentDir = cwd;
    let previousDir = "";
    while (currentDir !== previousDir && currentDir !== "/") {
      previousDir = currentDir;
      currentDir = path.dirname(currentDir);
      if (currentDir === cwd) {
        continue;
      }
      console.info(`Checking for workspace indicators in: ${currentDir}`);
      if (fs.existsSync(path.resolve(currentDir, "pnpm-workspace.yaml"))) {
        return true;
      }
      const parentPackageJson = path.resolve(currentDir, "package.json");
      if (fs.existsSync(parentPackageJson)) {
        try {
          const parentPkg = JSON.parse(fs.readFileSync(parentPackageJson, "utf-8"));
          if (parentPkg.workspaces) {
            return true;
          }
        } catch {
        }
      }
      if (fs.existsSync(path.resolve(currentDir, "lerna.json"))) {
        return true;
      }
    }
    return false;
  } catch (error) {
    console.warn(`Error in workspace detection: ${error}`);
    return false;
  }
}
function spawn(command, args, options) {
  return new Promise((resolve5, reject) => {
    const childProcess = child_process.spawn(command, args, {
      stdio: "inherit",
      // Enable proper stdio handling
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve5(void 0);
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });
  });
}
async function isGitInstalled() {
  try {
    await spawnWithOutput("git", ["--version"], {});
    return true;
  } catch {
    return false;
  }
}
async function isInsideGitRepo(cwd) {
  try {
    if (!await isGitInstalled()) return false;
    const { stdout } = await spawnWithOutput("git", ["rev-parse", "--is-inside-work-tree"], { cwd });
    return stdout.trim() === "true";
  } catch {
    return false;
  }
}
function spawnWithOutput(command, args, options) {
  return new Promise((resolvePromise, rejectPromise) => {
    const childProcess = child_process.spawn(command, args, {
      ...options
    });
    let stdout = "";
    let stderr = "";
    childProcess.on("error", (error) => {
      rejectPromise(error);
    });
    childProcess.stdout?.on("data", (chunk) => {
      process.stdout.write(chunk);
      stdout += chunk?.toString?.() ?? String(chunk);
    });
    childProcess.stderr?.on("data", (chunk) => {
      stderr += chunk?.toString?.() ?? String(chunk);
      process.stderr.write(chunk);
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolvePromise({ stdout, stderr, code: code ?? 0 });
      } else {
        const err = new Error(stderr || `Command failed: ${command} ${args.join(" ")}`);
        err.code = code;
        rejectPromise(err);
      }
    });
  });
}
async function spawnSWPM(cwd, command, packageNames) {
  try {
    console.info("Running install command with swpm");
    const swpmPath = module$1.createRequire(undefined).resolve("swpm");
    await spawn(swpmPath, [command, ...packageNames], { cwd });
    return;
  } catch (e2) {
    console.warn("Failed to run install command with swpm", e2);
  }
  try {
    let packageManager;
    if (fs.existsSync(path.resolve(cwd, "pnpm-lock.yaml"))) {
      packageManager = "pnpm";
    } else if (fs.existsSync(path.resolve(cwd, "yarn.lock"))) {
      packageManager = "yarn";
    } else {
      packageManager = "npm";
    }
    let nativeCommand = command === "add" ? "add" : command === "install" ? "install" : command;
    const args = [nativeCommand];
    if (nativeCommand === "install") {
      const inWorkspace = isInWorkspaceSubfolder(cwd);
      if (packageManager === "pnpm") {
        args.push("--force");
        if (inWorkspace) {
          args.push("--ignore-workspace");
        }
      } else if (packageManager === "npm") {
        args.push("--yes");
        if (inWorkspace) {
          args.push("--ignore-workspaces");
        }
      }
    }
    args.push(...packageNames);
    console.info(`Falling back to ${packageManager} ${args.join(" ")}`);
    await spawn(packageManager, args, { cwd });
    return;
  } catch (e2) {
    console.warn(`Failed to run install command with native package manager: ${e2}`);
  }
  throw new Error(`Failed to run install command with swpm and native package managers`);
}
function kindWeight(kind) {
  const idx = UNIT_KINDS.indexOf(kind);
  return idx === -1 ? UNIT_KINDS.length : idx;
}
async function logGitState(targetPath, label) {
  try {
    if (!await isInsideGitRepo(targetPath)) return;
    const gitStatusResult = await git(targetPath, "status", "--porcelain");
    const gitLogResult = await git(targetPath, "log", "--oneline", "-3");
    const gitCountResult = await git(targetPath, "rev-list", "--count", "HEAD");
    console.info(`\u{1F4CA} Git state ${label}:`);
    console.info("Status:", gitStatusResult.stdout.trim() || "Clean working directory");
    console.info("Recent commits:", gitLogResult.stdout.trim());
    console.info("Total commits:", gitCountResult.stdout.trim());
  } catch (gitError) {
    console.warn(`Could not get git state ${label}:`, gitError);
  }
}
async function git(cwd, ...args) {
  const { stdout, stderr } = await spawnWithOutput("git", args, { cwd });
  return { stdout: stdout ?? "", stderr: stderr ?? "" };
}
async function gitClone(repo, destDir, cwd) {
  await git(process.cwd(), "clone", repo, destDir);
}
async function gitCheckoutRef(cwd, ref) {
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "checkout", ref);
}
async function gitRevParse(cwd, rev) {
  if (!await isInsideGitRepo(cwd)) return "";
  const { stdout } = await git(cwd, "rev-parse", rev);
  return stdout.trim();
}
async function gitAddFiles(cwd, files) {
  if (!files || files.length === 0) return;
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "add", ...files);
}
async function gitAddAll(cwd) {
  if (!await isInsideGitRepo(cwd)) return;
  await git(cwd, "add", ".");
}
async function gitHasStagedChanges(cwd) {
  if (!await isInsideGitRepo(cwd)) return false;
  const { stdout } = await git(cwd, "diff", "--cached", "--name-only");
  return stdout.trim().length > 0;
}
async function gitCommit(cwd, message, opts) {
  try {
    if (!await isInsideGitRepo(cwd)) return false;
    if (opts?.skipIfNoStaged) {
      const has = await gitHasStagedChanges(cwd);
      if (!has) return false;
    }
    const args = ["commit", "-m", message];
    if (opts?.allowEmpty) args.push("--allow-empty");
    await git(cwd, ...args);
    return true;
  } catch (e2) {
    const msg = e2 instanceof Error ? e2.message : String(e2);
    if (/nothing to commit/i.test(msg) || /no changes added to commit/i.test(msg)) {
      return false;
    }
    throw e2;
  }
}
async function gitAddAndCommit(cwd, message, files, opts) {
  try {
    if (!await isInsideGitRepo(cwd)) return false;
    if (files && files.length > 0) {
      await gitAddFiles(cwd, files);
    } else {
      await gitAddAll(cwd);
    }
    return gitCommit(cwd, message, opts);
  } catch (e2) {
    console.error(`Failed to add and commit files: ${e2 instanceof Error ? e2.message : String(e2)}`);
    return false;
  }
}
async function gitCheckoutBranch(branchName, targetPath) {
  try {
    if (!await isInsideGitRepo(targetPath)) return;
    await git(targetPath, "checkout", "-b", branchName);
    console.info(`Created new branch: ${branchName}`);
  } catch (error) {
    const errorStr = error instanceof Error ? error.message : String(error);
    if (errorStr.includes("already exists")) {
      try {
        await git(targetPath, "checkout", branchName);
        console.info(`Switched to existing branch: ${branchName}`);
      } catch {
        const timestamp = Date.now().toString().slice(-6);
        const uniqueBranchName = `${branchName}-${timestamp}`;
        await git(targetPath, "checkout", "-b", uniqueBranchName);
        console.info(`Created unique branch: ${uniqueBranchName}`);
      }
    } else {
      throw error;
    }
  }
}
async function backupAndReplaceFile(sourceFile, targetFile) {
  const backupFile = `${targetFile}.backup-${Date.now()}`;
  await promises.copyFile(targetFile, backupFile);
  console.info(`\u{1F4E6} Created backup: ${path.basename(backupFile)}`);
  await promises.copyFile(sourceFile, targetFile);
  console.info(`\u{1F504} Replaced file with template version (backup created)`);
}
async function renameAndCopyFile(sourceFile, targetFile) {
  let counter = 1;
  let uniqueTargetFile = targetFile;
  const baseName = path.basename(targetFile, path.extname(targetFile));
  const extension = path.extname(targetFile);
  const directory = path.dirname(targetFile);
  while (fs.existsSync(uniqueTargetFile)) {
    const uniqueName = `${baseName}.template-${counter}${extension}`;
    uniqueTargetFile = path.resolve(directory, uniqueName);
    counter++;
  }
  await promises.copyFile(sourceFile, uniqueTargetFile);
  console.info(`\u{1F4DD} Copied with unique name: ${path.basename(uniqueTargetFile)}`);
  return uniqueTargetFile;
}
var isValidMastraLanguageModel = (model) => {
  return model && typeof model === "object" && typeof model.modelId === "string";
};
var resolveTargetPath = (inputData, requestContext) => {
  if (inputData.targetPath) {
    return inputData.targetPath;
  }
  const contextPath = requestContext.get("targetPath");
  if (contextPath) {
    return contextPath;
  }
  const envRoot = process.env.MASTRA_PROJECT_ROOT?.trim();
  if (envRoot) {
    return envRoot;
  }
  const cwd = process.cwd();
  const parent = path.dirname(cwd);
  const grand = path.dirname(parent);
  if (path.basename(cwd) === "output" && path.basename(parent) === ".mastra") {
    return grand;
  }
  return cwd;
};
var mergeGitignoreFiles = (targetContent, templateContent, templateSlug) => {
  const targetLines = targetContent.replace(/\r\n/g, "\n").split("\n");
  const templateLines = templateContent.replace(/\r\n/g, "\n").split("\n");
  const existingEntries = /* @__PURE__ */ new Set();
  for (const line of targetLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const normalized = trimmed.replace(/^\.\//, "").replace(/\\/g, "/");
      existingEntries.add(normalized);
    }
  }
  const newEntries = [];
  for (const line of templateLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const normalized = trimmed.replace(/^\.\//, "").replace(/\\/g, "/");
      if (!existingEntries.has(normalized)) {
        const isNegation = normalized.startsWith("!");
        const basePath = isNegation ? normalized.slice(1) : normalized;
        const hasConflict = isNegation ? existingEntries.has(basePath) : existingEntries.has("!" + basePath);
        if (!hasConflict) {
          newEntries.push(trimmed);
        } else {
          console.info(`\u26A0 Skipping conflicting .gitignore rule: ${trimmed} (conflicts with existing rule)`);
        }
      }
    }
  }
  if (newEntries.length === 0) {
    return targetContent;
  }
  const result = [...targetLines];
  const lastLine = result[result.length - 1];
  if (result.length > 0 && lastLine && lastLine.trim() !== "") {
    result.push("");
  }
  result.push(`# Added by template: ${templateSlug}`);
  result.push(...newEntries);
  return result.join("\n");
};
var mergeEnvFiles = (targetContent, templateVariables, templateSlug) => {
  const targetLines = targetContent.replace(/\r\n/g, "\n").split("\n");
  const existingVars = /* @__PURE__ */ new Set();
  for (const line of targetLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const equalIndex = trimmed.indexOf("=");
      if (equalIndex > 0) {
        const varName = trimmed.substring(0, equalIndex).trim();
        existingVars.add(varName);
      }
    }
  }
  const newVars = [];
  for (const [key, value] of Object.entries(templateVariables)) {
    if (!existingVars.has(key)) {
      newVars.push({ key, value });
    } else {
      console.info(`\u26A0 Skipping existing environment variable: ${key} (already exists in .env)`);
    }
  }
  if (newVars.length === 0) {
    return targetContent;
  }
  const result = [...targetLines];
  const lastLine = result[result.length - 1];
  if (result.length > 0 && lastLine && lastLine.trim() !== "") {
    result.push("");
  }
  result.push(`# Added by template: ${templateSlug}`);
  for (const { key, value } of newVars) {
    result.push(`${key}=${value}`);
  }
  return result.join("\n");
};
var detectAISDKVersion = async (projectPath) => {
  try {
    const packageJsonPath = path.join(projectPath, "package.json");
    if (!fs.existsSync(packageJsonPath)) {
      console.info("No package.json found, defaulting to v2");
      return "v2";
    }
    const packageContent = await promises.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageContent);
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
      ...packageJson.peerDependencies
    };
    const providerPackages = ["@ai-sdk/openai", "@ai-sdk/anthropic", "@ai-sdk/google", "@ai-sdk/groq", "@ai-sdk/xai"];
    for (const pkg of providerPackages) {
      const version = allDeps[pkg];
      if (version) {
        const versionMatch = version.match(/(\d+)/);
        if (versionMatch) {
          const majorVersion = parseInt(versionMatch[1]);
          if (majorVersion >= 2) {
            console.info(`Detected ${pkg} v${majorVersion} -> using v2 specification`);
            return "v2";
          } else {
            console.info(`Detected ${pkg} v${majorVersion} -> using v1 specification`);
            return "v1";
          }
        }
      }
    }
    console.info("No AI SDK version detected, defaulting to v2");
    return "v2";
  } catch (error) {
    console.warn(`Failed to detect AI SDK version: ${error instanceof Error ? error.message : String(error)}`);
    return "v2";
  }
};
var createModelInstance = async (provider, modelId, version = "v2") => {
  try {
    const providerMap = {
      v1: {
        openai: async () => {
          const { openai: openai2 } = await import('./dist-ZLC23RVC.cjs');
          return openai2(modelId);
        },
        anthropic: async () => {
          const { anthropic } = await import('./dist-P6YSNLL3.cjs');
          return anthropic(modelId);
        },
        groq: async () => {
          const { groq } = await import('./dist-OF24ZMHH.cjs');
          return groq(modelId);
        },
        xai: async () => {
          const { xai } = await import('./dist-7NTDEVLP.cjs');
          return xai(modelId);
        },
        google: async () => {
          const { google } = await import('./dist-VZTG56X2.cjs');
          return google(modelId);
        }
      }
    };
    const providerFn = version === `v1` ? providerMap[version][provider] : () => new llm.ModelRouterLanguageModel(`${provider}/${modelId}`);
    if (!providerFn) {
      console.error(`Unsupported provider: ${provider}`);
      return null;
    }
    const modelInstance = await providerFn();
    console.info(`Created ${provider} model instance (${version}): ${modelId}`);
    return modelInstance;
  } catch (error) {
    console.error(`Failed to create model instance: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
};
var resolveModel = async ({
  requestContext,
  defaultModel = "openai/gpt-4.1",
  projectPath
}) => {
  const modelFromContext = requestContext.get("model");
  if (modelFromContext) {
    console.info("Using model from request context");
    if (isValidMastraLanguageModel(modelFromContext)) {
      return modelFromContext;
    }
    throw new Error(
      'Invalid model provided. Model must be a MastraLanguageModel instance (e.g., openai("gpt-4"), anthropic("claude-3-5-sonnet"), etc.)'
    );
  }
  const selectedModel = requestContext.get("selectedModel");
  if (selectedModel?.provider && selectedModel?.modelId && projectPath) {
    console.info(`Resolving selected model: ${selectedModel.provider}/${selectedModel.modelId}`);
    const version = await detectAISDKVersion(projectPath);
    const modelInstance = await createModelInstance(selectedModel.provider, selectedModel.modelId, version);
    if (modelInstance) {
      requestContext.set("model", modelInstance);
      return modelInstance;
    }
  }
  console.info("Using default model");
  return typeof defaultModel === `string` ? new llm.ModelRouterLanguageModel(defaultModel) : defaultModel;
};
var AgentBuilderDefaults = class _AgentBuilderDefaults {
  static DEFAULT_INSTRUCTIONS = (projectPath) => `You are a Mastra Expert Agent, specialized in building production-ready AI applications using the Mastra framework. You excel at creating agents, tools, workflows, and complete applications with real, working implementations.

## Core Identity & Capabilities

**Primary Role:** Transform natural language requirements into working Mastra applications
**Key Strength:** Deep knowledge of Mastra patterns, conventions, and best practices
**Output Quality:** Production-ready code that follows Mastra ecosystem standards

## Workflow: The MASTRA Method

Follow this sequence for every coding task:

IF NO PROJECT EXISTS, USE THE MANAGEPROJECT TOOL TO CREATE A NEW PROJECT

DO NOT INCLUDE TODOS IN THE CODE, UNLESS SPECIFICALLY ASKED TO DO SO, CREATE REAL WORLD CODE

### 1. \u{1F50D} **UNDERSTAND** (Information Gathering)
- **Explore Mastra Docs**: Use docs tools to understand relevant Mastra patterns and APIs
- **Analyze Project**: Use file exploration to understand existing codebase structure
- **Web Research**: Search for packages, examples, or solutions when docs are insufficient
- **Clarify Requirements**: Ask targeted questions only when critical information is missing

### 2. \u{1F4CB} **PLAN** (Strategy & Design)
- **Architecture**: Design using Mastra conventions (agents, tools, workflows, memory)
- **Dependencies**: Identify required packages and Mastra components
- **Integration**: Plan how to integrate with existing project structure
- **Validation**: Define how to test and verify the implementation

### 3. \u{1F6E0}\uFE0F **BUILD** (Implementation)
- **Install First**: Use \`manageProject\` tool to install required packages
- **Follow Patterns**: Implement using established Mastra conventions
- **Real Code Only**: Build actual working functionality, never mock implementations
- **Environment Setup**: Create proper .env configuration and documentation

### 4. \u2705 **VALIDATE** (Quality Assurance)
- **Code Validation**: Run \`validateCode\` with types and lint checks
- **Testing**: Execute tests if available
- **Server Testing**: Use \`manageServer\` and \`httpRequest\` for API validation
- **Fix Issues**: Address all errors before completion

## Mastra-Specific Guidelines

### Framework Knowledge
- **Agents**: Use \`@mastra/core/agent\` with proper configuration
- **Tools**: Create tools with \`@mastra/core/tools\` and proper schemas
- **Memory**: Implement memory with \`@mastra/memory\` and appropriate processors
- **Workflows**: Build workflows with \`@mastra/core/workflows\`
- **Integrations**: Leverage Mastra's extensive integration ecosystem

### Code Standards
- **TypeScript First**: All code must be properly typed
- **Zod Schemas**: Use Zod for all data validation
- **Environment Variables**: Proper .env configuration with examples
- **Error Handling**: Comprehensive error handling with meaningful messages
- **Security**: Never expose credentials or sensitive data

### Project Structure
- Follow Mastra project conventions (\`src/mastra/\`, config files)
- Use proper file organization (agents, tools, workflows in separate directories)
- Maintain consistent naming conventions
- Include proper exports and imports

## Communication Style

**Conciseness**: Keep responses focused and actionable
**Clarity**: Explain complex concepts in simple terms
**Directness**: State what you're doing and why
**No Fluff**: Avoid unnecessary explanations or apologies

### Response Format
1. **Brief Status**: One line stating what you're doing
2. **Tool Usage**: Execute necessary tools
3. **Results Summary**: Concise summary of what was accomplished
4. **Next Steps**: Clear indication of completion or next actions

## Tool Usage Strategy

### File Operations
- **Project-Relative Paths**: All file paths are resolved relative to the project directory (unless absolute paths are used)
- **Read First**: Always read files before editing to understand context
- **Precise Edits**: Use exact text matching for search/replace operations
- **Batch Operations**: Group related file operations when possible

### Project Management
- **manageProject**: Use for package installation, project creation, dependency management
- **validateCode**: Always run after code changes to ensure quality
- **manageServer**: Use for testing Mastra server functionality
- **httpRequest**: Test API endpoints and integrations

### Information Gathering
- **Mastra Docs**: Primary source for Mastra-specific information
- **Web Search**: Secondary source for packages and external solutions
- **File Exploration**: Understand existing project structure and patterns

## Error Handling & Recovery

### Validation Failures
- Fix TypeScript errors immediately
- Address linting issues systematically
- Re-validate until clean

### Build Issues
- Check dependencies and versions
- Verify Mastra configuration
- Test in isolation when needed

### Integration Problems
- Verify API keys and environment setup
- Test connections independently
- Debug with logging and error messages

## Security & Best Practices

**Never:**
- Hard-code API keys or secrets
- Generate mock or placeholder implementations
- Skip error handling
- Ignore TypeScript errors
- Create insecure code patterns
- ask for file paths, you should be able to use the provided tools to explore the file system

**Always:**
- Use environment variables for configuration
- Implement proper input validation
- Follow security best practices
- Create complete, working implementations
- Test thoroughly before completion

## Output Requirements

### Code Quality
- \u2705 TypeScript compilation passes
- \u2705 ESLint validation passes
- \u2705 Proper error handling implemented
- \u2705 Environment variables configured
- \u2705 Tests included when appropriate

### Documentation
- \u2705 Clear setup instructions
- \u2705 Environment variable documentation
- \u2705 Usage examples provided
- \u2705 API documentation for custom tools

### Integration
- \u2705 Follows Mastra conventions
- \u2705 Integrates with existing project
- \u2705 Proper imports and exports
- \u2705 Compatible with Mastra ecosystem

## Project Context

**Working Directory**: ${projectPath}
**Focus**: Mastra framework applications
**Goal**: Production-ready implementations

Remember: You are building real applications, not prototypes. Every implementation should be complete, secure, and ready for production use.

## Enhanced Tool Set

You have access to an enhanced set of tools based on production coding agent patterns:

### Task Management
- **taskManager**: Create and track multi-step coding tasks with states (pending, in_progress, completed, blocked). Use this for complex projects that require systematic progress tracking.

### Code Discovery & Analysis
- **codeAnalyzer**: Analyze codebase structure, discover definitions (functions, classes, interfaces), map dependencies, and understand architectural patterns.
- **smartSearch**: Intelligent search with context awareness, pattern matching, and relevance scoring.

### Advanced File Operations
- **readFile**: Read files with optional line ranges, encoding support, metadata
- **writeFile**: Write files with directory creation
- **listDirectory**: Directory listing with filtering, recursion, metadata
- **multiEdit**: Perform multiple search-replace operations across files atomically with backup creation
- **executeCommand**: Execute shell commands with proper error handling and working directory support

**Important**: All file paths are resolved relative to the project directory unless absolute paths are provided.

### Communication & Workflow
- **attemptCompletion**: Signal task completion with validation status and confidence metrics.

### Guidelines for Enhanced Tools:

1. **Use taskManager proactively** for any task requiring 3+ steps or complex coordination
2. **Start with codeAnalyzer** when working with unfamiliar codebases to understand structure
3. **Use smartSearch** for intelligent pattern discovery across the codebase
4. **Apply multiEdit** for systematic refactoring across multiple files
5. **Ask for clarification** when requirements are ambiguous rather than making assumptions
6. **Signal completion** with comprehensive summaries and validation status

Use the following basic examples to guide your implementation.

<examples>
### Weather Agent
\`\`\`
// ./src/agents/weather-agent.ts
import { openai } from '@ai-sdk/openai';
import { Agent } from '@mastra/core/agent';
import { Memory } from '@mastra/memory';
import { LibSQLStore } from '@mastra/libsql';
import { weatherTool } from '../tools/weather-tool';

export const weatherAgent = new Agent({
  id: 'weather-agent',
  name: 'Weather Agent',
  instructions: \${instructions},
  model: openai('gpt-4o-mini'),
  tools: { weatherTool },
  memory: new Memory({
    storage: new LibSQLStore({
      id: 'mastra-memory-storage',
      url: 'file:../mastra.db', // ask user what database to use, use this as the default
    }),
  }),
});
\`\`\`

### Weather Tool
\`\`\`
// ./src/tools/weather-tool.ts
import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { getWeather } from '../tools/weather-tool';

export const weatherTool = createTool({
  id: 'get-weather',
  description: 'Get current weather for a location',
  inputSchema: z.object({
    location: z.string().describe('City name'),
  }),
  outputSchema: z.object({
    temperature: z.number(),
    feelsLike: z.number(),
    humidity: z.number(),
    windSpeed: z.number(),
    windGust: z.number(),
    conditions: z.string(),
    location: z.string(),
  }),
  execute: async (inputData) => {
    return await getWeather(inputData.location);
  },
});
\`\`\`

### Weather Workflow
\`\`\`
// ./src/workflows/weather-workflow.ts
import { createStep, createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

const fetchWeather = createStep({
  id: 'fetch-weather',
  description: 'Fetches weather forecast for a given city',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: forecastSchema,
  execute: async (inputData) => {
    if (!inputData) {
      throw new Error('Input data not found');
    }

    const geocodingUrl = \`https://geocoding-api.open-meteo.com/v1/search?name=\${encodeURIComponent(inputData.city)}&count=1\`;
    const geocodingResponse = await fetch(geocodingUrl);
    const geocodingData = (await geocodingResponse.json()) as {
      results: { latitude: number; longitude: number; name: string }[];
    };

    if (!geocodingData.results?.[0]) {
      throw new Error(\`Location '\${inputData.city}' not found\`);
    }

    const { latitude, longitude, name } = geocodingData.results[0];

    const weatherUrl = \`https://api.open-meteo.com/v1/forecast?latitude=\${latitude}&longitude=\${longitude}&current=precipitation,weathercode&timezone=auto,&hourly=precipitation_probability,temperature_2m\`
    const response = await fetch(weatherUrl);
    const data = (await response.json()) as {
      current: {
        time: string;
        precipitation: number;
        weathercode: number;
      };
      hourly: {
        precipitation_probability: number[];
        temperature_2m: number[];
      };
    };

    const forecast = {
      date: new Date().toISOString(),
      maxTemp: Math.max(...data.hourly.temperature_2m),
      minTemp: Math.min(...data.hourly.temperature_2m),
      condition: getWeatherCondition(data.current.weathercode),
      precipitationChance: data.hourly.precipitation_probability.reduce(
        (acc, curr) => Math.max(acc, curr),
        0,
      ),
      location: name,
    };

    return forecast;
  },
});

const planActivities = createStep({
  id: 'plan-activities',
  description: 'Suggests activities based on weather conditions',
  inputSchema: forecastSchema,
  outputSchema: z.object({
    activities: z.string(),
  }),
  execute: async (inputData, context) => {
    const mastra = context?.mastra;
    const forecast = inputData;

    if (!forecast) {
      throw new Error('Forecast data not found');
    }

    const agent = mastra?.getAgent('weatherAgent');
    if (!agent) {
      throw new Error('Weather agent not found');
    }

    const prompt = \${weatherWorkflowPrompt}

    const response = await agent.stream([
      {
        role: 'user',
        content: prompt,
      },
    ]);

    let activitiesText = '';

    for await (const chunk of response.textStream) {
      process.stdout.write(chunk);
      activitiesText += chunk;
    }

    return {
      activities: activitiesText,
    };
  },
});

const weatherWorkflow = createWorkflow({
  id: 'weather-workflow',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: z.object({
    activities: z.string(),
  }),
})
  .then(fetchWeather)
  .then(planActivities);

weatherWorkflow.commit();
\`\`\`
export { weatherWorkflow };
\`\`\`

### Mastra instance
\`\`\`
// ./src/mastra.ts

import { Mastra } from '@mastra/core/mastra';
import { PinoLogger } from '@mastra/loggers';
import { LibSQLStore } from '@mastra/libsql';
import { weatherWorkflow } from './workflows/weather-workflow';
import { weatherAgent } from './agents/weather-agent';

export const mastra = new Mastra({
  workflows: { weatherWorkflow },
  agents: { weatherAgent },
  storage: new LibSQLStore({
    id: 'mastra-storage',
    // stores observability, evals, ... into memory storage, if it needs to persist, change to file:../mastra.db
    url: ":memory:",
  }),
  logger: new PinoLogger({
    name: 'Mastra',
    level: 'info',
  }),
});
\`\`\`

</examples>`;
  static DEFAULT_MEMORY_CONFIG = {
    lastMessages: 20
  };
  static DEFAULT_FOLDER_STRUCTURE = {
    agent: "src/mastra/agents",
    workflow: "src/mastra/workflows",
    tool: "src/mastra/tools",
    "mcp-server": "src/mastra/mcp",
    network: "src/mastra/networks"
  };
  static DEFAULT_TOOLS = async (projectPath) => {
    return {
      readFile: tools.createTool({
        id: "read-file",
        description: "Read contents of a file with optional line range selection.",
        inputSchema: z18.z.object({
          filePath: z18.z.string().describe("Path to the file to read"),
          startLine: z18.z.number().optional().describe("Starting line number (1-indexed)"),
          endLine: z18.z.number().optional().describe("Ending line number (1-indexed, inclusive)"),
          encoding: z18.z.string().default("utf-8").describe("File encoding")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          content: z18.z.string().optional(),
          lines: z18.z.array(z18.z.string()).optional(),
          metadata: z18.z.object({
            size: z18.z.number(),
            totalLines: z18.z.number(),
            encoding: z18.z.string(),
            lastModified: z18.z.string()
          }).optional(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.readFile({ ...inputData, projectPath });
        }
      }),
      writeFile: tools.createTool({
        id: "write-file",
        description: "Write content to a file, with options for creating directories.",
        inputSchema: z18.z.object({
          filePath: z18.z.string().describe("Path to the file to write"),
          content: z18.z.string().describe("Content to write to the file"),
          createDirs: z18.z.boolean().default(true).describe("Create parent directories if they don't exist"),
          encoding: z18.z.string().default("utf-8").describe("File encoding")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          filePath: z18.z.string(),
          bytesWritten: z18.z.number().optional(),
          message: z18.z.string(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.writeFile({ ...inputData, projectPath });
        }
      }),
      listDirectory: tools.createTool({
        id: "list-directory",
        description: "List contents of a directory with filtering and metadata options.",
        inputSchema: z18.z.object({
          path: z18.z.string().describe("Directory path to list"),
          recursive: z18.z.boolean().default(false).describe("List subdirectories recursively"),
          includeHidden: z18.z.boolean().default(false).describe("Include hidden files and directories"),
          pattern: z18.z.string().default("*").describe("Glob pattern to filter files"),
          maxDepth: z18.z.number().default(10).describe("Maximum recursion depth"),
          includeMetadata: z18.z.boolean().default(true).describe("Include file metadata")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          items: z18.z.array(
            z18.z.object({
              name: z18.z.string(),
              path: z18.z.string(),
              type: z18.z.enum(["file", "directory", "symlink"]),
              size: z18.z.number().optional(),
              lastModified: z18.z.string().optional(),
              permissions: z18.z.string().optional()
            })
          ),
          totalItems: z18.z.number(),
          path: z18.z.string(),
          message: z18.z.string(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.listDirectory({ ...inputData, projectPath });
        }
      }),
      executeCommand: tools.createTool({
        id: "execute-command",
        description: "Execute shell commands with proper error handling and output capture.",
        inputSchema: z18.z.object({
          command: z18.z.string().describe("Shell command to execute"),
          workingDirectory: z18.z.string().optional().describe("Working directory for command execution"),
          timeout: z18.z.number().default(3e4).describe("Timeout in milliseconds"),
          captureOutput: z18.z.boolean().default(true).describe("Capture command output"),
          shell: z18.z.string().optional().describe("Shell to use (defaults to system shell)"),
          env: z18.z.record(z18.z.string()).optional().describe("Environment variables")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          exitCode: z18.z.number().optional(),
          stdout: z18.z.string().optional(),
          stderr: z18.z.string().optional(),
          command: z18.z.string(),
          workingDirectory: z18.z.string().optional(),
          executionTime: z18.z.number().optional(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.executeCommand({
            ...inputData,
            workingDirectory: inputData.workingDirectory || projectPath
          });
        }
      }),
      // Enhanced Task Management (Critical for complex coding tasks)
      taskManager: tools.createTool({
        id: "task-manager",
        description: "Create and manage structured task lists for coding sessions. Use this for complex multi-step tasks to track progress and ensure thoroughness.",
        inputSchema: z18.z.object({
          action: z18.z.enum(["create", "update", "list", "complete", "remove"]).describe("Task management action"),
          tasks: z18.z.array(
            z18.z.object({
              id: z18.z.string().describe("Unique task identifier"),
              content: z18.z.string().describe("Task description, optional if just updating the status").optional(),
              status: z18.z.enum(["pending", "in_progress", "completed", "blocked"]).describe("Task status"),
              priority: z18.z.enum(["high", "medium", "low"]).default("medium").describe("Task priority"),
              dependencies: z18.z.array(z18.z.string()).optional().describe("IDs of tasks this depends on"),
              notes: z18.z.string().optional().describe("Additional notes or context")
            })
          ).optional().describe("Tasks to create or update"),
          taskId: z18.z.string().optional().describe("Specific task ID for single task operations")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          tasks: z18.z.array(
            z18.z.object({
              id: z18.z.string(),
              content: z18.z.string(),
              status: z18.z.string(),
              priority: z18.z.string(),
              dependencies: z18.z.array(z18.z.string()).optional(),
              notes: z18.z.string().optional(),
              createdAt: z18.z.string(),
              updatedAt: z18.z.string()
            })
          ),
          message: z18.z.string()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.manageTaskList(inputData);
        }
      }),
      // Advanced File Operations
      multiEdit: tools.createTool({
        id: "multi-edit",
        description: "Perform multiple search-replace operations on one or more files in a single atomic operation.",
        inputSchema: z18.z.object({
          operations: z18.z.array(
            z18.z.object({
              filePath: z18.z.string().describe("Path to the file to edit"),
              edits: z18.z.array(
                z18.z.object({
                  oldString: z18.z.string().describe("Exact text to replace"),
                  newString: z18.z.string().describe("Replacement text"),
                  replaceAll: z18.z.boolean().default(false).describe("Replace all occurrences")
                })
              ).describe("List of edit operations for this file")
            })
          ).describe("File edit operations to perform"),
          createBackup: z18.z.boolean().default(false).describe("Create backup files before editing")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          results: z18.z.array(
            z18.z.object({
              filePath: z18.z.string(),
              editsApplied: z18.z.number(),
              errors: z18.z.array(z18.z.string()),
              backup: z18.z.string().optional()
            })
          ),
          message: z18.z.string()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.performMultiEdit({ ...inputData, projectPath });
        }
      }),
      replaceLines: tools.createTool({
        id: "replace-lines",
        description: "Replace specific line ranges in files with new content. IMPORTANT: This tool replaces ENTIRE lines, not partial content within lines. Lines are 1-indexed.",
        inputSchema: z18.z.object({
          filePath: z18.z.string().describe("Path to the file to edit"),
          startLine: z18.z.number().describe("Starting line number to replace (1-indexed, inclusive). Count from the first line = 1"),
          endLine: z18.z.number().describe(
            "Ending line number to replace (1-indexed, inclusive). To replace single line, use same number as startLine"
          ),
          newContent: z18.z.string().describe(
            'New content to replace the lines with. Use empty string "" to delete lines completely. For multiline content, include \\n characters'
          ),
          createBackup: z18.z.boolean().default(false).describe("Create backup file before editing")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          message: z18.z.string(),
          linesReplaced: z18.z.number().optional(),
          backup: z18.z.string().optional(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.replaceLines({ ...inputData, projectPath });
        }
      }),
      // File diagnostics tool to help debug line replacement issues
      showFileLines: tools.createTool({
        id: "show-file-lines",
        description: "Show specific lines from a file with line numbers. Useful for debugging before using replaceLines.",
        inputSchema: z18.z.object({
          filePath: z18.z.string().describe("Path to the file to examine"),
          startLine: z18.z.number().optional().describe("Starting line number to show (1-indexed). If not provided, shows all lines"),
          endLine: z18.z.number().optional().describe(
            "Ending line number to show (1-indexed, inclusive). If not provided but startLine is, shows only that line"
          ),
          context: z18.z.number().default(2).describe("Number of context lines to show before and after the range")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          lines: z18.z.array(
            z18.z.object({
              lineNumber: z18.z.number(),
              content: z18.z.string(),
              isTarget: z18.z.boolean().describe("Whether this line is in the target range")
            })
          ),
          totalLines: z18.z.number(),
          message: z18.z.string(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.showFileLines({ ...inputData, projectPath });
        }
      }),
      // Enhanced Pattern Search
      smartSearch: tools.createTool({
        id: "smart-search",
        description: "Intelligent search across codebase with context awareness and pattern matching.",
        inputSchema: z18.z.object({
          query: z18.z.string().describe("Search query or pattern"),
          type: z18.z.enum(["text", "regex", "fuzzy", "semantic"]).default("text").describe("Type of search to perform"),
          scope: z18.z.object({
            paths: z18.z.array(z18.z.string()).optional().describe("Specific paths to search"),
            fileTypes: z18.z.array(z18.z.string()).optional().describe("File extensions to include"),
            excludePaths: z18.z.array(z18.z.string()).optional().describe("Paths to exclude"),
            maxResults: z18.z.number().default(50).describe("Maximum number of results")
          }).optional(),
          context: z18.z.object({
            beforeLines: z18.z.number().default(2).describe("Lines of context before match"),
            afterLines: z18.z.number().default(2).describe("Lines of context after match"),
            includeDefinitions: z18.z.boolean().default(false).describe("Include function/class definitions")
          }).optional()
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          matches: z18.z.array(
            z18.z.object({
              file: z18.z.string(),
              line: z18.z.number(),
              column: z18.z.number().optional(),
              match: z18.z.string(),
              context: z18.z.object({
                before: z18.z.array(z18.z.string()),
                after: z18.z.array(z18.z.string())
              }),
              relevance: z18.z.number().optional()
            })
          ),
          summary: z18.z.object({
            totalMatches: z18.z.number(),
            filesSearched: z18.z.number(),
            patterns: z18.z.array(z18.z.string())
          })
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.performSmartSearch(inputData, projectPath);
        }
      }),
      validateCode: tools.createTool({
        id: "validate-code",
        description: "Validates code using a fast hybrid approach: syntax \u2192 semantic \u2192 lint. RECOMMENDED: Always provide specific files for optimal performance and accuracy.",
        inputSchema: z18.z.object({
          projectPath: z18.z.string().optional().describe("Path to the project to validate (defaults to current project)"),
          validationType: z18.z.array(z18.z.enum(["types", "lint", "schemas", "tests", "build"])).describe('Types of validation to perform. Recommended: ["types", "lint"] for code quality'),
          files: z18.z.array(z18.z.string()).optional().describe(
            "RECOMMENDED: Specific files to validate (e.g., files you created/modified). Uses hybrid validation: fast syntax check \u2192 semantic types \u2192 ESLint. Without files, falls back to slower CLI validation."
          )
        }),
        outputSchema: z18.z.object({
          valid: z18.z.boolean(),
          errors: z18.z.array(
            z18.z.object({
              type: z18.z.enum(["typescript", "eslint", "schema", "test", "build"]),
              severity: z18.z.enum(["error", "warning", "info"]),
              message: z18.z.string(),
              file: z18.z.string().optional(),
              line: z18.z.number().optional(),
              column: z18.z.number().optional(),
              code: z18.z.string().optional()
            })
          ),
          summary: z18.z.object({
            totalErrors: z18.z.number(),
            totalWarnings: z18.z.number(),
            validationsPassed: z18.z.array(z18.z.string()),
            validationsFailed: z18.z.array(z18.z.string())
          })
        }),
        execute: async (inputData) => {
          const { projectPath: validationProjectPath, validationType, files } = inputData;
          const targetPath = validationProjectPath || projectPath;
          return await _AgentBuilderDefaults.validateCode({
            projectPath: targetPath,
            validationType,
            files
          });
        }
      }),
      // Web Search (replaces MCP web search)
      webSearch: tools.createTool({
        id: "web-search",
        description: "Search the web for current information and return structured results.",
        inputSchema: z18.z.object({
          query: z18.z.string().describe("Search query"),
          maxResults: z18.z.number().default(10).describe("Maximum number of results to return"),
          region: z18.z.string().default("us").describe("Search region/country code"),
          language: z18.z.string().default("en").describe("Search language"),
          includeImages: z18.z.boolean().default(false).describe("Include image results"),
          dateRange: z18.z.enum(["day", "week", "month", "year", "all"]).default("all").describe("Date range filter")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          query: z18.z.string(),
          results: z18.z.array(
            z18.z.object({
              title: z18.z.string(),
              url: z18.z.string(),
              snippet: z18.z.string(),
              domain: z18.z.string(),
              publishDate: z18.z.string().optional(),
              relevanceScore: z18.z.number().optional()
            })
          ),
          totalResults: z18.z.number(),
          searchTime: z18.z.number(),
          suggestions: z18.z.array(z18.z.string()).optional(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.webSearch(inputData);
        }
      }),
      // Task Completion Signaling
      attemptCompletion: tools.createTool({
        id: "attempt-completion",
        description: "Signal that you believe the requested task has been completed and provide a summary.",
        inputSchema: z18.z.object({
          summary: z18.z.string().describe("Summary of what was accomplished"),
          changes: z18.z.array(
            z18.z.object({
              type: z18.z.enum(["file_created", "file_modified", "file_deleted", "command_executed", "dependency_added"]),
              description: z18.z.string(),
              path: z18.z.string().optional()
            })
          ).describe("List of changes made"),
          validation: z18.z.object({
            testsRun: z18.z.boolean().default(false),
            buildsSuccessfully: z18.z.boolean().default(false),
            manualTestingRequired: z18.z.boolean().default(false)
          }).describe("Validation status"),
          nextSteps: z18.z.array(z18.z.string()).optional().describe("Suggested next steps or follow-up actions")
        }),
        outputSchema: z18.z.object({
          completionId: z18.z.string(),
          status: z18.z.enum(["completed", "needs_review", "needs_testing"]),
          summary: z18.z.string(),
          confidence: z18.z.number().min(0).max(100)
        }),
        execute: async (inputData) => {
          return await _AgentBuilderDefaults.signalCompletion(inputData);
        }
      }),
      manageProject: tools.createTool({
        id: "manage-project",
        description: "Handles project management including creating project structures, managing dependencies, and package operations.",
        inputSchema: z18.z.object({
          action: z18.z.enum(["create", "install", "upgrade"]).describe("The action to perform"),
          features: z18.z.array(z18.z.string()).optional().describe('Mastra features to include (e.g., ["agents", "memory", "workflows"])'),
          packages: z18.z.array(
            z18.z.object({
              name: z18.z.string(),
              version: z18.z.string().optional()
            })
          ).optional().describe("Packages to install/upgrade")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          installed: z18.z.array(z18.z.string()).optional(),
          upgraded: z18.z.array(z18.z.string()).optional(),
          warnings: z18.z.array(z18.z.string()).optional(),
          message: z18.z.string().optional(),
          details: z18.z.string().optional(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          const { action, features, packages } = inputData;
          try {
            switch (action) {
              case "create":
                return await _AgentBuilderDefaults.createMastraProject({
                  projectName: projectPath,
                  features
                });
              case "install":
                if (!packages?.length) {
                  return {
                    success: false,
                    message: "Packages array is required for install action"
                  };
                }
                return await _AgentBuilderDefaults.installPackages({
                  packages,
                  projectPath
                });
              case "upgrade":
                if (!packages?.length) {
                  return {
                    success: false,
                    message: "Packages array is required for upgrade action"
                  };
                }
                return await _AgentBuilderDefaults.upgradePackages({
                  packages,
                  projectPath
                });
              default:
                return {
                  success: false,
                  message: `Unknown action: ${action}`
                };
            }
          } catch (error) {
            return {
              success: false,
              message: `Error executing ${action}: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
      }),
      manageServer: tools.createTool({
        id: "manage-server",
        description: "Manages the Mastra server - start, stop, restart, and check status, use the terminal tool to make curl requests to the server. There is an openapi spec for the server at http://localhost:{port}/openapi.json",
        inputSchema: z18.z.object({
          action: z18.z.enum(["start", "stop", "restart", "status"]).describe("Server management action"),
          port: z18.z.number().optional().default(4200).describe("Port to run the server on")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          status: z18.z.enum(["running", "stopped", "starting", "stopping", "unknown"]),
          pid: z18.z.number().optional(),
          port: z18.z.number().optional(),
          url: z18.z.string().optional(),
          message: z18.z.string().optional(),
          stdout: z18.z.array(z18.z.string()).optional().describe("Server output lines captured during startup"),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (inputData) => {
          const { action, port } = inputData;
          try {
            switch (action) {
              case "start":
                return await _AgentBuilderDefaults.startMastraServer({
                  port,
                  projectPath
                });
              case "stop":
                return await _AgentBuilderDefaults.stopMastraServer({
                  port,
                  projectPath
                });
              case "restart":
                const stopResult = await _AgentBuilderDefaults.stopMastraServer({
                  port,
                  projectPath
                });
                if (!stopResult.success) {
                  return {
                    success: false,
                    status: "unknown",
                    message: `Failed to restart: could not stop server on port ${port}`,
                    errorMessage: stopResult.errorMessage || "Unknown stop error"
                  };
                }
                await new Promise((resolve5) => setTimeout(resolve5, 500));
                const startResult = await _AgentBuilderDefaults.startMastraServer({
                  port,
                  projectPath
                });
                if (!startResult.success) {
                  return {
                    success: false,
                    status: "stopped",
                    message: `Failed to restart: server stopped successfully but failed to start on port ${port}`,
                    errorMessage: startResult.errorMessage || "Unknown start error"
                  };
                }
                return {
                  ...startResult,
                  message: `Mastra server restarted successfully on port ${port}`
                };
              case "status":
                return await _AgentBuilderDefaults.checkMastraServerStatus({
                  port,
                  projectPath
                });
              default:
                return {
                  success: false,
                  status: "unknown",
                  message: `Unknown action: ${action}`
                };
            }
          } catch (error) {
            return {
              success: false,
              status: "unknown",
              message: `Error managing server: ${error instanceof Error ? error.message : String(error)}`
            };
          }
        }
      }),
      httpRequest: tools.createTool({
        id: "http-request",
        description: "Makes HTTP requests to the Mastra server or external APIs for testing and integration",
        inputSchema: z18.z.object({
          method: z18.z.enum(["GET", "POST", "PUT", "DELETE", "PATCH"]).describe("HTTP method"),
          url: z18.z.string().describe("Full URL or path (if baseUrl provided)"),
          baseUrl: z18.z.string().optional().describe("Base URL for the server (e.g., http://localhost:4200)"),
          headers: z18.z.record(z18.z.string()).optional().describe("HTTP headers"),
          body: z18.z.any().optional().describe("Request body (will be JSON stringified if object)"),
          timeout: z18.z.number().optional().default(3e4).describe("Request timeout in milliseconds")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          status: z18.z.number().optional(),
          statusText: z18.z.string().optional(),
          headers: z18.z.record(z18.z.string()).optional(),
          data: z18.z.any().optional(),
          errorMessage: z18.z.string().optional(),
          url: z18.z.string(),
          method: z18.z.string()
        }),
        execute: async (inputData) => {
          const { method, url, baseUrl, headers, body, timeout } = inputData;
          try {
            return await _AgentBuilderDefaults.makeHttpRequest({
              method,
              url,
              baseUrl,
              headers,
              body,
              timeout
            });
          } catch (error) {
            return {
              success: false,
              url: baseUrl ? `${baseUrl}${url}` : url,
              method,
              errorMessage: error instanceof Error ? error.message : String(error)
            };
          }
        }
      })
    };
  };
  /**
   * Filter tools for template builder mode (excludes web search and other advanced tools)
   */
  static filterToolsForTemplateBuilder(tools) {
    const templateBuilderTools = [
      "readFile",
      "writeFile",
      "listDirectory",
      "executeCommand",
      "taskManager",
      "multiEdit",
      "replaceLines",
      "showFileLines",
      "smartSearch",
      "validateCode"
    ];
    const filtered = {};
    for (const toolName of templateBuilderTools) {
      if (tools[toolName]) {
        filtered[toolName] = tools[toolName];
      }
    }
    return filtered;
  }
  /**
   * Filter tools for code editor mode (includes all tools)
   */
  static filterToolsForCodeEditor(tools) {
    return tools;
  }
  /**
   * Get tools for a specific mode
   */
  static async listToolsForMode(projectPath, mode = "code-editor") {
    const allTools = await _AgentBuilderDefaults.DEFAULT_TOOLS(projectPath);
    if (mode === "template") {
      return _AgentBuilderDefaults.filterToolsForTemplateBuilder(allTools);
    } else {
      return _AgentBuilderDefaults.filterToolsForCodeEditor(allTools);
    }
  }
  /**
   * Create a new Mastra project using create-mastra CLI
   */
  static async createMastraProject({ features, projectName }) {
    try {
      const args = ["pnpx", "create-mastra@latest", projectName?.replace(/[;&|`$(){}\[\]]/g, "") ?? "", "-l", "openai"];
      if (features && features.length > 0) {
        args.push("--components", features.join(","));
      }
      args.push("--example");
      const { stdout, stderr } = await spawnWithOutput(args[0], args.slice(1), {});
      return {
        success: true,
        projectPath: `./${projectName}`,
        message: `Successfully created Mastra project: ${projectName}.`,
        details: stdout,
        errorMessage: stderr
      };
    } catch (error) {
      console.error(error);
      return {
        success: false,
        message: `Failed to create project: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Install packages using the detected package manager
   */
  static async installPackages({
    packages,
    projectPath
  }) {
    try {
      console.info("Installing packages:", JSON.stringify(packages, null, 2));
      const packageStrings = packages.map((p) => `${p.name}`);
      await spawnSWPM(projectPath || "", "add", packageStrings);
      return {
        success: true,
        installed: packageStrings,
        message: `Successfully installed ${packages.length} package(s).`,
        details: ""
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to install packages: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Upgrade packages using the detected package manager
   */
  static async upgradePackages({
    packages,
    projectPath
  }) {
    try {
      console.info("Upgrading specific packages:", JSON.stringify(packages, null, 2));
      let packageNames = [];
      if (packages && packages.length > 0) {
        packageNames = packages.map((p) => `${p.name}`);
      }
      await spawnSWPM(projectPath || "", "upgrade", packageNames);
      return {
        success: true,
        upgraded: packages?.map((p) => p.name) || ["all packages"],
        message: `Packages upgraded successfully.`,
        details: ""
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to upgrade packages: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Start the Mastra server
   */
  static async startMastraServer({
    port = 4200,
    projectPath,
    env = {}
  }) {
    try {
      const serverEnv = { ...process.env, ...env, PORT: port.toString() };
      const execOptions = {
        cwd: projectPath || process.cwd(),
        env: serverEnv
      };
      const serverProcess = child_process.spawn("pnpm", ["run", "dev"], {
        ...execOptions,
        detached: true,
        stdio: "pipe"
      });
      const stdoutLines = [];
      const serverStarted = new Promise((resolve5, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(`Server startup timeout after 30 seconds. Output: ${stdoutLines.join("\n")}`));
        }, 3e4);
        serverProcess.stdout?.on("data", (data) => {
          const output = data.toString();
          const lines = output.split("\n").filter((line) => line.trim());
          stdoutLines.push(...lines);
          if (output.includes("Mastra API running on ")) {
            clearTimeout(timeout);
            resolve5({
              success: true,
              status: "running",
              pid: serverProcess.pid,
              port,
              url: `http://localhost:${port}`,
              message: `Mastra server started successfully on port ${port}`,
              stdout: stdoutLines
            });
          }
        });
        serverProcess.stderr?.on("data", (data) => {
          const errorOutput = data.toString();
          stdoutLines.push(`[STDERR] ${errorOutput}`);
          clearTimeout(timeout);
          reject(new Error(`Server startup failed with error: ${errorOutput}`));
        });
        serverProcess.on("error", (error) => {
          clearTimeout(timeout);
          reject(error);
        });
        serverProcess.on("exit", (code, signal) => {
          clearTimeout(timeout);
          if (code !== 0 && code !== null) {
            reject(
              new Error(
                `Server process exited with code ${code}${signal ? ` (signal: ${signal})` : ""}. Output: ${stdoutLines.join("\n")}`
              )
            );
          }
        });
      });
      return await serverStarted;
    } catch (error) {
      return {
        success: false,
        status: "stopped",
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Stop the Mastra server
   */
  static async stopMastraServer({ port = 4200, projectPath: _projectPath }) {
    if (typeof port !== "number" || !Number.isInteger(port) || port < 1 || port > 65535) {
      return {
        success: false,
        status: "error",
        errorMessage: `Invalid port value: ${String(port)}`
      };
    }
    try {
      const { stdout } = await execFile("lsof", ["-ti", String(port)]);
      const effectiveStdout = stdout.trim() ? stdout : "No process found";
      if (!effectiveStdout || effectiveStdout === "No process found") {
        return {
          success: true,
          status: "stopped",
          message: `No Mastra server found running on port ${port}`
        };
      }
      const pids = stdout.trim().split("\n").filter((pid) => pid.trim());
      const killedPids = [];
      const failedPids = [];
      for (const pidStr of pids) {
        const pid = parseInt(pidStr.trim());
        if (isNaN(pid)) continue;
        try {
          process.kill(pid, "SIGTERM");
          killedPids.push(pid);
        } catch (e2) {
          failedPids.push(pid);
          console.warn(`Failed to kill process ${pid}:`, e2);
        }
      }
      if (killedPids.length === 0) {
        return {
          success: false,
          status: "unknown",
          message: `Failed to stop any processes on port ${port}`,
          errorMessage: `Could not kill PIDs: ${failedPids.join(", ")}`
        };
      }
      if (failedPids.length > 0) {
        console.warn(
          `Killed ${killedPids.length} processes but failed to kill ${failedPids.length} processes: ${failedPids.join(", ")}`
        );
      }
      await new Promise((resolve5) => setTimeout(resolve5, 2e3));
      try {
        const { stdout: checkStdoutRaw } = await execFile("lsof", ["-ti", String(port)]);
        const checkStdout = checkStdoutRaw.trim() ? checkStdoutRaw : "No process found";
        if (checkStdout && checkStdout !== "No process found") {
          const remainingPids = checkStdout.trim().split("\n").filter((pid) => pid.trim());
          for (const pidStr of remainingPids) {
            const pid = parseInt(pidStr.trim());
            if (!isNaN(pid)) {
              try {
                process.kill(pid, "SIGKILL");
              } catch {
              }
            }
          }
          await new Promise((resolve5) => setTimeout(resolve5, 1e3));
          const { stdout: finalCheckRaw } = await execFile("lsof", ["-ti", String(port)]);
          const finalCheck = finalCheckRaw.trim() ? finalCheckRaw : "No process found";
          if (finalCheck && finalCheck !== "No process found") {
            return {
              success: false,
              status: "unknown",
              message: `Server processes still running on port ${port} after stop attempts`,
              errorMessage: `Remaining PIDs: ${finalCheck.trim()}`
            };
          }
        }
      } catch (error) {
        console.warn("Failed to verify server stop:", error);
      }
      return {
        success: true,
        status: "stopped",
        message: `Mastra server stopped successfully (port ${port}). Killed PIDs: ${killedPids.join(", ")}`
      };
    } catch (error) {
      return {
        success: false,
        status: "unknown",
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Check Mastra server status
   */
  static async checkMastraServerStatus({
    port = 4200,
    projectPath: _projectPath
  }) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5e3);
      const response = await fetch(`http://localhost:${port}/health`, {
        method: "GET",
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (response.ok) {
        return {
          success: true,
          status: "running",
          port,
          url: `http://localhost:${port}`,
          message: "Mastra server is running and healthy"
        };
      } else {
        return {
          success: false,
          status: "unknown",
          port,
          message: `Server responding but not healthy (status: ${response.status})`
        };
      }
    } catch {
      try {
        const { stdout } = await execFile("lsof", ["-ti", String(port)]);
        const effectiveStdout = stdout.trim() ? stdout : "No process found";
        const hasProcess = effectiveStdout && effectiveStdout !== "No process found";
        return {
          success: Boolean(hasProcess),
          status: hasProcess ? "starting" : "stopped",
          port,
          message: hasProcess ? "Server process exists but not responding to health checks" : "No server process found on specified port"
        };
      } catch {
        return {
          success: false,
          status: "stopped",
          port,
          message: "Server is not running"
        };
      }
    }
  }
  // Cache for TypeScript program (lazily loaded)
  static tsProgram = null;
  static programProjectPath = null;
  /**
   * Validate code using hybrid approach: syntax -> types -> lint
   *
   * BEST PRACTICES FOR CODING AGENTS:
   *
   *  RECOMMENDED (Fast & Accurate):
   * validateCode({
   *   validationType: ['types', 'lint'],
   *   files: ['src/workflows/my-workflow.ts', 'src/components/Button.tsx']
   * })
   *
   * Performance: ~150ms
   * - Syntax check (1ms) - catches 80% of issues instantly
   * - Semantic validation (100ms) - full type checking with dependencies
   * - ESLint (50ms) - style and best practices
   * - Only shows errors from YOUR files
   *
   *  AVOID (Slow & Noisy):
   * validateCode({ validationType: ['types', 'lint'] }) // no files specified
   *
   * Performance: ~2000ms+
   * - Full project CLI validation
   * - Shows errors from all project files (confusing)
   * - Much slower for coding agents
   *
   * @param projectPath - Project root directory (defaults to cwd)
   * @param validationType - ['types', 'lint'] recommended for most use cases
   * @param files - ALWAYS provide this for best performance
   */
  static async validateCode({
    projectPath,
    validationType,
    files
  }) {
    const errors = [];
    const validationsPassed = [];
    const validationsFailed = [];
    const targetProjectPath = projectPath || process.cwd();
    if (!files || files.length === 0) {
      return this.validateCodeCLI({ projectPath, validationType });
    }
    for (const filePath of files) {
      const absolutePath = path.isAbsolute(filePath) ? filePath : path.resolve(targetProjectPath, filePath);
      try {
        const fileContent = await promises.readFile(absolutePath, "utf-8");
        const fileResults = await this.validateSingleFileHybrid(
          absolutePath,
          fileContent,
          targetProjectPath,
          validationType
        );
        errors.push(...fileResults.errors);
        for (const type of validationType) {
          const hasErrors = fileResults.errors.some((e2) => e2.type === type && e2.severity === "error");
          if (hasErrors) {
            if (!validationsFailed.includes(type)) validationsFailed.push(type);
          } else {
            if (!validationsPassed.includes(type)) validationsPassed.push(type);
          }
        }
      } catch (error) {
        errors.push({
          type: "typescript",
          severity: "error",
          message: `Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`,
          file: filePath
        });
        validationsFailed.push("types");
      }
    }
    const totalErrors = errors.filter((e2) => e2.severity === "error").length;
    const totalWarnings = errors.filter((e2) => e2.severity === "warning").length;
    const isValid = totalErrors === 0;
    return {
      valid: isValid,
      errors,
      summary: {
        totalErrors,
        totalWarnings,
        validationsPassed,
        validationsFailed
      }
    };
  }
  /**
   * CLI-based validation for when no specific files are provided
   */
  static async validateCodeCLI({
    projectPath,
    validationType
  }) {
    const errors = [];
    const validationsPassed = [];
    const validationsFailed = [];
    const execOptions = { cwd: projectPath };
    if (validationType.includes("types")) {
      try {
        const args = ["tsc", "--noEmit"];
        await execFile("npx", args, execOptions);
        validationsPassed.push("types");
      } catch (error) {
        let tsOutput = "";
        if (error.stdout) {
          tsOutput = error.stdout;
        } else if (error.stderr) {
          tsOutput = error.stderr;
        } else if (error.message) {
          tsOutput = error.message;
        }
        errors.push({
          type: "typescript",
          severity: "error",
          message: tsOutput.trim() || `TypeScript validation failed: ${error.message || String(error)}`
        });
        validationsFailed.push("types");
      }
    }
    if (validationType.includes("lint")) {
      try {
        const eslintArgs = ["eslint", "--format", "json"];
        const { stdout } = await execFile("npx", eslintArgs, execOptions);
        if (stdout) {
          const eslintResults = JSON.parse(stdout);
          const eslintErrors = _AgentBuilderDefaults.parseESLintErrors(eslintResults);
          errors.push(...eslintErrors);
          if (eslintErrors.some((e2) => e2.severity === "error")) {
            validationsFailed.push("lint");
          } else {
            validationsPassed.push("lint");
          }
        } else {
          validationsPassed.push("lint");
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes('"filePath"') || errorMessage.includes("messages")) {
          try {
            const eslintResults = JSON.parse(errorMessage);
            const eslintErrors = _AgentBuilderDefaults.parseESLintErrors(eslintResults);
            errors.push(...eslintErrors);
            validationsFailed.push("lint");
          } catch {
            errors.push({
              type: "eslint",
              severity: "error",
              message: `ESLint validation failed: ${errorMessage}`
            });
            validationsFailed.push("lint");
          }
        } else {
          validationsPassed.push("lint");
        }
      }
    }
    const totalErrors = errors.filter((e2) => e2.severity === "error").length;
    const totalWarnings = errors.filter((e2) => e2.severity === "warning").length;
    const isValid = totalErrors === 0;
    return {
      valid: isValid,
      errors,
      summary: {
        totalErrors,
        totalWarnings,
        validationsPassed,
        validationsFailed
      }
    };
  }
  /**
   * Hybrid validation for a single file
   */
  static async validateSingleFileHybrid(filePath, fileContent, projectPath, validationType) {
    const errors = [];
    if (validationType.includes("types")) {
      const syntaxErrors = await this.validateSyntaxOnly(fileContent, filePath);
      errors.push(...syntaxErrors);
      if (syntaxErrors.length > 0) {
        return { errors };
      }
      const typeErrors = await this.validateTypesSemantic(filePath, projectPath);
      errors.push(...typeErrors);
    }
    if (validationType.includes("lint") && !errors.some((e2) => e2.severity === "error")) {
      const lintErrors = await this.validateESLintSingle(filePath, projectPath);
      errors.push(...lintErrors);
    }
    return { errors };
  }
  /**
   * Fast syntax-only validation using TypeScript parser
   */
  static async validateSyntaxOnly(fileContent, fileName) {
    const errors = [];
    try {
      const ts = await import('typescript');
      const sourceFile = ts.createSourceFile(fileName, fileContent, ts.ScriptTarget.Latest, true);
      const options = {
        allowJs: true,
        checkJs: false,
        noEmit: true
      };
      const host = {
        getSourceFile: (name16) => name16 === fileName ? sourceFile : void 0,
        writeFile: () => {
        },
        getCurrentDirectory: () => "",
        getDirectories: () => [],
        fileExists: (name16) => name16 === fileName,
        readFile: (name16) => name16 === fileName ? fileContent : void 0,
        getCanonicalFileName: (name16) => name16,
        useCaseSensitiveFileNames: () => true,
        getNewLine: () => "\n",
        getDefaultLibFileName: () => "lib.d.ts"
      };
      const program = ts.createProgram([fileName], options, host);
      const diagnostics = program.getSyntacticDiagnostics(sourceFile);
      for (const diagnostic of diagnostics) {
        if (diagnostic.start !== void 0) {
          const position = sourceFile.getLineAndCharacterOfPosition(diagnostic.start);
          errors.push({
            type: "typescript",
            severity: "error",
            message: ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            file: fileName,
            line: position.line + 1,
            column: position.character + 1
          });
        }
      }
    } catch (error) {
      console.warn("TypeScript not available for syntax validation:", error);
      const lines = fileContent.split("\n");
      const commonErrors = [
        { pattern: /\bimport\s+.*\s+from\s+['""][^'"]*$/, message: "Unterminated import statement" },
        { pattern: /\{[^}]*$/, message: "Unclosed brace" },
        { pattern: /\([^)]*$/, message: "Unclosed parenthesis" },
        { pattern: /\[[^\]]*$/, message: "Unclosed bracket" }
      ];
      lines.forEach((line, index) => {
        commonErrors.forEach(({ pattern, message }) => {
          if (pattern.test(line)) {
            errors.push({
              type: "typescript",
              severity: "error",
              message,
              file: fileName,
              line: index + 1
            });
          }
        });
      });
    }
    return errors;
  }
  /**
   * TypeScript semantic validation using incremental program
   */
  static async validateTypesSemantic(filePath, projectPath) {
    const errors = [];
    try {
      const program = await this.getOrCreateTSProgram(projectPath);
      if (!program) {
        return errors;
      }
      const sourceFile = program.getSourceFile(filePath);
      if (!sourceFile) {
        return errors;
      }
      const diagnostics = [
        ...program.getSemanticDiagnostics(sourceFile),
        ...program.getSyntacticDiagnostics(sourceFile)
      ];
      const ts = await import('typescript');
      for (const diagnostic of diagnostics) {
        if (diagnostic.start !== void 0) {
          const position = sourceFile.getLineAndCharacterOfPosition(diagnostic.start);
          errors.push({
            type: "typescript",
            severity: diagnostic.category === ts.DiagnosticCategory.Warning ? "warning" : "error",
            message: ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            file: filePath,
            line: position.line + 1,
            column: position.character + 1
          });
        }
      }
    } catch (error) {
      console.warn(`TypeScript semantic validation failed for ${filePath}:`, error);
    }
    return errors;
  }
  /**
   * ESLint validation for a single file
   */
  static async validateESLintSingle(filePath, projectPath) {
    const errors = [];
    try {
      const { stdout } = await execFile("npx", ["eslint", filePath, "--format", "json"], { cwd: projectPath });
      if (stdout) {
        const eslintResults = JSON.parse(stdout);
        const eslintErrors = this.parseESLintErrors(eslintResults);
        errors.push(...eslintErrors);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('"filePath"') || errorMessage.includes("messages")) {
        try {
          const eslintResults = JSON.parse(errorMessage);
          const eslintErrors = this.parseESLintErrors(eslintResults);
          errors.push(...eslintErrors);
        } catch {
        }
      }
    }
    return errors;
  }
  /**
   * Get or create TypeScript program
   */
  static async getOrCreateTSProgram(projectPath) {
    if (this.tsProgram && this.programProjectPath === projectPath) {
      return this.tsProgram;
    }
    try {
      const ts = await import('typescript');
      const configPath = ts.findConfigFile(projectPath, ts.sys.fileExists, "tsconfig.json");
      if (!configPath) {
        return null;
      }
      const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
      if (configFile.error) {
        return null;
      }
      const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, projectPath);
      if (parsedConfig.errors.length > 0) {
        return null;
      }
      this.tsProgram = ts.createProgram({
        rootNames: parsedConfig.fileNames,
        options: parsedConfig.options
      });
      this.programProjectPath = projectPath;
      return this.tsProgram;
    } catch (error) {
      console.warn("Failed to create TypeScript program:", error);
      return null;
    }
  }
  // Note: Old filterTypeScriptErrors method removed in favor of hybrid validation approach
  /**
   * Parse ESLint errors from JSON output
   */
  static parseESLintErrors(eslintResults) {
    const errors = [];
    for (const result of eslintResults) {
      for (const message of result.messages || []) {
        if (message.message) {
          errors.push({
            type: "eslint",
            severity: message.severity === 1 ? "warning" : "error",
            message: message.message,
            file: result.filePath || void 0,
            line: message.line || void 0,
            column: message.column || void 0,
            code: message.ruleId || void 0
          });
        }
      }
    }
    return errors;
  }
  /**
   * Make HTTP request to server or external API
   */
  static async makeHttpRequest({
    method,
    url,
    baseUrl,
    headers = {},
    body,
    timeout = 3e4
  }) {
    try {
      const fullUrl = baseUrl ? `${baseUrl}${url}` : url;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const requestOptions = {
        method,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: controller.signal
      };
      if (body && (method === "POST" || method === "PUT" || method === "PATCH")) {
        requestOptions.body = typeof body === "string" ? body : JSON.stringify(body);
      }
      const response = await fetch(fullUrl, requestOptions);
      clearTimeout(timeoutId);
      let data;
      const contentType = response.headers.get("content-type");
      if (contentType?.includes("application/json")) {
        data = await response.json();
      } else {
        data = await response.text();
      }
      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      return {
        success: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders,
        data,
        url: fullUrl,
        method
      };
    } catch (error) {
      return {
        success: false,
        url: baseUrl ? `${baseUrl}${url}` : url,
        method,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Enhanced task management system for complex coding tasks
   */
  static async manageTaskList(context) {
    if (!_AgentBuilderDefaults.taskStorage) {
      _AgentBuilderDefaults.taskStorage = /* @__PURE__ */ new Map();
    }
    const sessions = Array.from(_AgentBuilderDefaults.taskStorage.keys());
    if (sessions.length > 10) {
      const sessionsToRemove = sessions.slice(0, sessions.length - 10);
      sessionsToRemove.forEach((session) => _AgentBuilderDefaults.taskStorage.delete(session));
    }
    const sessionId = "current";
    const existingTasks = _AgentBuilderDefaults.taskStorage.get(sessionId) || [];
    try {
      switch (context.action) {
        case "create":
          if (!context.tasks?.length) {
            return {
              success: false,
              tasks: existingTasks,
              message: "No tasks provided for creation"
            };
          }
          const newTasks = context.tasks.map((task) => ({
            ...task,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }));
          const allTasks = [...existingTasks, ...newTasks];
          _AgentBuilderDefaults.taskStorage.set(sessionId, allTasks);
          return {
            success: true,
            tasks: allTasks,
            message: `Created ${newTasks.length} new task(s)`
          };
        case "update":
          if (!context.tasks?.length) {
            return {
              success: false,
              tasks: existingTasks,
              message: "No tasks provided for update"
            };
          }
          const updatedTasks = existingTasks.map((existing) => {
            const update = context.tasks.find((t2) => t2.id === existing.id);
            return update ? { ...existing, ...update, updatedAt: (/* @__PURE__ */ new Date()).toISOString() } : existing;
          });
          _AgentBuilderDefaults.taskStorage.set(sessionId, updatedTasks);
          return {
            success: true,
            tasks: updatedTasks,
            message: "Tasks updated successfully"
          };
        case "complete":
          if (!context.taskId) {
            return {
              success: false,
              tasks: existingTasks,
              message: "Task ID required for completion"
            };
          }
          const completedTasks = existingTasks.map(
            (task) => task.id === context.taskId ? { ...task, status: "completed", updatedAt: (/* @__PURE__ */ new Date()).toISOString() } : task
          );
          _AgentBuilderDefaults.taskStorage.set(sessionId, completedTasks);
          return {
            success: true,
            tasks: completedTasks,
            message: `Task ${context.taskId} marked as completed`
          };
        case "remove":
          if (!context.taskId) {
            return {
              success: false,
              tasks: existingTasks,
              message: "Task ID required for removal"
            };
          }
          const filteredTasks = existingTasks.filter((task) => task.id !== context.taskId);
          _AgentBuilderDefaults.taskStorage.set(sessionId, filteredTasks);
          return {
            success: true,
            tasks: filteredTasks,
            message: `Task ${context.taskId} removed`
          };
        case "list":
        default:
          return {
            success: true,
            tasks: existingTasks,
            message: `Found ${existingTasks.length} task(s)`
          };
      }
    } catch (error) {
      return {
        success: false,
        tasks: existingTasks,
        message: `Task management error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Perform multiple edits across files atomically
   */
  static async performMultiEdit(context) {
    const { operations, createBackup = false, projectPath = process.cwd() } = context;
    const results = [];
    try {
      for (const operation of operations) {
        const filePath = path.isAbsolute(operation.filePath) ? operation.filePath : path.join(projectPath, operation.filePath);
        let editsApplied = 0;
        const errors = [];
        let backup;
        try {
          if (createBackup) {
            const backupPath = `${filePath}.backup.${Date.now()}`;
            const originalContent = await promises.readFile(filePath, "utf-8");
            await promises.writeFile(backupPath, originalContent, "utf-8");
            backup = backupPath;
          }
          let content = await promises.readFile(filePath, "utf-8");
          for (const edit of operation.edits) {
            const { oldString, newString, replaceAll = false } = edit;
            if (replaceAll) {
              const regex = new RegExp(oldString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
              const matches = content.match(regex);
              if (matches) {
                content = content.replace(regex, newString);
                editsApplied += matches.length;
              }
            } else {
              if (content.includes(oldString)) {
                content = content.replace(oldString, newString);
                editsApplied++;
              } else {
                errors.push(`String not found: "${oldString.substring(0, 50)}${oldString.length > 50 ? "..." : ""}"`);
              }
            }
          }
          await promises.writeFile(filePath, content, "utf-8");
        } catch (error) {
          errors.push(`File operation error: ${error instanceof Error ? error.message : String(error)}`);
        }
        results.push({
          filePath: operation.filePath,
          editsApplied,
          errors,
          backup
        });
      }
      const totalEdits = results.reduce((sum, r) => sum + r.editsApplied, 0);
      const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);
      return {
        success: totalErrors === 0,
        results,
        message: `Applied ${totalEdits} edits across ${operations.length} files${totalErrors > 0 ? ` with ${totalErrors} errors` : ""}`
      };
    } catch (error) {
      return {
        success: false,
        results,
        message: `Multi-edit operation failed: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Replace specific line ranges in a file with new content
   */
  static async replaceLines(context) {
    const { filePath, startLine, endLine, newContent, createBackup = false, projectPath = process.cwd() } = context;
    try {
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(projectPath, filePath);
      const content = await promises.readFile(fullPath, "utf-8");
      const lines = content.split("\n");
      if (startLine < 1 || endLine < 1) {
        return {
          success: false,
          message: `Line numbers must be 1 or greater. Got startLine: ${startLine}, endLine: ${endLine}`,
          errorMessage: "Invalid line range"
        };
      }
      if (startLine > lines.length || endLine > lines.length) {
        return {
          success: false,
          message: `Line range ${startLine}-${endLine} is out of bounds. File has ${lines.length} lines. Remember: lines are 1-indexed, so valid range is 1-${lines.length}.`,
          errorMessage: "Invalid line range"
        };
      }
      if (startLine > endLine) {
        return {
          success: false,
          message: `Start line (${startLine}) cannot be greater than end line (${endLine}).`,
          errorMessage: "Invalid line range"
        };
      }
      let backup;
      if (createBackup) {
        const backupPath = `${fullPath}.backup.${Date.now()}`;
        await promises.writeFile(backupPath, content, "utf-8");
        backup = backupPath;
      }
      const beforeLines = lines.slice(0, startLine - 1);
      const afterLines = lines.slice(endLine);
      const newLines = newContent ? newContent.split("\n") : [];
      const updatedLines = [...beforeLines, ...newLines, ...afterLines];
      const updatedContent = updatedLines.join("\n");
      await promises.writeFile(fullPath, updatedContent, "utf-8");
      const linesReplaced = endLine - startLine + 1;
      const newLineCount = newLines.length;
      return {
        success: true,
        message: `Successfully replaced ${linesReplaced} lines (${startLine}-${endLine}) with ${newLineCount} new lines in ${filePath}`,
        linesReplaced,
        backup
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to replace lines: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Show file lines with line numbers for debugging
   */
  static async showFileLines(context) {
    const { filePath, startLine, endLine, context: contextLines = 2, projectPath = process.cwd() } = context;
    try {
      const fullPath = path.isAbsolute(filePath) ? filePath : path.join(projectPath, filePath);
      const content = await promises.readFile(fullPath, "utf-8");
      const lines = content.split("\n");
      let targetStart = startLine;
      let targetEnd = endLine;
      if (!targetStart) {
        targetStart = 1;
        targetEnd = lines.length;
      } else if (!targetEnd) {
        targetEnd = targetStart;
      }
      const displayStart = Math.max(1, targetStart - contextLines);
      const displayEnd = Math.min(lines.length, targetEnd + contextLines);
      const result = [];
      for (let i = displayStart; i <= displayEnd; i++) {
        const lineIndex = i - 1;
        const isTarget = i >= targetStart && i <= targetEnd;
        result.push({
          lineNumber: i,
          content: lineIndex < lines.length ? lines[lineIndex] ?? "" : "",
          isTarget
        });
      }
      return {
        success: true,
        lines: result,
        totalLines: lines.length,
        message: `Showing lines ${displayStart}-${displayEnd} of ${lines.length} total lines in ${filePath}`
      };
    } catch (error) {
      return {
        success: false,
        lines: [],
        totalLines: 0,
        message: `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Signal task completion
   */
  static async signalCompletion(context) {
    const completionId = `completion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    let confidence = 70;
    if (context.validation.testsRun) confidence += 15;
    if (context.validation.buildsSuccessfully) confidence += 15;
    if (context.validation.manualTestingRequired) confidence -= 10;
    let status;
    if (context.validation.testsRun && context.validation.buildsSuccessfully) {
      status = "completed";
    } else if (context.validation.manualTestingRequired) {
      status = "needs_testing";
    } else {
      status = "needs_review";
    }
    return {
      completionId,
      status,
      summary: context.summary,
      confidence: Math.min(100, Math.max(0, confidence))
    };
  }
  /**
   * Perform intelligent search with context
   */
  static async performSmartSearch(context, projectPath) {
    try {
      const { query, type = "text", scope = {}, context: searchContext = {} } = context;
      const { paths = ["."], fileTypes = [], excludePaths = [], maxResults = 50 } = scope;
      const { beforeLines = 2, afterLines = 2 } = searchContext;
      const rgArgs = [];
      if (beforeLines > 0) {
        rgArgs.push("-B", beforeLines.toString());
      }
      if (afterLines > 0) {
        rgArgs.push("-A", afterLines.toString());
      }
      rgArgs.push("-n");
      if (type === "regex") {
        rgArgs.push("-e");
      } else if (type === "fuzzy") {
        rgArgs.push("--fixed-strings");
      }
      if (fileTypes.length > 0) {
        fileTypes.forEach((ft) => {
          rgArgs.push("--type-add", `custom:*.${ft}`, "-t", "custom");
        });
      }
      excludePaths.forEach((path) => {
        rgArgs.push("--glob", `!${path}`);
      });
      rgArgs.push("-m", maxResults.toString());
      rgArgs.push(query);
      rgArgs.push(...paths);
      const { stdout } = await execFile("rg", rgArgs, {
        cwd: projectPath
      });
      const lines = stdout.split("\n").filter((line) => line.trim());
      const matches = [];
      let currentMatch = null;
      lines.forEach((line) => {
        if (line.includes(":") && !line.startsWith("-")) {
          const parts = line.split(":");
          if (parts.length >= 3) {
            if (currentMatch) {
              matches.push(currentMatch);
            }
            currentMatch = {
              file: parts[0] || "",
              line: parseInt(parts[1] || "0"),
              match: parts.slice(2).join(":"),
              context: { before: [], after: [] },
              relevance: type === "fuzzy" ? Math.random() * 100 : void 0
            };
          }
        } else if (line.startsWith("-") && currentMatch) {
          const contextLine = line.substring(1);
          if (currentMatch.context.before.length < beforeLines) {
            currentMatch.context.before.push(contextLine);
          } else {
            currentMatch.context.after.push(contextLine);
          }
        }
      });
      if (currentMatch) {
        matches.push(currentMatch);
      }
      const filesSearched = new Set(matches.map((m) => m.file)).size;
      return {
        success: true,
        matches: matches.slice(0, maxResults),
        summary: {
          totalMatches: matches.length,
          filesSearched,
          patterns: [query]
        }
      };
    } catch {
      return {
        success: false,
        matches: [],
        summary: {
          totalMatches: 0,
          filesSearched: 0,
          patterns: [context.query]
        }
      };
    }
  }
  // Static storage properties
  static taskStorage;
  static pendingQuestions;
  /**
   * Read file contents with optional line range
   */
  static async readFile(context) {
    try {
      const { filePath, startLine, endLine, encoding = "utf-8", projectPath } = context;
      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.resolve(projectPath || process.cwd(), filePath);
      const stats = await promises.stat(resolvedPath);
      const content = await promises.readFile(resolvedPath, { encoding });
      const lines = content.split("\n");
      let resultContent = content;
      let resultLines = lines;
      if (startLine !== void 0 || endLine !== void 0) {
        const start = Math.max(0, (startLine || 1) - 1);
        const end = endLine !== void 0 ? Math.min(lines.length, endLine) : lines.length;
        resultLines = lines.slice(start, end);
        resultContent = resultLines.join("\n");
      }
      return {
        success: true,
        content: resultContent,
        lines: resultLines,
        metadata: {
          size: stats.size,
          totalLines: lines.length,
          encoding,
          lastModified: stats.mtime.toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Write content to file with directory creation and backup options
   */
  static async writeFile(context) {
    try {
      const { filePath, content, createDirs = true, encoding = "utf-8", projectPath } = context;
      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.resolve(projectPath || process.cwd(), filePath);
      const dir = path.dirname(resolvedPath);
      if (createDirs) {
        await promises.mkdir(dir, { recursive: true });
      }
      await promises.writeFile(resolvedPath, content, { encoding });
      return {
        success: true,
        filePath: resolvedPath,
        bytesWritten: Buffer.byteLength(content, encoding),
        message: `Successfully wrote ${Buffer.byteLength(content, encoding)} bytes to ${filePath}`
      };
    } catch (error) {
      return {
        success: false,
        filePath: context.filePath,
        message: `Failed to write file: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * List directory contents with filtering and metadata
   */
  static async listDirectory(context) {
    try {
      const {
        path: path$1,
        recursive = false,
        includeHidden = false,
        pattern,
        maxDepth = 10,
        includeMetadata = true,
        projectPath
      } = context;
      const gitignorePath = path.join(projectPath || process.cwd(), ".gitignore");
      let gitignoreFilter;
      try {
        const gitignoreContent = await promises.readFile(gitignorePath, "utf-8");
        gitignoreFilter = (0, import_ignore.default)().add(gitignoreContent);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.error(`Error reading .gitignore file:`, err);
        }
      }
      const resolvedPath = path.isAbsolute(path$1) ? path$1 : path.resolve(projectPath || process.cwd(), path$1);
      const items = [];
      async function processDirectory(dirPath, currentDepth = 0) {
        const relativeToProject = path.relative(projectPath || process.cwd(), dirPath);
        if (gitignoreFilter?.ignores(relativeToProject)) return;
        if (currentDepth > maxDepth) return;
        const entries = await promises.readdir(dirPath);
        for (const entry of entries) {
          const entryPath = path.join(dirPath, entry);
          const relativeEntryPath = path.relative(projectPath || process.cwd(), entryPath);
          if (gitignoreFilter?.ignores(relativeEntryPath)) continue;
          if (!includeHidden && entry.startsWith(".")) continue;
          const fullPath = entryPath;
          const relativePath = path.relative(resolvedPath, fullPath);
          if (pattern) {
            const regexPattern = pattern.replace(/\*/g, ".*").replace(/\?/g, ".");
            if (!new RegExp(regexPattern).test(entry)) continue;
          }
          let stats;
          let type;
          try {
            stats = await promises.stat(fullPath);
            if (stats.isDirectory()) {
              type = "directory";
            } else if (stats.isSymbolicLink()) {
              type = "symlink";
            } else {
              type = "file";
            }
          } catch {
            continue;
          }
          const item = {
            name: entry,
            path: relativePath || entry,
            type
          };
          if (includeMetadata) {
            item.size = stats.size;
            item.lastModified = stats.mtime.toISOString();
            item.permissions = `0${(stats.mode & parseInt("777", 8)).toString(8)}`;
          }
          items.push(item);
          if (recursive && type === "directory") {
            await processDirectory(fullPath, currentDepth + 1);
          }
        }
      }
      await processDirectory(resolvedPath);
      return {
        success: true,
        items,
        totalItems: items.length,
        path: resolvedPath,
        message: `Listed ${items.length} items in ${resolvedPath}`
      };
    } catch (error) {
      return {
        success: false,
        items: [],
        totalItems: 0,
        path: context.path,
        message: `Failed to list directory: ${error instanceof Error ? error.message : String(error)}`,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Execute shell commands with proper error handling
   */
  static async executeCommand(context) {
    const startTime = Date.now();
    try {
      const { command, workingDirectory, timeout = 3e4, captureOutput = true, shell, env } = context;
      const execOptions = {
        timeout,
        env: { ...process.env, ...env }
      };
      if (workingDirectory) {
        execOptions.cwd = workingDirectory;
      }
      if (shell) {
        execOptions.shell = shell;
      }
      const { stdout, stderr } = await exec(command, execOptions);
      const executionTime = Date.now() - startTime;
      return {
        success: true,
        exitCode: 0,
        stdout: captureOutput ? String(stdout) : void 0,
        stderr: captureOutput ? String(stderr) : void 0,
        command,
        workingDirectory,
        executionTime
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return {
        success: false,
        exitCode: error.code || 1,
        stdout: String(error.stdout || ""),
        stderr: String(error.stderr || ""),
        command: context.command,
        workingDirectory: context.workingDirectory,
        executionTime,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Web search using a simple search approach
   */
  static async webSearch(context) {
    try {
      const {
        query,
        maxResults = 10
        // region = 'us',
        // language = 'en',
        // includeImages = false,
        // dateRange = 'all',
      } = context;
      const startTime = Date.now();
      const searchUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_redirect=1&skip_disambig=1`;
      const response = await fetch(searchUrl);
      const data = await response.json();
      const results = [];
      if (data.RelatedTopics && Array.isArray(data.RelatedTopics)) {
        for (const topic of data.RelatedTopics.slice(0, maxResults)) {
          if (topic.FirstURL && topic.Text) {
            const url = new URL(topic.FirstURL);
            results.push({
              title: topic.Text.split(" - ")[0] || topic.Text.substring(0, 60),
              url: topic.FirstURL,
              snippet: topic.Text,
              domain: url.hostname,
              relevanceScore: Math.random() * 100
              // Placeholder scoring
            });
          }
        }
      }
      if (data.Abstract && data.AbstractURL) {
        const url = new URL(data.AbstractURL);
        results.unshift({
          title: data.Heading || "Main Result",
          url: data.AbstractURL,
          snippet: data.Abstract,
          domain: url.hostname,
          relevanceScore: 100
        });
      }
      const searchTime = Date.now() - startTime;
      return {
        success: true,
        query,
        results: results.slice(0, maxResults),
        totalResults: results.length,
        searchTime,
        suggestions: data.RelatedTopics?.slice(maxResults, maxResults + 3)?.map((t2) => t2.Text?.split(" - ")[0] || t2.Text?.substring(0, 30)).filter(Boolean) || []
      };
    } catch (error) {
      return {
        success: false,
        query: context.query,
        results: [],
        totalResults: 0,
        searchTime: 0,
        errorMessage: error instanceof Error ? error.message : String(error)
      };
    }
  }
};
var ToolSummaryProcessor = class {
  id = "tool-summary-processor";
  name = "ToolSummaryProcessor";
  summaryAgent;
  summaryCache = /* @__PURE__ */ new Map();
  constructor({ summaryModel }) {
    this.summaryAgent = new agent.Agent({
      id: "tool-summary-agent",
      name: "Tool Summary Agent",
      description: "A summary agent that summarizes tool calls and results",
      instructions: "You are a summary agent that summarizes tool calls and results",
      model: summaryModel
    });
  }
  /**
   * Creates a cache key from tool call arguments
   */
  createCacheKey(toolCall) {
    if (!toolCall) return "unknown";
    const toolName = toolCall.toolName || "unknown";
    const args = toolCall.args || {};
    const sortedArgs = Object.keys(args).sort().reduce((result, key) => {
      result[key] = args[key];
      return result;
    }, {});
    return `${toolName}:${JSON.stringify(sortedArgs)}`;
  }
  /**
   * Clears the summary cache
   */
  clearCache() {
    this.summaryCache.clear();
  }
  /**
   * Gets cache statistics
   */
  getCacheStats() {
    return {
      size: this.summaryCache.size,
      keys: Array.from(this.summaryCache.keys())
    };
  }
  async processInput({
    messages,
    messageList: _messageList
  }) {
    const summaryTasks = [];
    for (const message of messages) {
      if (message.content.format === 2 && message.content.parts) {
        for (let partIndex = 0; partIndex < message.content.parts.length; partIndex++) {
          const part = message.content.parts[partIndex];
          if (part && part.type === "tool-invocation" && part.toolInvocation?.state === "result") {
            const cacheKey = this.createCacheKey(part.toolInvocation);
            const cachedSummary = this.summaryCache.get(cacheKey);
            if (cachedSummary) {
              message.content.parts[partIndex] = {
                type: "tool-invocation",
                toolInvocation: {
                  state: "result",
                  step: part.toolInvocation.step,
                  toolCallId: part.toolInvocation.toolCallId,
                  toolName: part.toolInvocation.toolName,
                  args: part.toolInvocation.args,
                  result: `Tool call summary: ${cachedSummary}`
                }
              };
            } else {
              const summaryPromise = this.summaryAgent.generate(
                `Summarize the following tool call: ${JSON.stringify(part.toolInvocation)}`
              );
              summaryTasks.push({
                message,
                partIndex,
                promise: summaryPromise,
                cacheKey
              });
            }
          }
        }
      }
    }
    if (summaryTasks.length > 0) {
      const summaryResults = await Promise.allSettled(summaryTasks.map((task) => task.promise));
      summaryTasks.forEach((task, index) => {
        const result = summaryResults[index];
        if (!result) return;
        if (result.status === "fulfilled") {
          const summaryResult = result.value;
          const summaryText = summaryResult.text;
          this.summaryCache.set(task.cacheKey, summaryText);
          if (task.message.content.format === 2 && task.message.content.parts) {
            const part = task.message.content.parts[task.partIndex];
            if (part && part.type === "tool-invocation" && part.toolInvocation?.state === "result") {
              task.message.content.parts[task.partIndex] = {
                type: "tool-invocation",
                toolInvocation: {
                  state: "result",
                  step: part.toolInvocation.step,
                  toolCallId: part.toolInvocation.toolCallId,
                  toolName: part.toolInvocation.toolName,
                  args: part.toolInvocation.args,
                  result: `Tool call summary: ${summaryText}`
                }
              };
            }
          }
        } else if (result.status === "rejected") {
          console.warn(`Failed to generate summary for tool call:`, result.reason);
        }
      });
    }
    return messages;
  }
};
var AgentBuilder = class extends agent.Agent {
  builderConfig;
  /**
   * Constructor for AgentBuilder
   */
  constructor(config) {
    const additionalInstructions = config.instructions ? `## Priority Instructions 

${config.instructions}` : "";
    const combinedInstructions = additionalInstructions + AgentBuilderDefaults.DEFAULT_INSTRUCTIONS(config.projectPath);
    const agentConfig = {
      id: "agent-builder",
      name: "agent-builder",
      description: "An AI agent specialized in generating Mastra agents, tools, and workflows from natural language requirements.",
      instructions: combinedInstructions,
      model: config.model,
      tools: async () => {
        return {
          ...await AgentBuilderDefaults.listToolsForMode(config.projectPath, config.mode),
          ...config.tools || {}
        };
      },
      memory: new Memory({
        options: AgentBuilderDefaults.DEFAULT_MEMORY_CONFIG
      }),
      inputProcessors: [
        // use the write to disk processor to debug the agent's context
        // new WriteToDiskProcessor({ prefix: 'before-filter' }),
        new ToolSummaryProcessor({ summaryModel: config.summaryModel || config.model })
        // new WriteToDiskProcessor({ prefix: 'after-filter' }),
      ]
    };
    super(agentConfig);
    this.builderConfig = config;
  }
  /**
   * Enhanced generate method with AgentBuilder-specific configuration
   * Overrides the base Agent generate method to provide additional project context
   */
  generateLegacy = async (messages, generateOptions = {}) => {
    const { maxSteps, ...baseOptions } = generateOptions;
    const originalInstructions = await this.getInstructions({ requestContext: generateOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      maxSteps: maxSteps || 100,
      // Higher default for code generation
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting generation with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.generateLegacy(messages, enhancedOptions);
  };
  /**
   * Enhanced stream method with AgentBuilder-specific configuration
   * Overrides the base Agent stream method to provide additional project context
   */
  streamLegacy = async (messages, streamOptions = {}) => {
    const { maxSteps, ...baseOptions } = streamOptions;
    const originalInstructions = await this.getInstructions({ requestContext: streamOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      maxSteps: maxSteps || 100,
      // Higher default for code generation
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.streamLegacy(messages, enhancedOptions);
  };
  async stream(messages, streamOptions) {
    const { ...baseOptions } = streamOptions || {};
    const originalInstructions = await this.getInstructions({ requestContext: streamOptions?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      maxSteps: baseOptions?.maxSteps || 100,
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.stream(messages, enhancedOptions);
  }
  async generate(messages, options) {
    const { ...baseOptions } = options || {};
    const originalInstructions = await this.getInstructions({ requestContext: options?.requestContext });
    const additionalInstructions = baseOptions.instructions;
    let enhancedInstructions = originalInstructions;
    if (additionalInstructions) {
      enhancedInstructions = `${originalInstructions}

${additionalInstructions}`;
    }
    const enhancedContext = [...baseOptions.context || []];
    const enhancedOptions = {
      ...baseOptions,
      temperature: 0.3,
      // Lower temperature for more consistent code generation
      maxSteps: baseOptions?.maxSteps || 100,
      instructions: enhancedInstructions,
      context: enhancedContext
    };
    this.logger.debug(`[AgentBuilder:${this.name}] Starting streaming with enhanced context`, {
      projectPath: this.builderConfig.projectPath
    });
    return super.generate(messages, enhancedOptions);
  }
};
var cloneTemplateStep = workflows.createStep({
  id: "clone-template",
  description: "Clone the template repository to a temporary directory at the specified ref",
  inputSchema: AgentBuilderInputSchema,
  outputSchema: CloneTemplateResultSchema,
  execute: async ({ inputData }) => {
    const { repo, ref = "main", slug, targetPath } = inputData;
    if (!repo) {
      throw new Error("Repository URL or path is required");
    }
    const inferredSlug = slug || repo.split("/").pop()?.replace(/\.git$/, "") || "template";
    const tempDir = await promises.mkdtemp(path.join(os.tmpdir(), "mastra-template-"));
    try {
      await gitClone(repo, tempDir);
      if (ref !== "main" && ref !== "master") {
        await gitCheckoutRef(tempDir, ref);
      }
      const commitSha = await gitRevParse(tempDir, "HEAD");
      return {
        templateDir: tempDir,
        commitSha: commitSha.trim(),
        slug: inferredSlug,
        success: true,
        targetPath
      };
    } catch (error) {
      try {
        await promises.rm(tempDir, { recursive: true, force: true });
      } catch {
      }
      return {
        templateDir: "",
        commitSha: "",
        slug: slug || "unknown",
        success: false,
        error: `Failed to clone template: ${error instanceof Error ? error.message : String(error)}`,
        targetPath
      };
    }
  }
});
var analyzePackageStep = workflows.createStep({
  id: "analyze-package",
  description: "Analyze the template package.json to extract dependency information",
  inputSchema: CloneTemplateResultSchema,
  outputSchema: PackageAnalysisSchema,
  execute: async ({ inputData }) => {
    console.info("Analyzing template package.json...");
    const { templateDir } = inputData;
    const packageJsonPath = path.join(templateDir, "package.json");
    try {
      const packageJsonContent = await promises.readFile(packageJsonPath, "utf-8");
      const packageJson = JSON.parse(packageJsonContent);
      console.info("Template package.json:", JSON.stringify(packageJson, null, 2));
      return {
        dependencies: packageJson.dependencies || {},
        devDependencies: packageJson.devDependencies || {},
        peerDependencies: packageJson.peerDependencies || {},
        scripts: packageJson.scripts || {},
        name: packageJson.name || "",
        version: packageJson.version || "",
        description: packageJson.description || "",
        success: true
      };
    } catch (error) {
      console.warn(`Failed to read template package.json: ${error instanceof Error ? error.message : String(error)}`);
      return {
        dependencies: {},
        devDependencies: {},
        peerDependencies: {},
        scripts: {},
        name: "",
        version: "",
        description: "",
        success: true
        // This is a graceful fallback, not a failure
      };
    }
  }
});
var discoverUnitsStep = workflows.createStep({
  id: "discover-units",
  description: "Discover template units by analyzing the templates directory structure",
  inputSchema: CloneTemplateResultSchema,
  outputSchema: DiscoveryResultSchema,
  execute: async ({ inputData, requestContext }) => {
    const { templateDir } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    const tools = await AgentBuilderDefaults.DEFAULT_TOOLS(templateDir);
    console.info("targetPath", targetPath);
    const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: chunkAQI6GLTN_cjs.openai("gpt-4.1") });
    try {
      const agent$1 = new agent.Agent({
        id: "mastra-project-discoverer",
        model,
        instructions: `You are an expert at analyzing Mastra projects.

Your task is to scan the provided directory and identify all available units (agents, workflows, tools, MCP servers, networks).

Mastra Project Structure Analysis:
- Each Mastra project has a structure like: ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.agent}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.workflow}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE["mcp-server"]}, ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.network}
- Analyze TypeScript files in each category directory to identify exported units

CRITICAL: YOU MUST USE YOUR TOOLS (readFile, listDirectory) TO DISCOVER THE UNITS IN THE TEMPLATE DIRECTORY.

IMPORTANT - Agent Discovery Rules:
1. **Multiple Agent Files**: Some templates have separate files for each agent (e.g., evaluationAgent.ts, researchAgent.ts)
2. **Single File Multiple Agents**: Some files may export multiple agents (look for multiple 'export const' or 'export default' statements)
3. **Agent Identification**: Look for exported variables that are instances of 'new Agent()' or similar patterns
4. **Naming Convention**: Agent names should be extracted from the export name (e.g., 'weatherAgent', 'evaluationAgent')

For each Mastra project directory you analyze:
1. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.agent} and identify ALL exported agents
2. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.workflow} and identify ALL exported workflows
3. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool} and identify ALL exported tools
4. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE["mcp-server"]} and identify ALL exported MCP servers
5. Scan all TypeScript files in ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.network} and identify ALL exported networks
6. Scan for any OTHER files in src/mastra that are NOT in the above default folders (e.g., lib/, utils/, types/, etc.) and identify them as 'other' files

IMPORTANT - Naming Consistency Rules:
- For ALL unit types (including 'other'), the 'name' field should be the filename WITHOUT extension
- For structured units (agents, workflows, tools, etc.), prefer the actual export name if clearly identifiable
- use the base filename without extension for the id (e.g., 'util.ts' \u2192 name: 'util')
- use the relative path from the template root for the file (e.g., 'src/mastra/lib/util.ts' \u2192 file: 'src/mastra/lib/util.ts')

Return the actual exported names of the units, as well as the file names.`,
        name: "Mastra Project Discoverer",
        tools: {
          readFile: tools.readFile,
          listDirectory: tools.listDirectory
        }
      });
      const resolvedModel = await agent$1.getModel();
      const isSupported = agent.isSupportedLanguageModel(resolvedModel);
      const prompt = `Analyze the Mastra project directory structure at "${templateDir}".

            List directory contents using listDirectory tool, and then analyze each file with readFile tool.
      IMPORTANT:
      - Look inside the actual file content to find export statements like 'export const agentName = new Agent(...)'
      - A single file may contain multiple exports
      - Return the actual exported variable names, as well as the file names
      - If a directory doesn't exist or has no files, return an empty array

      Return the analysis in the exact format specified in the output schema.`;
      const output = z18.z.object({
        agents: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional(),
        workflows: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional(),
        tools: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional(),
        mcp: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional(),
        networks: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional(),
        other: z18.z.array(z18.z.object({ name: z18.z.string(), file: z18.z.string() })).optional()
      });
      const result = isSupported ? await agent.tryGenerateWithJsonFallback(agent$1, prompt, {
        structuredOutput: {
          schema: output
        },
        maxSteps: 100
      }) : await agent$1.generateLegacy(prompt, {
        experimental_output: output,
        maxSteps: 100
      });
      const template = result.object ?? {};
      const units = [];
      template.agents?.forEach((agentId) => {
        units.push({ kind: "agent", id: agentId.name, file: agentId.file });
      });
      template.workflows?.forEach((workflowId) => {
        units.push({ kind: "workflow", id: workflowId.name, file: workflowId.file });
      });
      template.tools?.forEach((toolId) => {
        units.push({ kind: "tool", id: toolId.name, file: toolId.file });
      });
      template.mcp?.forEach((mcpId) => {
        units.push({ kind: "mcp-server", id: mcpId.name, file: mcpId.file });
      });
      template.networks?.forEach((networkId) => {
        units.push({ kind: "network", id: networkId.name, file: networkId.file });
      });
      template.other?.forEach((otherId) => {
        units.push({ kind: "other", id: otherId.name, file: otherId.file });
      });
      console.info("Discovered units:", JSON.stringify(units, null, 2));
      if (units.length === 0) {
        throw new Error(`No Mastra units (agents, workflows, tools) found in template.
          Possible causes:
          - Template may not follow standard Mastra structure
          - AI agent couldn't analyze template files (model/token limits)
          - Template is empty or in wrong branch

          Debug steps:
          - Check template has files in src/mastra/ directories
          - Try a different branch
          - Check template repository structure manually`);
      }
      return {
        units,
        success: true
      };
    } catch (error) {
      console.error("Failed to discover units:", error);
      return {
        units: [],
        success: false,
        error: `Failed to discover units: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
});
var orderUnitsStep = workflows.createStep({
  id: "order-units",
  description: "Sort units in topological order based on kind weights",
  inputSchema: DiscoveryResultSchema,
  outputSchema: OrderedUnitsSchema,
  execute: async ({ inputData }) => {
    const { units } = inputData;
    const orderedUnits = [...units].sort((a, b) => {
      const aWeight = kindWeight(a.kind);
      const bWeight = kindWeight(b.kind);
      return aWeight - bWeight;
    });
    return {
      orderedUnits,
      success: true
    };
  }
});
var prepareBranchStep = workflows.createStep({
  id: "prepare-branch",
  description: "Create or switch to integration branch before modifications",
  inputSchema: PrepareBranchInputSchema,
  outputSchema: PrepareBranchResultSchema,
  execute: async ({ inputData, requestContext }) => {
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const branchName = `feat/install-template-${inputData.slug}`;
      await gitCheckoutBranch(branchName, targetPath);
      return {
        branchName,
        success: true
      };
    } catch (error) {
      console.error("Failed to prepare branch:", error);
      return {
        branchName: `feat/install-template-${inputData.slug}`,
        // Return the intended name anyway
        success: false,
        error: `Failed to prepare branch: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
});
var packageMergeStep = workflows.createStep({
  id: "package-merge",
  description: "Merge template package.json dependencies into target project",
  inputSchema: PackageMergeInputSchema,
  outputSchema: PackageMergeResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Package merge step starting...");
    const { slug, packageInfo } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const targetPkgPath = path.join(targetPath, "package.json");
      let targetPkgRaw = "{}";
      try {
        targetPkgRaw = await promises.readFile(targetPkgPath, "utf-8");
      } catch {
        console.warn(`No existing package.json at ${targetPkgPath}, creating a new one`);
      }
      let targetPkg;
      try {
        targetPkg = JSON.parse(targetPkgRaw || "{}");
      } catch (e2) {
        throw new Error(
          `Failed to parse existing package.json at ${targetPkgPath}: ${e2 instanceof Error ? e2.message : String(e2)}`
        );
      }
      const ensureObj = (o) => o && typeof o === "object" ? o : {};
      targetPkg.dependencies = ensureObj(targetPkg.dependencies);
      targetPkg.devDependencies = ensureObj(targetPkg.devDependencies);
      targetPkg.peerDependencies = ensureObj(targetPkg.peerDependencies);
      targetPkg.scripts = ensureObj(targetPkg.scripts);
      const tplDeps = ensureObj(packageInfo.dependencies);
      const tplDevDeps = ensureObj(packageInfo.devDependencies);
      const tplPeerDeps = ensureObj(packageInfo.peerDependencies);
      const tplScripts = ensureObj(packageInfo.scripts);
      const existsAnywhere = (name16) => name16 in targetPkg.dependencies || name16 in targetPkg.devDependencies || name16 in targetPkg.peerDependencies;
      for (const [name16, ver] of Object.entries(tplDeps)) {
        if (!existsAnywhere(name16)) {
          targetPkg.dependencies[name16] = String(ver);
        }
      }
      for (const [name16, ver] of Object.entries(tplDevDeps)) {
        if (!existsAnywhere(name16)) {
          targetPkg.devDependencies[name16] = String(ver);
        }
      }
      for (const [name16, ver] of Object.entries(tplPeerDeps)) {
        if (!(name16 in targetPkg.peerDependencies)) {
          targetPkg.peerDependencies[name16] = String(ver);
        }
      }
      const prefix = `template:${slug}:`;
      for (const [name16, cmd] of Object.entries(tplScripts)) {
        const newKey = `${prefix}${name16}`;
        if (!(newKey in targetPkg.scripts)) {
          targetPkg.scripts[newKey] = String(cmd);
        }
      }
      await promises.writeFile(targetPkgPath, JSON.stringify(targetPkg, null, 2), "utf-8");
      await gitAddAndCommit(targetPath, `feat(template): merge deps for ${slug}`, [targetPkgPath], {
        skipIfNoStaged: true
      });
      return {
        success: true,
        applied: true,
        message: `Successfully merged template dependencies for ${slug}`
      };
    } catch (error) {
      console.error("Package merge failed:", error);
      return {
        success: false,
        applied: false,
        message: `Package merge failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var installStep = workflows.createStep({
  id: "install",
  description: "Install packages based on merged package.json",
  inputSchema: InstallInputSchema,
  outputSchema: InstallResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Running install step...");
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      await spawnSWPM(targetPath, "install", []);
      const lock = ["pnpm-lock.yaml", "package-lock.json", "yarn.lock"].map((f) => path.join(targetPath, f)).find((f) => fs.existsSync(f));
      if (lock) {
        await gitAddAndCommit(targetPath, `chore(template): commit lockfile after install`, [lock], {
          skipIfNoStaged: true
        });
      }
      return {
        success: true
      };
    } catch (error) {
      console.error("Install failed:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var programmaticFileCopyStep = workflows.createStep({
  id: "programmatic-file-copy",
  description: "Programmatically copy template files to target project based on ordered units",
  inputSchema: FileCopyInputSchema,
  outputSchema: FileCopyResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Programmatic file copy step starting...");
    const { orderedUnits, templateDir, commitSha, slug } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const copiedFiles = [];
      const conflicts = [];
      const analyzeNamingConvention = async (directory) => {
        try {
          const files = await promises.readdir(path.resolve(targetPath, directory), { withFileTypes: true });
          const tsFiles = files.filter((f) => f.isFile() && f.name.endsWith(".ts")).map((f) => f.name);
          if (tsFiles.length === 0) return "unknown";
          const camelCaseCount = tsFiles.filter((f) => /^[a-z][a-zA-Z0-9]*\.ts$/.test(f)).length;
          const snakeCaseCount = tsFiles.filter((f) => /^[a-z][a-z0-9_]*\.ts$/.test(f) && f.includes("_")).length;
          const kebabCaseCount = tsFiles.filter((f) => /^[a-z][a-z0-9-]*\.ts$/.test(f) && f.includes("-")).length;
          const pascalCaseCount = tsFiles.filter((f) => /^[A-Z][a-zA-Z0-9]*\.ts$/.test(f)).length;
          const max = Math.max(camelCaseCount, snakeCaseCount, kebabCaseCount, pascalCaseCount);
          if (max === 0) return "unknown";
          if (camelCaseCount === max) return "camelCase";
          if (snakeCaseCount === max) return "snake_case";
          if (kebabCaseCount === max) return "kebab-case";
          if (pascalCaseCount === max) return "PascalCase";
          return "unknown";
        } catch {
          return "unknown";
        }
      };
      const convertNaming = (name16, convention) => {
        const baseName = path.basename(name16, path.extname(name16));
        const ext = path.extname(name16);
        switch (convention) {
          case "camelCase":
            return baseName.replace(/[-_]/g, "").replace(/([A-Z])/g, (match, p1, offset) => offset === 0 ? p1.toLowerCase() : p1) + ext;
          case "snake_case":
            return baseName.replace(/[-]/g, "_").replace(/([A-Z])/g, (match, p1, offset) => (offset === 0 ? "" : "_") + p1.toLowerCase()) + ext;
          case "kebab-case":
            return baseName.replace(/[_]/g, "-").replace(/([A-Z])/g, (match, p1, offset) => (offset === 0 ? "" : "-") + p1.toLowerCase()) + ext;
          case "PascalCase":
            return baseName.replace(/[-_]/g, "").replace(/^[a-z]/, (match) => match.toUpperCase()) + ext;
          default:
            return name16;
        }
      };
      for (const unit of orderedUnits) {
        console.info(`Processing ${unit.kind} unit "${unit.id}" from file "${unit.file}"`);
        let sourceFile;
        let resolvedUnitFile;
        if (unit.file.includes("/")) {
          sourceFile = path.resolve(templateDir, unit.file);
          resolvedUnitFile = unit.file;
        } else {
          const folderPath = AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE[unit.kind];
          if (!folderPath) {
            conflicts.push({
              unit: { kind: unit.kind, id: unit.id },
              issue: `Unknown unit kind: ${unit.kind}`,
              sourceFile: unit.file,
              targetFile: "N/A"
            });
            continue;
          }
          resolvedUnitFile = `${folderPath}/${unit.file}`;
          sourceFile = path.resolve(templateDir, resolvedUnitFile);
        }
        if (!fs.existsSync(sourceFile)) {
          conflicts.push({
            unit: { kind: unit.kind, id: unit.id },
            issue: `Source file not found: ${sourceFile}`,
            sourceFile: resolvedUnitFile,
            targetFile: "N/A"
          });
          continue;
        }
        const targetDir = path.dirname(resolvedUnitFile);
        const namingConvention = await analyzeNamingConvention(targetDir);
        console.info(`Detected naming convention in ${targetDir}: ${namingConvention}`);
        const hasExtension = path.extname(unit.id) !== "";
        const baseId = hasExtension ? path.basename(unit.id, path.extname(unit.id)) : unit.id;
        const fileExtension = path.extname(unit.file);
        const convertedFileName = namingConvention !== "unknown" ? convertNaming(baseId + fileExtension, namingConvention) : baseId + fileExtension;
        const targetFile = path.resolve(targetPath, targetDir, convertedFileName);
        if (fs.existsSync(targetFile)) {
          const strategy = determineConflictStrategy();
          console.info(`File exists: ${convertedFileName}, using strategy: ${strategy}`);
          switch (strategy) {
            case "skip":
              conflicts.push({
                unit: { kind: unit.kind, id: unit.id },
                issue: `File exists - skipped: ${convertedFileName}`,
                sourceFile: unit.file,
                targetFile: `${targetDir}/${convertedFileName}`
              });
              console.info(`\u23ED\uFE0F Skipped ${unit.kind} "${unit.id}": file already exists`);
              continue;
            case "backup-and-replace":
              try {
                await backupAndReplaceFile(sourceFile, targetFile);
                copiedFiles.push({
                  source: sourceFile,
                  destination: targetFile,
                  unit: { kind: unit.kind, id: unit.id }
                });
                console.info(
                  `\u{1F504} Replaced ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${convertedFileName} (backup created)`
                );
                continue;
              } catch (backupError) {
                conflicts.push({
                  unit: { kind: unit.kind, id: unit.id },
                  issue: `Failed to backup and replace: ${backupError instanceof Error ? backupError.message : String(backupError)}`,
                  sourceFile: unit.file,
                  targetFile: `${targetDir}/${convertedFileName}`
                });
                continue;
              }
            case "rename":
              try {
                const uniqueTargetFile = await renameAndCopyFile(sourceFile, targetFile);
                copiedFiles.push({
                  source: sourceFile,
                  destination: uniqueTargetFile,
                  unit: { kind: unit.kind, id: unit.id }
                });
                console.info(`\u{1F4DD} Renamed ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${path.basename(uniqueTargetFile)}`);
                continue;
              } catch (renameError) {
                conflicts.push({
                  unit: { kind: unit.kind, id: unit.id },
                  issue: `Failed to rename and copy: ${renameError instanceof Error ? renameError.message : String(renameError)}`,
                  sourceFile: unit.file,
                  targetFile: `${targetDir}/${convertedFileName}`
                });
                continue;
              }
            default:
              conflicts.push({
                unit: { kind: unit.kind, id: unit.id },
                issue: `Unknown conflict strategy: ${strategy}`,
                sourceFile: unit.file,
                targetFile: `${targetDir}/${convertedFileName}`
              });
              continue;
          }
        }
        await promises.mkdir(path.dirname(targetFile), { recursive: true });
        try {
          await promises.copyFile(sourceFile, targetFile);
          copiedFiles.push({
            source: sourceFile,
            destination: targetFile,
            unit: { kind: unit.kind, id: unit.id }
          });
          console.info(`\u2713 Copied ${unit.kind} "${unit.id}": ${unit.file} \u2192 ${convertedFileName}`);
        } catch (copyError) {
          conflicts.push({
            unit: { kind: unit.kind, id: unit.id },
            issue: `Failed to copy file: ${copyError instanceof Error ? copyError.message : String(copyError)}`,
            sourceFile: unit.file,
            targetFile: `${targetDir}/${convertedFileName}`
          });
        }
      }
      try {
        const targetTsconfig = path.resolve(targetPath, "tsconfig.json");
        if (!fs.existsSync(targetTsconfig)) {
          const templateTsconfig = path.resolve(templateDir, "tsconfig.json");
          if (fs.existsSync(templateTsconfig)) {
            await promises.copyFile(templateTsconfig, targetTsconfig);
            copiedFiles.push({
              source: templateTsconfig,
              destination: targetTsconfig,
              unit: { kind: "other", id: "tsconfig.json" }
            });
            console.info("\u2713 Copied tsconfig.json from template to target");
          } else {
            const minimalTsconfig = {
              compilerOptions: {
                target: "ES2020",
                module: "NodeNext",
                moduleResolution: "NodeNext",
                strict: false,
                esModuleInterop: true,
                skipLibCheck: true,
                resolveJsonModule: true,
                outDir: "dist"
              },
              include: ["**/*.ts", "**/*.tsx", "**/*.mts", "**/*.cts"],
              exclude: ["node_modules", "dist", "build", ".next", ".output", ".turbo"]
            };
            await promises.writeFile(targetTsconfig, JSON.stringify(minimalTsconfig, null, 2), "utf-8");
            copiedFiles.push({
              source: "[generated tsconfig.json]",
              destination: targetTsconfig,
              unit: { kind: "other", id: "tsconfig.json" }
            });
            console.info("\u2713 Generated minimal tsconfig.json in target");
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "tsconfig.json" },
          issue: `Failed to ensure tsconfig.json: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: "tsconfig.json",
          targetFile: "tsconfig.json"
        });
      }
      try {
        const targetMastraIndex = path.resolve(targetPath, "src/mastra/index.ts");
        if (!fs.existsSync(targetMastraIndex)) {
          const templateMastraIndex = path.resolve(templateDir, "src/mastra/index.ts");
          if (fs.existsSync(templateMastraIndex)) {
            if (!fs.existsSync(path.dirname(targetMastraIndex))) {
              await promises.mkdir(path.dirname(targetMastraIndex), { recursive: true });
            }
            await promises.copyFile(templateMastraIndex, targetMastraIndex);
            copiedFiles.push({
              source: templateMastraIndex,
              destination: targetMastraIndex,
              unit: { kind: "other", id: "mastra-index" }
            });
            console.info("\u2713 Copied Mastra index file from template");
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "mastra-index" },
          issue: `Failed to ensure Mastra index file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: "src/mastra/index.ts",
          targetFile: "src/mastra/index.ts"
        });
      }
      try {
        const targetGitignore = path.resolve(targetPath, ".gitignore");
        const templateGitignore = path.resolve(templateDir, ".gitignore");
        const targetExists = fs.existsSync(targetGitignore);
        const templateExists = fs.existsSync(templateGitignore);
        if (templateExists) {
          if (!targetExists) {
            await promises.copyFile(templateGitignore, targetGitignore);
            copiedFiles.push({
              source: templateGitignore,
              destination: targetGitignore,
              unit: { kind: "other", id: "gitignore" }
            });
            console.info("\u2713 Copied .gitignore from template to target");
          } else {
            const targetContent = await promises.readFile(targetGitignore, "utf-8");
            const templateContent = await promises.readFile(templateGitignore, "utf-8");
            const mergedContent = mergeGitignoreFiles(targetContent, templateContent, slug);
            if (mergedContent !== targetContent) {
              const addedLines = mergedContent.split("\n").length - targetContent.split("\n").length;
              await promises.writeFile(targetGitignore, mergedContent, "utf-8");
              copiedFiles.push({
                source: templateGitignore,
                destination: targetGitignore,
                unit: { kind: "other", id: "gitignore-merge" }
              });
              console.info(`\u2713 Merged template .gitignore entries into existing .gitignore (${addedLines} new entries)`);
            } else {
              console.info("\u2139 No new .gitignore entries to add from template");
            }
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "gitignore" },
          issue: `Failed to handle .gitignore file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: ".gitignore",
          targetFile: ".gitignore"
        });
      }
      try {
        const { variables } = inputData;
        if (variables && Object.keys(variables).length > 0) {
          const targetEnv = path.resolve(targetPath, ".env");
          const targetExists = fs.existsSync(targetEnv);
          if (!targetExists) {
            const envContent = [
              `# Environment variables for ${slug}`,
              ...Object.entries(variables).map(([key, value]) => `${key}=${value}`)
            ].join("\n");
            await promises.writeFile(targetEnv, envContent, "utf-8");
            copiedFiles.push({
              source: "[template variables]",
              destination: targetEnv,
              unit: { kind: "other", id: "env" }
            });
            console.info(`\u2713 Created .env file with ${Object.keys(variables).length} template variables`);
          } else {
            const targetContent = await promises.readFile(targetEnv, "utf-8");
            const mergedContent = mergeEnvFiles(targetContent, variables, slug);
            if (mergedContent !== targetContent) {
              const addedLines = mergedContent.split("\n").length - targetContent.split("\n").length;
              await promises.writeFile(targetEnv, mergedContent, "utf-8");
              copiedFiles.push({
                source: "[template variables]",
                destination: targetEnv,
                unit: { kind: "other", id: "env-merge" }
              });
              console.info(`\u2713 Merged new environment variables into existing .env file (${addedLines} new entries)`);
            } else {
              console.info("\u2139 No new environment variables to add (all already exist in .env)");
            }
          }
        }
      } catch (e2) {
        conflicts.push({
          unit: { kind: "other", id: "env" },
          issue: `Failed to handle .env file: ${e2 instanceof Error ? e2.message : String(e2)}`,
          sourceFile: ".env",
          targetFile: ".env"
        });
      }
      if (copiedFiles.length > 0) {
        try {
          const fileList = copiedFiles.map((f) => f.destination);
          await gitAddAndCommit(
            targetPath,
            `feat(template): copy ${copiedFiles.length} files from ${slug}@${commitSha.substring(0, 7)}`,
            fileList,
            { skipIfNoStaged: true }
          );
          console.info(`\u2713 Committed ${copiedFiles.length} copied files`);
        } catch (commitError) {
          console.warn("Failed to commit copied files:", commitError);
        }
      }
      const message = `Programmatic file copy completed. Copied ${copiedFiles.length} files, ${conflicts.length} conflicts detected.`;
      console.info(message);
      return {
        success: true,
        copiedFiles,
        conflicts,
        message
      };
    } catch (error) {
      console.error("Programmatic file copy failed:", error);
      return {
        success: false,
        copiedFiles: [],
        conflicts: [],
        message: `Programmatic file copy failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var intelligentMergeStep = workflows.createStep({
  id: "intelligent-merge",
  description: "Use AgentBuilder to intelligently merge template files",
  inputSchema: IntelligentMergeInputSchema,
  outputSchema: IntelligentMergeResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Intelligent merge step starting...");
    const { conflicts, copiedFiles, commitSha, slug, templateDir, branchName } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    try {
      const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: chunkAQI6GLTN_cjs.openai("gpt-4.1") });
      const copyFileTool = tools.createTool({
        id: "copy-file",
        description: "Copy a file from template to target project (use only for edge cases - most files are already copied programmatically).",
        inputSchema: z18.z.object({
          sourcePath: z18.z.string().describe("Path to the source file relative to template directory"),
          destinationPath: z18.z.string().describe("Path to the destination file relative to target project")
        }),
        outputSchema: z18.z.object({
          success: z18.z.boolean(),
          message: z18.z.string(),
          errorMessage: z18.z.string().optional()
        }),
        execute: async (input) => {
          try {
            const { sourcePath, destinationPath } = input;
            const resolvedSourcePath = path.resolve(templateDir, sourcePath);
            const resolvedDestinationPath = path.resolve(targetPath, destinationPath);
            if (fs.existsSync(resolvedSourcePath) && !fs.existsSync(path.dirname(resolvedDestinationPath))) {
              await promises.mkdir(path.dirname(resolvedDestinationPath), { recursive: true });
            }
            await promises.copyFile(resolvedSourcePath, resolvedDestinationPath);
            return {
              success: true,
              message: `Successfully copied file from ${sourcePath} to ${destinationPath}`
            };
          } catch (err) {
            return {
              success: false,
              message: `Failed to copy file: ${err instanceof Error ? err.message : String(err)}`,
              errorMessage: err instanceof Error ? err.message : String(err)
            };
          }
        }
      });
      const agentBuilder = new AgentBuilder({
        projectPath: targetPath,
        mode: "template",
        model,
        instructions: `
You are an expert at integrating Mastra template components into existing projects.

CRITICAL CONTEXT:
- Files have been programmatically copied from template to target project
- Your job is to handle integration issues, registration, and validation

FILES SUCCESSFULLY COPIED:
${JSON.stringify(copiedFiles, null, 2)}

CONFLICTS TO RESOLVE:
${JSON.stringify(conflicts, null, 2)}

CRITICAL INSTRUCTIONS:
1. **Package management**: NO need to install packages (already handled by package merge step)
2. **File copying**: Most files are already copied programmatically. Only use copyFile tool for edge cases where additional files are needed for conflict resolution

KEY RESPONSIBILITIES:
1. Resolve any conflicts from the programmatic copy step
2. Register components in existing Mastra index file (agents, workflows, networks, mcp-servers)
3. DO NOT register tools in existing Mastra index file - tools should remain standalone
4. Copy additional files ONLY if needed for conflict resolution

MASTRA INDEX FILE HANDLING (src/mastra/index.ts):
1. **Verify the file exists**
   - Call readFile
   - If it fails with ENOENT (or listDirectory shows it missing) -> copyFile the template version to src/mastra/index.ts, then confirm it now exists
   - Always verify after copying that the file exists and is accessible

2. **Edit the file**
   - Always work with the full file content
   - Generate the complete, correct source (imports, anchors, registrations, formatting)
   - Keep existing registrations intact and maintain file structure
   - Ensure proper spacing and organization of new additions

3. **Handle anchors and structure**
   - When generating new content, ensure you do not duplicate existing imports or object entries
   - If required anchors (e.g., agents: {}) are missing, add them while generating the new content
   - Add missing anchors just before the closing brace of the Mastra config
   - Do not restructure or reorder existing anchors and registrations

CRITICAL: ALWAYS use writeFile to update the mastra/index.ts file when needed to register new components.

MASTRA-SPECIFIC REGISTRATION:
- Agents: Register in existing Mastra index file
- Workflows: Register in existing Mastra index file
- Networks: Register in existing Mastra index file
- MCP servers: Register in existing Mastra index file
- Tools: Copy to ${AgentBuilderDefaults.DEFAULT_FOLDER_STRUCTURE.tool} but DO NOT register in existing Mastra index file
- If an anchor (e.g., "agents: {") is not found, avoid complex restructuring; instead, insert the missing anchor on a new line (e.g., add "agents: {" just before the closing brace of the Mastra config) and then proceed with the other registrations.

CONFLICT RESOLUTION AND FILE COPYING:
- Only copy files if needed to resolve specific conflicts
- When copying files from template:
  - Ensure you get the right file name and path
  - Verify the destination directory exists
  - Maintain the same relative path structure
  - Only copy files that are actually needed
- Preserve existing functionality when resolving conflicts
- Focus on registration and conflict resolution, validation will happen in a later step

Template information:
- Slug: ${slug}
- Commit: ${commitSha.substring(0, 7)}
- Branch: ${branchName}
`,
        tools: {
          copyFile: copyFileTool
        }
      });
      const tasks = [];
      conflicts.forEach((conflict) => {
        tasks.push({
          id: `conflict-${conflict.unit.kind}-${conflict.unit.id}`,
          content: `Resolve conflict: ${conflict.issue}`,
          status: "pending",
          priority: "high",
          notes: `Unit: ${conflict.unit.kind}:${conflict.unit.id}, Issue: ${conflict.issue}, Source: ${conflict.sourceFile}, Target: ${conflict.targetFile}`
        });
      });
      const registrableKinds = /* @__PURE__ */ new Set(["agent", "workflow", "network", "mcp-server"]);
      const registrableFiles = copiedFiles.filter((f) => registrableKinds.has(f.unit.kind));
      const targetMastraIndex = path.resolve(targetPath, "src/mastra/index.ts");
      const mastraIndexExists = fs.existsSync(targetMastraIndex);
      console.info(`Mastra index exists: ${mastraIndexExists} at ${targetMastraIndex}`);
      console.info(
        "Registrable components:",
        registrableFiles.map((f) => `${f.unit.kind}:${f.unit.id}`)
      );
      if (registrableFiles.length > 0) {
        tasks.push({
          id: "register-components",
          content: `Register ${registrableFiles.length} components in existing Mastra index file (src/mastra/index.ts)`,
          status: "pending",
          priority: "medium",
          dependencies: conflicts.length > 0 ? conflicts.map((c) => `conflict-${c.unit.kind}-${c.unit.id}`) : void 0,
          notes: `Components to register: ${registrableFiles.map((f) => `${f.unit.kind}:${f.unit.id}`).join(", ")}`
        });
      }
      console.info(`Creating task list with ${tasks.length} tasks...`);
      await AgentBuilderDefaults.manageTaskList({ action: "create", tasks });
      await logGitState(targetPath, "before intelligent merge");
      const prompt = `
You need to work through a task list to complete the template integration.

CRITICAL INSTRUCTIONS:

**STEP 1: GET YOUR TASK LIST**
1. Use manageTaskList tool with action "list" to see all pending tasks
2. Work through tasks in dependency order (complete dependencies first)

**STEP 2: PROCESS EACH TASK SYSTEMATICALLY**
For each task:
1. Use manageTaskList to mark the current task as 'in_progress'
2. Complete the task according to its requirements
3. Use manageTaskList to mark the task as 'completed' when done
4. Continue until all tasks are completed

**TASK TYPES AND REQUIREMENTS:**

**Conflict Resolution Tasks:**
- Analyze the specific conflict and determine best resolution strategy
- For file name conflicts: merge content or rename appropriately
- For missing files: investigate and copy if needed
- For other issues: apply appropriate fixes

**Component Registration Task:**
- Update main Mastra instance file to register new components
- Only register: agents, workflows, networks, mcp-servers
- DO NOT register tools in main config
- Ensure proper import paths and naming conventions

**COMMIT STRATEGY:**
- After resolving conflicts: "feat(template): resolve conflicts for ${slug}@${commitSha.substring(0, 7)}"
- After registration: "feat(template): register components from ${slug}@${commitSha.substring(0, 7)}"

**CRITICAL NOTES:**
- Template source: ${templateDir}
- Target project: ${targetPath}
- Focus ONLY on conflict resolution and component registration
- Use executeCommand for git commits after each task
- DO NOT perform validation - that's handled by the dedicated validation step

Start by listing your tasks and work through them systematically!
`;
      const resolvedModel = await agentBuilder.getModel();
      const isSupported = agent.isSupportedLanguageModel(resolvedModel);
      const result = isSupported ? await agentBuilder.stream(prompt) : await agentBuilder.streamLegacy(prompt);
      const actualResolutions = [];
      for await (const chunk of result.fullStream) {
        if (chunk.type === "step-finish" || chunk.type === "step-start") {
          const chunkData = "payload" in chunk ? chunk.payload : chunk;
          console.info({
            type: chunk.type,
            msgId: chunkData.messageId
          });
        } else {
          console.info(JSON.stringify(chunk, null, 2));
          if (chunk.type === "tool-result") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            if (chunkData.toolName === "manageTaskList") {
              try {
                const toolResult = chunkData.result;
                if (toolResult.action === "update" && toolResult.status === "completed") {
                  actualResolutions.push({
                    taskId: toolResult.taskId || "",
                    action: toolResult.action,
                    status: toolResult.status,
                    content: toolResult.content || "",
                    notes: toolResult.notes
                  });
                  console.info(`\u{1F4CB} Task completed: ${toolResult.taskId} - ${toolResult.content}`);
                }
              } catch (parseError) {
                console.warn("Failed to parse task management result:", parseError);
              }
            }
          }
        }
      }
      await logGitState(targetPath, "after intelligent merge");
      const conflictResolutions = conflicts.map((conflict) => {
        const taskId = `conflict-${conflict.unit.kind}-${conflict.unit.id}`;
        const actualResolution = actualResolutions.find((r) => r.taskId === taskId);
        if (actualResolution) {
          return {
            unit: conflict.unit,
            issue: conflict.issue,
            resolution: actualResolution.notes || actualResolution.content || `Completed: ${conflict.unit.kind} ${conflict.unit.id}`,
            actualWork: true
          };
        } else {
          return {
            unit: conflict.unit,
            issue: conflict.issue,
            resolution: `No specific resolution found for ${conflict.unit.kind} ${conflict.unit.id}`,
            actualWork: false
          };
        }
      });
      await gitAddAndCommit(targetPath, `feat(template): apply intelligent merge for ${slug}`, void 0, {
        skipIfNoStaged: true
      });
      return {
        success: true,
        applied: true,
        message: `Successfully resolved ${conflicts.length} conflicts from template ${slug}`,
        conflictsResolved: conflictResolutions
      };
    } catch (error) {
      return {
        success: false,
        applied: false,
        message: `Failed to resolve conflicts: ${error instanceof Error ? error.message : String(error)}`,
        conflictsResolved: [],
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var validationAndFixStep = workflows.createStep({
  id: "validation-and-fix",
  description: "Validate the merged template code and fix any issues using a specialized agent",
  inputSchema: ValidationFixInputSchema,
  outputSchema: ValidationFixResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Validation and fix step starting...");
    const { commitSha, slug, orderedUnits, templateDir, copiedFiles, conflictsResolved, maxIterations = 5 } = inputData;
    const targetPath = resolveTargetPath(inputData, requestContext);
    const hasChanges = copiedFiles.length > 0 || conflictsResolved && conflictsResolved.length > 0;
    if (!hasChanges) {
      console.info("\u23ED\uFE0F Skipping validation - no files copied or conflicts resolved");
      return {
        success: true,
        applied: false,
        message: "No changes to validate - template already integrated or no conflicts resolved",
        validationResults: {
          valid: true,
          errorsFixed: 0,
          remainingErrors: 0
        }
      };
    }
    console.info(
      `\u{1F4CB} Changes detected: ${copiedFiles.length} files copied, ${conflictsResolved?.length || 0} conflicts resolved`
    );
    let currentIteration = 1;
    try {
      const model = await resolveModel({ requestContext, projectPath: targetPath, defaultModel: chunkAQI6GLTN_cjs.openai("gpt-4.1") });
      const allTools = await AgentBuilderDefaults.listToolsForMode(targetPath, "template");
      const validationAgent = new agent.Agent({
        id: "code-validator-fixer",
        name: "Code Validator Fixer",
        description: "Specialized agent for validating and fixing template integration issues",
        instructions: `You are a code validation and fixing specialist. Your job is to:

1. **Run comprehensive validation** using the validateCode tool to check for:
   - TypeScript compilation errors
   - ESLint issues
   - Import/export problems
   - Missing dependencies
   - Index file structure and exports
   - Component registration correctness
   - Naming convention compliance

2. **Fix validation errors systematically**:
   - Use readFile to examine files with errors
   - Use multiEdit for simple search-replace fixes (single line changes)
   - Use replaceLines for complex multiline fixes (imports, function signatures, etc.)
   - Use listDirectory to understand project structure when fixing import paths
   - Update file contents to resolve TypeScript and linting issues

3. **Choose the right tool for the job**:
   - multiEdit: Simple replacements, single line changes, small fixes
   - replaceLines: Multiline imports, function signatures, complex code blocks
   - writeFile: ONLY for creating new files (never overwrite existing)

4. **Create missing files ONLY when necessary**:
   - Use writeFile ONLY for creating NEW files that don't exist
   - NEVER overwrite existing files - use multiEdit or replaceLines instead
   - Common cases: missing barrel files (index.ts), missing config files, missing type definitions
   - Always check with readFile first to ensure file doesn't exist

5. **Fix ALL template integration issues**:
   - Fix import path issues in copied files
   - Ensure TypeScript imports and exports are correct
   - Validate integration works properly
   - Fix files copied with new names based on unit IDs
   - Update original template imports that reference old filenames
   - Fix missing imports in index files
   - Fix incorrect file paths in imports
   - Fix type mismatches after integration
   - Fix missing exports in barrel files
   - Use the COPIED FILES mapping below to fix import paths
   - Fix any missing dependencies or module resolution issues

6. **Validate index file structure**:
   - Correct imports for all components
   - Proper anchor structure (agents: {}, etc.)
   - No duplicate registrations
   - Correct export names and paths
   - Proper formatting and organization

7. **Follow naming conventions**:
   Import paths:
   - camelCase: import { myAgent } from './myAgent'
   - snake_case: import { myAgent } from './my_agent'
   - kebab-case: import { myAgent } from './my-agent'
   - PascalCase: import { MyAgent } from './MyAgent'

   File names:
   - camelCase: weatherAgent.ts, chatAgent.ts
   - snake_case: weather_agent.ts, chat_agent.ts
   - kebab-case: weather-agent.ts, chat-agent.ts
   - PascalCase: WeatherAgent.ts, ChatAgent.ts

   Key Rule: Keep variable/export names unchanged, only adapt file names and import paths

8. **Re-validate after fixes** to ensure all issues are resolved

CRITICAL: Always validate the entire project first to get a complete picture of issues, then fix them systematically, and re-validate to confirm fixes worked.

CRITICAL TOOL SELECTION GUIDE:
- **multiEdit**: Use for simple string replacements, single-line changes
  Example: changing './oldPath' to './newPath'
  
- **replaceLines**: Use for multiline fixes, complex code structures
  Example: fixing multiline imports, function signatures, or code blocks
  Usage: replaceLines({ filePath: 'file.ts', startLine: 5, endLine: 8, newContent: 'new multiline content' })
  
- **writeFile**: ONLY for creating new files that don't exist
  Example: creating missing index.ts barrel files

CRITICAL WRITEFIL\u0415 SAFETY RULES:
- ONLY use writeFile for creating NEW files that don't exist
- ALWAYS check with readFile first to verify file doesn't exist
- NEVER use writeFile to overwrite existing files - use multiEdit or replaceLines instead
- Common valid uses: missing index.ts barrel files, missing type definitions, missing config files

CRITICAL IMPORT PATH RESOLUTION:
The following files were copied from template with new names:
${JSON.stringify(copiedFiles, null, 2)}

When fixing import errors:
1. Check if the missing module corresponds to a copied file
2. Use listDirectory to verify actual filenames in target directories
3. Update import paths to match the actual copied filenames
4. Ensure exported variable names match what's being imported

EXAMPLE: If error shows "Cannot find module './tools/download-csv-tool'" but a file was copied as "csv-fetcher-tool.ts", update the import to "./tools/csv-fetcher-tool"

${conflictsResolved ? `CONFLICTS RESOLVED BY INTELLIGENT MERGE:
${JSON.stringify(conflictsResolved, null, 2)}
` : ""}

INTEGRATED UNITS:
${JSON.stringify(orderedUnits, null, 2)}

Be thorough and methodical. Always use listDirectory to verify actual file existence before fixing imports.`,
        model,
        tools: {
          validateCode: allTools.validateCode,
          readFile: allTools.readFile,
          writeFile: allTools.writeFile,
          multiEdit: allTools.multiEdit,
          replaceLines: allTools.replaceLines,
          listDirectory: allTools.listDirectory,
          executeCommand: allTools.executeCommand
        }
      });
      console.info("Starting validation and fix agent with internal loop...");
      let validationResults = {
        valid: false,
        errorsFixed: 0,
        remainingErrors: 1,
        // Start with 1 to enter the loop
        iteration: currentIteration,
        lastValidationErrors: []
        // Store the actual error details
      };
      while (validationResults.remainingErrors > 0 && currentIteration <= maxIterations) {
        console.info(`
=== Validation Iteration ${currentIteration} ===`);
        const iterationPrompt = currentIteration === 1 ? `Please validate the template integration and fix any errors found in the project at ${targetPath}. The template "${slug}" (${commitSha.substring(0, 7)}) was just integrated and may have validation issues that need fixing.

Start by running validateCode with all validation types to get a complete picture of any issues, then systematically fix them.` : `Continue validation and fixing for the template integration at ${targetPath}. This is iteration ${currentIteration} of validation.

Previous iterations may have fixed some issues, so start by re-running validateCode to see the current state, then fix any remaining issues.`;
        const resolvedModel = await validationAgent.getModel();
        const isSupported = agent.isSupportedLanguageModel(resolvedModel);
        const output = z18.z.object({ success: z18.z.boolean() });
        const result = isSupported ? await agent.tryStreamWithJsonFallback(validationAgent, iterationPrompt, {
          structuredOutput: {
            schema: output
          }
        }) : await validationAgent.streamLegacy(iterationPrompt, {
          experimental_output: output
        });
        let iterationErrors = 0;
        let previousErrors = validationResults.remainingErrors;
        let lastValidationResult = null;
        for await (const chunk of result.fullStream) {
          if (chunk.type === "step-finish" || chunk.type === "step-start") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            console.info({
              type: chunk.type,
              msgId: chunkData.messageId,
              iteration: currentIteration
            });
          } else {
            console.info(JSON.stringify(chunk, null, 2));
          }
          if (chunk.type === "tool-result") {
            const chunkData = "payload" in chunk ? chunk.payload : chunk;
            if (chunkData.toolName === "validateCode") {
              const toolResult = chunkData.result;
              lastValidationResult = toolResult;
              if (toolResult?.summary) {
                iterationErrors = toolResult.summary.totalErrors || 0;
                console.info(`Iteration ${currentIteration}: Found ${iterationErrors} errors`);
              }
            }
          }
        }
        validationResults.remainingErrors = iterationErrors;
        validationResults.errorsFixed += Math.max(0, previousErrors - iterationErrors);
        validationResults.valid = iterationErrors === 0;
        validationResults.iteration = currentIteration;
        if (iterationErrors > 0 && lastValidationResult?.errors) {
          validationResults.lastValidationErrors = lastValidationResult.errors;
        }
        console.info(`Iteration ${currentIteration} complete: ${iterationErrors} errors remaining`);
        if (iterationErrors === 0) {
          console.info(`\u2705 All validation issues resolved in ${currentIteration} iterations!`);
          break;
        } else if (currentIteration >= maxIterations) {
          console.info(`\u26A0\uFE0F  Max iterations (${maxIterations}) reached. ${iterationErrors} errors still remaining.`);
          break;
        }
        currentIteration++;
      }
      try {
        await gitAddAndCommit(
          targetPath,
          `fix(template): resolve validation errors for ${slug}@${commitSha.substring(0, 7)}`,
          void 0,
          {
            skipIfNoStaged: true
          }
        );
      } catch (commitError) {
        console.warn("Failed to commit validation fixes:", commitError);
      }
      const success = validationResults.valid;
      return {
        success,
        applied: true,
        message: `Validation completed in ${currentIteration} iteration${currentIteration > 1 ? "s" : ""}. ${validationResults.valid ? "All issues resolved!" : `${validationResults.remainingErrors} issue${validationResults.remainingErrors > 1 ? "s" : ""} remaining`}`,
        validationResults: {
          valid: validationResults.valid,
          errorsFixed: validationResults.errorsFixed,
          remainingErrors: validationResults.remainingErrors,
          errors: validationResults.lastValidationErrors
        }
      };
    } catch (error) {
      console.error("Validation and fix failed:", error);
      return {
        success: false,
        applied: false,
        message: `Validation and fix failed: ${error instanceof Error ? error.message : String(error)}`,
        validationResults: {
          valid: false,
          errorsFixed: 0,
          remainingErrors: -1
        },
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      try {
        await promises.rm(templateDir, { recursive: true, force: true });
        console.info(`\u2713 Cleaned up template directory: ${templateDir}`);
      } catch (cleanupError) {
        console.warn("Failed to cleanup template directory:", cleanupError);
      }
    }
  }
});
var agentBuilderTemplateWorkflow = workflows.createWorkflow({
  id: "agent-builder-template",
  description: "Merges a Mastra template repository into the current project using intelligent AgentBuilder-powered merging",
  inputSchema: AgentBuilderInputSchema,
  outputSchema: ApplyResultSchema,
  steps: [
    cloneTemplateStep,
    analyzePackageStep,
    discoverUnitsStep,
    orderUnitsStep,
    packageMergeStep,
    installStep,
    programmaticFileCopyStep,
    intelligentMergeStep,
    validationAndFixStep
  ]
}).then(cloneTemplateStep).map(async ({ getStepResult }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  if (shouldAbortWorkflow(cloneResult)) {
    throw new Error(`Critical failure in clone step: ${cloneResult.error}`);
  }
  return cloneResult;
}).parallel([analyzePackageStep, discoverUnitsStep]).map(async ({ getStepResult }) => {
  const analyzeResult = getStepResult(analyzePackageStep);
  const discoverResult = getStepResult(discoverUnitsStep);
  if (shouldAbortWorkflow(analyzeResult)) {
    throw new Error(`Failure in analyze package step: ${analyzeResult.error || "Package analysis failed"}`);
  }
  if (shouldAbortWorkflow(discoverResult)) {
    throw new Error(`Failure in discover units step: ${discoverResult.error || "Unit discovery failed"}`);
  }
  return discoverResult;
}).then(orderUnitsStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath
  };
}).then(prepareBranchStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const packageResult = getStepResult(analyzePackageStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    packageInfo: packageResult
  };
}).then(packageMergeStep).map(async ({ getInitData }) => {
  const initData = getInitData();
  return {
    targetPath: initData.targetPath
  };
}).then(installStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const orderResult = getStepResult(orderUnitsStep);
  const installResult = getStepResult(installStep);
  const initData = getInitData();
  if (shouldAbortWorkflow(installResult)) {
    throw new Error(`Failure in install step: ${installResult.error || "Install failed"}`);
  }
  return {
    orderedUnits: orderResult.orderedUnits,
    templateDir: cloneResult.templateDir,
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    variables: initData.variables
  };
}).then(programmaticFileCopyStep).map(async ({ getStepResult, getInitData }) => {
  const copyResult = getStepResult(programmaticFileCopyStep);
  const cloneResult = getStepResult(cloneTemplateStep);
  const initData = getInitData();
  return {
    conflicts: copyResult.conflicts,
    copiedFiles: copyResult.copiedFiles,
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    templateDir: cloneResult.templateDir
  };
}).then(intelligentMergeStep).map(async ({ getStepResult, getInitData }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const orderResult = getStepResult(orderUnitsStep);
  const copyResult = getStepResult(programmaticFileCopyStep);
  const mergeResult = getStepResult(intelligentMergeStep);
  const initData = getInitData();
  return {
    commitSha: cloneResult.commitSha,
    slug: cloneResult.slug,
    targetPath: initData.targetPath,
    templateDir: cloneResult.templateDir,
    orderedUnits: orderResult.orderedUnits,
    copiedFiles: copyResult.copiedFiles,
    conflictsResolved: mergeResult.conflictsResolved
  };
}).then(validationAndFixStep).map(async ({ getStepResult }) => {
  const cloneResult = getStepResult(cloneTemplateStep);
  const analyzeResult = getStepResult(analyzePackageStep);
  const discoverResult = getStepResult(discoverUnitsStep);
  const orderResult = getStepResult(orderUnitsStep);
  const prepareBranchResult = getStepResult(prepareBranchStep);
  const packageMergeResult = getStepResult(packageMergeStep);
  const installResult = getStepResult(installStep);
  const copyResult = getStepResult(programmaticFileCopyStep);
  const intelligentMergeResult = getStepResult(intelligentMergeStep);
  const validationResult = getStepResult(validationAndFixStep);
  const branchName = prepareBranchResult.branchName;
  const allErrors = [
    cloneResult.error,
    analyzeResult.error,
    discoverResult.error,
    orderResult.error,
    prepareBranchResult.error,
    packageMergeResult.error,
    installResult.error,
    copyResult.error,
    intelligentMergeResult.error,
    validationResult.error
  ].filter(Boolean);
  const overallSuccess = cloneResult.success !== false && analyzeResult.success !== false && discoverResult.success !== false && orderResult.success !== false && prepareBranchResult.success !== false && packageMergeResult.success !== false && installResult.success !== false && copyResult.success !== false && intelligentMergeResult.success !== false && validationResult.success !== false;
  const messages = [];
  if (copyResult.copiedFiles?.length > 0) {
    messages.push(`${copyResult.copiedFiles.length} files copied`);
  }
  if (copyResult.conflicts?.length > 0) {
    messages.push(`${copyResult.conflicts.length} conflicts skipped`);
  }
  if (intelligentMergeResult.conflictsResolved?.length > 0) {
    messages.push(`${intelligentMergeResult.conflictsResolved.length} conflicts resolved`);
  }
  if (validationResult.validationResults?.errorsFixed > 0) {
    messages.push(`${validationResult.validationResults.errorsFixed} validation errors fixed`);
  }
  if (validationResult.validationResults?.remainingErrors > 0) {
    messages.push(`${validationResult.validationResults.remainingErrors} validation issues remain`);
  }
  const comprehensiveMessage = messages.length > 0 ? `Template merge completed: ${messages.join(", ")}` : validationResult.message || "Template merge completed";
  return {
    success: overallSuccess,
    applied: validationResult.applied || copyResult.copiedFiles?.length > 0 || false,
    message: comprehensiveMessage,
    validationResults: validationResult.validationResults,
    error: allErrors.length > 0 ? allErrors.join("; ") : void 0,
    errors: allErrors.length > 0 ? allErrors : void 0,
    branchName,
    // Additional debugging info
    stepResults: {
      cloneSuccess: cloneResult.success,
      analyzeSuccess: analyzeResult.success,
      discoverSuccess: discoverResult.success,
      orderSuccess: orderResult.success,
      prepareBranchSuccess: prepareBranchResult.success,
      packageMergeSuccess: packageMergeResult.success,
      installSuccess: installResult.success,
      copySuccess: copyResult.success,
      mergeSuccess: intelligentMergeResult.success,
      validationSuccess: validationResult.success,
      filesCopied: copyResult.copiedFiles?.length || 0,
      conflictsSkipped: copyResult.conflicts?.length || 0,
      conflictsResolved: intelligentMergeResult.conflictsResolved?.length || 0
    }
  };
}).commit();
var determineConflictStrategy = (_unit, _targetFile) => {
  return "skip";
};
var shouldAbortWorkflow = (stepResult) => {
  return stepResult?.success === false || stepResult?.error;
};
var marker3 = "vercel.ai.error";
var symbol3 = Symbol.for(marker3);
var _a3;
var _AISDKError5 = class _AISDKError23 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name143,
    message,
    cause
  }) {
    super(message);
    this[_a3] = true;
    this.name = name143;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError23.hasMarker(error, marker3);
  }
  static hasMarker(error, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a3 = symbol3;
var AISDKError4 = _AISDKError5;
var name2 = "AI_APICallError";
var marker27 = `vercel.ai.error.${name2}`;
var symbol27 = Symbol.for(marker27);
var _a27;
var APICallError4 = class extends AISDKError4 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name2, message, cause });
    this[_a27] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker27);
  }
};
_a27 = symbol27;
var name27 = "AI_EmptyResponseBodyError";
var marker32 = `vercel.ai.error.${name27}`;
var symbol32 = Symbol.for(marker32);
var _a32;
var EmptyResponseBodyError3 = class extends AISDKError4 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name27, message });
    this[_a32] = true;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker32);
  }
};
_a32 = symbol32;
function getErrorMessage5(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name37 = "AI_InvalidArgumentError";
var marker47 = `vercel.ai.error.${name37}`;
var symbol47 = Symbol.for(marker47);
var _a47;
var InvalidArgumentError5 = class extends AISDKError4 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name37, message, cause });
    this[_a47] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker47);
  }
};
_a47 = symbol47;
var name67 = "AI_JSONParseError";
var marker77 = `vercel.ai.error.${name67}`;
var symbol77 = Symbol.for(marker77);
var _a77;
var JSONParseError4 = class extends AISDKError4 {
  constructor({ text: text23, cause }) {
    super({
      name: name67,
      message: `JSON parsing failed: Text: ${text23}.
Error message: ${getErrorMessage5(cause)}`,
      cause
    });
    this[_a77] = true;
    this.text = text23;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker77);
  }
};
_a77 = symbol77;
var name124 = "AI_TypeValidationError";
var marker134 = `vercel.ai.error.${name124}`;
var symbol134 = Symbol.for(marker134);
var _a134;
var _TypeValidationError5 = class _TypeValidationError23 extends AISDKError4 {
  constructor({ value, cause }) {
    super({
      name: name124,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage5(cause)}`,
      cause
    });
    this[_a134] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker134);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError23.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError23({ value, cause });
  }
};
_a134 = symbol134;
var TypeValidationError4 = _TypeValidationError5;
var ParseError3 = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop3(_arg) {
}
function createParser3(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop3, onError = noop3, onRetry = noop3, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines3(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError3(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError3(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines3(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream3 = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser3({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
function combineHeaders3(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function extractResponseHeaders3(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator4 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError5({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
createIdGenerator4();
function isAbortError4(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES3 = ["fetch failed", "failed to fetch"];
function handleFetchError3({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError4(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES3.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError4({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent3(globalThisAny = globalThis) {
  var _a153, _b82, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a153 = globalThisAny.navigator) == null ? void 0 : _a153.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b82 = globalThisAny.process) == null ? void 0 : _b82.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders3(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix3(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders3(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION6 = "3.0.17";
var getOriginalFetch4 = () => globalThis.fetch;
var getFromApi3 = async ({
  url,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch4()
}) => {
  try {
    const response = await fetch2(url, {
      method: "GET",
      headers: withUserAgentSuffix3(
        headers,
        `ai-sdk/provider-utils/${VERSION6}`,
        getRuntimeEnvironmentUserAgent3()
      ),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders3(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
        throw new APICallError4({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: {}
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError4({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error) {
    throw handleFetchError3({ error, url, requestBodyValues: {} });
  }
};
function loadOptionalSetting3({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx3 = /"__proto__"\s*:/;
var suspectConstructorRx3 = /"constructor"\s*:/;
function _parse3(text23) {
  const obj = JSON.parse(text23);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx3.test(text23) === false && suspectConstructorRx3.test(text23) === false) {
    return obj;
  }
  return filter3(obj);
}
function filter3(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse3(text23) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse3(text23);
  }
  try {
    return _parse3(text23);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol3 = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator3(validate) {
  return { [validatorSymbol3]: true, validate };
}
function isValidator3(value) {
  return typeof value === "object" && value !== null && validatorSymbol3 in value && value[validatorSymbol3] === true && "validate" in value;
}
function lazyValidator2(createValidator) {
  let validator23;
  return () => {
    if (validator23 == null) {
      validator23 = createValidator();
    }
    return validator23;
  };
}
function asValidator3(value) {
  return isValidator3(value) ? value : typeof value === "function" ? value() : standardSchemaValidator2(value);
}
function standardSchemaValidator2(standardSchema2) {
  return validator3(async (value) => {
    const result = await standardSchema2["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError4({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes3({
  value,
  schema
}) {
  const result = await safeValidateTypes4({ value, schema });
  if (!result.success) {
    throw TypeValidationError4.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes4({
  value,
  schema
}) {
  const validator23 = asValidator3(schema);
  try {
    if (validator23.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator23.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError4.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON3({
  text: text23,
  schema
}) {
  try {
    const value = secureJsonParse3(text23);
    if (schema == null) {
      return value;
    }
    return validateTypes3({ value, schema });
  } catch (error) {
    if (JSONParseError4.isInstance(error) || TypeValidationError4.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError4({ text: text23, cause: error });
  }
}
async function safeParseJSON4({
  text: text23,
  schema
}) {
  try {
    const value = secureJsonParse3(text23);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes4({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError4.isInstance(error) ? error : new JSONParseError4({ text: text23, cause: error }),
      rawValue: void 0
    };
  }
}
function parseJsonEventStream3({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream3()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON4({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch23 = () => globalThis.fetch;
var postJsonToApi3 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi3({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi3 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch23()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix3(
        headers,
        `ai-sdk/provider-utils/${VERSION6}`,
        getRuntimeEnvironmentUserAgent3()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders3(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
        throw new APICallError4({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError4(error) || APICallError4.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError4({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError3({ error, url, requestBodyValues: body.values });
  }
};
async function resolve4(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler3 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders3(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError4({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON3({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError4({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError4({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler3 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders3(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError3({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream3({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler3 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON4({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders3(response);
  if (!parsedResult.success) {
    throw new APICallError4({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var getRelativePath4 = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var ignoreOverride4 = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions4 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions4 = (options) => typeof options === "string" ? {
  ...defaultOptions4,
  name: options
} : {
  ...defaultOptions4,
  ...options
};
function parseAnyDef4() {
  return {};
}
function parseArrayDef4(def, refs) {
  var _a153, _b82, _c;
  const res = {
    type: "array"
  };
  if (((_a153 = def.type) == null ? void 0 : _a153._def) && ((_c = (_b82 = def.type) == null ? void 0 : _b82._def) == null ? void 0 : _c.typeName) !== v3.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef4(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef4(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef4() {
  return { type: "boolean" };
}
function parseBrandedDef4(_def, refs) {
  return parseDef4(_def.type._def, refs);
}
var parseCatchDef4 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};
function parseDateDef4(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef4(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser4(def);
  }
}
var integerDateParser4 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef4(_def, refs) {
  return {
    ...parseDef4(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef4(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef4(_def.schema._def, refs) : parseAnyDef4();
}
function parseEnumDef4(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType4 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef4(def, refs) {
  const allOf = [
    parseDef4(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef4(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType4(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef4(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex4 = void 0;
var zodPatterns4 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex4 === void 0) {
      emojiRegex4 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex4;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef4(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat4(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat4(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern4(res, zodPatterns4.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat4(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat4(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern4(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern4(res, zodPatterns4.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern4(res, zodPatterns4.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern4(
            res,
            RegExp(`^${escapeLiteralCheckValue4(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern4(
            res,
            RegExp(`${escapeLiteralCheckValue4(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat4(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat4(res, "date", check.message, refs);
          break;
        case "time":
          addFormat4(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat4(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern4(
            res,
            RegExp(escapeLiteralCheckValue4(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat4(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat4(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern4(res, zodPatterns4.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern4(res, zodPatterns4.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern4(res, zodPatterns4.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern4(res, zodPatterns4.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern4(res, zodPatterns4.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern4(res, zodPatterns4.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat4(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern4(res, zodPatterns4.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern4(res, zodPatterns4.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue4(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric4(literal) : literal;
}
var ALPHA_NUMERIC4 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric4(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC4.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat4(schema, value, message, refs) {
  var _a153;
  if (schema.format || ((_a153 = schema.anyOf) == null ? void 0 : _a153.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern4(schema, regex, message, refs) {
  var _a153;
  if (schema.pattern || ((_a153 = schema.allOf) == null ? void 0 : _a153.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags4(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags4(regex, refs);
  }
}
function stringifyRegExpWithFlags4(regex, refs) {
  var _a153;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a153 = source[i + 2]) == null ? void 0 : _a153.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  return pattern;
}
function parseRecordDef4(def, refs) {
  var _a153, _b82, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a153 = parseDef4(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a153 : refs.allowedAdditionalProperties
  };
  if (((_b82 = def.keyType) == null ? void 0 : _b82._def.typeName) === v3.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef4(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === v3.ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === v3.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === v3.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef4(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef4(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef4(def, refs);
  }
  const keys = parseDef4(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef4();
  const values = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef4();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef4(def) {
  const object23 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object23[object23[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object23[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef4() {
  return { not: parseAnyDef4() };
}
function parseNullDef4() {
  return {
    type: "null"
  };
}
var primitiveMappings4 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef4(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings4 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings4[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf4(def, refs);
}
var asAnyOf4 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef4(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef4(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings4[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef4(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef4(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional4(propDef);
    const parsedDef = parseDef4(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties4(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties4(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef4(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional4(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef4 = (def, refs) => {
  var _a153;
  if (refs.currentPath.toString() === ((_a153 = refs.propertyPath) == null ? void 0 : _a153.toString())) {
    return parseDef4(def.innerType._def, refs);
  }
  const innerSchema = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef4() }, innerSchema] } : parseAnyDef4();
};
var parsePipelineDef4 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef4(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef4(def.out._def, refs);
  }
  const a = parseDef4(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef4(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef4(def, refs) {
  return parseDef4(def.type._def, refs);
}
function parseSetDef4(def, refs) {
  const items = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef4(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef4(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef4(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef4() {
  return {
    not: parseAnyDef4()
  };
}
function parseUnknownDef4() {
  return parseAnyDef4();
}
var parseReadonlyDef4 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};
var selectParser4 = (def, typeName, refs) => {
  switch (typeName) {
    case v3.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef4(def);
    case v3.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef4(def);
    case v3.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef4();
    case v3.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef4();
    case v3.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef4();
    case v3.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodUnion:
    case v3.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef4(def);
    case v3.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef4(def);
    case v3.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef4(def);
    case v3.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case v3.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodNaN:
    case v3.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef4();
    case v3.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef4();
    case v3.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef4();
    case v3.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef4(def, refs);
    case v3.ZodFirstPartyTypeKind.ZodFunction:
    case v3.ZodFirstPartyTypeKind.ZodVoid:
    case v3.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef4(def, refs, forceResolution = false) {
  var _a153;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a153 = refs.override) == null ? void 0 : _a153.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride4) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref4(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser4(def, def.typeName, refs);
  const jsonSchema23 = typeof jsonSchemaOrGetter === "function" ? parseDef4(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema23) {
    addMeta4(def, refs, jsonSchema23);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema23, def, refs);
    newItem.jsonSchema = jsonSchema23;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema23;
  return jsonSchema23;
}
var get$ref4 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath4(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef4();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef4() : void 0;
    }
  }
};
var addMeta4 = (def, refs, jsonSchema23) => {
  if (def.description) {
    jsonSchema23.description = def.description;
  }
  return jsonSchema23;
};
var getRefs4 = (options) => {
  const _options = getDefaultOptions4(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name143, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name143],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};
var zodToJsonSchema4 = (schema, options) => {
  var _a153;
  const refs = getRefs4(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2232, schema2]) => {
      var _a2232;
      return {
        ...acc,
        [name2232]: (_a2232 = parseDef4(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name2232]
          },
          true
        )) != null ? _a2232 : parseAnyDef4()
      };
    },
    {}
  ) : void 0;
  const name143 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a153 = parseDef4(
    schema._def,
    name143 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name143]
    },
    false
  )) != null ? _a153 : parseAnyDef4();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name143 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name143
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name143]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default2 = zodToJsonSchema4;
function zod3Schema3(zodSchema23, options) {
  var _a153;
  const useReferences = (_a153 = void 0) != null ? _a153 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default2(zodSchema23, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema23.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema3(zodSchema23, options) {
  var _a153;
  const useReferences = (_a153 = void 0) != null ? _a153 : false;
  return jsonSchema4(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z42__namespace.toJSONSchema(zodSchema23, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: async (value) => {
        const result = await z42__namespace.safeParseAsync(zodSchema23, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema3(zodSchema23) {
  return "_zod" in zodSchema23;
}
function zodSchema4(zodSchema23, options) {
  if (isZod4Schema3(zodSchema23)) {
    return zod4Schema3(zodSchema23);
  } else {
    return zod3Schema3(zodSchema23);
  }
}
var schemaSymbol4 = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jsonSchema4(jsonSchema23, {
  validate
} = {}) {
  return {
    [schemaSymbol4]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol3]: true,
    get jsonSchema() {
      if (typeof jsonSchema23 === "function") {
        jsonSchema23 = jsonSchema23();
      }
      return jsonSchema23;
    },
    validate
  };
}
function isSchema4(value) {
  return typeof value === "object" && value !== null && schemaSymbol4 in value && value[schemaSymbol4] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema4(schema) {
  return schema == null ? jsonSchema4({
    properties: {},
    additionalProperties: false
  }) : isSchema4(schema) ? schema : typeof schema === "function" ? schema() : zodSchema4(schema);
}
function withoutTrailingSlash3(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var require_get_context3 = chunkFWSKVWS7_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-context.js"(exports, module) {
    var __defProp23 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp23(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps3 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames3(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp23(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps3(__defProp23({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export23(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = /* @__PURE__ */ Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});
var require_get_vercel_oidc_token3 = chunkFWSKVWS7_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports, module) {
    var __defProp23 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp23(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps3 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames3(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp23(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps3(__defProp23({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export23(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context3();
    var import_token_error = chunkFWSKVWS7_cjs.require_token_error();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await import('./token-util-NEHG7TUY-DJYRKLRD-6TH3ODCN.cjs'),
          await import('./token-6GSAFR2W-KVDFAJ2M-EPLMGMHT.cjs')
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        if (err?.message && error instanceof Error) {
          error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});
var require_dist3 = chunkFWSKVWS7_cjs.__commonJS({
  "../../../node_modules/.pnpm/@vercel+oidc@3.0.5/node_modules/@vercel/oidc/dist/index.js"(exports, module) {
    var __defProp23 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export23 = (target, all) => {
      for (var name16 in all)
        __defProp23(target, name16, { get: all[name16], enumerable: true });
    };
    var __copyProps3 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames3(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp23(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps3(__defProp23({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export23(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token3();
    var import_get_context = require_get_context3();
  }
});
var import_oidc4 = chunkFWSKVWS7_cjs.__toESM(require_dist3(), 1);
var import_oidc23 = chunkFWSKVWS7_cjs.__toESM(require_dist3(), 1);
var marker15 = "vercel.ai.gateway.error";
var symbol15 = Symbol.for(marker15);
var _a15;
var _b9;
var GatewayError3 = class _GatewayError3 extends (_b9 = Error, _a15 = symbol15, _b9) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a15] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error) {
    return _GatewayError3.hasMarker(error);
  }
  static hasMarker(error) {
    return typeof error === "object" && error !== null && symbol15 in error && error[symbol15] === true;
  }
};
var name14 = "GatewayAuthenticationError";
var marker223 = `vercel.ai.gateway.error.${name14}`;
var symbol223 = Symbol.for(marker223);
var _a223;
var _b24;
var GatewayAuthenticationError3 = class _GatewayAuthenticationError3 extends (_b24 = GatewayError3, _a223 = symbol223, _b24) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a223] = true;
    this.name = name14;
    this.type = "authentication_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol223 in error;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    }
    return new _GatewayAuthenticationError3({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name223 = "GatewayInvalidRequestError";
var marker322 = `vercel.ai.gateway.error.${name223}`;
var symbol322 = Symbol.for(marker322);
var _a322;
var _b34;
var GatewayInvalidRequestError3 = class extends (_b34 = GatewayError3, _a322 = symbol322, _b34) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a322] = true;
    this.name = name223;
    this.type = "invalid_request_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol322 in error;
  }
};
var name322 = "GatewayRateLimitError";
var marker423 = `vercel.ai.gateway.error.${name322}`;
var symbol423 = Symbol.for(marker423);
var _a423;
var _b44;
var GatewayRateLimitError3 = class extends (_b44 = GatewayError3, _a423 = symbol423, _b44) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a423] = true;
    this.name = name322;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol423 in error;
  }
};
var name423 = "GatewayModelNotFoundError";
var marker52 = `vercel.ai.gateway.error.${name423}`;
var symbol52 = Symbol.for(marker52);
var modelNotFoundParamSchema3 = lazyValidator2(
  () => zodSchema4(
    z42.z.object({
      modelId: z42.z.string()
    })
  )
);
var _a52;
var _b52;
var GatewayModelNotFoundError3 = class extends (_b52 = GatewayError3, _a52 = symbol52, _b52) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a52] = true;
    this.name = name423;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol52 in error;
  }
};
var name52 = "GatewayInternalServerError";
var marker62 = `vercel.ai.gateway.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var _b62;
var GatewayInternalServerError3 = class extends (_b62 = GatewayError3, _a62 = symbol62, _b62) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a62] = true;
    this.name = name52;
    this.type = "internal_server_error";
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol62 in error;
  }
};
var name623 = "GatewayResponseError";
var marker722 = `vercel.ai.gateway.error.${name623}`;
var symbol722 = Symbol.for(marker722);
var _a722;
var _b74;
var GatewayResponseError3 = class extends (_b74 = GatewayError3, _a722 = symbol722, _b74) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a722] = true;
    this.name = name623;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error) {
    return GatewayError3.hasMarker(error) && symbol722 in error;
  }
};
async function createGatewayErrorFromResponse3({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = await safeValidateTypes4({
    value: response,
    schema: gatewayErrorResponseSchema3
  });
  if (!parseResult.success) {
    return new GatewayResponseError3({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError3.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError3({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError3({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = await safeValidateTypes4({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema3
      });
      return new GatewayModelNotFoundError3({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError3({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError3({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z42.z.object({
      error: z42.z.object({
        message: z42.z.string(),
        type: z42.z.string().nullish(),
        param: z42.z.unknown().nullish(),
        code: z42.z.union([z42.z.string(), z42.z.number()]).nullish()
      })
    })
  )
);
function asGatewayError3(error, authMethod) {
  var _a83;
  if (GatewayError3.isInstance(error)) {
    return error;
  }
  if (APICallError4.isInstance(error)) {
    return createGatewayErrorFromResponse3({
      response: extractApiCallResponse3(error),
      statusCode: (_a83 = error.statusCode) != null ? _a83 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse3({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse3(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e2) {
      return error.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER3 = "ai-gateway-auth-method";
async function parseAuthMethod3(headers) {
  const result = await safeValidateTypes4({
    value: headers[GATEWAY_AUTH_METHOD_HEADER3],
    schema: gatewayAuthMethodSchema3
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema3 = lazyValidator2(
  () => zodSchema4(z42.z.union([z42.z.literal("api-key"), z42.z.literal("oidc")]))
);
var GatewayFetchMetadata3 = class {
  constructor(config) {
    this.config = config;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi3({
        url: `${this.config.baseURL}/config`,
        headers: await resolve4(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayAvailableModelsResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError3(error);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi3({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve4(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayCreditsResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error) {
      throw await asGatewayError3(error);
    }
  }
};
var gatewayAvailableModelsResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z42.z.object({
      models: z42.z.array(
        z42.z.object({
          id: z42.z.string(),
          name: z42.z.string(),
          description: z42.z.string().nullish(),
          pricing: z42.z.object({
            input: z42.z.string(),
            output: z42.z.string(),
            input_cache_read: z42.z.string().nullish(),
            input_cache_write: z42.z.string().nullish()
          }).transform(
            ({ input, output, input_cache_read, input_cache_write }) => ({
              input,
              output,
              ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
              ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
            })
          ).nullish(),
          specification: z42.z.object({
            specificationVersion: z42.z.literal("v2"),
            provider: z42.z.string(),
            modelId: z42.z.string()
          }),
          modelType: z42.z.enum(["language", "embedding", "image"]).nullish()
        })
      )
    })
  )
);
var gatewayCreditsResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z42.z.object({
      balance: z42.z.string(),
      total_used: z42.z.string()
    }).transform(({ balance, total_used }) => ({
      balance,
      totalUsed: total_used
    }))
  )
);
var GatewayLanguageModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve4(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler3(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve4(this.config.o11yHeaders)
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler3(z42.z.any()),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(
                  chunk.error
                );
              }
            }
          })
        ),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a83;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve4(this.config.o11yHeaders)
        ),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayEmbeddingResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a83 = responseBody.usage) != null ? _a83 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    } catch (error) {
      throw await asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema3 = lazyValidator2(
  () => zodSchema4(
    z42.z.object({
      embeddings: z42.z.array(z42.z.array(z42.z.number())),
      usage: z42.z.object({ tokens: z42.z.number() }).nullish(),
      providerMetadata: z42.z.record(z42.z.string(), z42.z.record(z42.z.string(), z42.z.unknown())).optional()
    })
  )
);
var GatewayImageModel3 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a83;
    const resolvedHeaders = await resolve4(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody
      } = await postJsonToApi3({
        url: this.getUrl(),
        headers: combineHeaders3(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve4(this.config.o11yHeaders)
        ),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions }
        },
        successfulResponseHandler: createJsonResponseHandler3(
          gatewayImageResponseSchema3
        ),
        failedResponseHandler: createJsonErrorResponseHandler3({
          errorSchema: z42.z.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        // Always base64 strings from server
        warnings: (_a83 = responseBody.warnings) != null ? _a83 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date(),
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error) {
      throw asGatewayError3(error, await parseAuthMethod3(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var providerMetadataEntrySchema3 = z42.z.object({
  images: z42.z.array(z42.z.unknown()).optional()
}).catchall(z42.z.unknown());
var gatewayImageResponseSchema3 = z42.z.object({
  images: z42.z.array(z42.z.string()),
  // Always base64 strings over the wire
  warnings: z42.z.array(
    z42.z.object({
      type: z42.z.literal("other"),
      message: z42.z.string()
    })
  ).optional(),
  providerMetadata: z42.z.record(z42.z.string(), providerMetadataEntrySchema3).optional()
});
async function getVercelRequestId3() {
  var _a83;
  return (_a83 = (0, import_oidc4.getContext)().headers) == null ? void 0 : _a83["x-vercel-id"];
}
var VERSION24 = "2.0.15";
var AI_GATEWAY_PROTOCOL_VERSION3 = "0.0.1";
function createGatewayProvider3(options = {}) {
  var _a83, _b82;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a83 = options.metadataCacheRefreshMillis) != null ? _a83 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b82 = withoutTrailingSlash3(options.baseURL)) != null ? _b82 : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken3(options);
    if (auth) {
      return withUserAgentSuffix3(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION3,
          [GATEWAY_AUTH_METHOD_HEADER3]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION24}`
      );
    }
    throw GatewayAuthenticationError3.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting3({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId3();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a922, _b92, _c;
    const now2 = (_c = (_b92 = (_a922 = options._internal) == null ? void 0 : _a922.currentDate) == null ? void 0 : _b92.call(_a922).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata3({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError3(
          error,
          await parseAuthMethod3(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata3({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError3(
        error,
        await parseAuthMethod3(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel3(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider;
}
createGatewayProvider3();
async function getGatewayAuthToken3(options) {
  const apiKey = loadOptionalSetting3({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await (0, import_oidc23.getVercelOidcToken)();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e2) {
    return null;
  }
}
var _globalThis4 = typeof globalThis === "object" ? globalThis : global;
var VERSION223 = "1.9.0";
var re4 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck4(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re4);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible23(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re4);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible4 = _makeCompatibilityCheck4(VERSION223);
var major4 = VERSION223.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY4 = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major4);
var _global4 = _globalThis4;
function registerGlobal4(type, instance, diag, allowOverride) {
  var _a16;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global4[GLOBAL_OPENTELEMETRY_API_KEY4] = (_a16 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) !== null && _a16 !== void 0 ? _a16 : {
    version: VERSION223
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION223) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION223);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION223 + ".");
  return true;
}
function getGlobal4(type) {
  var _a16, _b82;
  var globalVersion = (_a16 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) === null || _a16 === void 0 ? void 0 : _a16.version;
  if (!globalVersion || !isCompatible4(globalVersion)) {
    return;
  }
  return (_b82 = _global4[GLOBAL_OPENTELEMETRY_API_KEY4]) === null || _b82 === void 0 ? void 0 : _b82[type];
}
function unregisterGlobal4(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION223 + ".");
  var api = _global4[GLOBAL_OPENTELEMETRY_API_KEY4];
  if (api) {
    delete api[type];
  }
}
var __read7 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray7 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger4 = (
  /** @class */
  (function() {
    function DiagComponentLogger23(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger23.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("debug", this._namespace, args);
    };
    DiagComponentLogger23.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("error", this._namespace, args);
    };
    DiagComponentLogger23.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("info", this._namespace, args);
    };
    DiagComponentLogger23.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("warn", this._namespace, args);
    };
    DiagComponentLogger23.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy4("verbose", this._namespace, args);
    };
    return DiagComponentLogger23;
  })()
);
function logProxy4(funcName, namespace, args) {
  var logger = getGlobal4("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray7([], __read7(args), false));
}
var DiagLogLevel4;
(function(DiagLogLevel23) {
  DiagLogLevel23[DiagLogLevel23["NONE"] = 0] = "NONE";
  DiagLogLevel23[DiagLogLevel23["ERROR"] = 30] = "ERROR";
  DiagLogLevel23[DiagLogLevel23["WARN"] = 50] = "WARN";
  DiagLogLevel23[DiagLogLevel23["INFO"] = 60] = "INFO";
  DiagLogLevel23[DiagLogLevel23["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel23[DiagLogLevel23["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel23[DiagLogLevel23["ALL"] = 9999] = "ALL";
})(DiagLogLevel4 || (DiagLogLevel4 = {}));
function createLogLevelDiagLogger4(maxLevel, logger) {
  if (maxLevel < DiagLogLevel4.NONE) {
    maxLevel = DiagLogLevel4.NONE;
  } else if (maxLevel > DiagLogLevel4.ALL) {
    maxLevel = DiagLogLevel4.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel4.ERROR),
    warn: _filterFunc("warn", DiagLogLevel4.WARN),
    info: _filterFunc("info", DiagLogLevel4.INFO),
    debug: _filterFunc("debug", DiagLogLevel4.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel4.VERBOSE)
  };
}
var __read24 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray24 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME6 = "diag";
var DiagAPI4 = (
  /** @class */
  (function() {
    function DiagAPI23() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal4("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray24([], __read24(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a16, _b82, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel4.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a16 = err.stack) !== null && _a16 !== void 0 ? _a16 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal4("diag");
        var newLogger = createLogLevelDiagLogger4((_b82 = optionsOrLogLevel.logLevel) !== null && _b82 !== void 0 ? _b82 : DiagLogLevel4.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal4("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal4(API_NAME6, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger4(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI23.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI23();
      }
      return this._instance;
    };
    return DiagAPI23;
  })()
);
function createContextKey4(description) {
  return Symbol.for(description);
}
var BaseContext4 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext23(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context = new BaseContext23(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function(key) {
        var context = new BaseContext23(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext23;
  })()
);
var ROOT_CONTEXT4 = new BaseContext4();
var __read34 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray34 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager4 = (
  /** @class */
  (function() {
    function NoopContextManager23() {
    }
    NoopContextManager23.prototype.active = function() {
      return ROOT_CONTEXT4;
    };
    NoopContextManager23.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray34([thisArg], __read34(args), false));
    };
    NoopContextManager23.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager23.prototype.enable = function() {
      return this;
    };
    NoopContextManager23.prototype.disable = function() {
      return this;
    };
    return NoopContextManager23;
  })()
);
var __read44 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while (!(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray44 = function(to, from, pack) {
  if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME24 = "context";
var NOOP_CONTEXT_MANAGER4 = new NoopContextManager4();
var ContextAPI4 = (
  /** @class */
  (function() {
    function ContextAPI23() {
    }
    ContextAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI23();
      }
      return this._instance;
    };
    ContextAPI23.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal4(API_NAME24, contextManager, DiagAPI4.instance());
    };
    ContextAPI23.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI23.prototype.with = function(context, fn, thisArg) {
      var _a16;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a16 = this._getContextManager()).with.apply(_a16, __spreadArray44([context, fn, thisArg], __read44(args), false));
    };
    ContextAPI23.prototype.bind = function(context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI23.prototype._getContextManager = function() {
      return getGlobal4(API_NAME24) || NOOP_CONTEXT_MANAGER4;
    };
    ContextAPI23.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal4(API_NAME24, DiagAPI4.instance());
    };
    return ContextAPI23;
  })()
);
var TraceFlags4;
(function(TraceFlags23) {
  TraceFlags23[TraceFlags23["NONE"] = 0] = "NONE";
  TraceFlags23[TraceFlags23["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags4 || (TraceFlags4 = {}));
var INVALID_SPANID4 = "0000000000000000";
var INVALID_TRACEID4 = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT4 = {
  traceId: INVALID_TRACEID4,
  spanId: INVALID_SPANID4,
  traceFlags: TraceFlags4.NONE
};
var NonRecordingSpan4 = (
  /** @class */
  (function() {
    function NonRecordingSpan23(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT4;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan23.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan23.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan23.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan23.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan23.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan23.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan23.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan23.prototype.end = function(_endTime) {
    };
    NonRecordingSpan23.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan23.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan23;
  })()
);
var SPAN_KEY4 = createContextKey4("OpenTelemetry Context Key SPAN");
function getSpan4(context) {
  return context.getValue(SPAN_KEY4) || void 0;
}
function getActiveSpan4() {
  return getSpan4(ContextAPI4.getInstance().active());
}
function setSpan4(context, span) {
  return context.setValue(SPAN_KEY4, span);
}
function deleteSpan4(context) {
  return context.deleteValue(SPAN_KEY4);
}
function setSpanContext4(context, spanContext) {
  return setSpan4(context, new NonRecordingSpan4(spanContext));
}
function getSpanContext4(context) {
  var _a16;
  return (_a16 = getSpan4(context)) === null || _a16 === void 0 ? void 0 : _a16.spanContext();
}
var VALID_TRACEID_REGEX4 = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX4 = /^[0-9a-f]{16}$/i;
function isValidTraceId4(traceId) {
  return VALID_TRACEID_REGEX4.test(traceId) && traceId !== INVALID_TRACEID4;
}
function isValidSpanId4(spanId) {
  return VALID_SPANID_REGEX4.test(spanId) && spanId !== INVALID_SPANID4;
}
function isSpanContextValid4(spanContext) {
  return isValidTraceId4(spanContext.traceId) && isValidSpanId4(spanContext.spanId);
}
function wrapSpanContext4(spanContext) {
  return new NonRecordingSpan4(spanContext);
}
var contextApi4 = ContextAPI4.getInstance();
var NoopTracer4 = (
  /** @class */
  (function() {
    function NoopTracer23() {
    }
    NoopTracer23.prototype.startSpan = function(name16, options, context) {
      if (context === void 0) {
        context = contextApi4.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan4();
      }
      var parentFromContext = context && getSpanContext4(context);
      if (isSpanContext4(parentFromContext) && isSpanContextValid4(parentFromContext)) {
        return new NonRecordingSpan4(parentFromContext);
      } else {
        return new NonRecordingSpan4();
      }
    };
    NoopTracer23.prototype.startActiveSpan = function(name16, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi4.active();
      var span = this.startSpan(name16, opts, parentContext);
      var contextWithSpanSet = setSpan4(parentContext, span);
      return contextApi4.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer23;
  })()
);
function isSpanContext4(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER4 = new NoopTracer4();
var ProxyTracer4 = (
  /** @class */
  (function() {
    function ProxyTracer23(_provider, name16, version, options) {
      this._provider = _provider;
      this.name = name16;
      this.version = version;
      this.options = options;
    }
    ProxyTracer23.prototype.startSpan = function(name16, options, context) {
      return this._getTracer().startSpan(name16, options, context);
    };
    ProxyTracer23.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer23.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER4;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer23;
  })()
);
var NoopTracerProvider4 = (
  /** @class */
  (function() {
    function NoopTracerProvider23() {
    }
    NoopTracerProvider23.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer4();
    };
    return NoopTracerProvider23;
  })()
);
var NOOP_TRACER_PROVIDER4 = new NoopTracerProvider4();
var ProxyTracerProvider4 = (
  /** @class */
  (function() {
    function ProxyTracerProvider23() {
    }
    ProxyTracerProvider23.prototype.getTracer = function(name16, version, options) {
      var _a16;
      return (_a16 = this.getDelegateTracer(name16, version, options)) !== null && _a16 !== void 0 ? _a16 : new ProxyTracer4(this, name16, version, options);
    };
    ProxyTracerProvider23.prototype.getDelegate = function() {
      var _a16;
      return (_a16 = this._delegate) !== null && _a16 !== void 0 ? _a16 : NOOP_TRACER_PROVIDER4;
    };
    ProxyTracerProvider23.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider23.prototype.getDelegateTracer = function(name16, version, options) {
      var _a16;
      return (_a16 = this._delegate) === null || _a16 === void 0 ? void 0 : _a16.getTracer(name16, version, options);
    };
    return ProxyTracerProvider23;
  })()
);
var SpanStatusCode4;
(function(SpanStatusCode23) {
  SpanStatusCode23[SpanStatusCode23["UNSET"] = 0] = "UNSET";
  SpanStatusCode23[SpanStatusCode23["OK"] = 1] = "OK";
  SpanStatusCode23[SpanStatusCode23["ERROR"] = 2] = "ERROR";
})(SpanStatusCode4 || (SpanStatusCode4 = {}));
var API_NAME34 = "trace";
var TraceAPI4 = (
  /** @class */
  (function() {
    function TraceAPI23() {
      this._proxyTracerProvider = new ProxyTracerProvider4();
      this.wrapSpanContext = wrapSpanContext4;
      this.isSpanContextValid = isSpanContextValid4;
      this.deleteSpan = deleteSpan4;
      this.getSpan = getSpan4;
      this.getActiveSpan = getActiveSpan4;
      this.getSpanContext = getSpanContext4;
      this.setSpan = setSpan4;
      this.setSpanContext = setSpanContext4;
    }
    TraceAPI23.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI23();
      }
      return this._instance;
    };
    TraceAPI23.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal4(API_NAME34, this._proxyTracerProvider, DiagAPI4.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI23.prototype.getTracerProvider = function() {
      return getGlobal4(API_NAME34) || this._proxyTracerProvider;
    };
    TraceAPI23.prototype.getTracer = function(name16, version) {
      return this.getTracerProvider().getTracer(name16, version);
    };
    TraceAPI23.prototype.disable = function() {
      unregisterGlobal4(API_NAME34, DiagAPI4.instance());
      this._proxyTracerProvider = new ProxyTracerProvider4();
    };
    return TraceAPI23;
  })()
);
TraceAPI4.getInstance();
var __defProp5 = Object.defineProperty;
var __export4 = (target, all) => {
  for (var name16 in all)
    __defProp5(target, name16, { get: all[name16], enumerable: true });
};
var name6222 = "AI_NoObjectGeneratedError";
var marker6222 = `vercel.ai.error.${name6222}`;
var symbol6222 = Symbol.for(marker6222);
var _a6222;
var NoObjectGeneratedError4 = class extends AISDKError4 {
  constructor({
    message = "No object generated.",
    cause,
    text: text23,
    response,
    usage,
    finishReason
  }) {
    super({ name: name6222, message, cause });
    this[_a6222] = true;
    this.text = text23;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError4.hasMarker(error, marker6222);
  }
};
_a6222 = symbol6222;
var dataContentSchema4 = z42.z.union([
  z42.z.string(),
  z42.z.instanceof(Uint8Array),
  z42.z.instanceof(ArrayBuffer),
  z42.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a16, _b82;
      return (_b82 = (_a16 = globalThis.Buffer) == null ? void 0 : _a16.isBuffer(value)) != null ? _b82 : false;
    },
    { message: "Must be a Buffer" }
  )
]);
var jsonValueSchema4 = z42.z.lazy(
  () => z42.z.union([
    z42.z.null(),
    z42.z.string(),
    z42.z.number(),
    z42.z.boolean(),
    z42.z.record(z42.z.string(), jsonValueSchema4),
    z42.z.array(jsonValueSchema4)
  ])
);
var providerMetadataSchema4 = z42.z.record(
  z42.z.string(),
  z42.z.record(z42.z.string(), jsonValueSchema4)
);
var textPartSchema4 = z42.z.object({
  type: z42.z.literal("text"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var imagePartSchema4 = z42.z.object({
  type: z42.z.literal("image"),
  image: z42.z.union([dataContentSchema4, z42.z.instanceof(URL)]),
  mediaType: z42.z.string().optional(),
  providerOptions: providerMetadataSchema4.optional()
});
var filePartSchema4 = z42.z.object({
  type: z42.z.literal("file"),
  data: z42.z.union([dataContentSchema4, z42.z.instanceof(URL)]),
  filename: z42.z.string().optional(),
  mediaType: z42.z.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var reasoningPartSchema4 = z42.z.object({
  type: z42.z.literal("reasoning"),
  text: z42.z.string(),
  providerOptions: providerMetadataSchema4.optional()
});
var toolCallPartSchema4 = z42.z.object({
  type: z42.z.literal("tool-call"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  input: z42.z.unknown(),
  providerOptions: providerMetadataSchema4.optional(),
  providerExecuted: z42.z.boolean().optional()
});
var outputSchema3 = z42.z.discriminatedUnion("type", [
  z42.z.object({
    type: z42.z.literal("text"),
    value: z42.z.string()
  }),
  z42.z.object({
    type: z42.z.literal("json"),
    value: jsonValueSchema4
  }),
  z42.z.object({
    type: z42.z.literal("error-text"),
    value: z42.z.string()
  }),
  z42.z.object({
    type: z42.z.literal("error-json"),
    value: jsonValueSchema4
  }),
  z42.z.object({
    type: z42.z.literal("content"),
    value: z42.z.array(
      z42.z.union([
        z42.z.object({
          type: z42.z.literal("text"),
          text: z42.z.string()
        }),
        z42.z.object({
          type: z42.z.literal("media"),
          data: z42.z.string(),
          mediaType: z42.z.string()
        })
      ])
    )
  })
]);
var toolResultPartSchema4 = z42.z.object({
  type: z42.z.literal("tool-result"),
  toolCallId: z42.z.string(),
  toolName: z42.z.string(),
  output: outputSchema3,
  providerOptions: providerMetadataSchema4.optional()
});
var systemModelMessageSchema3 = z42.z.object(
  {
    role: z42.z.literal("system"),
    content: z42.z.string(),
    providerOptions: providerMetadataSchema4.optional()
  }
);
var userModelMessageSchema3 = z42.z.object({
  role: z42.z.literal("user"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(z42.z.union([textPartSchema4, imagePartSchema4, filePartSchema4]))
  ]),
  providerOptions: providerMetadataSchema4.optional()
});
var assistantModelMessageSchema3 = z42.z.object({
  role: z42.z.literal("assistant"),
  content: z42.z.union([
    z42.z.string(),
    z42.z.array(
      z42.z.union([
        textPartSchema4,
        filePartSchema4,
        reasoningPartSchema4,
        toolCallPartSchema4,
        toolResultPartSchema4
      ])
    )
  ]),
  providerOptions: providerMetadataSchema4.optional()
});
var toolModelMessageSchema3 = z42.z.object({
  role: z42.z.literal("tool"),
  content: z42.z.array(toolResultPartSchema4),
  providerOptions: providerMetadataSchema4.optional()
});
z42.z.union([
  systemModelMessageSchema3,
  userModelMessageSchema3,
  assistantModelMessageSchema3,
  toolModelMessageSchema3
]);
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
createIdGenerator4({
  prefix: "aitxt",
  size: 24
});
function fixJson4(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson4(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON4({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON4({ text: fixJson4(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
createIdGenerator4({
  prefix: "aitxt",
  size: 24
});
createIdGenerator4({ prefix: "aiobj", size: 24 });
createIdGenerator4({ prefix: "aiobj", size: 24 });
var output_exports4 = {};
__export4(output_exports4, {
  object: () => object4,
  text: () => text4
});
var text4 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text23 }) {
    return { partial: text23 };
  },
  async parseOutput({ text: text23 }) {
    return text23;
  }
});
var object4 = ({
  schema: inputSchema
}) => {
  const schema = asSchema4(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text23 }) {
      const result = await parsePartialJson4(text23);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text23 }, context) {
      const parseResult = await safeParseJSON4({ text: text23 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError4({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text23,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = await safeValidateTypes4({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError4({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text23,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
var TaskSchema = z18.z.array(
  z18.z.object({
    id: z18.z.string().describe("Unique task ID using kebab-case"),
    content: z18.z.string().describe("Specific, actionable task description"),
    status: z18.z.enum(["pending", "in_progress", "completed", "blocked"]).default("pending"),
    priority: z18.z.enum(["high", "medium", "low"]).describe("Task priority"),
    dependencies: z18.z.array(z18.z.string()).optional().describe("IDs of tasks this depends on"),
    notes: z18.z.string().describe("Detailed implementation notes and specifics")
  })
);
var QuestionSchema = z18.z.array(
  z18.z.object({
    id: z18.z.string().describe("Unique question ID"),
    question: z18.z.string().describe("Clear, specific question for the user"),
    type: z18.z.enum(["choice", "text", "boolean"]).describe("Type of answer expected"),
    options: z18.z.array(z18.z.string()).optional().describe("Options for choice questions"),
    context: z18.z.string().optional().describe("Additional context or explanation")
  })
);
var PlanningIterationResultSchema = z18.z.object({
  success: z18.z.boolean(),
  tasks: TaskSchema,
  questions: QuestionSchema,
  reasoning: z18.z.string(),
  planComplete: z18.z.boolean(),
  message: z18.z.string(),
  error: z18.z.string().optional(),
  allPreviousQuestions: z18.z.array(z18.z.any()).optional(),
  allPreviousAnswers: z18.z.record(z18.z.string()).optional()
});
var taskPlanningPrompts = {
  planningAgent: {
    instructions: (context) => `You are a Mastra workflow planning expert. Your task is to create a detailed, executable task plan.

PLANNING RESPONSIBILITIES:
1. **Analyze Requirements**: Review the user's description and requirements thoroughly
2. **Identify Decision Points**: Find any choices that require user input (email providers, databases, APIs, etc.)
3. **Create Specific Tasks**: Generate concrete, actionable tasks with clear implementation notes
4. **Ask Clarifying Questions**: If any decisions are unclear, formulate specific questions for the user 
- do not ask about package managers
- Assume the user is going to use zod for validation
- You do not need to ask questions if you have none
- NEVER ask questions that have already been answered before
5. **Incorporate Feedback**: Use any previous answers or feedback to refine the plan

${context.storedQAPairs.length > 0 ? `PREVIOUS QUESTION-ANSWER PAIRS (${context.storedQAPairs.length} total):
${context.storedQAPairs.map(
      (pair, index) => `${index + 1}. Q: ${pair.question.question}
   A: ${pair.answer || "NOT ANSWERED YET"}
   Type: ${pair.question.type}
   Asked: ${pair.askedAt}
   ${pair.answer ? `Answered: ${pair.answeredAt}` : ""}`
    ).join("\n\n")}

IMPORTANT: DO NOT ASK ANY QUESTIONS THAT HAVE ALREADY BEEN ASKED!` : ""}

Based on the context and any user answers, create or refine the task plan.`,
    refinementPrompt: (context) => `Refine the existing task plan based on all user answers collected so far. 

ANSWERED QUESTIONS AND RESPONSES:
${context.storedQAPairs.filter((pair) => pair.answer).map(
      (pair, index) => `${index + 1}. Q: ${pair.question.question}
   A: ${pair.answer}
   Context: ${pair.question.context || "None"}`
    ).join("\n\n")}

REQUIREMENTS:
- Action: ${context.action}
- Workflow Name: ${context.workflowName || "To be determined"}
- Description: ${context.description || "Not specified"}
- Requirements: ${context.requirements || "Not specified"}

PROJECT CONTEXT:
- Discovered Workflows: ${JSON.stringify(context.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context.projectStructure, null, 2)}
- Research: ${JSON.stringify(context.research, null, 2)}

${context.hasTaskFeedback ? `
USER FEEDBACK ON PREVIOUS TASK LIST:
${context.userAnswers?.taskFeedback}

PLEASE INCORPORATE THIS FEEDBACK INTO THE REFINED TASK LIST.` : ""}

Refine the task list and determine if any additional questions are needed.`,
    initialPrompt: (context) => `Create an initial task plan for ${context.action}ing a Mastra workflow.

REQUIREMENTS:
- Action: ${context.action}
- Workflow Name: ${context.workflowName || "To be determined"}
- Description: ${context.description || "Not specified"}  
- Requirements: ${context.requirements || "Not specified"}

PROJECT CONTEXT:
- Discovered Workflows: ${JSON.stringify(context.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context.projectStructure, null, 2)}
- Research: ${JSON.stringify(context.research, null, 2)}

Create specific tasks and identify any questions that need user clarification.`
  },
  taskApproval: {
    message: (questionsCount) => `Please answer ${questionsCount} question(s) to finalize the workflow plan:`,
    approvalMessage: (tasksCount) => `Please review and approve the ${tasksCount} task(s) for execution:`
  }
};
var WorkflowBuilderInputSchema = z18.z.object({
  workflowName: z18.z.string().optional().describe("Name of the workflow to create or edit"),
  action: z18.z.enum(["create", "edit"]).describe("Action to perform: create new or edit existing workflow"),
  description: z18.z.string().optional().describe("Description of what the workflow should do"),
  requirements: z18.z.string().optional().describe("Detailed requirements for the workflow"),
  projectPath: z18.z.string().optional().describe("Path to the Mastra project (defaults to current directory)")
});
var DiscoveredWorkflowSchema = z18.z.object({
  name: z18.z.string(),
  file: z18.z.string(),
  description: z18.z.string().optional(),
  inputSchema: z18.z.any().optional(),
  outputSchema: z18.z.any().optional(),
  steps: z18.z.array(z18.z.string()).optional()
});
var WorkflowDiscoveryResultSchema = z18.z.object({
  success: z18.z.boolean(),
  workflows: z18.z.array(DiscoveredWorkflowSchema),
  mastraIndexExists: z18.z.boolean(),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var ProjectDiscoveryResultSchema = z18.z.object({
  success: z18.z.boolean(),
  structure: z18.z.object({
    hasWorkflowsDir: z18.z.boolean(),
    hasAgentsDir: z18.z.boolean(),
    hasToolsDir: z18.z.boolean(),
    hasMastraIndex: z18.z.boolean(),
    existingWorkflows: z18.z.array(z18.z.string()),
    existingAgents: z18.z.array(z18.z.string()),
    existingTools: z18.z.array(z18.z.string())
  }),
  dependencies: z18.z.record(z18.z.string()),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var WorkflowResearchResultSchema = z18.z.object({
  success: z18.z.boolean(),
  documentation: z18.z.object({
    workflowPatterns: z18.z.array(z18.z.string()),
    stepExamples: z18.z.array(z18.z.string()),
    bestPractices: z18.z.array(z18.z.string())
  }),
  webResources: z18.z.array(
    z18.z.object({
      title: z18.z.string(),
      url: z18.z.string(),
      snippet: z18.z.string(),
      relevance: z18.z.number()
    })
  ),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var TaskManagementResultSchema = z18.z.object({
  success: z18.z.boolean(),
  tasks: TaskSchema,
  message: z18.z.string(),
  error: z18.z.string().optional()
});
var TaskExecutionInputSchema = z18.z.object({
  action: z18.z.enum(["create", "edit"]),
  workflowName: z18.z.string().optional(),
  description: z18.z.string().optional(),
  requirements: z18.z.string().optional(),
  tasks: TaskSchema,
  discoveredWorkflows: z18.z.array(z18.z.any()),
  projectStructure: z18.z.any(),
  research: z18.z.any(),
  projectPath: z18.z.string().optional()
});
var TaskExecutionSuspendSchema = z18.z.object({
  questions: QuestionSchema,
  currentProgress: z18.z.string(),
  completedTasks: z18.z.array(z18.z.string()),
  message: z18.z.string()
});
var TaskExecutionResumeSchema = z18.z.object({
  answers: z18.z.array(
    z18.z.object({
      questionId: z18.z.string(),
      answer: z18.z.string()
    })
  )
});
var TaskExecutionResultSchema = z18.z.object({
  success: z18.z.boolean(),
  filesModified: z18.z.array(z18.z.string()),
  validationResults: z18.z.object({
    passed: z18.z.boolean(),
    errors: z18.z.array(z18.z.string()),
    warnings: z18.z.array(z18.z.string())
  }),
  completedTasks: z18.z.array(z18.z.string()),
  message: z18.z.string(),
  error: z18.z.string().optional()
});
z18.z.object({
  questions: QuestionSchema
});
z18.z.object({
  answers: z18.z.record(z18.z.string()),
  hasAnswers: z18.z.boolean()
});
var WorkflowBuilderResultSchema = z18.z.object({
  success: z18.z.boolean(),
  action: z18.z.enum(["create", "edit"]),
  workflowName: z18.z.string().optional(),
  workflowFile: z18.z.string().optional(),
  discovery: WorkflowDiscoveryResultSchema.optional(),
  projectStructure: ProjectDiscoveryResultSchema.optional(),
  research: WorkflowResearchResultSchema.optional(),
  planning: PlanningIterationResultSchema.optional(),
  taskManagement: TaskManagementResultSchema.optional(),
  execution: TaskExecutionResultSchema.optional(),
  needsUserInput: z18.z.boolean().optional(),
  questions: QuestionSchema.optional(),
  message: z18.z.string(),
  nextSteps: z18.z.array(z18.z.string()).optional(),
  error: z18.z.string().optional()
});
var TaskExecutionIterationInputSchema = (taskLength) => z18.z.object({
  status: z18.z.enum(["in_progress", "completed", "needs_clarification"]).describe('Status - only use "completed" when ALL remaining tasks are finished'),
  progress: z18.z.string().describe("Current progress description"),
  completedTasks: z18.z.array(z18.z.string()).describe("List of ALL completed task IDs (including previously completed ones)"),
  totalTasksRequired: z18.z.number().describe(`Total number of tasks that must be completed (should be ${taskLength})`),
  tasksRemaining: z18.z.array(z18.z.string()).describe("List of task IDs that still need to be completed"),
  filesModified: z18.z.array(z18.z.string()).describe("List of files that were created or modified - use these exact paths for validateCode tool"),
  questions: QuestionSchema.optional().describe("Questions for user if clarification is needed"),
  message: z18.z.string().describe("Summary of work completed or current status"),
  error: z18.z.string().optional().describe("Any errors encountered")
});
var PlanningIterationInputSchema = z18.z.object({
  action: z18.z.enum(["create", "edit"]),
  workflowName: z18.z.string().optional(),
  description: z18.z.string().optional(),
  requirements: z18.z.string().optional(),
  discoveredWorkflows: z18.z.array(DiscoveredWorkflowSchema),
  projectStructure: ProjectDiscoveryResultSchema,
  research: WorkflowResearchResultSchema,
  userAnswers: z18.z.record(z18.z.string()).optional()
});
var PlanningIterationSuspendSchema = z18.z.object({
  questions: QuestionSchema,
  message: z18.z.string(),
  currentPlan: z18.z.object({
    tasks: TaskSchema,
    reasoning: z18.z.string()
  })
});
var PlanningIterationResumeSchema = z18.z.object({
  answers: z18.z.record(z18.z.string())
});
var PlanningAgentOutputSchema = z18.z.object({
  tasks: TaskSchema,
  questions: QuestionSchema.optional(),
  reasoning: z18.z.string().describe("Explanation of the plan and any questions"),
  planComplete: z18.z.boolean().describe("Whether the plan is ready for execution (no more questions)")
});
var TaskApprovalOutputSchema = z18.z.object({
  approved: z18.z.boolean(),
  tasks: TaskSchema,
  message: z18.z.string(),
  userFeedback: z18.z.string().optional()
});
var TaskApprovalSuspendSchema = z18.z.object({
  taskList: TaskSchema,
  summary: z18.z.string(),
  message: z18.z.string()
});
var TaskApprovalResumeSchema = z18.z.object({
  approved: z18.z.boolean(),
  modifications: z18.z.string().optional()
});
var planningIterationStep = workflows.createStep({
  id: "planning-iteration",
  description: "Create or refine task plan with user input",
  inputSchema: PlanningIterationInputSchema,
  outputSchema: PlanningIterationResultSchema,
  suspendSchema: PlanningIterationSuspendSchema,
  resumeSchema: PlanningIterationResumeSchema,
  execute: async ({ inputData, resumeData, suspend, requestContext }) => {
    const {
      action,
      workflowName,
      description,
      requirements,
      discoveredWorkflows,
      projectStructure,
      research,
      userAnswers
    } = inputData;
    console.info("Starting planning iteration...");
    const qaKey = "workflow-builder-qa";
    let storedQAPairs = requestContext.get(qaKey) || [];
    const newAnswers = { ...userAnswers || {}, ...resumeData?.answers || {} };
    if (Object.keys(newAnswers).length > 0) {
      storedQAPairs = storedQAPairs.map((pair) => {
        if (newAnswers[pair.question.id]) {
          return {
            ...pair,
            answer: newAnswers[pair.question.id] || null,
            answeredAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
        return pair;
      });
      requestContext.set(qaKey, storedQAPairs);
    }
    try {
      const model = await resolveModel({ requestContext });
      const planningAgent = new agent.Agent({
        id: "workflow-planning-agent",
        model,
        instructions: taskPlanningPrompts.planningAgent.instructions({
          storedQAPairs
        }),
        name: "Workflow Planning Agent"
        // tools: filteredMcpTools,
      });
      const hasTaskFeedback = Boolean(userAnswers && userAnswers.taskFeedback);
      const planningPrompt = storedQAPairs.some((pair) => pair.answer) ? taskPlanningPrompts.planningAgent.refinementPrompt({
        action,
        workflowName,
        description,
        requirements,
        discoveredWorkflows,
        projectStructure,
        research,
        storedQAPairs,
        hasTaskFeedback,
        userAnswers
      }) : taskPlanningPrompts.planningAgent.initialPrompt({
        action,
        workflowName,
        description,
        requirements,
        discoveredWorkflows,
        projectStructure,
        research
      });
      const result = await planningAgent.generate(planningPrompt, {
        structuredOutput: {
          schema: PlanningAgentOutputSchema
        }
        // maxSteps: 15,
      });
      const planResult = await result.object;
      if (!planResult) {
        return {
          tasks: [],
          success: false,
          questions: [],
          reasoning: "Planning agent failed to generate a valid response",
          planComplete: false,
          message: "Planning failed"
        };
      }
      if (planResult.questions && planResult.questions.length > 0 && !planResult.planComplete) {
        console.info(`Planning needs user clarification: ${planResult.questions.length} questions`);
        console.info(planResult.questions);
        const newQAPairs = planResult.questions.map((question) => ({
          question,
          answer: null,
          askedAt: (/* @__PURE__ */ new Date()).toISOString(),
          answeredAt: null
        }));
        storedQAPairs = [...storedQAPairs, ...newQAPairs];
        requestContext.set(qaKey, storedQAPairs);
        console.info(
          `Updated Q&A state: ${storedQAPairs.length} total question-answer pairs, ${storedQAPairs.filter((p) => p.answer).length} answered`
        );
        return suspend({
          questions: planResult.questions,
          message: taskPlanningPrompts.taskApproval.message(planResult.questions.length),
          currentPlan: {
            tasks: planResult.tasks,
            reasoning: planResult.reasoning
          }
        });
      }
      console.info(`Planning complete with ${planResult.tasks.length} tasks`);
      requestContext.set(qaKey, storedQAPairs);
      console.info(
        `Final Q&A state: ${storedQAPairs.length} total question-answer pairs, ${storedQAPairs.filter((p) => p.answer).length} answered`
      );
      return {
        tasks: planResult.tasks,
        success: true,
        questions: [],
        reasoning: planResult.reasoning,
        planComplete: true,
        message: `Successfully created ${planResult.tasks.length} tasks`,
        allPreviousQuestions: storedQAPairs.map((pair) => pair.question),
        allPreviousAnswers: Object.fromEntries(
          storedQAPairs.filter((pair) => pair.answer).map((pair) => [pair.question.id, pair.answer])
        )
      };
    } catch (error) {
      console.error("Planning iteration failed:", error);
      return {
        tasks: [],
        success: false,
        questions: [],
        reasoning: `Planning failed: ${error instanceof Error ? error.message : String(error)}`,
        planComplete: false,
        message: "Planning iteration failed",
        error: error instanceof Error ? error.message : String(error),
        allPreviousQuestions: storedQAPairs.map((pair) => pair.question),
        allPreviousAnswers: Object.fromEntries(
          storedQAPairs.filter((pair) => pair.answer).map((pair) => [pair.question.id, pair.answer])
        )
      };
    }
  }
});
var taskApprovalStep = workflows.createStep({
  id: "task-approval",
  description: "Get user approval for the final task list",
  inputSchema: PlanningIterationResultSchema,
  outputSchema: TaskApprovalOutputSchema,
  suspendSchema: TaskApprovalSuspendSchema,
  resumeSchema: TaskApprovalResumeSchema,
  execute: async ({ inputData, resumeData, suspend }) => {
    const { tasks } = inputData;
    if (!resumeData?.approved && resumeData?.approved !== false) {
      console.info(`Requesting user approval for ${tasks.length} tasks`);
      const summary = `Task List for Approval:

${tasks.length} tasks planned:
${tasks.map((task, i) => `${i + 1}. [${task.priority.toUpperCase()}] ${task.content}${task.dependencies?.length ? ` (depends on: ${task.dependencies.join(", ")})` : ""}
   Notes: ${task.notes || "None"}`).join("\n")}`;
      return suspend({
        taskList: tasks,
        summary,
        message: taskPlanningPrompts.taskApproval.approvalMessage(tasks.length)
      });
    }
    if (resumeData.approved) {
      console.info("Task list approved by user");
      return {
        approved: true,
        tasks,
        message: "Task list approved, ready for execution"
      };
    } else {
      console.info("Task list rejected by user");
      return {
        approved: false,
        tasks,
        message: "Task list rejected",
        userFeedback: resumeData.modifications
      };
    }
  }
});
var planningAndApprovalWorkflow = workflows.createWorkflow({
  id: "planning-and-approval",
  description: "Handle iterative planning with questions and task list approval",
  inputSchema: PlanningIterationInputSchema,
  outputSchema: TaskApprovalOutputSchema,
  steps: [planningIterationStep, taskApprovalStep]
}).dountil(planningIterationStep, async ({ inputData }) => {
  console.info(`Sub-workflow planning check: planComplete=${inputData.planComplete}`);
  return inputData.planComplete === true;
}).map(async ({ inputData }) => {
  return {
    tasks: inputData.tasks || [],
    success: inputData.success || false,
    questions: inputData.questions || [],
    reasoning: inputData.reasoning || "",
    planComplete: inputData.planComplete || false,
    message: inputData.message || ""
  };
}).then(taskApprovalStep).commit();
var workflowResearch = `
## \u{1F50D} **COMPREHENSIVE MASTRA WORKFLOW RESEARCH SUMMARY**

Based on extensive research of Mastra documentation and examples, here's essential information for building effective Mastra workflows:

### **\u{1F4CB} WORKFLOW FUNDAMENTALS**

**Core Components:**
- **\`createWorkflow()\`**: Main factory function that creates workflow instances
- **\`createStep()\`**: Creates individual workflow steps with typed inputs/outputs  
- **\`.commit()\`**: Finalizes workflow definition (REQUIRED to make workflows executable)
- **Zod schemas**: Used for strict input/output typing and validation

**Basic Structure:**
\`\`\`typescript
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const workflow = createWorkflow({
  id: "unique-workflow-id",           // Required: kebab-case recommended
  description: "What this workflow does", // Optional but recommended
  inputSchema: z.object({...}),       // Required: Defines workflow inputs
  outputSchema: z.object({...})       // Required: Defines final outputs
})
  .then(step1)                       // Chain steps sequentially
  .then(step2)
  .commit();                         // CRITICAL: Makes workflow executable
\`\`\`

### **\u{1F527} STEP CREATION PATTERNS**

**Standard Step Definition:**
\`\`\`typescript
const myStep = createStep({
  id: "step-id",                     // Required: unique identifier
  description: "Step description",    // Recommended for clarity
  inputSchema: z.object({...}),       // Required: input validation
  outputSchema: z.object({...}),      // Required: output validation
  execute: async ({ inputData, mastra, getStepResult, getInitData }) => {
    // Step logic here
    return { /* matches outputSchema */ };
  }
});
\`\`\`

**Execute Function Parameters:**
- \`inputData\`: Validated input matching inputSchema
- \`mastra\`: Access to Mastra instance (agents, tools, other workflows)
- \`getStepResult(stepInstance)\`: Get results from previous steps
- \`getInitData()\`: Access original workflow input data
- \`requestContext\`: Runtime dependency injection context
- \`runCount\`: Number of times this step has run (useful for retries)

### **\u{1F504} CONTROL FLOW METHODS**

**Sequential Execution:**
- \`.then(step)\`: Execute steps one after another
- Data flows automatically if schemas match

**Parallel Execution:**
- \`.parallel([step1, step2])\`: Run steps simultaneously
- All parallel steps complete before continuing

**Conditional Logic:**
- \`.branch([[condition, step], [condition, step]])\`: Execute different steps based on conditions
- Conditions evaluated sequentially, matching steps run in parallel

**Loops:**
- \`.dountil(step, condition)\`: Repeat until condition becomes true
- \`.dowhile(step, condition)\`: Repeat while condition is true  
- \`.foreach(step, {concurrency: N})\`: Execute step for each array item

**Data Transformation:**
- \`.map(({ inputData, getStepResult, getInitData }) => transformedData)\`: Transform data between steps

### **\u23F8\uFE0F SUSPEND & RESUME CAPABILITIES**

**For Human-in-the-Loop Workflows:**
\`\`\`typescript
const userInputStep = createStep({
  id: "user-input",
  suspendSchema: z.object({}),        // Schema for suspension payload
  resumeSchema: z.object({            // Schema for resume data
    userResponse: z.string()
  }),
  execute: async ({ resumeData, suspend }) => {
    if (!resumeData?.userResponse) {
      await suspend({});  // Pause workflow
      return { response: "" };
    }
    return { response: resumeData.userResponse };
  }
});
\`\`\`

**Resume Workflow:**
\`\`\`typescript
const result = await run.start({ inputData: {...} });
if (result.status === "suspended") {
  await run.resume({
    step: result.suspended[0],        // Or specific step ID
    resumeData: { userResponse: "answer" }
  });
}
\`\`\`

### **\u{1F6E0}\uFE0F INTEGRATING AGENTS & TOOLS**

**Using Agents in Steps:**
\`\`\`typescript
// Method 1: Agent as step
const agentStep = createStep(myAgent);

// Method 2: Call agent in execute function
const step = createStep({
  execute: async ({ inputData }) => {
    const result = await myAgent.generate(prompt);
    return { output: result.text };
  }
});
\`\`\`

**Using Tools in Steps:**
\`\`\`typescript
// Method 1: Tool as step  
const toolStep = createStep(myTool);

// Method 2: Call tool in execute function
const step = createStep({
  execute: async ({ inputData, requestContext }) => {
    const result = await myTool.execute({
      context: inputData,
      requestContext
    });
    return result;
  }
});
\`\`\`

### **\u{1F5C2}\uFE0F PROJECT ORGANIZATION PATTERNS**

**MANDATORY Workflow Organization:**
Each workflow MUST be organized in its own dedicated folder with separated concerns:

\`\`\`
src/mastra/workflows/
\u251C\u2500\u2500 my-workflow-name/         # Kebab-case folder name
\u2502   \u251C\u2500\u2500 types.ts             # All Zod schemas and TypeScript types
\u2502   \u251C\u2500\u2500 steps.ts             # All individual step definitions
\u2502   \u251C\u2500\u2500 workflow.ts          # Main workflow composition and export
\u2502   \u2514\u2500\u2500 utils.ts             # Helper functions (if needed)
\u251C\u2500\u2500 another-workflow/
\u2502   \u251C\u2500\u2500 types.ts
\u2502   \u251C\u2500\u2500 steps.ts
\u2502   \u251C\u2500\u2500 workflow.ts
\u2502   \u2514\u2500\u2500 utils.ts
\u2514\u2500\u2500 index.ts                 # Export all workflows
\`\`\`

**CRITICAL File Organization Rules:**
- **ALWAYS create a dedicated folder** for each workflow
- **Folder names MUST be kebab-case** version of workflow name
- **types.ts**: Define all input/output schemas, validation types, and interfaces
- **steps.ts**: Create all individual step definitions using createStep()
- **workflow.ts**: Compose steps into workflow using createWorkflow() and export the final workflow
- **utils.ts**: Any helper functions, constants, or utilities (create only if needed)
- **NEVER put everything in one file** - always separate concerns properly

**Workflow Registration:**
\`\`\`typescript
// src/mastra/index.ts
export const mastra = new Mastra({
  workflows: {
    sendEmailWorkflow,      // Use camelCase for keys
    dataProcessingWorkflow
  },
  storage: new LibSQLStore({ id: 'mastra-storage', url: 'file:./mastra.db' }), // Required for suspend/resume
});
\`\`\`

### **\u{1F4E6} ESSENTIAL DEPENDENCIES**

**Required Packages:**
\`\`\`json
{
  "dependencies": {
    "@mastra/core": "latest",
    "zod": "^3.25.67"
  }
}
\`\`\`

**Additional Packages (as needed):**
- \`@mastra/libsql\`: For workflow state persistence
- \`@ai-sdk/openai\`: For AI model integration
- \`ai\`: For AI SDK functionality

### **\u2705 WORKFLOW BEST PRACTICES**

**Schema Design:**
- Use descriptive property names in schemas
- Make schemas as specific as possible (avoid \`z.any()\`)
- Include validation for required business logic

**Error Handling:**
- Use \`try/catch\` blocks in step execute functions
- Return meaningful error messages
- Consider using \`bail()\` for early successful exits

**Step Organization:**
- Keep steps focused on single responsibilities
- Use descriptive step IDs (kebab-case recommended)
- Create reusable steps for common operations

**Data Flow:**
- Use \`.map()\` when schemas don't align between steps
- Access previous step results with \`getStepResult(stepInstance)\`
- Use \`getInitData()\` to access original workflow input

### **\u{1F680} EXECUTION PATTERNS**

**Running Workflows:**
\`\`\`typescript
// Create and start run
const run = await workflow.createRun();
const result = await run.start({ inputData: {...} });

// Stream execution for real-time monitoring
const stream = await run.streamVNext({ inputData: {...} });
for await (const chunk of stream) {
  console.log(chunk);
}

// Watch for events
run.watch((event) => console.log(event));
\`\`\`

**Workflow Status Types:**
- \`"success"\`: Completed successfully
- \`"suspended"\`: Paused awaiting input
- \`"failed"\`: Encountered error

### **\u{1F517} ADVANCED FEATURES**

**Nested Workflows:**
- Use workflows as steps: \`.then(otherWorkflow)\`
- Enable complex workflow composition

**Request Context:**
- Pass shared data across all steps
- Enable dependency injection patterns

**Streaming & Events:**
- Real-time workflow monitoring
- Integration with external event systems

**Cloning:**
- \`cloneWorkflow(original, {id: "new-id"})\`: Reuse workflow structure
- \`cloneStep(original, {id: "new-id"})\`: Reuse step logic

This comprehensive research provides the foundation for creating robust, maintainable Mastra workflows with proper typing, error handling, and architectural patterns.
`;
var workflowBuilderPrompts = {
  researchAgent: {
    instructions: `You are a Mastra workflow research expert. Your task is to gather relevant information about creating Mastra workflows.

RESEARCH OBJECTIVES:
1. **Core Concepts**: Understand how Mastra workflows work
2. **Best Practices**: Learn workflow patterns and conventions  
3. **Code Examples**: Find relevant implementation examples
4. **Technical Details**: Understand schemas, steps, and configuration

Use the available documentation and examples tools to gather comprehensive information about Mastra workflows.`,
    prompt: (context) => `Research everything about Mastra workflows to help create or edit them effectively.

PROJECT CONTEXT:
- Project Structure: ${JSON.stringify(context.projectStructure, null, 2)}
- Dependencies: ${JSON.stringify(context.dependencies, null, 2)}
- Has Workflows Directory: ${context.hasWorkflowsDir}

Focus on:
1. How to create workflows using createWorkflow()
2. How to create and chain workflow steps
3. Best practices for workflow organization
4. Common workflow patterns and examples
5. Schema definitions and types
6. Error handling and debugging

Use the docs and examples tools to gather comprehensive information.`
  },
  executionAgent: {
    instructions: (context) => `You are executing a workflow ${context.action} task for: "${context.workflowName}"

CRITICAL WORKFLOW EXECUTION REQUIREMENTS:
1. **EXPLORE PROJECT STRUCTURE FIRST**: Use listDirectory and readFile tools to understand the existing project layout, folder structure, and conventions before creating any files
2. **FOLLOW PROJECT CONVENTIONS**: Look at existing workflows, agents, and file structures to understand where new files should be placed (typically src/mastra/workflows/, src/mastra/agents/, etc.)
3. **USE PRE-LOADED TASK LIST**: Your task list has been pre-populated in the taskManager tool. Use taskManager with action 'list' to see all tasks, and action 'update' to mark progress
4. **COMPLETE EVERY SINGLE TASK**: You MUST complete ALL ${context.tasksLength} tasks that are already in the taskManager. Do not stop until every task is marked as 'completed'
5. **Follow Task Dependencies**: Execute tasks in the correct order, respecting dependencies
6. **Request User Input When Needed**: If you encounter choices (like email providers, databases, etc.) that require user decision, return questions for clarification
7. **STRICT WORKFLOW ORGANIZATION**: When creating or editing workflows, you MUST follow this exact structure

MANDATORY WORKFLOW FOLDER STRUCTURE:
When ${context.action === "create" ? "creating a new workflow" : "editing a workflow"}, you MUST organize files as follows:

\u{1F4C1} src/mastra/workflows/${context.workflowName?.toLowerCase().replace(/[^a-z0-9]/g, "-") || "new-workflow"}/
\u251C\u2500\u2500 \u{1F4C4} types.ts          # All Zod schemas and TypeScript types
\u251C\u2500\u2500 \u{1F4C4} steps.ts          # All individual step definitions  
\u251C\u2500\u2500 \u{1F4C4} workflow.ts       # Main workflow composition and export
\u2514\u2500\u2500 \u{1F4C4} utils.ts          # Helper functions (if needed)

CRITICAL FILE ORGANIZATION RULES:
- **ALWAYS create a dedicated folder** for the workflow in src/mastra/workflows/
- **Folder name MUST be kebab-case** version of workflow name
- **types.ts**: Define all input/output schemas, validation types, and interfaces
- **steps.ts**: Create all individual step definitions using createStep()
- **workflow.ts**: Compose steps into workflow using createWorkflow() and export the final workflow
- **utils.ts**: Any helper functions, constants, or utilities (create only if needed)
- **NEVER put everything in one file** - always separate concerns properly

CRITICAL COMPLETION REQUIREMENTS: 
- ALWAYS explore the directory structure before creating files to understand where they should go
- You MUST complete ALL ${context.tasksLength} tasks before returning status='completed'
- Use taskManager tool with action 'list' to see your current task list and action 'update' to mark tasks as 'in_progress' or 'completed'
- If you need to make any decisions during implementation (choosing providers, configurations, etc.), return questions for user clarification
- DO NOT make assumptions about file locations - explore first!
- You cannot finish until ALL tasks in the taskManager are marked as 'completed'

PROJECT CONTEXT:
- Action: ${context.action}
- Workflow Name: ${context.workflowName}
- Project Path: ${context.currentProjectPath}
- Discovered Workflows: ${JSON.stringify(context.discoveredWorkflows, null, 2)}
- Project Structure: ${JSON.stringify(context.projectStructure, null, 2)}

AVAILABLE RESEARCH:
${JSON.stringify(context.research, null, 2)}

PRE-LOADED TASK LIST (${context.tasksLength} tasks already in taskManager):
${context.tasks.map((task) => `- ${task.id}: ${task.content} (Priority: ${task.priority})`).join("\n")}

${context.resumeData ? `USER PROVIDED ANSWERS: ${JSON.stringify(context.resumeData.answers, null, 2)}` : ""}

Start by exploring the project structure, then use 'taskManager' with action 'list' to see your pre-loaded tasks, and work through each task systematically.`,
    prompt: (context) => context.resumeData ? `Continue working on the task list. The user has provided answers to your questions: ${JSON.stringify(context.resumeData.answers, null, 2)}. 

CRITICAL: You must complete ALL ${context.tasks.length} tasks that are pre-loaded in the taskManager. Use the taskManager tool with action 'list' to check your progress and continue with the next tasks. Do not stop until every single task is marked as 'completed'.` : `Begin executing the pre-loaded task list to ${context.action} the workflow "${context.workflowName}". 

CRITICAL REQUIREMENTS:
- Your ${context.tasks.length} tasks have been PRE-LOADED into the taskManager tool
- Start by exploring the project directory structure using listDirectory and readFile tools to understand:
  - Where workflows are typically stored (look for src/mastra/workflows/ or similar)
  - What the existing file structure looks like
  - How other workflows are organized and named
  - Where agent files are stored if needed
- Then use taskManager with action 'list' to see your pre-loaded tasks
- Use taskManager with action 'update' to mark tasks as 'in_progress' or 'completed'

CRITICAL FILE ORGANIZATION RULES:
- **ALWAYS create a dedicated folder** for the workflow in src/mastra/workflows/
- **Folder name MUST be kebab-case** version of workflow name  
- **NEVER put everything in one file** - separate types, steps, and workflow composition
- Follow the 4-file structure above for maximum maintainability and clarity

- DO NOT return status='completed' until ALL ${context.tasks.length} tasks are marked as 'completed' in the taskManager

PRE-LOADED TASKS (${context.tasks.length} total tasks in taskManager):
${context.tasks.map((task, index) => `${index + 1}. [${task.id}] ${task.content}`).join("\n")}

Use taskManager with action 'list' to see the current status of all tasks. You must complete every single one before finishing.`,
    iterationPrompt: (context) => `Continue working on the remaining tasks. You have already completed these tasks: [${context.completedTasks.map((t2) => t2.id).join(", ")}]

REMAINING TASKS TO COMPLETE (${context.pendingTasks.length} tasks):
${context.pendingTasks.map((task, index) => `${index + 1}. [${task.id}] ${task.content}`).join("\n")}

CRITICAL: You must complete ALL of these remaining ${context.pendingTasks.length} tasks. Use taskManager with action 'list' to check current status and action 'update' to mark tasks as completed.

${context.resumeData ? `USER PROVIDED ANSWERS: ${JSON.stringify(context.resumeData.answers, null, 2)}` : ""}`
  },
  validation: {
    instructions: `CRITICAL VALIDATION INSTRUCTIONS:
- When using the validateCode tool, ALWAYS pass the specific files you created or modified using the 'files' parameter
- The tool uses a hybrid validation approach: fast syntax checking \u2192 semantic type checking \u2192 ESLint
- This is much faster than full project compilation and only shows errors from your specific files
- Example: validateCode({ validationType: ['types', 'lint'], files: ['src/workflows/my-workflow.ts', 'src/agents/my-agent.ts'] })
- ALWAYS validate after creating or modifying files to ensure they compile correctly`
  }
};
var restrictedTaskManager = tools.createTool({
  id: "task-manager",
  description: "View and update your pre-loaded task list. You can only mark tasks as in_progress or completed, not create new tasks.",
  inputSchema: z18.z.object({
    action: z18.z.enum(["list", "update", "complete"]).describe("List tasks, update status, or mark complete - tasks are pre-loaded"),
    tasks: z18.z.array(
      z18.z.object({
        id: z18.z.string().describe("Task ID - must match existing task"),
        content: z18.z.string().optional().describe("Task content (read-only)"),
        status: z18.z.enum(["pending", "in_progress", "completed", "blocked"]).describe("Task status"),
        priority: z18.z.enum(["high", "medium", "low"]).optional().describe("Task priority (read-only)"),
        dependencies: z18.z.array(z18.z.string()).optional().describe("Task dependencies (read-only)"),
        notes: z18.z.string().optional().describe("Additional notes or progress updates")
      })
    ).optional().describe("Tasks to update (status and notes only)"),
    taskId: z18.z.string().optional().describe("Specific task ID for single task operations")
  }),
  outputSchema: z18.z.object({
    success: z18.z.boolean(),
    tasks: z18.z.array(
      z18.z.object({
        id: z18.z.string(),
        content: z18.z.string(),
        status: z18.z.string(),
        priority: z18.z.string(),
        dependencies: z18.z.array(z18.z.string()).optional(),
        notes: z18.z.string().optional(),
        createdAt: z18.z.string(),
        updatedAt: z18.z.string()
      })
    ),
    message: z18.z.string()
  }),
  execute: async (input) => {
    const adaptedContext = {
      ...input,
      action: input.action,
      tasks: input.tasks?.map((task) => ({
        ...task,
        priority: task.priority || "medium"
      }))
    };
    return await AgentBuilderDefaults.manageTaskList(adaptedContext);
  }
});
var workflowDiscoveryStep = workflows.createStep({
  id: "workflow-discovery",
  description: "Discover existing workflows in the project",
  inputSchema: WorkflowBuilderInputSchema,
  outputSchema: WorkflowDiscoveryResultSchema,
  execute: async ({ inputData, requestContext: _requestContext }) => {
    console.info("Starting workflow discovery...");
    const { projectPath = process.cwd() } = inputData;
    try {
      const workflowsPath = path.join(projectPath, "src/mastra/workflows");
      if (!fs.existsSync(workflowsPath)) {
        console.info("No workflows directory found");
        return {
          success: true,
          workflows: [],
          mastraIndexExists: fs.existsSync(path.join(projectPath, "src/mastra/index.ts")),
          message: "No existing workflows found in the project"
        };
      }
      const workflowFiles = await promises.readdir(workflowsPath);
      const workflows = [];
      for (const fileName of workflowFiles) {
        if (fileName.endsWith(".ts") && !fileName.endsWith(".test.ts")) {
          const filePath = path.join(workflowsPath, fileName);
          try {
            const content = await promises.readFile(filePath, "utf-8");
            const nameMatch = content.match(/createWorkflow\s*\(\s*{\s*id:\s*['"]([^'"]+)['"]/);
            const descMatch = content.match(/description:\s*['"]([^'"]*)['"]/);
            if (nameMatch && nameMatch[1]) {
              workflows.push({
                name: nameMatch[1],
                file: filePath,
                description: descMatch?.[1] ?? "No description available"
              });
            }
          } catch (error) {
            console.warn(`Failed to read workflow file ${filePath}:`, error);
          }
        }
      }
      console.info(`Discovered ${workflows.length} existing workflows`);
      return {
        success: true,
        workflows,
        mastraIndexExists: fs.existsSync(path.join(projectPath, "src/mastra/index.ts")),
        message: workflows.length > 0 ? `Found ${workflows.length} existing workflow(s): ${workflows.map((w) => w.name).join(", ")}` : "No existing workflows found in the project"
      };
    } catch (error) {
      console.error("Workflow discovery failed:", error);
      return {
        success: false,
        workflows: [],
        mastraIndexExists: false,
        message: `Workflow discovery failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var projectDiscoveryStep = workflows.createStep({
  id: "project-discovery",
  description: "Analyze the project structure and setup",
  inputSchema: WorkflowDiscoveryResultSchema,
  outputSchema: ProjectDiscoveryResultSchema,
  execute: async ({ inputData: _inputData, requestContext: _requestContext }) => {
    console.info("Starting project discovery...");
    try {
      const projectPath = process.cwd();
      const projectStructure = {
        hasPackageJson: fs.existsSync(path.join(projectPath, "package.json")),
        hasMastraConfig: fs.existsSync(path.join(projectPath, "mastra.config.js")) || fs.existsSync(path.join(projectPath, "mastra.config.ts")),
        hasSrcDirectory: fs.existsSync(path.join(projectPath, "src")),
        hasMastraDirectory: fs.existsSync(path.join(projectPath, "src/mastra")),
        hasWorkflowsDirectory: fs.existsSync(path.join(projectPath, "src/mastra/workflows")),
        hasToolsDirectory: fs.existsSync(path.join(projectPath, "src/mastra/tools")),
        hasAgentsDirectory: fs.existsSync(path.join(projectPath, "src/mastra/agents"))
      };
      let packageInfo = null;
      if (projectStructure.hasPackageJson) {
        try {
          const packageContent = await promises.readFile(path.join(projectPath, "package.json"), "utf-8");
          packageInfo = JSON.parse(packageContent);
        } catch (error) {
          console.warn("Failed to read package.json:", error);
        }
      }
      console.info("Project discovery completed");
      return {
        success: true,
        structure: {
          hasWorkflowsDir: projectStructure.hasWorkflowsDirectory,
          hasAgentsDir: projectStructure.hasAgentsDirectory,
          hasToolsDir: projectStructure.hasToolsDirectory,
          hasMastraIndex: fs.existsSync(path.join(projectPath, "src/mastra/index.ts")),
          existingWorkflows: [],
          existingAgents: [],
          existingTools: []
        },
        dependencies: packageInfo?.dependencies || {},
        message: "Project discovery completed successfully"
      };
    } catch (error) {
      console.error("Project discovery failed:", error);
      return {
        success: false,
        structure: {
          hasWorkflowsDir: false,
          hasAgentsDir: false,
          hasToolsDir: false,
          hasMastraIndex: false,
          existingWorkflows: [],
          existingAgents: [],
          existingTools: []
        },
        dependencies: {},
        message: "Project discovery failed",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var workflowResearchStep = workflows.createStep({
  id: "workflow-research",
  description: "Research Mastra workflows and gather relevant documentation",
  inputSchema: ProjectDiscoveryResultSchema,
  outputSchema: WorkflowResearchResultSchema,
  execute: async ({ inputData, requestContext }) => {
    console.info("Starting workflow research...");
    try {
      const model = await resolveModel({ requestContext });
      const researchAgent = new agent.Agent({
        id: "workflow-research-agent",
        model,
        instructions: workflowBuilderPrompts.researchAgent.instructions,
        name: "Workflow Research Agent"
        // tools: filteredMcpTools,
      });
      const researchPrompt = workflowBuilderPrompts.researchAgent.prompt({
        projectStructure: inputData.structure,
        dependencies: inputData.dependencies,
        hasWorkflowsDir: inputData.structure.hasWorkflowsDir
      });
      const result = await researchAgent.generate(researchPrompt, {
        structuredOutput: {
          schema: WorkflowResearchResultSchema
        }
        // stopWhen: stepCountIs(10),
      });
      const researchResult = await result.object;
      if (!researchResult) {
        return {
          success: false,
          documentation: {
            workflowPatterns: [],
            stepExamples: [],
            bestPractices: []
          },
          webResources: [],
          message: "Research agent failed to generate valid response",
          error: "Research agent failed to generate valid response"
        };
      }
      console.info("Research completed successfully");
      return {
        success: true,
        documentation: {
          workflowPatterns: researchResult.documentation.workflowPatterns,
          stepExamples: researchResult.documentation.stepExamples,
          bestPractices: researchResult.documentation.bestPractices
        },
        webResources: researchResult.webResources,
        message: "Research completed successfully"
      };
    } catch (error) {
      console.error("Workflow research failed:", error);
      return {
        success: false,
        documentation: {
          workflowPatterns: [],
          stepExamples: [],
          bestPractices: []
        },
        webResources: [],
        message: "Research failed",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var taskExecutionStep = workflows.createStep({
  id: "task-execution",
  description: "Execute the approved task list to create or edit the workflow",
  inputSchema: TaskExecutionInputSchema,
  outputSchema: TaskExecutionResultSchema,
  suspendSchema: TaskExecutionSuspendSchema,
  resumeSchema: TaskExecutionResumeSchema,
  execute: async ({ inputData, resumeData, suspend, requestContext }) => {
    const {
      action,
      workflowName,
      tasks,
      discoveredWorkflows,
      projectStructure,
      research,
      projectPath
    } = inputData;
    console.info(`Starting task execution for ${action}ing workflow: ${workflowName}`);
    console.info(`Executing ${tasks.length} tasks using AgentBuilder stream...`);
    try {
      const model = await resolveModel({ requestContext });
      const currentProjectPath = projectPath || process.cwd();
      console.info("Pre-populating taskManager with planned tasks...");
      const taskManagerContext = {
        action: "create",
        tasks: tasks.map((task) => ({
          id: task.id,
          content: task.content,
          status: "pending",
          priority: task.priority,
          dependencies: task.dependencies,
          notes: task.notes
        }))
      };
      const taskManagerResult = await AgentBuilderDefaults.manageTaskList(taskManagerContext);
      console.info(`Task manager initialized with ${taskManagerResult.tasks.length} tasks`);
      if (!taskManagerResult.success) {
        throw new Error(`Failed to initialize task manager: ${taskManagerResult.message}`);
      }
      const executionAgent = new AgentBuilder({
        projectPath: currentProjectPath,
        model,
        tools: {
          "task-manager": restrictedTaskManager
        },
        instructions: `${workflowBuilderPrompts.executionAgent.instructions({
          action,
          workflowName,
          tasksLength: tasks.length,
          currentProjectPath,
          discoveredWorkflows,
          projectStructure,
          research,
          tasks,
          resumeData
        })}

${workflowBuilderPrompts.validation.instructions}`
      });
      const executionPrompt = workflowBuilderPrompts.executionAgent.prompt({
        action,
        workflowName,
        tasks,
        resumeData
      });
      const originalInstructions = await executionAgent.getInstructions({ requestContext });
      const enhancedOptions = {
        stopWhen: stepCountIs(100),
        temperature: 0.3,
        instructions: originalInstructions
      };
      let finalResult = null;
      let allTasksCompleted = false;
      let iterationCount = 0;
      const maxIterations = 5;
      const expectedTaskIds = tasks.map((task) => task.id);
      while (!allTasksCompleted && iterationCount < maxIterations) {
        iterationCount++;
        const currentTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
        const completedTasks = currentTaskStatus.tasks.filter((task) => task.status === "completed");
        const pendingTasks = currentTaskStatus.tasks.filter((task) => task.status !== "completed");
        console.info(`
=== EXECUTION ITERATION ${iterationCount} ===`);
        console.info(`Completed tasks: ${completedTasks.length}/${expectedTaskIds.length}`);
        console.info(`Remaining tasks: ${pendingTasks.map((t2) => t2.id).join(", ")}`);
        allTasksCompleted = pendingTasks.length === 0;
        if (allTasksCompleted) {
          console.info("All tasks completed! Breaking execution loop.");
          break;
        }
        const iterationPrompt = iterationCount === 1 ? executionPrompt : `${workflowBuilderPrompts.executionAgent.iterationPrompt({
          completedTasks,
          pendingTasks,
          workflowName,
          resumeData
        })}

${workflowBuilderPrompts.validation.instructions}`;
        const stream = await executionAgent.stream(iterationPrompt, {
          structuredOutput: {
            schema: TaskExecutionIterationInputSchema(tasks.length),
            model
          },
          ...enhancedOptions
        });
        let finalMessage = "";
        for await (const chunk of stream.fullStream) {
          if (chunk.type === "text-delta") {
            finalMessage += chunk.payload.text;
          }
          if (chunk.type === "step-finish") {
            console.info(finalMessage);
            finalMessage = "";
          }
          if (chunk.type === "tool-result") {
            console.info(JSON.stringify(chunk, null, 2));
          }
          if (chunk.type === "finish") {
            console.info(chunk);
          }
        }
        await stream.consumeStream();
        finalResult = await stream.object;
        console.info(`Iteration ${iterationCount} result:`, { finalResult });
        if (!finalResult) {
          throw new Error(`No result received from agent execution on iteration ${iterationCount}`);
        }
        const postIterationTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
        const postCompletedTasks = postIterationTaskStatus.tasks.filter((task) => task.status === "completed");
        const postPendingTasks = postIterationTaskStatus.tasks.filter((task) => task.status !== "completed");
        allTasksCompleted = postPendingTasks.length === 0;
        console.info(
          `After iteration ${iterationCount}: ${postCompletedTasks.length}/${expectedTaskIds.length} tasks completed in taskManager`
        );
        if (finalResult.status === "needs_clarification" && finalResult.questions && finalResult.questions.length > 0) {
          console.info(
            `Agent needs clarification on iteration ${iterationCount}: ${finalResult.questions.length} questions`
          );
          break;
        }
        if (finalResult.status === "completed" && !allTasksCompleted) {
          console.info(
            `Agent claimed completion but taskManager shows pending tasks: ${postPendingTasks.map((t2) => t2.id).join(", ")}`
          );
        }
      }
      if (iterationCount >= maxIterations && !allTasksCompleted) {
        finalResult.error = `Maximum iterations (${maxIterations}) reached but not all tasks completed`;
        finalResult.status = "in_progress";
      }
      if (!finalResult) {
        throw new Error("No result received from agent execution");
      }
      if (finalResult.status === "needs_clarification" && finalResult.questions && finalResult.questions.length > 0) {
        console.info(`Agent needs clarification: ${finalResult.questions.length} questions`);
        console.info("finalResult", JSON.stringify(finalResult, null, 2));
        return suspend({
          questions: finalResult.questions,
          currentProgress: finalResult.progress,
          completedTasks: finalResult.completedTasks || [],
          message: finalResult.message
        });
      }
      const finalTaskStatus = await AgentBuilderDefaults.manageTaskList({ action: "list" });
      const finalCompletedTasks = finalTaskStatus.tasks.filter((task) => task.status === "completed");
      const finalPendingTasks = finalTaskStatus.tasks.filter((task) => task.status !== "completed");
      const tasksCompleted = finalCompletedTasks.length;
      const tasksExpected = expectedTaskIds.length;
      const finalAllTasksCompleted = finalPendingTasks.length === 0;
      const success = finalAllTasksCompleted && !finalResult.error;
      const message = success ? `Successfully completed workflow ${action} - all ${tasksExpected} tasks completed after ${iterationCount} iteration(s): ${finalResult.message}` : `Workflow execution finished with issues after ${iterationCount} iteration(s): ${finalResult.message}. Completed: ${tasksCompleted}/${tasksExpected} tasks`;
      console.info(message);
      const missingTasks = finalPendingTasks.map((task) => task.id);
      const validationErrors = [];
      if (finalResult.error) {
        validationErrors.push(finalResult.error);
      }
      if (!finalAllTasksCompleted) {
        validationErrors.push(
          `Incomplete tasks: ${missingTasks.join(", ")} (${tasksCompleted}/${tasksExpected} completed)`
        );
      }
      return {
        success,
        completedTasks: finalCompletedTasks.map((task) => task.id),
        filesModified: finalResult.filesModified || [],
        validationResults: {
          passed: success,
          errors: validationErrors,
          warnings: finalAllTasksCompleted ? [] : [`Missing ${missingTasks.length} tasks: ${missingTasks.join(", ")}`]
        },
        message,
        error: finalResult.error
      };
    } catch (error) {
      console.error("Task execution failed:", error);
      return {
        success: false,
        completedTasks: [],
        filesModified: [],
        validationResults: {
          passed: false,
          errors: [`Task execution failed: ${error instanceof Error ? error.message : String(error)}`],
          warnings: []
        },
        message: `Task execution failed: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
});
var workflowBuilderWorkflow = workflows.createWorkflow({
  id: "workflow-builder",
  description: "Create or edit Mastra workflows using AI-powered assistance with iterative planning",
  inputSchema: WorkflowBuilderInputSchema,
  outputSchema: WorkflowBuilderResultSchema,
  steps: [
    workflowDiscoveryStep,
    projectDiscoveryStep,
    workflowResearchStep,
    planningAndApprovalWorkflow,
    taskExecutionStep
  ]
}).then(workflowDiscoveryStep).then(projectDiscoveryStep).then(workflowResearchStep).map(async ({ getStepResult, getInitData }) => {
  const initData = getInitData();
  const discoveryResult = getStepResult(workflowDiscoveryStep);
  const projectResult = getStepResult(projectDiscoveryStep);
  return {
    action: initData.action,
    workflowName: initData.workflowName,
    description: initData.description,
    requirements: initData.requirements,
    discoveredWorkflows: discoveryResult.workflows,
    projectStructure: projectResult,
    // research: researchResult,
    research: workflowResearch,
    userAnswers: void 0
  };
}).dountil(planningAndApprovalWorkflow, async ({ inputData }) => {
  console.info(`Sub-workflow check: approved=${inputData.approved}`);
  return inputData.approved === true;
}).map(async ({ getStepResult, getInitData }) => {
  const initData = getInitData();
  const discoveryResult = getStepResult(workflowDiscoveryStep);
  const projectResult = getStepResult(projectDiscoveryStep);
  const subWorkflowResult = getStepResult(planningAndApprovalWorkflow);
  return {
    action: initData.action,
    workflowName: initData.workflowName,
    description: initData.description,
    requirements: initData.requirements,
    tasks: subWorkflowResult.tasks,
    discoveredWorkflows: discoveryResult.workflows,
    projectStructure: projectResult,
    // research: researchResult,
    research: workflowResearch,
    projectPath: initData.projectPath || process.cwd()
  };
}).then(taskExecutionStep).commit();
var agentBuilderWorkflows = {
  "merge-template": agentBuilderTemplateWorkflow,
  "workflow-builder": workflowBuilderWorkflow
};
var actionIdPathParams = z18__default.default.object({
  actionId: z18__default.default.string().describe("Unique identifier for the agent-builder action")
});
var actionRunPathParams = z18__default.default.object({
  actionId: z18__default.default.string().describe("Unique identifier for the agent-builder action"),
  runId: z18__default.default.string().describe("Unique identifier for the action run")
});
var streamAgentBuilderBodySchema = chunkILV5M6C7_cjs.streamWorkflowBodySchema;
var streamLegacyAgentBuilderBodySchema = chunkILV5M6C7_cjs.streamLegacyWorkflowBodySchema;
var resumeAgentBuilderBodySchema = chunkILV5M6C7_cjs.resumeBodySchema;
var startAsyncAgentBuilderBodySchema = chunkILV5M6C7_cjs.startAsyncWorkflowBodySchema;

// src/server/handlers/agent-builder.ts
var LIST_AGENT_BUILDER_ACTIONS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agent-builder",
  responseType: "json",
  responseSchema: chunkILV5M6C7_cjs.listWorkflowsResponseSchema,
  summary: "List agent-builder actions",
  description: "Returns a list of all available agent-builder actions",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      logger.info("Listing agent builder actions");
      return await chunkILV5M6C7_cjs.LIST_WORKFLOWS_ROUTE.handler(ctx);
    } catch (error) {
      logger.error("Error listing agent builder actions", { error });
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent builder workflows");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agent-builder/:actionId",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  responseSchema: chunkILV5M6C7_cjs.workflowInfoSchema,
  summary: "Get action by ID",
  description: "Returns details for a specific agent-builder action",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, {
          message: `Invalid agent-builder action: ${actionId}. Valid actions are: ${Object.keys(agentBuilderWorkflows).join(", ")}`
        });
      }
      logger.info("Getting agent builder action by ID", { actionId });
      return await chunkILV5M6C7_cjs.GET_WORKFLOW_BY_ID_ROUTE.handler({ ...ctx, workflowId: actionId });
    } catch (error) {
      logger.error("Error getting agent builder action by ID", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agent-builder/:actionId/runs",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkILV5M6C7_cjs.listWorkflowRunsQuerySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowRunsResponseSchema,
  summary: "List action runs",
  description: "Returns a paginated list of execution runs for the specified action",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Listing agent builder action runs", { actionId });
      return await chunkILV5M6C7_cjs.LIST_WORKFLOW_RUNS_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error listing agent builder action runs", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent builder action runs");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agent-builder/:actionId/runs/:runId",
  responseType: "json",
  pathParamSchema: actionRunPathParams,
  queryParamSchema: chunkILV5M6C7_cjs.workflowRunResultQuerySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowRunResultSchema,
  summary: "Get action run by ID",
  description: "Returns details for a specific action run with metadata and processed execution state. Use the fields query parameter to reduce payload size.",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Getting agent builder action run by ID", { actionId, runId });
      return await chunkILV5M6C7_cjs.GET_WORKFLOW_RUN_BY_ID_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error getting agent builder action run", { error, actionId, runId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent builder action run");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/create-run",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.optionalRunIdSchema,
  responseSchema: chunkILV5M6C7_cjs.createWorkflowRunResponseSchema,
  summary: "Create action run",
  description: "Creates a new action execution instance with an optional custom run ID",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Creating agent builder action run", { actionId, runId });
      return await chunkILV5M6C7_cjs.CREATE_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error creating agent builder action run", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error creating agent builder action run");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var STREAM_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/stream",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: streamAgentBuilderBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.streamResponseSchema,
  summary: "Stream action execution",
  description: "Executes an action and streams the results in real-time",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Streaming agent builder action", { actionId, runId });
      return await chunkILV5M6C7_cjs.STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error streaming agent builder action", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error streaming agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var START_ASYNC_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/start-async",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.optionalRunIdSchema,
  bodySchema: startAsyncAgentBuilderBodySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowExecutionResultSchema,
  summary: "Start action asynchronously",
  description: "Starts an action execution asynchronously without streaming results",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Starting agent builder action asynchronously", { actionId, runId });
      return await chunkILV5M6C7_cjs.START_ASYNC_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error starting agent builder action asynchronously", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error starting agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var START_AGENT_BUILDER_ACTION_RUN_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/start",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: startAsyncAgentBuilderBodySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowControlResponseSchema,
  summary: "Start specific action run",
  description: "Starts execution of a specific action run by ID",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Starting specific agent builder action run", { actionId, runId });
      return await chunkILV5M6C7_cjs.START_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error starting agent builder action run", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error starting agent builder action run");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/observe",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  responseSchema: chunkBRI4GUZ2_cjs.streamResponseSchema,
  summary: "Observe action stream",
  description: "Observes and streams updates from an already running action execution",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Observing agent builder action stream", { actionId, runId });
      return await chunkILV5M6C7_cjs.OBSERVE_STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error observing agent builder action stream", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error observing agent builder action stream");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/resume-async",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowExecutionResultSchema,
  summary: "Resume action asynchronously",
  description: "Resumes a suspended action execution asynchronously without streaming",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action asynchronously", { actionId, runId, step });
      return await chunkILV5M6C7_cjs.RESUME_ASYNC_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action asynchronously", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error resuming agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/resume",
  responseType: "json",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: chunkILV5M6C7_cjs.workflowControlResponseSchema,
  summary: "Resume action",
  description: "Resumes a suspended action execution from a specific step",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action", { actionId, runId, step });
      return await chunkILV5M6C7_cjs.RESUME_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error resuming agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/resume-stream",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: resumeAgentBuilderBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.streamResponseSchema,
  summary: "Resume action stream",
  description: "Resumes a suspended action execution and continues streaming results",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, step, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Resuming agent builder action stream", { actionId, runId, step });
      return await chunkILV5M6C7_cjs.RESUME_STREAM_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error resuming agent builder action stream", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error resuming agent builder action stream");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/runs/:runId/cancel",
  responseType: "json",
  pathParamSchema: actionRunPathParams,
  responseSchema: chunkILV5M6C7_cjs.workflowControlResponseSchema,
  summary: "Cancel action run",
  description: "Cancels an in-progress action execution",
  tags: ["Agent Builder"],
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Cancelling agent builder action run", { actionId, runId });
      return await chunkILV5M6C7_cjs.CANCEL_WORKFLOW_RUN_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error cancelling agent builder action run", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error cancelling agent builder action run");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/stream-legacy",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  bodySchema: streamLegacyAgentBuilderBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.streamResponseSchema,
  summary: "[DEPRECATED] Stream agent-builder action with legacy format",
  description: "Legacy endpoint for streaming agent-builder action execution. Use /api/agent-builder/:actionId/stream instead.",
  tags: ["Agent Builder", "Legacy"],
  handler: async (ctx) => {
    const { mastra, actionId, runId, requestContext } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Streaming agent builder action (legacy)", { actionId, runId });
      return await chunkILV5M6C7_cjs.STREAM_LEGACY_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId,
        requestContext
      });
    } catch (error) {
      logger.error("Error streaming agent builder action (legacy)", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error streaming agent builder action");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});
var OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agent-builder/:actionId/observe-stream-legacy",
  responseType: "stream",
  pathParamSchema: actionIdPathParams,
  queryParamSchema: chunkMCYD5LW7_cjs.runIdSchema,
  responseSchema: chunkBRI4GUZ2_cjs.streamResponseSchema,
  summary: "[DEPRECATED] Observe agent-builder action stream with legacy format",
  description: "Legacy endpoint for observing agent-builder action stream. Use /api/agent-builder/:actionId/observe instead.",
  tags: ["Agent Builder", "Legacy"],
  handler: async (ctx) => {
    const { mastra, actionId, runId } = ctx;
    const logger = mastra.getLogger();
    try {
      chunkGWLR6K3H_cjs.WorkflowRegistry.registerTemporaryWorkflows(agentBuilderWorkflows, mastra);
      if (actionId && !chunkGWLR6K3H_cjs.WorkflowRegistry.isAgentBuilderWorkflow(actionId)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: `Invalid agent-builder action: ${actionId}` });
      }
      logger.info("Observing agent builder action stream (legacy)", { actionId, runId });
      return await chunkILV5M6C7_cjs.OBSERVE_STREAM_LEGACY_WORKFLOW_ROUTE.handler({
        ...ctx,
        workflowId: actionId
      });
    } catch (error) {
      logger.error("Error observing agent builder action stream (legacy)", { error, actionId });
      return chunkSUKFO7UM_cjs.handleError(error, "Error observing agent builder action stream");
    } finally {
      chunkGWLR6K3H_cjs.WorkflowRegistry.cleanup();
    }
  }
});

exports.CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE = CANCEL_AGENT_BUILDER_ACTION_RUN_ROUTE;
exports.CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE = CREATE_AGENT_BUILDER_ACTION_RUN_ROUTE;
exports.GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE = GET_AGENT_BUILDER_ACTION_BY_ID_ROUTE;
exports.GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE = GET_AGENT_BUILDER_ACTION_RUN_BY_ID_ROUTE;
exports.LIST_AGENT_BUILDER_ACTIONS_ROUTE = LIST_AGENT_BUILDER_ACTIONS_ROUTE;
exports.LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE = LIST_AGENT_BUILDER_ACTION_RUNS_ROUTE;
exports.OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE = OBSERVE_STREAM_AGENT_BUILDER_ACTION_ROUTE;
exports.OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = OBSERVE_STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE;
exports.RESUME_AGENT_BUILDER_ACTION_ROUTE = RESUME_AGENT_BUILDER_ACTION_ROUTE;
exports.RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE = RESUME_ASYNC_AGENT_BUILDER_ACTION_ROUTE;
exports.RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE = RESUME_STREAM_AGENT_BUILDER_ACTION_ROUTE;
exports.START_AGENT_BUILDER_ACTION_RUN_ROUTE = START_AGENT_BUILDER_ACTION_RUN_ROUTE;
exports.START_ASYNC_AGENT_BUILDER_ACTION_ROUTE = START_ASYNC_AGENT_BUILDER_ACTION_ROUTE;
exports.STREAM_AGENT_BUILDER_ACTION_ROUTE = STREAM_AGENT_BUILDER_ACTION_ROUTE;
exports.STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE = STREAM_LEGACY_AGENT_BUILDER_ACTION_ROUTE;
exports.agent_builder_exports = agent_builder_exports;
//# sourceMappingURL=chunk-TENMF4X2.cjs.map
//# sourceMappingURL=chunk-TENMF4X2.cjs.map