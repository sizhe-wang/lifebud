'use strict';

var chunk5W4RPVTK_cjs = require('./chunk-5W4RPVTK.cjs');
var chunkBRI4GUZ2_cjs = require('./chunk-BRI4GUZ2.cjs');
var chunkAVRO3FIN_cjs = require('./chunk-AVRO3FIN.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var stream = require('stream');
var error = require('@mastra/core/error');

// src/server/handlers/voice.ts
var voice_exports = {};
chunkO7I5CWRX_cjs.__export(voice_exports, {
  GENERATE_SPEECH_DEPRECATED_ROUTE: () => GENERATE_SPEECH_DEPRECATED_ROUTE,
  GENERATE_SPEECH_ROUTE: () => GENERATE_SPEECH_ROUTE,
  GET_LISTENER_ROUTE: () => GET_LISTENER_ROUTE,
  GET_SPEAKERS_DEPRECATED_ROUTE: () => GET_SPEAKERS_DEPRECATED_ROUTE,
  GET_SPEAKERS_ROUTE: () => GET_SPEAKERS_ROUTE,
  TRANSCRIBE_SPEECH_DEPRECATED_ROUTE: () => TRANSCRIBE_SPEECH_DEPRECATED_ROUTE,
  TRANSCRIBE_SPEECH_ROUTE: () => TRANSCRIBE_SPEECH_ROUTE
});
var GET_SPEAKERS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agents/:agentId/voice/speakers",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  responseSchema: chunkBRI4GUZ2_cjs.voiceSpeakersResponseSchema,
  summary: "Get voice speakers",
  description: "Returns available voice speakers for the specified agent",
  tags: ["Agents", "Voice"],
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      const speakers = await Promise.resolve().then(() => voice.getSpeakers()).catch((err) => {
        if (err instanceof error.MastraError) {
          return [];
        }
        throw err;
      });
      return speakers;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting speakers");
    }
  }
});
var GET_SPEAKERS_DEPRECATED_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agents/:agentId/speakers",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  responseSchema: chunkBRI4GUZ2_cjs.voiceSpeakersResponseSchema,
  summary: "Get available speakers for an agent",
  description: "[DEPRECATED] Use /api/agents/:agentId/voice/speakers instead. Get available speakers for an agent",
  tags: ["Agents", "Voice"],
  handler: GET_SPEAKERS_ROUTE.handler
});
var GENERATE_SPEECH_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agents/:agentId/voice/speak",
  responseType: "stream",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  bodySchema: chunkBRI4GUZ2_cjs.generateSpeechBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.speakResponseSchema,
  summary: "Generate speech",
  description: "Generates speech audio from text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  handler: async ({ mastra, agentId, text, speakerId, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      chunk5W4RPVTK_cjs.validateBody({ text });
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = await Promise.resolve().then(() => voice.speak(text, { speaker: speakerId })).catch((err) => {
        if (err instanceof error.MastraError) {
          throw new chunk64ITUOXI_cjs.HTTPException(400, { message: err.message });
        }
        throw err;
      });
      if (!audioStream) {
        throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Failed to generate speech" });
      }
      return audioStream;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error generating speech");
    }
  }
});
var GENERATE_SPEECH_DEPRECATED_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agents/:agentId/speak",
  responseType: "stream",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  bodySchema: chunkBRI4GUZ2_cjs.generateSpeechBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.speakResponseSchema,
  summary: "Convert text to speech",
  description: "[DEPRECATED] Use /api/agents/:agentId/voice/speak instead. Convert text to speech using the agent's voice provider",
  tags: ["Agents", "Voice"],
  handler: GENERATE_SPEECH_ROUTE.handler
});
var TRANSCRIBE_SPEECH_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agents/:agentId/voice/listen",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  bodySchema: chunkBRI4GUZ2_cjs.transcribeSpeechBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.transcribeSpeechResponseSchema,
  summary: "Transcribe speech",
  description: "Transcribes speech audio to text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  handler: async ({ mastra, agentId, audio, options, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      if (!audio) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Audio data is required" });
      }
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = new stream.Readable();
      audioStream.push(audio);
      audioStream.push(null);
      const text = await voice.listen(audioStream, options);
      return { text };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error transcribing speech");
    }
  }
});
var TRANSCRIBE_SPEECH_DEPRECATED_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/agents/:agentId/listen",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  bodySchema: chunkBRI4GUZ2_cjs.transcribeSpeechBodySchema,
  responseSchema: chunkBRI4GUZ2_cjs.transcribeSpeechResponseSchema,
  summary: "Convert speech to text",
  description: "[DEPRECATED] Use /api/agents/:agentId/voice/listen instead. Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.",
  tags: ["Agents", "Voice"],
  handler: TRANSCRIBE_SPEECH_ROUTE.handler
});
var GET_LISTENER_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/agents/:agentId/voice/listener",
  responseType: "json",
  pathParamSchema: chunkBRI4GUZ2_cjs.agentIdPathParams,
  responseSchema: chunkBRI4GUZ2_cjs.getListenerResponseSchema,
  summary: "Get voice listener",
  description: "Returns the voice listener configuration for the agent",
  tags: ["Agents", "Voice"],
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      const listeners = await Promise.resolve().then(() => voice.getListener()).catch((err) => {
        if (err instanceof error.MastraError) {
          return { enabled: false };
        }
        throw err;
      });
      return listeners;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting listeners");
    }
  }
});

exports.GENERATE_SPEECH_DEPRECATED_ROUTE = GENERATE_SPEECH_DEPRECATED_ROUTE;
exports.GENERATE_SPEECH_ROUTE = GENERATE_SPEECH_ROUTE;
exports.GET_LISTENER_ROUTE = GET_LISTENER_ROUTE;
exports.GET_SPEAKERS_DEPRECATED_ROUTE = GET_SPEAKERS_DEPRECATED_ROUTE;
exports.GET_SPEAKERS_ROUTE = GET_SPEAKERS_ROUTE;
exports.TRANSCRIBE_SPEECH_DEPRECATED_ROUTE = TRANSCRIBE_SPEECH_DEPRECATED_ROUTE;
exports.TRANSCRIBE_SPEECH_ROUTE = TRANSCRIBE_SPEECH_ROUTE;
exports.voice_exports = voice_exports;
//# sourceMappingURL=chunk-UK4FZWNW.cjs.map
//# sourceMappingURL=chunk-UK4FZWNW.cjs.map