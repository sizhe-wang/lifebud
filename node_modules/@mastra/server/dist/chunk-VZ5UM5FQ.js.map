{"version":3,"sources":["../src/server/handlers/memory.ts","../src/server/schemas/memory.ts"],"names":["agents"],"mappings":"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","file":"chunk-VZ5UM5FQ.js","sourcesContent":["import type { MastraDBMessage } from '@mastra/core/agent';\nimport type { RequestContext } from '@mastra/core/di';\nimport type { MastraMemory } from '@mastra/core/memory';\nimport type { MastraStorage } from '@mastra/core/storage';\nimport { generateEmptyFromSchema } from '@mastra/core/utils';\nimport { HTTPException } from '../http-exception';\nimport {\n  threadIdPathParams,\n  agentIdQuerySchema,\n  getMemoryStatusQuerySchema,\n  getMemoryConfigQuerySchema,\n  listThreadsQuerySchema,\n  getThreadByIdQuerySchema,\n  listMessagesQuerySchema,\n  getWorkingMemoryQuerySchema,\n  getMemoryStatusNetworkQuerySchema,\n  listThreadsNetworkQuerySchema,\n  getThreadByIdNetworkQuerySchema,\n  listMessagesNetworkQuerySchema,\n  saveMessagesNetworkQuerySchema,\n  createThreadNetworkQuerySchema,\n  updateThreadNetworkQuerySchema,\n  deleteThreadNetworkQuerySchema,\n  deleteMessagesNetworkQuerySchema,\n  memoryStatusResponseSchema,\n  memoryConfigResponseSchema,\n  listThreadsResponseSchema,\n  getThreadByIdResponseSchema,\n  listMessagesResponseSchema,\n  getWorkingMemoryResponseSchema,\n  saveMessagesBodySchema,\n  createThreadBodySchema,\n  updateThreadBodySchema,\n  updateWorkingMemoryBodySchema,\n  deleteMessagesBodySchema,\n  searchMemoryQuerySchema,\n  saveMessagesResponseSchema,\n  updateWorkingMemoryResponseSchema,\n  searchMemoryResponseSchema,\n  deleteThreadResponseSchema,\n  deleteMessagesResponseSchema,\n  cloneThreadBodySchema,\n  cloneThreadResponseSchema,\n} from '../schemas/memory';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\nimport { validateBody } from './utils';\n\ninterface MemoryContext extends Context {\n  agentId?: string;\n  resourceId?: string;\n  threadId?: string;\n  requestContext?: RequestContext;\n}\n\ninterface SearchResult {\n  id: string;\n  role: string;\n  content: string;\n  createdAt: Date;\n  threadId?: string;\n  threadTitle?: string;\n  score?: number;\n  context?: {\n    before?: SearchResult[];\n    after?: SearchResult[];\n  };\n}\n\nexport function getTextContent(message: MastraDBMessage): string {\n  if (typeof message.content === 'string') {\n    return message.content;\n  }\n  if (message.content && typeof message.content === 'object' && 'parts' in message.content) {\n    const textPart = message.content.parts.find(p => p.type === 'text');\n    return textPart?.text || '';\n  }\n  return '';\n}\n\nasync function getMemoryFromContext({\n  mastra,\n  agentId,\n  requestContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'requestContext'>): Promise<MastraMemory | null | undefined> {\n  const logger = mastra.getLogger();\n  let agent;\n  if (agentId) {\n    try {\n      agent = mastra.getAgentById(agentId);\n    } catch (error) {\n      logger.debug('Error getting agent from mastra, searching agents for agent', error);\n    }\n  }\n  if (agentId && !agent) {\n    logger.debug('Agent not found, searching agents for agent', { agentId });\n    const agents = mastra.listAgents();\n    if (Object.keys(agents || {}).length) {\n      for (const [_, ag] of Object.entries(agents)) {\n        try {\n          const agents = await ag.listAgents();\n\n          if (agents[agentId]) {\n            agent = agents[agentId];\n            break;\n          }\n        } catch (error) {\n          logger.debug('Error getting agent from agent', error);\n        }\n      }\n    }\n\n    if (!agent) {\n      throw new HTTPException(404, { message: 'Agent not found' });\n    }\n  }\n\n  if (agent) {\n    return await agent?.getMemory({\n      requestContext,\n    });\n  }\n}\n\n/**\n * Gets the storage from context, used as a fallback when no agentId is provided.\n * This allows fetching threads/messages without knowing which agents were involved.\n */\nfunction getStorageFromContext({ mastra }: Pick<MemoryContext, 'mastra'>): MastraStorage | undefined {\n  return mastra.getStorage();\n}\n\n// ============================================================================\n// Route Definitions (new pattern - handlers defined inline with createRoute)\n// ============================================================================\n\nexport const GET_MEMORY_STATUS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/status',\n  responseType: 'json',\n  queryParamSchema: getMemoryStatusQuerySchema,\n  responseSchema: memoryStatusResponseSchema,\n  summary: 'Get memory status',\n  description: 'Returns the current status of the memory system including configuration and health information',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        return { result: true };\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          return { result: true };\n        }\n      }\n\n      return { result: false };\n    } catch (error) {\n      return handleError(error, 'Error getting memory status');\n    }\n  },\n});\n\nexport const GET_MEMORY_CONFIG_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/config',\n  responseType: 'json',\n  queryParamSchema: getMemoryConfigQuerySchema,\n  responseSchema: memoryConfigResponseSchema,\n  summary: 'Get memory configuration',\n  description: 'Returns the memory configuration for a specific agent or the system default',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Get the merged configuration (defaults + custom)\n      const config = memory.getMergedThreadConfig({});\n\n      return { config };\n    } catch (error) {\n      return handleError(error, 'Error getting memory configuration');\n    }\n  },\n});\n\nexport const LIST_THREADS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/threads',\n  responseType: 'json',\n  queryParamSchema: listThreadsQuerySchema,\n  responseSchema: listThreadsResponseSchema,\n  summary: 'List memory threads',\n  description: 'Returns a paginated list of conversation threads filtered by resource ID',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, resourceId, requestContext, page, perPage, orderBy }) => {\n    try {\n      validateBody({ resourceId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        const result = await memory.listThreadsByResourceId({\n          resourceId: resourceId!,\n          page,\n          perPage,\n          orderBy,\n        });\n        return result;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const result = await memoryStore.listThreadsByResourceId({\n              resourceId: resourceId!,\n              page,\n              perPage,\n              orderBy,\n            });\n            return result;\n          }\n        }\n      }\n\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    } catch (error) {\n      return handleError(error, 'Error listing threads');\n    }\n  },\n});\n\nexport const GET_THREAD_BY_ID_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getThreadByIdQuerySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Get thread by ID',\n  description: 'Returns details for a specific conversation thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, requestContext }) => {\n    try {\n      validateBody({ threadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (memory) {\n        const thread = await memory.getThreadById({ threadId: threadId! });\n        if (!thread) {\n          throw new HTTPException(404, { message: 'Thread not found' });\n        }\n        return thread;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const thread = await memoryStore.getThreadById({ threadId: threadId! });\n            if (!thread) {\n              throw new HTTPException(404, { message: 'Thread not found' });\n            }\n            return thread;\n          }\n        }\n      }\n\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    } catch (error) {\n      return handleError(error, 'Error getting thread');\n    }\n  },\n});\n\nexport const LIST_MESSAGES_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/threads/:threadId/messages',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: listMessagesQuerySchema,\n  responseSchema: listMessagesResponseSchema,\n  summary: 'List thread messages',\n  description: 'Returns a paginated list of messages in a conversation thread',\n  tags: ['Memory'],\n  handler: async ({\n    mastra,\n    agentId,\n    threadId,\n    resourceId,\n    perPage,\n    page,\n    orderBy,\n    include,\n    filter,\n    requestContext,\n  }) => {\n    try {\n      validateBody({ threadId });\n\n      if (!threadId) {\n        throw new HTTPException(400, { message: 'No threadId found' });\n      }\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        const thread = await memory.getThreadById({ threadId: threadId });\n        if (!thread) {\n          throw new HTTPException(404, { message: 'Thread not found' });\n        }\n\n        const result = await memory.recall({\n          threadId: threadId,\n          resourceId,\n          perPage,\n          page,\n          orderBy,\n          include,\n          filter,\n        });\n        return result;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const thread = await memoryStore.getThreadById({ threadId: threadId });\n            if (!thread) {\n              throw new HTTPException(404, { message: 'Thread not found' });\n            }\n\n            const result = await memoryStore.listMessages({\n              threadId: threadId,\n              resourceId,\n              perPage,\n              page,\n              orderBy,\n              include,\n              filter,\n            });\n            return result;\n          }\n        }\n      }\n\n      // Return empty messages when memory is not configured (Issue #11765)\n      // This allows the playground UI to gracefully handle agents without memory\n      return { messages: [], uiMessages: [] };\n    } catch (error) {\n      return handleError(error, 'Error getting messages');\n    }\n  },\n});\n\nexport const GET_WORKING_MEMORY_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/threads/:threadId/working-memory',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getWorkingMemoryQuerySchema,\n  responseSchema: getWorkingMemoryResponseSchema,\n  summary: 'Get working memory',\n  description: 'Returns the working memory state for a thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, resourceId, requestContext, memoryConfig }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      validateBody({ threadId });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n      const thread = await memory.getThreadById({ threadId: threadId! });\n      const threadExists = !!thread;\n      const template = await memory.getWorkingMemoryTemplate({ memoryConfig });\n      const workingMemoryTemplate =\n        template?.format === 'json'\n          ? { ...template, content: JSON.stringify(generateEmptyFromSchema(template.content)) }\n          : template;\n      const workingMemory = await memory.getWorkingMemory({ threadId: threadId!, resourceId, memoryConfig });\n      const config = memory.getMergedThreadConfig(memoryConfig || {});\n      const source: 'thread' | 'resource' =\n        config.workingMemory?.scope !== 'thread' && resourceId ? 'resource' : 'thread';\n      return { workingMemory, source, workingMemoryTemplate, threadExists };\n    } catch (error) {\n      return handleError(error, 'Error getting working memory');\n    }\n  },\n});\n\nexport const SAVE_MESSAGES_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/save-messages',\n  responseType: 'json',\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: saveMessagesBodySchema,\n  responseSchema: saveMessagesResponseSchema,\n  summary: 'Save messages',\n  description: 'Saves new messages to memory',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, messages, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      if (!messages) {\n        throw new HTTPException(400, { message: 'Messages are required' });\n      }\n\n      if (!Array.isArray(messages)) {\n        throw new HTTPException(400, { message: 'Messages should be an array' });\n      }\n\n      // Validate that all messages have threadId and resourceId\n      const invalidMessages = messages.filter(message => !message.threadId || !message.resourceId);\n      if (invalidMessages.length > 0) {\n        throw new HTTPException(400, {\n          message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`,\n        });\n      }\n\n      const processedMessages = messages.map(message => ({\n        ...message,\n        id: message.id || memory.generateId(),\n        createdAt: message.createdAt ? new Date(message.createdAt) : new Date(),\n      }));\n\n      const result = await memory.saveMessages({ messages: processedMessages as any, memoryConfig: {} });\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error saving messages');\n    }\n  },\n});\n\nexport const CREATE_THREAD_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/threads',\n  responseType: 'json',\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: createThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Create thread',\n  description: 'Creates a new conversation thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, resourceId, title, metadata, threadId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      validateBody({ resourceId });\n\n      const result = await memory.createThread({\n        resourceId: resourceId!,\n        title,\n        metadata,\n        threadId,\n      });\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error saving thread to memory');\n    }\n  },\n});\n\nexport const UPDATE_THREAD_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/api/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: updateThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Update thread',\n  description: 'Updates a conversation thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, title, metadata, resourceId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      const updatedAt = new Date();\n\n      validateBody({ threadId });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      const thread = await memory.getThreadById({ threadId: threadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n\n      const updatedThread = {\n        ...thread,\n        title: title || thread.title,\n        metadata: metadata || thread.metadata,\n        resourceId: resourceId || thread.resourceId,\n        createdAt: thread.createdAt,\n        updatedAt,\n      };\n\n      const result = await memory.saveThread({ thread: updatedThread });\n      return {\n        ...result,\n        resourceId: result.resourceId ?? null,\n      };\n    } catch (error) {\n      return handleError(error, 'Error updating thread');\n    }\n  },\n});\n\nexport const DELETE_THREAD_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/api/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  responseSchema: deleteThreadResponseSchema,\n  summary: 'Delete thread',\n  description: 'Deletes a conversation thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, requestContext }) => {\n    try {\n      validateBody({ threadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      const thread = await memory.getThreadById({ threadId: threadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n\n      await memory.deleteThread(threadId!);\n      return { result: 'Thread deleted' };\n    } catch (error) {\n      return handleError(error, 'Error deleting thread');\n    }\n  },\n});\n\nexport const CLONE_THREAD_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/threads/:threadId/clone',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: cloneThreadBodySchema,\n  responseSchema: cloneThreadResponseSchema,\n  summary: 'Clone thread',\n  description: 'Creates a copy of a conversation thread with all its messages',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, newThreadId, resourceId, title, metadata, options, requestContext }) => {\n    try {\n      validateBody({ threadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      const result = await memory.cloneThread({\n        sourceThreadId: threadId!,\n        newThreadId,\n        resourceId,\n        title,\n        metadata,\n        options,\n      });\n\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error cloning thread');\n    }\n  },\n});\n\nexport const UPDATE_WORKING_MEMORY_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/threads/:threadId/working-memory',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: updateWorkingMemoryBodySchema,\n  responseSchema: updateWorkingMemoryResponseSchema,\n  summary: 'Update working memory',\n  description: 'Updates the working memory state for a thread',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, threadId, resourceId, memoryConfig, workingMemory, requestContext }) => {\n    try {\n      validateBody({ threadId, workingMemory });\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n      const thread = await memory.getThreadById({ threadId: threadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n\n      await memory.updateWorkingMemory({ threadId: threadId!, resourceId, workingMemory, memoryConfig });\n      return { success: true };\n    } catch (error) {\n      return handleError(error, 'Error updating working memory');\n    }\n  },\n});\n\nexport const DELETE_MESSAGES_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/messages/delete',\n  responseType: 'json',\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: deleteMessagesBodySchema,\n  responseSchema: deleteMessagesResponseSchema,\n  summary: 'Delete messages',\n  description: 'Deletes specific messages from memory',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, messageIds, requestContext }) => {\n    try {\n      if (messageIds === undefined || messageIds === null) {\n        throw new HTTPException(400, { message: 'messageIds is required' });\n      }\n\n      // Normalize messageIds to the format expected by deleteMessages\n      // Convert single values to arrays and extract IDs from objects\n      let normalizedIds: string[] | { id: string }[];\n\n      if (Array.isArray(messageIds)) {\n        // Already an array - keep as is (could be string[] or { id: string }[])\n        normalizedIds = messageIds;\n      } else if (typeof messageIds === 'string') {\n        // Single string ID - wrap in array\n        normalizedIds = [messageIds];\n      } else {\n        // Single object with id property - wrap in array\n        normalizedIds = [messageIds];\n      }\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (memory) {\n        await memory.deleteMessages(normalizedIds);\n      } else if (!agentId) {\n        // Only fallback to storage if no agentId was provided\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            // Extract string IDs from the normalized array\n            const stringIds = normalizedIds.map(id => (typeof id === 'string' ? id : id.id));\n            await memoryStore.deleteMessages(stringIds);\n          } else {\n            throw new HTTPException(400, { message: 'Memory is not initialized' });\n          }\n        } else {\n          throw new HTTPException(400, { message: 'Memory is not initialized' });\n        }\n      } else {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Count messages for response\n      const count = Array.isArray(messageIds) ? messageIds.length : 1;\n\n      return { success: true, message: `${count} message${count === 1 ? '' : 's'} deleted successfully` };\n    } catch (error) {\n      return handleError(error, 'Error deleting messages');\n    }\n  },\n});\n\nexport const SEARCH_MEMORY_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/search',\n  responseType: 'json',\n  queryParamSchema: searchMemoryQuerySchema,\n  responseSchema: searchMemoryResponseSchema,\n  summary: 'Search memory',\n  description: 'Searches across memory using semantic or text search',\n  tags: ['Memory'],\n  handler: async ({ mastra, agentId, searchQuery, resourceId, threadId, limit = 20, requestContext, memoryConfig }) => {\n    try {\n      validateBody({ searchQuery, resourceId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Get memory configuration first to check scope\n      const config = memory.getMergedThreadConfig(memoryConfig || {});\n      const hasSemanticRecall = !!config?.semanticRecall;\n      const resourceScope =\n        typeof config?.semanticRecall === 'object' ? config?.semanticRecall?.scope !== 'thread' : true;\n\n      const searchResults: SearchResult[] = [];\n\n      // If threadId is provided and scope is thread-based, check if the thread exists\n      if (threadId && !resourceScope) {\n        const thread = await memory.getThreadById({ threadId });\n        if (!thread) {\n          // Thread doesn't exist yet (new unsaved thread) - return empty results\n          return {\n            results: [],\n            count: 0,\n            query: searchQuery,\n            searchScope: resourceScope ? 'resource' : 'thread',\n            searchType: hasSemanticRecall ? 'semantic' : 'text',\n          };\n        }\n        if (thread.resourceId !== resourceId) {\n          throw new HTTPException(403, { message: 'Thread does not belong to the specified resource' });\n        }\n      }\n\n      // If no threadId provided, get one from the resource\n      if (!threadId) {\n        const { threads } = await memory.listThreadsByResourceId({\n          resourceId,\n          page: 0,\n          perPage: 1,\n          orderBy: { field: 'updatedAt', direction: 'DESC' },\n        });\n\n        if (threads.length === 0) {\n          return {\n            results: [],\n            count: 0,\n            query: searchQuery,\n            searchScope: resourceScope ? 'resource' : 'thread',\n            searchType: hasSemanticRecall ? 'semantic' : 'text',\n          };\n        }\n\n        // Use first thread - Memory class will handle scope internally\n        threadId = threads[0]!.id;\n      }\n\n      const beforeRange =\n        typeof config.semanticRecall === `boolean`\n          ? 2\n          : typeof config.semanticRecall?.messageRange === `number`\n            ? config.semanticRecall.messageRange\n            : config.semanticRecall?.messageRange.before || 2;\n      const afterRange =\n        typeof config.semanticRecall === `boolean`\n          ? 2\n          : typeof config.semanticRecall?.messageRange === `number`\n            ? config.semanticRecall.messageRange\n            : config.semanticRecall?.messageRange.after || 2;\n\n      if (resourceScope && config.semanticRecall) {\n        config.semanticRecall =\n          typeof config.semanticRecall === `boolean`\n            ? // make message range 0 so we can highlight the matches in search, message range will include other messages, not the matching ones\n              // and we add prev/next messages in a special section on each message anyway\n              { messageRange: 0, topK: 2, scope: 'resource' }\n            : { ...config.semanticRecall, messageRange: 0 };\n      }\n\n      // Single call to recall - just like the agent does\n      // The Memory class handles scope (thread vs resource) internally\n      const threadConfig = memory.getMergedThreadConfig(config || {});\n      if (!threadConfig.lastMessages && !threadConfig.semanticRecall) {\n        return { results: [], count: 0, query: searchQuery };\n      }\n\n      const result = await memory.recall({\n        threadId,\n        resourceId,\n        perPage: threadConfig.lastMessages,\n        threadConfig: config,\n        vectorSearchString: threadConfig.semanticRecall && searchQuery ? searchQuery : undefined,\n      });\n\n      // Get all threads to build context and show which thread each message is from\n      // Fetch threads by IDs from the actual messages to avoid truncation\n      const threadIds = Array.from(\n        new Set(result.messages.map((m: MastraDBMessage) => m.threadId || threadId!).filter(Boolean)),\n      );\n      const fetched = await Promise.all(threadIds.map((id: string) => memory.getThreadById({ threadId: id })));\n      const threadMap = new Map(fetched.filter(Boolean).map(t => [t!.id, t!]));\n\n      // Process each message in the results\n      for (const msg of result.messages) {\n        const content = getTextContent(msg);\n\n        const msgThreadId = msg.threadId || threadId;\n        const thread = threadMap.get(msgThreadId);\n\n        // Get thread messages for context\n        const threadMessages = (await memory.recall({ threadId: msgThreadId })).messages;\n        const messageIndex = threadMessages.findIndex(m => m.id === msg.id);\n\n        const searchResult: SearchResult = {\n          id: msg.id,\n          role: msg.role,\n          content,\n          createdAt: msg.createdAt,\n          threadId: msgThreadId,\n          threadTitle: thread?.title || msgThreadId,\n        };\n\n        if (messageIndex !== -1) {\n          searchResult.context = {\n            before: threadMessages.slice(Math.max(0, messageIndex - beforeRange), messageIndex).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: getTextContent(m),\n              createdAt: m.createdAt || new Date(),\n            })),\n            after: threadMessages.slice(messageIndex + 1, messageIndex + afterRange + 1).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: getTextContent(m),\n              createdAt: m.createdAt || new Date(),\n            })),\n          };\n        }\n\n        searchResults.push(searchResult);\n      }\n\n      // Sort by date (newest first) and limit\n      const sortedResults = searchResults\n        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n        .slice(0, limit);\n\n      return {\n        results: sortedResults,\n        count: sortedResults.length,\n        query: searchQuery,\n        searchScope: resourceScope ? 'resource' : 'thread',\n        searchType: hasSemanticRecall ? 'semantic' : 'text',\n      };\n    } catch (error) {\n      return handleError(error, 'Error searching memory');\n    }\n  },\n});\n\n// Network routes (same handlers with /network/ prefix)\nexport const GET_MEMORY_STATUS_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/network/status',\n  responseType: 'json',\n  queryParamSchema: getMemoryStatusNetworkQuerySchema,\n  responseSchema: memoryStatusResponseSchema,\n  summary: 'Get memory status (network)',\n  description: 'Returns the current status of the memory system (network route)',\n  tags: ['Memory - Network'],\n  handler: GET_MEMORY_STATUS_ROUTE.handler,\n});\n\nexport const LIST_THREADS_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/network/threads',\n  responseType: 'json',\n  queryParamSchema: listThreadsNetworkQuerySchema,\n  responseSchema: listThreadsResponseSchema,\n  summary: 'List memory threads (network)',\n  description: 'Returns a paginated list of conversation threads (network route)',\n  tags: ['Memory - Network'],\n  handler: LIST_THREADS_ROUTE.handler,\n});\n\nexport const GET_THREAD_BY_ID_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getThreadByIdNetworkQuerySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Get thread by ID (network)',\n  description: 'Returns details for a specific conversation thread (network route)',\n  tags: ['Memory - Network'],\n  handler: GET_THREAD_BY_ID_ROUTE.handler,\n});\n\nexport const LIST_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/memory/network/threads/:threadId/messages',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: listMessagesNetworkQuerySchema,\n  responseSchema: listMessagesResponseSchema,\n  summary: 'List thread messages (network)',\n  description: 'Returns a paginated list of messages in a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  handler: LIST_MESSAGES_ROUTE.handler,\n});\n\nexport const SAVE_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/network/save-messages',\n  responseType: 'json',\n  queryParamSchema: saveMessagesNetworkQuerySchema,\n  bodySchema: saveMessagesBodySchema,\n  responseSchema: saveMessagesResponseSchema,\n  summary: 'Save messages (network)',\n  description: 'Saves new messages to memory (network route)',\n  tags: ['Memory - Network'],\n  handler: SAVE_MESSAGES_ROUTE.handler,\n});\n\nexport const CREATE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/network/threads',\n  responseType: 'json',\n  queryParamSchema: createThreadNetworkQuerySchema,\n  bodySchema: createThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Create thread (network)',\n  description: 'Creates a new conversation thread (network route)',\n  tags: ['Memory - Network'],\n  handler: CREATE_THREAD_ROUTE.handler,\n});\n\nexport const UPDATE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/api/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: updateThreadNetworkQuerySchema,\n  bodySchema: updateThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Update thread (network)',\n  description: 'Updates a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  handler: UPDATE_THREAD_ROUTE.handler,\n});\n\nexport const DELETE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/api/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: deleteThreadNetworkQuerySchema,\n  responseSchema: deleteThreadResponseSchema,\n  summary: 'Delete thread (network)',\n  description: 'Deletes a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  handler: DELETE_THREAD_ROUTE.handler,\n});\n\nexport const DELETE_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/memory/network/messages/delete',\n  responseType: 'json',\n  queryParamSchema: deleteMessagesNetworkQuerySchema,\n  bodySchema: deleteMessagesBodySchema,\n  responseSchema: deleteMessagesResponseSchema,\n  summary: 'Delete messages (network)',\n  description: 'Deletes specific messages from memory (network route)',\n  tags: ['Memory - Network'],\n  handler: DELETE_MESSAGES_ROUTE.handler,\n});\n","import z from 'zod';\nimport { paginationInfoSchema, createPagePaginationSchema, successResponseSchema } from './common';\n\n// Path parameter schemas\nexport const threadIdPathParams = z.object({\n  threadId: z.string().describe('Unique identifier for the conversation thread'),\n});\n\n/**\n * Common query parameter: required agent ID\n */\nexport const agentIdQuerySchema = z.object({\n  agentId: z.string(),\n});\n\n/**\n * Common query parameter: optional agent ID\n * Used for read operations that can fall back to storage when agentId is not provided\n */\nexport const optionalAgentIdQuerySchema = z.object({\n  agentId: z.string().optional(),\n});\n\n/**\n * Storage order by configuration for threads and agents (have both createdAt and updatedAt)\n * Handles JSON parsing from query strings\n */\nconst storageOrderBySchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      field: z.enum(['createdAt', 'updatedAt']).optional(),\n      direction: z.enum(['ASC', 'DESC']).optional(),\n    })\n    .optional(),\n);\n\n/**\n * Storage order by configuration for messages (only have createdAt)\n * Handles JSON parsing from query strings\n */\nconst messageOrderBySchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      field: z.enum(['createdAt']).optional(),\n      direction: z.enum(['ASC', 'DESC']).optional(),\n    })\n    .optional(),\n);\n\n/**\n * Include schema for message listing - handles JSON parsing from query strings\n */\nconst includeSchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .array(\n      z.object({\n        id: z.string(),\n        threadId: z.string().optional(),\n        withPreviousMessages: z.number().optional(),\n        withNextMessages: z.number().optional(),\n      }),\n    )\n    .optional(),\n);\n\n/**\n * Filter schema for message listing - handles JSON parsing from query strings\n */\nconst filterSchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      dateRange: z\n        .object({\n          start: z.coerce.date().optional(),\n          end: z.coerce.date().optional(),\n        })\n        .optional(),\n    })\n    .optional(),\n);\n\n/**\n * Memory config schema - handles JSON parsing from query strings\n */\nconst memoryConfigSchema = z.preprocess(val => {\n  if (typeof val === 'string') {\n    try {\n      return JSON.parse(val);\n    } catch {\n      return undefined;\n    }\n  }\n  return val;\n}, z.record(z.string(), z.unknown()).optional());\n\n/**\n * Thread object structure\n */\nconst threadSchema = z.object({\n  id: z.string(),\n  title: z.string().optional(),\n  resourceId: z.string(),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n});\n\n/**\n * Message structure for storage\n * Extends coreMessageSchema with storage-specific fields\n */\nconst messageSchema = z.any();\n// const messageSchema = coreMessageSchema.extend({\n//   id: z.string(),\n//   createdAt: z.coerce.date(),\n//   threadId: z.string().optional(),\n//   resourceId: z.string().optional(),\n// });\n\n// ============================================================================\n// Query Parameter Schemas\n// ============================================================================\n\n/**\n * GET /api/memory/status\n */\nexport const getMemoryStatusQuerySchema = agentIdQuerySchema;\n\n/**\n * GET /api/memory/config\n */\nexport const getMemoryConfigQuerySchema = agentIdQuerySchema;\n\n/**\n * GET /api/memory/threads\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listThreadsQuerySchema = createPagePaginationSchema(100).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string(),\n  orderBy: storageOrderBySchema,\n});\n\n/**\n * GET /api/memory/threads/:threadId\n * agentId is optional - can use storage fallback when not provided\n */\nexport const getThreadByIdQuerySchema = optionalAgentIdQuerySchema;\n\n/**\n * GET /api/memory/threads/:threadId/messages\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listMessagesQuerySchema = createPagePaginationSchema(40).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  orderBy: messageOrderBySchema,\n  include: includeSchema,\n  filter: filterSchema,\n});\n\n/**\n * GET /api/memory/threads/:threadId/working-memory\n */\nexport const getWorkingMemoryQuerySchema = z.object({\n  agentId: z.string(),\n  resourceId: z.string().optional(),\n  memoryConfig: memoryConfigSchema,\n});\n\n// ============================================================================\n// Legacy /network Query Parameter Schemas (backward compatibility)\n// ============================================================================\n\n/**\n * GET /api/memory/network/status\n */\nexport const getMemoryStatusNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * GET /api/memory/network/threads\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listThreadsNetworkQuerySchema = createPagePaginationSchema(100).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string(),\n  orderBy: storageOrderBySchema,\n});\n\n/**\n * GET /api/memory/network/threads/:threadId\n * agentId is optional - can use storage fallback when not provided\n */\nexport const getThreadByIdNetworkQuerySchema = optionalAgentIdQuerySchema;\n\n/**\n * GET /api/memory/network/threads/:threadId/messages\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listMessagesNetworkQuerySchema = createPagePaginationSchema(40).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  orderBy: messageOrderBySchema,\n  include: includeSchema,\n  filter: filterSchema,\n});\n\n/**\n * POST /api/memory/network/save-messages\n */\nexport const saveMessagesNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * POST /api/memory/network/threads\n */\nexport const createThreadNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * PATCH /api/memory/network/threads/:threadId\n */\nexport const updateThreadNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * DELETE /api/memory/network/threads/:threadId\n */\nexport const deleteThreadNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * POST /api/memory/network/messages/delete\n */\nexport const deleteMessagesNetworkQuerySchema = agentIdQuerySchema;\n\n// ============================================================================\n// Response Schemas\n// ============================================================================\n\n/**\n * Response for GET /api/memory/status\n */\nexport const memoryStatusResponseSchema = z.object({\n  result: z.boolean(),\n});\n\n/**\n * Response for GET /api/memory/config\n * MemoryConfig is complex with many optional fields - using passthrough\n */\nexport const memoryConfigResponseSchema = z.object({\n  config: z.object({\n    lastMessages: z.union([z.number(), z.literal(false)]).optional(),\n    semanticRecall: z.union([z.boolean(), z.any()]).optional(),\n    workingMemory: z.any().optional(),\n  }),\n});\n\n/**\n * Response for GET /api/memory/threads\n */\nexport const listThreadsResponseSchema = paginationInfoSchema.extend({\n  threads: z.array(threadSchema),\n});\n\n/**\n * Response for GET /api/memory/threads/:threadId\n */\nexport const getThreadByIdResponseSchema = threadSchema;\n\n/**\n * Response for GET /api/memory/threads/:threadId/messages\n */\nexport const listMessagesResponseSchema = z.object({\n  messages: z.array(messageSchema),\n  uiMessages: z.unknown(), // Converted messages in UI format\n});\n\n/**\n * Response for GET /api/memory/threads/:threadId/working-memory\n */\nexport const getWorkingMemoryResponseSchema = z.object({\n  workingMemory: z.unknown(), // Can be string or structured object depending on template\n  source: z.enum(['thread', 'resource']),\n  workingMemoryTemplate: z.unknown(), // Template structure varies\n  threadExists: z.boolean(),\n});\n\n// ============================================================================\n// Body Parameter Schemas for POST/PUT/DELETE\n// ============================================================================\n\n/**\n * Body schema for POST /api/memory/messages\n */\nexport const saveMessagesBodySchema = z.object({\n  messages: z.array(messageSchema),\n});\n\n/**\n * Body schema for POST /api/memory/threads\n */\nexport const createThreadBodySchema = z.object({\n  resourceId: z.string(),\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  threadId: z.string().optional(),\n});\n\n/**\n * Body schema for PUT /api/memory/threads/:threadId\n */\nexport const updateThreadBodySchema = z.object({\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  resourceId: z.string().optional(),\n});\n\n/**\n * Body schema for PUT /api/memory/threads/:threadId/working-memory\n */\nexport const updateWorkingMemoryBodySchema = z.object({\n  workingMemory: z.string(),\n  resourceId: z.string().optional(),\n  memoryConfig: z.record(z.string(), z.unknown()).optional(),\n});\n\n/**\n * Body schema for POST /api/memory/messages/delete\n * Accepts: string | string[] | { id: string } | { id: string }[]\n */\nexport const deleteMessagesBodySchema = z.object({\n  messageIds: z.union([\n    z.string(),\n    z.array(z.string()),\n    z.object({ id: z.string() }),\n    z.array(z.object({ id: z.string() })),\n  ]),\n});\n\n/**\n * Query schema for GET /api/memory/search\n */\nexport const searchMemoryQuerySchema = z.object({\n  agentId: z.string(),\n  searchQuery: z.string(),\n  resourceId: z.string(),\n  threadId: z.string().optional(),\n  limit: z.coerce.number().optional().default(20),\n  memoryConfig: memoryConfigSchema,\n});\n\n/**\n * Response schemas\n */\nexport const saveMessagesResponseSchema = z.object({\n  messages: z.array(messageSchema),\n});\n\nexport const deleteThreadResponseSchema = z.object({\n  result: z.string(),\n});\n\nexport const updateWorkingMemoryResponseSchema = successResponseSchema;\n\nexport const deleteMessagesResponseSchema = successResponseSchema.extend({\n  message: z.string(),\n});\n\nexport const searchMemoryResponseSchema = z.object({\n  results: z.array(z.unknown()),\n  count: z.number(),\n  query: z.string(),\n  searchScope: z.string().optional(),\n  searchType: z.string().optional(),\n});\n\n/**\n * Body schema for POST /api/memory/threads/:threadId/clone\n */\nexport const cloneThreadBodySchema = z.object({\n  newThreadId: z.string().optional(),\n  resourceId: z.string().optional(),\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  options: z\n    .object({\n      messageLimit: z.number().optional(),\n      messageFilter: z\n        .object({\n          startDate: z.coerce.date().optional(),\n          endDate: z.coerce.date().optional(),\n          messageIds: z.array(z.string()).optional(),\n        })\n        .optional(),\n    })\n    .optional(),\n});\n\n/**\n * Response schema for POST /api/memory/threads/:threadId/clone\n */\nexport const cloneThreadResponseSchema = z.object({\n  thread: threadSchema,\n  clonedMessages: z.array(messageSchema),\n});\n"]}