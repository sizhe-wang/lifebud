'use strict';

var chunkMCYD5LW7_cjs = require('./chunk-MCYD5LW7.cjs');
var chunkAVRO3FIN_cjs = require('./chunk-AVRO3FIN.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var zod = require('zod');

// src/server/handlers/mcp.ts
var mcp_exports = {};
chunkO7I5CWRX_cjs.__export(mcp_exports, {
  EXECUTE_MCP_SERVER_TOOL_ROUTE: () => EXECUTE_MCP_SERVER_TOOL_ROUTE,
  GET_MCP_SERVER_DETAIL_ROUTE: () => GET_MCP_SERVER_DETAIL_ROUTE,
  GET_MCP_SERVER_TOOL_DETAIL_ROUTE: () => GET_MCP_SERVER_TOOL_DETAIL_ROUTE,
  LIST_MCP_SERVERS_ROUTE: () => LIST_MCP_SERVERS_ROUTE,
  LIST_MCP_SERVER_TOOLS_ROUTE: () => LIST_MCP_SERVER_TOOLS_ROUTE,
  MCP_HTTP_TRANSPORT_ROUTE: () => MCP_HTTP_TRANSPORT_ROUTE,
  MCP_SSE_MESSAGES_ROUTE: () => MCP_SSE_MESSAGES_ROUTE,
  MCP_SSE_TRANSPORT_ROUTE: () => MCP_SSE_TRANSPORT_ROUTE
});
var mcpServerIdPathParams = zod.z.object({
  serverId: zod.z.string().describe("MCP server ID")
});
var mcpServerDetailPathParams = zod.z.object({
  id: zod.z.string().describe("MCP server ID")
});
var mcpServerToolPathParams = zod.z.object({
  serverId: zod.z.string().describe("MCP server ID"),
  toolId: zod.z.string().describe("Tool ID")
});
var executeToolBodySchema = zod.z.object({
  data: zod.z.unknown().optional()
});
var listMcpServersQuerySchema = chunkMCYD5LW7_cjs.createCombinedPaginationSchema();
var getMcpServerDetailQuerySchema = zod.z.object({
  version: zod.z.string().optional()
});
var versionDetailSchema = zod.z.object({
  version: zod.z.string(),
  release_date: zod.z.string(),
  is_latest: zod.z.boolean()
});
var serverInfoSchema = zod.z.object({
  id: zod.z.string(),
  name: zod.z.string(),
  version_detail: versionDetailSchema
});
var listMcpServersResponseSchema = zod.z.object({
  servers: zod.z.array(serverInfoSchema),
  total_count: zod.z.number(),
  next: zod.z.string().nullable()
});
var serverDetailSchema = zod.z.object({
  id: zod.z.string(),
  name: zod.z.string(),
  description: zod.z.string().optional(),
  version_detail: versionDetailSchema,
  package_canonical: zod.z.string().optional(),
  packages: zod.z.array(zod.z.unknown()).optional(),
  remotes: zod.z.array(zod.z.unknown()).optional()
});
var mcpToolInfoSchema = zod.z.object({
  name: zod.z.string(),
  description: zod.z.string().optional(),
  inputSchema: zod.z.unknown(),
  outputSchema: zod.z.unknown().optional(),
  toolType: zod.z.string().optional()
});
var listMcpServerToolsResponseSchema = zod.z.object({
  tools: zod.z.array(mcpToolInfoSchema)
});
var executeToolResponseSchema = zod.z.object({
  result: zod.z.unknown()
});
zod.z.object({
  jsonrpc: zod.z.literal("2.0"),
  error: zod.z.object({
    code: zod.z.number(),
    message: zod.z.string()
  }),
  id: zod.z.null()
});

// src/server/handlers/mcp.ts
var LIST_MCP_SERVERS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/mcp/v0/servers",
  responseType: "json",
  queryParamSchema: listMcpServersQuerySchema,
  responseSchema: listMcpServersResponseSchema,
  summary: "List MCP servers",
  description: "Returns a list of registered MCP servers with pagination support",
  tags: ["MCP"],
  handler: async ({
    mastra,
    page,
    perPage,
    limit,
    offset
  }) => {
    if (!mastra || typeof mastra.listMCPServers !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or listMCPServers method not available" });
    }
    const servers = mastra.listMCPServers();
    if (!servers) {
      return { servers: [], total_count: 0, next: null };
    }
    const serverList = Object.values(servers);
    const totalCount = serverList.length;
    const useLegacyFormat = (limit !== void 0 || offset !== void 0) && page === void 0 && perPage === void 0;
    const finalPerPage = perPage ?? limit;
    let finalPage = page;
    if (finalPage === void 0 && offset !== void 0 && finalPerPage !== void 0 && finalPerPage > 0) {
      finalPage = Math.floor(offset / finalPerPage);
    }
    const actualOffset = finalPage !== void 0 && finalPerPage !== void 0 ? finalPage * finalPerPage : 0;
    let paginatedServers = serverList;
    let nextUrl = null;
    if (finalPerPage !== void 0) {
      paginatedServers = serverList.slice(actualOffset, actualOffset + finalPerPage);
      if (actualOffset + finalPerPage < totalCount) {
        const nextPage = (finalPage ?? 0) + 1;
        if (useLegacyFormat) {
          const nextOffset = actualOffset + finalPerPage;
          nextUrl = `/api/mcp/v0/servers?limit=${finalPerPage}&offset=${nextOffset}`;
        } else {
          nextUrl = `/api/mcp/v0/servers?perPage=${finalPerPage}&page=${nextPage}`;
        }
      }
    }
    const serverInfoList = paginatedServers.map((server) => server.getServerInfo());
    return {
      servers: serverInfoList,
      total_count: totalCount,
      next: nextUrl
    };
  }
});
var GET_MCP_SERVER_DETAIL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/mcp/v0/servers/:id",
  responseType: "json",
  pathParamSchema: mcpServerDetailPathParams,
  queryParamSchema: getMcpServerDetailQuerySchema,
  responseSchema: serverDetailSchema,
  summary: "Get MCP server details",
  description: "Returns detailed information about a specific MCP server",
  tags: ["MCP"],
  handler: async ({ mastra, id, version }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(id);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server with ID '${id}' not found` });
    }
    const serverDetail = server.getServerDetail();
    if (version && serverDetail.version_detail.version !== version) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, {
        message: `MCP server with ID '${id}' found, but not version '${version}'. Available version: ${serverDetail.version_detail.version}`
      });
    }
    return serverDetail;
  }
});
var LIST_MCP_SERVER_TOOLS_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/mcp/:serverId/tools",
  responseType: "json",
  pathParamSchema: mcpServerIdPathParams,
  responseSchema: listMcpServerToolsResponseSchema,
  summary: "List MCP server tools",
  description: "Returns a list of tools available on the specified MCP server",
  tags: ["MCP"],
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.getToolListInfo !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(501, { message: `Server '${serverId}' cannot list tools in this way.` });
    }
    return server.getToolListInfo();
  }
});
var GET_MCP_SERVER_TOOL_DETAIL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "GET",
  path: "/api/mcp/:serverId/tools/:toolId",
  responseType: "json",
  pathParamSchema: mcpServerToolPathParams,
  responseSchema: mcpToolInfoSchema,
  summary: "Get MCP server tool details",
  description: "Returns detailed information about a specific tool on the MCP server",
  tags: ["MCP"],
  handler: async ({ mastra, serverId, toolId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.getToolInfo !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(501, { message: `Server '${serverId}' cannot provide tool details in this way.` });
    }
    const toolInfo = server.getToolInfo(toolId);
    if (!toolInfo) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `Tool with ID '${toolId}' not found on MCP server '${serverId}'` });
    }
    return toolInfo;
  }
});
var EXECUTE_MCP_SERVER_TOOL_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/mcp/:serverId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: mcpServerToolPathParams,
  bodySchema: executeToolBodySchema,
  responseSchema: executeToolResponseSchema,
  summary: "Execute MCP server tool",
  description: "Executes a tool on the specified MCP server with the provided arguments",
  tags: ["MCP"],
  handler: async ({
    mastra,
    serverId,
    toolId,
    data
  }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server with ID '${serverId}' not found` });
    }
    if (typeof server.executeTool !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(501, { message: `Server '${serverId}' cannot execute tools in this way.` });
    }
    const result = await server.executeTool(toolId, data);
    return { result };
  }
});
var MCP_HTTP_TRANSPORT_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "ALL",
  path: "/api/mcp/:serverId/mcp",
  responseType: "mcp-http",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP HTTP Transport",
  description: "Streamable HTTP transport endpoint for MCP protocol communication",
  tags: ["MCP"],
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server '${serverId}' not found` });
    }
    return {
      server,
      httpPath: `/api/mcp/${serverId}/mcp`
    };
  }
});
var MCP_SSE_TRANSPORT_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "ALL",
  path: "/api/mcp/:serverId/sse",
  responseType: "mcp-sse",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP SSE Transport",
  description: "SSE transport endpoint for MCP protocol communication",
  tags: ["MCP"],
  handler: async ({ mastra, serverId }) => {
    if (!mastra || typeof mastra.getMCPServerById !== "function") {
      throw new chunk64ITUOXI_cjs.HTTPException(500, { message: "Mastra instance or getMCPServerById method not available" });
    }
    const server = mastra.getMCPServerById(serverId);
    if (!server) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `MCP server '${serverId}' not found` });
    }
    return {
      server,
      ssePath: `/api/mcp/${serverId}/sse`,
      messagePath: `/api/mcp/${serverId}/messages`
    };
  }
});
var MCP_SSE_MESSAGES_ROUTE = chunkAVRO3FIN_cjs.createRoute({
  method: "POST",
  path: "/api/mcp/:serverId/messages",
  responseType: "mcp-sse",
  pathParamSchema: mcpServerIdPathParams,
  summary: "MCP SSE Messages",
  description: "Message endpoint for SSE transport (posts messages to active SSE streams)",
  tags: ["MCP"],
  handler: MCP_SSE_TRANSPORT_ROUTE.handler
});

exports.EXECUTE_MCP_SERVER_TOOL_ROUTE = EXECUTE_MCP_SERVER_TOOL_ROUTE;
exports.GET_MCP_SERVER_DETAIL_ROUTE = GET_MCP_SERVER_DETAIL_ROUTE;
exports.GET_MCP_SERVER_TOOL_DETAIL_ROUTE = GET_MCP_SERVER_TOOL_DETAIL_ROUTE;
exports.LIST_MCP_SERVERS_ROUTE = LIST_MCP_SERVERS_ROUTE;
exports.LIST_MCP_SERVER_TOOLS_ROUTE = LIST_MCP_SERVER_TOOLS_ROUTE;
exports.MCP_HTTP_TRANSPORT_ROUTE = MCP_HTTP_TRANSPORT_ROUTE;
exports.MCP_SSE_MESSAGES_ROUTE = MCP_SSE_MESSAGES_ROUTE;
exports.MCP_SSE_TRANSPORT_ROUTE = MCP_SSE_TRANSPORT_ROUTE;
exports.mcp_exports = mcp_exports;
//# sourceMappingURL=chunk-WJ6DNHLW.cjs.map
//# sourceMappingURL=chunk-WJ6DNHLW.cjs.map