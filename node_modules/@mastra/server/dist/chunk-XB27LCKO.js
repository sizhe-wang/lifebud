import { successResponseSchema } from './chunk-HT4LP3BO.js';
import { createRoute } from './chunk-7S7ALPCY.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import { __export } from './chunk-PR4QN5HX.js';
import z from 'zod';

// src/server/handlers/vector.ts
var vector_exports = {};
__export(vector_exports, {
  CREATE_INDEX_ROUTE: () => CREATE_INDEX_ROUTE,
  DELETE_INDEX_ROUTE: () => DELETE_INDEX_ROUTE,
  DESCRIBE_INDEX_ROUTE: () => DESCRIBE_INDEX_ROUTE,
  LIST_INDEXES_ROUTE: () => LIST_INDEXES_ROUTE,
  QUERY_VECTORS_ROUTE: () => QUERY_VECTORS_ROUTE,
  UPSERT_VECTORS_ROUTE: () => UPSERT_VECTORS_ROUTE,
  createIndex: () => createIndex,
  deleteIndex: () => deleteIndex,
  describeIndex: () => describeIndex,
  listIndexes: () => listIndexes,
  queryVectors: () => queryVectors,
  upsertVectors: () => upsertVectors
});
var vectorNamePathParams = z.object({
  vectorName: z.string().describe("Name of the vector store")
});
var vectorIndexPathParams = vectorNamePathParams.extend({
  indexName: z.string().describe("Name of the index")
});
var indexBodyBaseSchema = z.object({
  indexName: z.string()
});
var upsertVectorsBodySchema = indexBodyBaseSchema.extend({
  vectors: z.array(z.array(z.number())),
  metadata: z.array(z.record(z.string(), z.any())).optional(),
  ids: z.array(z.string()).optional()
});
var createIndexBodySchema = indexBodyBaseSchema.extend({
  dimension: z.number(),
  metric: z.enum(["cosine", "euclidean", "dotproduct"]).optional()
});
var queryVectorsBodySchema = indexBodyBaseSchema.extend({
  queryVector: z.array(z.number()),
  topK: z.number().optional(),
  filter: z.record(z.string(), z.any()).optional(),
  includeVector: z.boolean().optional()
});
var upsertVectorsResponseSchema = z.object({
  ids: z.array(z.string())
});
var createIndexResponseSchema = successResponseSchema;
var queryVectorsResponseSchema = z.array(z.unknown());
var listIndexesResponseSchema = z.array(z.string());
var describeIndexResponseSchema = z.object({
  dimension: z.number(),
  count: z.number(),
  metric: z.string().optional()
});
var deleteIndexResponseSchema = successResponseSchema;

// src/server/handlers/vector.ts
function getVector(mastra, vectorName) {
  if (!vectorName) {
    throw new HTTPException(400, { message: "Vector name is required" });
  }
  const vector = mastra.getVector(vectorName);
  if (!vector) {
    throw new HTTPException(404, { message: `Vector store ${vectorName} not found` });
  }
  return vector;
}
async function upsertVectors({
  mastra,
  vectorName,
  indexName,
  vectors,
  metadata,
  ids
}) {
  try {
    if (!indexName || !vectors || !Array.isArray(vectors)) {
      throw new HTTPException(400, { message: "Invalid request index. indexName and vectors array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const result = await vector.upsert({ indexName, vectors, metadata, ids });
    return { ids: result };
  } catch (error) {
    return handleError(error, "Error upserting vectors");
  }
}
async function createIndex({
  mastra,
  vectorName,
  indexName,
  dimension,
  metric
}) {
  try {
    if (!indexName || typeof dimension !== "number" || dimension <= 0) {
      throw new HTTPException(400, {
        message: "Invalid request index, indexName and positive dimension number are required."
      });
    }
    if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
      throw new HTTPException(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.createIndex({ indexName, dimension, metric });
    return { success: true };
  } catch (error) {
    return handleError(error, "Error creating index");
  }
}
async function queryVectors({
  mastra,
  vectorName,
  indexName,
  queryVector,
  topK,
  filter,
  includeVector
}) {
  try {
    if (!indexName || !queryVector || !Array.isArray(queryVector)) {
      throw new HTTPException(400, { message: "Invalid request query. indexName and queryVector array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
    return results;
  } catch (error) {
    return handleError(error, "Error querying vectors");
  }
}
async function listIndexes({ mastra, vectorName }) {
  try {
    const vector = getVector(mastra, vectorName);
    const indexes = await vector.listIndexes();
    return indexes.filter(Boolean);
  } catch (error) {
    return handleError(error, "Error listing indexes");
  }
}
async function describeIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new HTTPException(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    const stats = await vector.describeIndex({ indexName });
    return {
      dimension: stats.dimension,
      count: stats.count,
      metric: stats.metric?.toLowerCase()
    };
  } catch (error) {
    return handleError(error, "Error describing index");
  }
}
async function deleteIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new HTTPException(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.deleteIndex({ indexName });
    return { success: true };
  } catch (error) {
    return handleError(error, "Error deleting index");
  }
}
var UPSERT_VECTORS_ROUTE = createRoute({
  method: "POST",
  path: "/api/vector/:vectorName/upsert",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: upsertVectorsBodySchema,
  responseSchema: upsertVectorsResponseSchema,
  summary: "Upsert vectors",
  description: "Inserts or updates vectors in the specified index",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, vectors, metadata, ids } = params;
      if (!indexName || !vectors || !Array.isArray(vectors)) {
        throw new HTTPException(400, { message: "Invalid request index. indexName and vectors array are required." });
      }
      const vector = getVector(mastra, vectorName);
      const result = await vector.upsert({ indexName, vectors, metadata, ids });
      return { ids: result };
    } catch (error) {
      return handleError(error, "Error upserting vectors");
    }
  }
});
var CREATE_INDEX_ROUTE = createRoute({
  method: "POST",
  path: "/api/vector/:vectorName/create-index",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: createIndexBodySchema,
  responseSchema: createIndexResponseSchema,
  summary: "Create index",
  description: "Creates a new vector index with the specified dimension and metric",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, dimension, metric } = params;
      if (!indexName || typeof dimension !== "number" || dimension <= 0) {
        throw new HTTPException(400, {
          message: "Invalid request index, indexName and positive dimension number are required."
        });
      }
      if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
        throw new HTTPException(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.createIndex({ indexName, dimension, metric });
      return { success: true };
    } catch (error) {
      return handleError(error, "Error creating index");
    }
  }
});
var QUERY_VECTORS_ROUTE = createRoute({
  method: "POST",
  path: "/api/vector/:vectorName/query",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: queryVectorsBodySchema,
  responseSchema: queryVectorsResponseSchema,
  summary: "Query vectors",
  description: "Performs a similarity search on the vector index",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, queryVector, topK, filter, includeVector } = params;
      if (!indexName || !queryVector || !Array.isArray(queryVector)) {
        throw new HTTPException(400, {
          message: "Invalid request query. indexName and queryVector array are required."
        });
      }
      const vector = getVector(mastra, vectorName);
      const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
      return results;
    } catch (error) {
      return handleError(error, "Error querying vectors");
    }
  }
});
var LIST_INDEXES_ROUTE = createRoute({
  method: "GET",
  path: "/api/vector/:vectorName/indexes",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  responseSchema: listIndexesResponseSchema,
  summary: "List indexes",
  description: "Returns a list of all indexes in the vector store",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName }) => {
    try {
      const vector = getVector(mastra, vectorName);
      const indexes = await vector.listIndexes();
      return indexes.filter(Boolean);
    } catch (error) {
      return handleError(error, "Error listing indexes");
    }
  }
});
var DESCRIBE_INDEX_ROUTE = createRoute({
  method: "GET",
  path: "/api/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: describeIndexResponseSchema,
  summary: "Describe index",
  description: "Returns statistics and metadata for a specific index",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new HTTPException(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      const stats = await vector.describeIndex({ indexName });
      return {
        dimension: stats.dimension,
        count: stats.count,
        metric: stats.metric?.toLowerCase()
      };
    } catch (error) {
      return handleError(error, "Error describing index");
    }
  }
});
var DELETE_INDEX_ROUTE = createRoute({
  method: "DELETE",
  path: "/api/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: deleteIndexResponseSchema,
  summary: "Delete index",
  description: "Deletes a vector index and all its data",
  tags: ["Vectors"],
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new HTTPException(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.deleteIndex({ indexName });
      return { success: true };
    } catch (error) {
      return handleError(error, "Error deleting index");
    }
  }
});

export { CREATE_INDEX_ROUTE, DELETE_INDEX_ROUTE, DESCRIBE_INDEX_ROUTE, LIST_INDEXES_ROUTE, QUERY_VECTORS_ROUTE, UPSERT_VECTORS_ROUTE, createIndex, deleteIndex, describeIndex, listIndexes, queryVectors, upsertVectors, vector_exports };
//# sourceMappingURL=chunk-XB27LCKO.js.map
//# sourceMappingURL=chunk-XB27LCKO.js.map