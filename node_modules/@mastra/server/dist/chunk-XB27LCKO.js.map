{"version":3,"sources":["../src/server/handlers/vector.ts","../src/server/schemas/vectors.ts"],"names":[],"mappings":"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","file":"chunk-XB27LCKO.js","sourcesContent":["import type { MastraVector, QueryResult, IndexStats } from '@mastra/core/vector';\nimport { HTTPException } from '../http-exception';\nimport {\n  vectorNamePathParams,\n  vectorIndexPathParams,\n  upsertVectorsBodySchema,\n  upsertVectorsResponseSchema,\n  createIndexBodySchema,\n  createIndexResponseSchema,\n  queryVectorsBodySchema,\n  queryVectorsResponseSchema,\n  listIndexesResponseSchema,\n  describeIndexResponseSchema,\n  deleteIndexResponseSchema,\n} from '../schemas/vectors';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\n\ninterface VectorContext extends Context {\n  vectorName?: string;\n}\n\ninterface UpsertRequest {\n  indexName: string;\n  vectors: number[][];\n  metadata?: Record<string, any>[];\n  ids?: string[];\n}\n\ninterface CreateIndexRequest {\n  indexName: string;\n  dimension: number;\n  metric?: 'cosine' | 'euclidean' | 'dotproduct';\n}\n\ninterface QueryRequest {\n  indexName: string;\n  queryVector: number[];\n  topK?: number;\n  filter?: Record<string, any>;\n  includeVector?: boolean;\n}\n\nfunction getVector(mastra: Context['mastra'], vectorName?: string): MastraVector {\n  if (!vectorName) {\n    throw new HTTPException(400, { message: 'Vector name is required' });\n  }\n\n  const vector = mastra.getVector(vectorName);\n  if (!vector) {\n    throw new HTTPException(404, { message: `Vector store ${vectorName} not found` });\n  }\n\n  return vector;\n}\n\n// Upsert vectors\nexport async function upsertVectors({\n  mastra,\n  vectorName,\n  indexName,\n  vectors,\n  metadata,\n  ids,\n}: VectorContext & UpsertRequest) {\n  try {\n    if (!indexName || !vectors || !Array.isArray(vectors)) {\n      throw new HTTPException(400, { message: 'Invalid request index. indexName and vectors array are required.' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const result = await vector.upsert({ indexName, vectors, metadata, ids });\n    return { ids: result };\n  } catch (error) {\n    return handleError(error, 'Error upserting vectors');\n  }\n}\n\n// Create index\nexport async function createIndex({\n  mastra,\n  vectorName,\n  indexName,\n  dimension,\n  metric,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & CreateIndexRequest) {\n  try {\n    if (!indexName || typeof dimension !== 'number' || dimension <= 0) {\n      throw new HTTPException(400, {\n        message: 'Invalid request index, indexName and positive dimension number are required.',\n      });\n    }\n\n    if (metric && !['cosine', 'euclidean', 'dotproduct'].includes(metric)) {\n      throw new HTTPException(400, { message: 'Invalid metric. Must be one of: cosine, euclidean, dotproduct' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    await vector.createIndex({ indexName, dimension, metric });\n    return { success: true };\n  } catch (error) {\n    return handleError(error, 'Error creating index');\n  }\n}\n\n// Query vectors\nexport async function queryVectors({\n  mastra,\n  vectorName,\n  indexName,\n  queryVector,\n  topK,\n  filter,\n  includeVector,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & QueryRequest) {\n  try {\n    if (!indexName || !queryVector || !Array.isArray(queryVector)) {\n      throw new HTTPException(400, { message: 'Invalid request query. indexName and queryVector array are required.' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const results: QueryResult[] = await vector.query({ indexName, queryVector, topK, filter, includeVector });\n    return results;\n  } catch (error) {\n    return handleError(error, 'Error querying vectors');\n  }\n}\n\n// List indexes\nexport async function listIndexes({ mastra, vectorName }: Pick<VectorContext, 'mastra' | 'vectorName'>) {\n  try {\n    const vector = getVector(mastra, vectorName);\n\n    const indexes = await vector.listIndexes();\n    return indexes.filter(Boolean);\n  } catch (error) {\n    return handleError(error, 'Error listing indexes');\n  }\n}\n\n// Describe index\nexport async function describeIndex({\n  mastra,\n  vectorName,\n  indexName,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { indexName?: string }) {\n  try {\n    if (!indexName) {\n      throw new HTTPException(400, { message: 'Index name is required' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const stats: IndexStats = await vector.describeIndex({ indexName });\n\n    return {\n      dimension: stats.dimension,\n      count: stats.count,\n      metric: stats.metric?.toLowerCase(),\n    };\n  } catch (error) {\n    return handleError(error, 'Error describing index');\n  }\n}\n\n// Delete index\nexport async function deleteIndex({\n  mastra,\n  vectorName,\n  indexName,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { indexName?: string }) {\n  try {\n    if (!indexName) {\n      throw new HTTPException(400, { message: 'Index name is required' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    await vector.deleteIndex({ indexName });\n    return { success: true };\n  } catch (error) {\n    return handleError(error, 'Error deleting index');\n  }\n}\n\n// ============================================================================\n// Route Definitions (new pattern - handlers defined inline with createRoute)\n// ============================================================================\n\nexport const UPSERT_VECTORS_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/vector/:vectorName/upsert',\n  responseType: 'json',\n  pathParamSchema: vectorNamePathParams,\n  bodySchema: upsertVectorsBodySchema,\n  responseSchema: upsertVectorsResponseSchema,\n  summary: 'Upsert vectors',\n  description: 'Inserts or updates vectors in the specified index',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName, ...params }) => {\n    try {\n      const { indexName, vectors, metadata, ids } = params;\n\n      if (!indexName || !vectors || !Array.isArray(vectors)) {\n        throw new HTTPException(400, { message: 'Invalid request index. indexName and vectors array are required.' });\n      }\n\n      const vector = getVector(mastra, vectorName);\n      const result = await vector.upsert({ indexName, vectors, metadata, ids });\n      return { ids: result };\n    } catch (error) {\n      return handleError(error, 'Error upserting vectors');\n    }\n  },\n});\n\nexport const CREATE_INDEX_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/vector/:vectorName/create-index',\n  responseType: 'json',\n  pathParamSchema: vectorNamePathParams,\n  bodySchema: createIndexBodySchema,\n  responseSchema: createIndexResponseSchema,\n  summary: 'Create index',\n  description: 'Creates a new vector index with the specified dimension and metric',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName, ...params }) => {\n    try {\n      const { indexName, dimension, metric } = params;\n\n      if (!indexName || typeof dimension !== 'number' || dimension <= 0) {\n        throw new HTTPException(400, {\n          message: 'Invalid request index, indexName and positive dimension number are required.',\n        });\n      }\n\n      if (metric && !['cosine', 'euclidean', 'dotproduct'].includes(metric)) {\n        throw new HTTPException(400, { message: 'Invalid metric. Must be one of: cosine, euclidean, dotproduct' });\n      }\n\n      const vector = getVector(mastra, vectorName);\n      await vector.createIndex({ indexName, dimension, metric });\n      return { success: true };\n    } catch (error) {\n      return handleError(error, 'Error creating index');\n    }\n  },\n});\n\nexport const QUERY_VECTORS_ROUTE = createRoute({\n  method: 'POST',\n  path: '/api/vector/:vectorName/query',\n  responseType: 'json',\n  pathParamSchema: vectorNamePathParams,\n  bodySchema: queryVectorsBodySchema,\n  responseSchema: queryVectorsResponseSchema,\n  summary: 'Query vectors',\n  description: 'Performs a similarity search on the vector index',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName, ...params }) => {\n    try {\n      const { indexName, queryVector, topK, filter, includeVector } = params;\n\n      if (!indexName || !queryVector || !Array.isArray(queryVector)) {\n        throw new HTTPException(400, {\n          message: 'Invalid request query. indexName and queryVector array are required.',\n        });\n      }\n\n      const vector = getVector(mastra, vectorName);\n      const results: QueryResult[] = await vector.query({ indexName, queryVector, topK, filter, includeVector });\n      return results;\n    } catch (error) {\n      return handleError(error, 'Error querying vectors');\n    }\n  },\n});\n\nexport const LIST_INDEXES_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/vector/:vectorName/indexes',\n  responseType: 'json',\n  pathParamSchema: vectorNamePathParams,\n  responseSchema: listIndexesResponseSchema,\n  summary: 'List indexes',\n  description: 'Returns a list of all indexes in the vector store',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName }) => {\n    try {\n      const vector = getVector(mastra, vectorName);\n      const indexes = await vector.listIndexes();\n      return indexes.filter(Boolean);\n    } catch (error) {\n      return handleError(error, 'Error listing indexes');\n    }\n  },\n});\n\nexport const DESCRIBE_INDEX_ROUTE = createRoute({\n  method: 'GET',\n  path: '/api/vector/:vectorName/indexes/:indexName',\n  responseType: 'json',\n  pathParamSchema: vectorIndexPathParams,\n  responseSchema: describeIndexResponseSchema,\n  summary: 'Describe index',\n  description: 'Returns statistics and metadata for a specific index',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName, indexName }) => {\n    try {\n      if (!indexName) {\n        throw new HTTPException(400, { message: 'Index name is required' });\n      }\n\n      const vector = getVector(mastra, vectorName);\n      const stats: IndexStats = await vector.describeIndex({ indexName: indexName });\n\n      return {\n        dimension: stats.dimension,\n        count: stats.count,\n        metric: stats.metric?.toLowerCase(),\n      };\n    } catch (error) {\n      return handleError(error, 'Error describing index');\n    }\n  },\n});\n\nexport const DELETE_INDEX_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/api/vector/:vectorName/indexes/:indexName',\n  responseType: 'json',\n  pathParamSchema: vectorIndexPathParams,\n  responseSchema: deleteIndexResponseSchema,\n  summary: 'Delete index',\n  description: 'Deletes a vector index and all its data',\n  tags: ['Vectors'],\n  handler: async ({ mastra, vectorName, indexName }) => {\n    try {\n      if (!indexName) {\n        throw new HTTPException(400, { message: 'Index name is required' });\n      }\n\n      const vector = getVector(mastra, vectorName);\n      await vector.deleteIndex({ indexName: indexName });\n      return { success: true };\n    } catch (error) {\n      return handleError(error, 'Error deleting index');\n    }\n  },\n});\n","import z from 'zod';\nimport { successResponseSchema } from './common';\n\n// Path parameter schemas\nexport const vectorNamePathParams = z.object({\n  vectorName: z.string().describe('Name of the vector store'),\n});\n\nexport const vectorIndexPathParams = vectorNamePathParams.extend({\n  indexName: z.string().describe('Name of the index'),\n});\n\n// Body schemas\n// Base schema for operations that require an index name\nconst indexBodyBaseSchema = z.object({\n  indexName: z.string(),\n});\n\nexport const upsertVectorsBodySchema = indexBodyBaseSchema.extend({\n  vectors: z.array(z.array(z.number())),\n  metadata: z.array(z.record(z.string(), z.any())).optional(),\n  ids: z.array(z.string()).optional(),\n});\n\nexport const createIndexBodySchema = indexBodyBaseSchema.extend({\n  dimension: z.number(),\n  metric: z.enum(['cosine', 'euclidean', 'dotproduct']).optional(),\n});\n\nexport const queryVectorsBodySchema = indexBodyBaseSchema.extend({\n  queryVector: z.array(z.number()),\n  topK: z.number().optional(),\n  filter: z.record(z.string(), z.any()).optional(),\n  includeVector: z.boolean().optional(),\n});\n\n// Response schemas\nexport const upsertVectorsResponseSchema = z.object({\n  ids: z.array(z.string()),\n});\n\nexport const createIndexResponseSchema = successResponseSchema;\n\nexport const queryVectorsResponseSchema = z.array(z.unknown()); // QueryResult[]\n\nexport const listIndexesResponseSchema = z.array(z.string());\n\nexport const describeIndexResponseSchema = z.object({\n  dimension: z.number(),\n  count: z.number(),\n  metric: z.string().optional(),\n});\n\nexport const deleteIndexResponseSchema = successResponseSchema;\n"]}