'use strict';

// src/server/auth/defaults.ts
var defaultAuthConfig = {
  protected: ["/api/*"],
  public: ["/api"],
  // Simple rule system
  rules: [
    // Admin users can do anything
    {
      condition: (user) => {
        if (typeof user === "object" && user !== null) {
          if ("isAdmin" in user) {
            return !!user.isAdmin;
          }
          if ("role" in user) {
            return user.role === "admin";
          }
        }
        return false;
      },
      allow: true
    }
  ]
};

// src/server/auth/helpers.ts
var isDevPlaygroundRequest = (path, method, getHeader, authConfig) => {
  const protectedAccess = [...defaultAuthConfig.protected || [], ...authConfig.protected || []];
  return process.env.MASTRA_DEV === "true" && (!isAnyMatch(path, method, protectedAccess) || getHeader("x-mastra-dev-playground") === "true");
};
var isCustomRoutePublic = (path, method, customRouteAuthConfig) => {
  if (!customRouteAuthConfig) {
    return false;
  }
  const routeKey = `${method}:${path}`;
  if (customRouteAuthConfig.has(routeKey)) {
    return !customRouteAuthConfig.get(routeKey);
  }
  const allRouteKey = `ALL:${path}`;
  if (customRouteAuthConfig.has(allRouteKey)) {
    return !customRouteAuthConfig.get(allRouteKey);
  }
  return false;
};
var isProtectedPath = (path, method, authConfig, customRouteAuthConfig) => {
  const protectedAccess = [...defaultAuthConfig.protected || [], ...authConfig.protected || []];
  return isAnyMatch(path, method, protectedAccess) || !isCustomRoutePublic(path, method, customRouteAuthConfig);
};
var canAccessPublicly = (path, method, authConfig) => {
  const publicAccess = [...defaultAuthConfig.public || [], ...authConfig.public || []];
  return isAnyMatch(path, method, publicAccess);
};
var isAnyMatch = (path, method, patterns) => {
  if (!patterns) {
    return false;
  }
  for (const patternPathOrMethod of patterns) {
    if (patternPathOrMethod instanceof RegExp) {
      if (patternPathOrMethod.test(path)) {
        return true;
      }
    }
    if (typeof patternPathOrMethod === "string" && pathMatchesPattern(path, patternPathOrMethod)) {
      return true;
    }
    if (Array.isArray(patternPathOrMethod) && patternPathOrMethod.length === 2) {
      const [pattern, methodOrMethods] = patternPathOrMethod;
      if (pathMatchesPattern(path, pattern) && matchesOrIncludes(methodOrMethods, method)) {
        return true;
      }
    }
  }
  return false;
};
var pathMatchesPattern = (path, pattern) => {
  if (pattern.endsWith("*")) {
    const prefix = pattern.slice(0, -1);
    return path.startsWith(prefix);
  }
  return path === pattern;
};
var pathMatchesRule = (path, rulePath) => {
  if (!rulePath) return true;
  if (typeof rulePath === "string") {
    return pathMatchesPattern(path, rulePath);
  }
  if (rulePath instanceof RegExp) {
    return rulePath.test(path);
  }
  if (Array.isArray(rulePath)) {
    return rulePath.some((p) => pathMatchesPattern(path, p));
  }
  return false;
};
var matchesOrIncludes = (values, value) => {
  if (typeof values === "string") {
    return values === value;
  }
  if (Array.isArray(values)) {
    return values.includes(value);
  }
  return false;
};
var checkRules = async (rules, path, method, user) => {
  for (const i in rules || []) {
    const rule = rules?.[i];
    if (!pathMatchesRule(path, rule.path)) {
      continue;
    }
    if (rule.methods && !matchesOrIncludes(rule.methods, method)) {
      continue;
    }
    const condition = rule.condition;
    if (typeof condition === "function") {
      const allowed = await Promise.resolve().then(() => condition(user)).catch(() => false);
      if (allowed) {
        return true;
      }
    } else if (rule.allow) {
      return true;
    }
  }
  return false;
};

exports.canAccessPublicly = canAccessPublicly;
exports.checkRules = checkRules;
exports.defaultAuthConfig = defaultAuthConfig;
exports.isCustomRoutePublic = isCustomRoutePublic;
exports.isDevPlaygroundRequest = isDevPlaygroundRequest;
exports.isProtectedPath = isProtectedPath;
exports.matchesOrIncludes = matchesOrIncludes;
exports.pathMatchesPattern = pathMatchesPattern;
exports.pathMatchesRule = pathMatchesRule;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map