import { z } from 'zod';
import type { ZodObject, ZodRawShape, ZodTypeAny } from 'zod';
import type { InferParams, ResponseType, ServerRoute, ServerRouteHandler } from './index.js';
/**
 * Extracts parameters matching a Zod schema's shape from a params object.
 * Useful for separating schema-defined params from ServerContext in handlers.
 *
 * @example
 * ```typescript
 * const querySchema = z.object({ page: z.number(), name: z.string() });
 *
 * handler: async (params) => {
 *   const query = pickParams(querySchema, params);
 *   // query is typed as { page: number, name: string }
 * }
 * ```
 */
export declare function pickParams<T extends z.ZodRawShape, P extends Record<string, unknown>>(schema: z.ZodObject<T>, params: P): z.infer<z.ZodObject<T>>;
/**
 * Wraps a Zod schema to accept either the expected type OR a JSON string.
 * Used for complex query parameters (arrays, objects) that are serialized as JSON in URLs.
 *
 * - If input is already the expected type, passes through to schema validation
 * - If input is a string, attempts JSON.parse then validates
 * - Provides clear error messages for JSON parse failures
 *
 * @example
 * ```typescript
 * const tagsSchema = jsonQueryParam(z.array(z.string()));
 * // Accepts: ["tag1", "tag2"] OR '["tag1", "tag2"]'
 *
 * const dateRangeSchema = jsonQueryParam(z.object({ gte: z.coerce.date() }));
 * // Accepts: { gte: "2024-01-01" } OR '{"gte": "2024-01-01"}'
 * ```
 */
export declare function jsonQueryParam<T extends ZodTypeAny>(schema: T): z.ZodType<z.infer<T>>;
/**
 * Wraps a Zod object schema for HTTP query parameter handling.
 * Automatically detects complex fields (arrays, objects, records) and wraps them
 * with jsonQueryParam() to accept JSON strings from query parameters.
 *
 * Simple fields (strings, numbers, booleans, enums) are left unchanged and should
 * use z.coerce for string-to-type conversion.
 *
 * @example
 * ```typescript
 * // Base schema (for internal/storage use)
 * const tracesFilterSchema = z.object({
 *   tags: z.array(z.string()).optional(),
 *   startedAt: dateRangeSchema.optional(),
 *   perPage: z.coerce.number().optional(),
 * });
 *
 * // HTTP schema (accepts JSON strings for complex fields)
 * const httpTracesFilterSchema = wrapSchemaForQueryParams(tracesFilterSchema);
 *
 * // Now accepts:
 * // ?tags=["tag1","tag2"]&startedAt={"gte":"2024-01-01"}&perPage=10
 * ```
 */
export declare function wrapSchemaForQueryParams<T extends ZodRawShape>(schema: ZodObject<T>): ZodObject<ZodRawShape>;
interface RouteConfig<TPathSchema extends z.ZodTypeAny | undefined = undefined, TQuerySchema extends z.ZodTypeAny | undefined = undefined, TBodySchema extends z.ZodTypeAny | undefined = undefined, TResponseSchema extends z.ZodTypeAny | undefined = undefined, TResponseType extends ResponseType = 'json'> {
    method: ServerRoute['method'];
    path: string;
    responseType: TResponseType;
    streamFormat?: 'sse' | 'stream';
    handler: ServerRouteHandler<InferParams<TPathSchema, TQuerySchema, TBodySchema>, TResponseSchema extends z.ZodTypeAny ? z.infer<TResponseSchema> : unknown, TResponseType>;
    pathParamSchema?: TPathSchema;
    queryParamSchema?: TQuerySchema;
    bodySchema?: TBodySchema;
    responseSchema?: TResponseSchema;
    summary?: string;
    description?: string;
    tags?: string[];
    deprecated?: boolean;
    maxBodySize?: number;
}
/**
 * Creates a server route with auto-generated OpenAPI specification and type-safe handler inference.
 *
 * The handler parameters are automatically inferred from the provided schemas:
 * - pathParamSchema: Infers path parameter types (e.g., :agentId)
 * - queryParamSchema: Infers query parameter types
 * - bodySchema: Infers request body types
 * - Runtime context (mastra, requestContext, tools, taskStore) is always available
 *
 * @param config - Route configuration including schemas, handler, and metadata
 * @returns Complete ServerRoute with OpenAPI spec
 *
 * @example
 * ```typescript
 * export const getAgentRoute = createRoute({
 *   method: 'GET',
 *   path: '/api/agents/:agentId',
 *   responseType: 'json',
 *   pathParamSchema: z.object({ agentId: z.string() }),
 *   responseSchema: serializedAgentSchema,
 *   handler: async ({ agentId, mastra, requestContext }) => {
 *     // agentId is typed as string
 *     // mastra, requestContext, tools, taskStore are always available
 *     return mastra.getAgentById(agentId);
 *   },
 *   summary: 'Get agent by ID',
 *   description: 'Returns details for a specific agent',
 *   tags: ['Agents'],
 * });
 * ```
 */
export declare function createRoute<TPathSchema extends z.ZodTypeAny | undefined = undefined, TQuerySchema extends z.ZodTypeAny | undefined = undefined, TBodySchema extends z.ZodTypeAny | undefined = undefined, TResponseSchema extends z.ZodTypeAny | undefined = undefined, TResponseType extends ResponseType = 'json'>(config: RouteConfig<TPathSchema, TQuerySchema, TBodySchema, TResponseSchema, TResponseType>): ServerRoute<InferParams<TPathSchema, TQuerySchema, TBodySchema>, TResponseSchema extends z.ZodTypeAny ? z.infer<TResponseSchema> : unknown, TResponseType>;
export {};
//# sourceMappingURL=route-builder.d.ts.map