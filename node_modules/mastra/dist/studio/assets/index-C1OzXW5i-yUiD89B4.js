async function k(n,I,{concurrency:o=Number.POSITIVE_INFINITY,stopOnError:y=!0,signal:s}={}){return new Promise((E,N)=>{if(n[Symbol.iterator]===void 0&&n[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof n})`);if(typeof I!="function")throw new TypeError("Mapper function is required");if(!(Number.isSafeInteger(o)&&o>=1||o===Number.POSITIVE_INFINITY))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${o}\` (${typeof o})`);const c=[],p=[],d=new Map;let w=!1,i=!1,b=!1,u=0,m=0;const T=n[Symbol.iterator]===void 0?n[Symbol.asyncIterator]():n[Symbol.iterator](),x=()=>{a(s.reason)},h=()=>{s?.removeEventListener("abort",x)},S=e=>{E(e),h()},a=e=>{w=!0,i=!0,N(e),h()};s&&(s.aborted&&a(s.reason),s.addEventListener("abort",x,{once:!0}));const l=async()=>{if(i)return;const e=await T.next(),f=m;if(m++,e.done){if(b=!0,u===0&&!i){if(!y&&p.length>0){a(new AggregateError(p));return}if(i=!0,d.size===0){S(c);return}const t=[];for(const[r,g]of c.entries())d.get(r)!==v&&t.push(g);S(t)}return}u++,(async()=>{try{const t=await e.value;if(i)return;const r=await I(t,f);r===v&&d.set(f,r),c[f]=r,u--,await l()}catch(t){if(y)a(t);else{p.push(t),u--;try{await l()}catch(r){a(r)}}}})()};(async()=>{for(let e=0;e<o;e++){try{await l()}catch(f){a(f);break}if(b||w)break}})()})}const v=Symbol("skip");export{k as default,v as pMapSkip};
